./ ADD NAME=IERABA   0101-20211-20211-1200-00112-00112-00000-RELEASE 00
ABA      TITLE 'IERABA - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERABA
*
*        MODULE FUNCTION -
*        OSCILLATING OR CRCX BLOCK ASSIGNMENT
*        ASSIGNMENT ROUTINE FOR MODULE IERRBA
*        USED FOR VARIABLE LENGTH RECORDS. IN THE SORT PHASE
*        OF AN OSCILLATING OR CRCX SORT IT INITIALIZES THE RUNNING
*        PROGRAM AND SETS UP POINTERS TO THE OUTPUT BUFFER
*
*        USED AS A DSECT IN - N/A
*
*        LIST OF MACROS USED BY MODULE - SMPPI
*
*        ENTRY POINTS - ENTRY FROM IERRC9 -
*                       LOAD EP=IERABE,DCB=SORTLIB
*                       LR   R15,R0
*                       BALR R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPILAB04
*        PPILAB07
*        PPIBLK
*        VALUES USED TO COMPUTE THE SIZE OF THE OUTPUT BLOCK
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED - NONE
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - NONE
*
*        EXITS - NORMAL - IERRC9 - RETURN VIA R14
*
*        EXITS - ERROR - NONE
*
*        TABLES/WORK AREAS - NONE
*
*        NOTES -
*        THIS MODULE WILL BE EXECUTED ONLY FOR A VARIABLE LENGTH
*        SORT
*
IERABA   CSECT
*
         USING *,R11               MODULE BASE REG
         USING IERRCA,R13          ADDR OF PPI
         USING DIERRBA,R10         ADDR DSECT FOR IERRBA
*
         IERENTRY 'IERABA &SYSDATE &SYSTIME'
*
         LR    R11,R15             LOAD MODULE BASE REG
         L     R10,PPIBLK+4        R10 -> IERRBA FOR DSECT BASE
         MVC   WBLKCCNT,KEIGHT     SET IERRBA BLOCK CHAR CTR TO 8
         L     R5,PPILAB04         R5 -> OUTPUT BUFFER #1
         LA    R5,0(,R5)
         PPITEST  PPI2314          CRCX SORT ?
         BZ    ABA1010             NO, BRANCH
*
*        OVERLAY INSTRUCTIONS IN RUNNING PROGRAM SO THAT RECORD
*        IS MOVED TO THE OUTPUT AREA BEFORE BLOCK POINTER IS
*        INCREMENTED AND SO THAT INITIAL POINTER RATHER THAN
*        BLOCK POINTER IS PASSED TO WRITE ROUTINE AS THE BUFFER
*        ADDR
*
         LA    R5,16(,R5)          START OF BUF + EOS + BCC + CHAIN
         MVI   KEIGHT+3,X'10'      SET CONSTANT TO 16
         MVC   RBTAPE(2),KNOP      NOP, SO MVC BEFORE UPDATE BUF PTR
         MVC   RBINCR(4),KON       INCR FOR OUTPUT FILE
         MVI   WBLKCCNT+3,X'10'    BLOCK COUNT= BCC + EOS + CHAIN
         MVC   RBTAPE1(4),KON1     OBTAIN INITIAL
         MVC   RBOVLAY2(4),KON2    POINTER TO BUFFER
         MVC   RBLDLPTR(4),KON1
         B     ABA1020
*
ABA1010  AH    R5,PPILAB07+2       ADD ROUNDED LENGTH OF OUTPUT BLOCK
         MVC   RBDISK(2),KNOP      NOP, FOR UPDATE BUF PTR BEFORE MVC
*
ABA1020  ST    R5,WLSTPTR          OUTPUT BUFFER POINTER
         ST    R5,WLSTPTRD         CURRENT OUTPUT BLK ENDING ADDR+1
         BR    R14                 RETURN TO LOAD ROUTINE
*
*        CONSTANTS USED BY THE MODULE
*
KNOP     DC    X'4700'             NOP
*
         DROP  R11
         DROP  R10
*
         USING DIERRBA,R11
KON      IC    R9,PPIDEPHO+1       INCR FOR OUTPUT FILE
KON1     L     R7,WLSTPTRD         INITIAL BUFFER
KON2     L     R2,WLSTPTRD         POINTER
*
DIERRBA  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRBA SOURCE
*
*----------------------------------------------------------------------
*
         COPY IERRBAI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERABB   0101-20211-20211-1200-00110-00110-00000-RELEASE 00
ABB      TITLE 'IERABB - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERABB
*
*        MODULE FUNCTION/OPERATION -
*        ASSIGNMENT ROUTINE FOR MODULE IERRBB
*        IT IS A SORT PHASE MODULE USED FOR FIXED LENGTH RECORDS
*        LESS THAN 256 BYTES LONG. IT INITIALIZES THE RUNNING
*        PROGRAM AND SETS UP POINTERS TO THE OUTPUT BUFFER
*
*        MODULE IS USED AS A DSECT IN - N/A
*
*        MACROS USED BY THIS MODULE - SMPPI
*
*        ENTRY POINTS - N/A
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPISRTBL
*        PPILAB07
*        PPIRCDL2
*        PPILAB04
*        PPICNTL
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED - N/A
*        CONSTANTS AND CODE IN RUNNING PROGRAM ARE INITIALIZED
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS -
*        PPIBLK - ADDR OF RUNNING PROGRAM USED TO ADDR DSECT
*
*        EXITS - NORMAL - BR R14 RETURN TO LOAD MODULE
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS - N/A
*
*        NOTES -
*        THIS MODULE IS USED FOR FIXED LENGTH RECORDS LESS THAN
*        256 BYTES
*
IERABB   CSECT
*
         USING *,R11
         USING DIERRBB,R8
         USING IERRCA,R13
*
IERMBA   IERENTRY 'IERABB &SYSDATE &SYSTIME'
*
         LR    R11,R15
         L     R8,PPIBLK+4         MAKE RUNNING PROGRAM ADDRESSABLE
         LH    R6,PPISRTBL
         STH   R6,KBLKCNT          SET BLK CNT = SORT BLOCKING
         LH    R3,PPILAB07+2       SET R3 = BUFFER SIZE
         ST    R3,KBUFSIZ          STORE BUFSIZ IN RUNNING PROGRAM
         LH    R6,PPIRCDL2
         BCTR  R6,0                DECR L'RECORD
         STC   R6,RBB1030+1        STORE RCD LENGTH - 1 IN MOVE INSTR
         STC   R6,KABBMOD2+1       STORE RCD LENGTH - 1 IN MOVE INSTR
         SR    R5,R5
         ICM   R5,B'0111',PPILAB04+1  R5 -> OUTPUT BUFFER
         PPITEST  PPITAPE          TAPE SORT ?
         BO    ABB1010             YES, BRANCH
         LA    R3,4                DASD, ADJUST FOR EOS INDICATION
*
*        OVERLAY INSTRUCTIONS IN RUNNING PROGRAM SO THAT RECORD
*        IS MOVED TO THE OUTPUT BUFFER BEFORE BLOCK POINTER IS
*        INCREMENTED AND SO THAT INITIAL POINTER RATHER THAN
*        BLOCK POINTER IS PASSED TO WRITE ROUTINE AS THE BUFFER
*        ADDRESS
*
         MVC   RBB1020(14),KABBMOD2
         MVC   RBB1055(4),KABBMOD1
         MVC   RBB1105(4),KABBMOD1
ABB1010  AR    R5,R3               CALCULATE BLK PTR
         ST    R5,KBLKPTR
         ST    R5,KIBLKPTR         SET INITIAL PTR
         BR    R14                 RETURN TO LOAD MODULE
*
*        CONSTANTS
*
         DROP  R11
         DROP  R8
*
         USING DIERRBB,R11
KABBMOD1 L     R2,KIBLKPTR         LOAD INITIAL BLK PTR
*
KABBMOD2 MVC   0(1,R2),0(R3)    *  MOVE RCD FROM RSA TO OUTPUT BUFFER
         AH    R2,PPIRCDL2      |  INCREMENT BLK PTR BY RCD LENGTH
         ST    R2,KBLKPTR       V
*
DIERRBB  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRBB SOURCE
*
*----------------------------------------------------------------------
*
         COPY IERRBBI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERABC   0101-20211-20211-1200-00110-00110-00000-RELEASE 00
ABC      TITLE 'IERABC - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERABC
*
*        MODULE FUNCTION/OPERATION -
*        ASSIGNMENT ROUTINE FOR MODULE IERRBC
*        SORT PHASE MODULE USED FOR FIXED LENGTH RECORDS
*        GREATER THAN 256 BYTES LONG. IT INITIALIZES THE RUNNING
*        PROGRAM AND SETS UP POINTERS TO THE OUTPUT BUFFER
*
*        MODULE IS USED AS A DSECT IN - N/A
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                       CALLING SEQUENCE -
*                          L    R15,ASSG
*                          BALR R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPISRTBL
*        PPILAB07
*        PPILAB04
*        PPICNTL
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED - N/A
*
*        CONSTANTS AND CODE IN RUNNING PROGRAM ARE INITIALIZED
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS -
*        PPIBLK - ADDR OF RUNNING PROGRAM USED TO ADDRESS DSECT
*
*        EXITS - NORMAL - BR R14 - RETURN TO LOAD MODULE - IERRC9
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS - N/A
*
*        NOTES -
*        THIS MODULE IS USED FOR FIXED LENGTH RECORDS GREATER
*        THAN 256 BYTES
*
IERABC   CSECT
*
         USING *,R11
         USING DIERRBC,R8
         USING IERRCA,R13
*
IERMBA   LR    R11,R15
         L     R8,PPIBLK+4         MAKE RUNNING PROGRAM ADDRESSABLE
         LH    R3,PPISRTBL
         STH   R3,KBLKCNT
         LH    R3,PPILAB07+2       R3 = OUTPUT BUFFER SIZE
         ST    R3,KBUFSIZ          STORE BUFFER SIZE IN RUN PROG
         SR    R5,R5
         ICM   R5,B'0111',PPILAB04+1  R5 -> FIRST SORT BUFFER
         PPITEST  PPITAPE          TAPE SORT ?
         BO    ABC1010             YES, BRANCH
         LA    R3,4                DISK, ADJUST FOR EOS INDICATION
*
*        OVERLAY INSTRUCTIONS IN RUNNING PROGRAM SO THAT WINNER
*        WILL BE MOVED TO OUTPUT BUFFER BEFORE BLOCK POINTER IS
*        INCREMENTED AND INITIAL POINTER WILL BE PASSED TO WRITE
*        ROUTINE AS BUFFER ADDRESS
*
         MVC   RBC1020(18),KABCMOD2
         MVC   RBC1045(4),KABCMOD1
         MVC   RBC1078(4),KABCMOD1
ABC1010  AR    R5,R3               SET BLK PTR AND INITIAL BLK PTR
         ST    R5,KBLKPTR
         ST    R5,KIBLKPTR
         BR    R14                 RETURN TO LOAD MODULE
*
*        CONSTANTS
*
         DROP  R11
         DROP  R8
*
         USING DIERRBC,R11
*
KABCMOD1 L     R2,KIBLKPTR         LOAD INITIAL POINTER
*
KABCMOD2 LR    R4,R3            *
         LR    R5,R2            |
         L     R15,PPIBDSVA+4   |
         BASR  R14,R15          |  LINK TO MOVE LIST
         AH    R2,PPIRCDL2      |  INCREMENT BLK PTR BY RECORD LENGTH
         ST    R2,KBLKPTR       V
*
DIERRBC  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRBC SOURCE
*
*----------------------------------------------------------------------
*
         COPY IERRBCI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERABE   0101-20211-20211-1200-00112-00112-00000-RELEASE 00
ABE      TITLE 'IERABE - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERABE
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 1 ASSIGNMENT MODULE - ANY VARIABLE LENGTH RECORD SORT
*        THE FUNCTION OF THIS MODULE IS TO OVERLAY IERRBE IN
*        APPROPRIATE PLACES DEPENDING UPON THE TYPE OF SORT
*        (IE TAPE, DISK, DRUM) IT ALSO INITIALIZES POINTERS IN IERRBE
*
*        THIS MODULE IS USED AS A DSECT IN - N/A
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                       CALLING SEQUENCE -
*                           LOAD EP=IERABE,DCB=SORTLIB
*                           LR    R15,R0
*                           BALR  R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPILAB04
*        PPILAB07
*        PPIBLK
*
*        VALUES USED TO COMPUTE THE SIZE OF THE OUTPUT BLOCK
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED - NONE
*
*        EXTERNAL ROUTINES -
*        IERRBE - BLOCK RUNNING PROGRAM
*
*        EXTERNAL PARAMETERS - NONE
*
*        EXITS - NORMAL - IERRC9 - RETURN VIA R14
*
*        EXITS - ERROR - NONE
*
*        TABLES/WORK AREAS - NONE
*
*        NOTES -
*        THIS MODULE WILL BE EXECUTED ONLY FOR A VARIABLE LENGTH
*        SORT
*
IERABE   CSECT
*
         USING *,R11               MODULE BASE REG LOADED EXTERNALLY
         USING IERRCA,R13          ADDR OF PPI
         USING DIERRBE,R10         ADDR OF RUNNING PROGRAM DUMMY MOD
*
IERMBA   LR    R11,R15             LOAD MODULE BASE REG
         L     R10,PPIBLK+4        ADDR OF IERRBE FOR DSECT BASE
         MVC   WBLKCCNT,KEIGHT     SET RP BLOCK CHAR CTR TO 8
         L     R5,PPILAB04         R5 -> OUTPUT BUFFER #1
         LA    R5,0(,R5)           ZERO HIGH ORDER FLAG BYTE
         PPITEST  PPITAPE          TAPE SORT ?
         BZ    ABDISK              NO, BRANCH TO OVERLAY RP FOR DASD
*
*        TAPE SORT ROUTINE
*        CALCULATE ENDING ADDR+1 OF THE OUTPUT BUFFER
*
         AH    R5,PPILAB07+2       ADD ROUNDED LENGTH OF OUTPUT BLOCK
         ST    R5,WLSTPTR          HAS OUTPUT BLOCK PTR ENDING ADDR+1
         ST    R5,WLSTPTRD         CURRENT OUTPUT BLK ENDG ADDR+1
         MVC   RBDISK(2),KNOP      OVERLAY RP INSTR WITH A NOP
         MVC   RBLDLPTR(4),KON2    OVERLAY RP INSTR
         MVC   RBTAPE1(4),KON2     OVERLAY RP INSTR
*
*        INTERFACE TO NEXT MODULE
*
ABNEXTAP BR    R14                 RETURN
*
*        DASD SORT ROUTINE
*
ABDISK   LA    R5,8(,R5)           EQUALS OUTPUT BLOCK STARTING ADDR+8
         ST    R5,WLSTPTR          STORE IN RP OUTPUT BLK LIST PTR
         ST    R5,WLSTPTRD         STORE IN RP AS CURRENT OUTPUT
*                                  BLOCK ADDR+8
         MVC   RBTAPE(2),KNOP      OVERLAY RP INSTR WITH A NOP
         MVC   RBOVLAY2(4),KON1    OVERLAY RP INSTR WITH KON1
         B     ABNEXTAP            BR TO INTERFACE FOR NEXT AP
*
*        CONSTANTS
*
KNOP     DC    X'4700'
*
         DROP  R10
         USING DIERRBE,R11
KON1     L     R2,WLSTPTRD
KON2     L     R7,WLSTPTR
*
*        DIERRBE
*
DIERRBE   DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRBE SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRBEI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERABF   0101-20211-20211-1200-00505-00505-00000-RELEASE 00
ABF      TITLE 'IERABF - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERABF
*
*        FUNCTION/OPERATION -
*        THE PURPOSE OF THIS MODULE IS TO CHOOSE ONE OF THE
*        THREE VARIABLE MOVE ROUTINES, ASSIGN IT AND PLACE IT IN
*        RUNNING PROGRAM STORAGE. IN ORDER TO CHOOSE THE CORRECT
*        VARIABLE MOVE ROUTINE THIS MODULE CALCULATES THE
*        FOLLOWING VALUES -
*
*        X = LENGTH OF EXTRACT CONTROL FIELDS + 4
*
*        Y = BINSIZE - X - 4
*
*        IF Y < 256 AND (X+Y) < 256 MODULE RBFM1 IS USED
*
*        IF Y < 256 AND (X+Y) > 256 MODULE RBFM2 IS USED
*
*        IF Y > 256 AND (X+Y) > 256 MODULE RBFM3 IS USED
*
*        MODULES IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACROS USED BY MODULE - SMPPI
*
*        ENTRY POINTS - CALLING SEQUENCE -
*                          L    R15,=A(IERABF)
*                          BALR R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIBINSZ   PPILEXFF
*
*        THESE VALUES ARE USED TO CALCULATE THE VALUES OF X AND Y
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPIBDSVA
*
*        THE ADDR OF THE MOVE ROUTINE IS PLACED IN THIS FIELD
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL -
*                BR R14 - RETURN TO CALLER
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREA - N/A
*
*        NOTES -
*        THIS MODULE IS USED IN PHASE 1 OF A VARIABLE SORT
*
IERABF   CSECT
*
         USING *,R11
         USING IERRCA,R13
         USING DIERAMA,R8          MESSAGE BASE REG
*
IERMBF   LR    R11,R15             SET BASE
         ST    R14,KSAVE           SAVE RETURN REGISTER TO IERRC9
         L     R10,PPIVMV+4        GET ADDRESS OF MOVE ROUTINE
         ST    R10,PPIBDSVA+12     PUT ADDRESS OF MOVE ROUTINE IN PPI
         L     R8,PPIAMA+4         SET MESSAGE BASE REG
         PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTICS ?
         BZ    ABFNOMES            NO, BRANCH
         LR    R0,R10              LOAD NUMBER TO BE CONVERTED
         L     R15,PPICONV+4       LOAD ADDR OF CONVERSION ROUTINE
         BAS   R14,4(,R15)         BRANCH TO CONVERSION ROUTINE
         MVC   IER905A,2(R1)       MOVE FORMATTED ADDR INTO MESSAGE
         LM    R0,R1,IER905        IER905 MOVE ROUTINE ADDR
         L     R15,PPIADSSC        R15 -> PRINT ROUTINE
         BAS   R14,12(,R15)        CALL PRINT RTN
ABFNOMES L     R4,PPIBINSZ         GET BIN SIZE
         S     R4,BFK4             X + Y = BINSIZE - 4
         LH    R3,PPILEXFF         GET LENGTH OF EXTRACTED FIELDS
         A     R3,BFK4             X = LEXFF + 4
         LR    R2,R4               PUT X+Y IN R2
         SR    R2,R3               Y = (X+Y) - X
         C     R4,BFK256           COMPARE (X+Y) TO 256
         BNH   BFMOVE1             IF (X+Y) < 256 BRANCH TO MOVE1
         C     R2,BFK256           COMPARE Y TO 256
         BNH   BFMOVE2             IF Y < 256 BRANCH TO MOVE2
*
*        MOVE3 ROUTINE SELECTED
*
BFMOVE3  ST    R2,M3VALUES+8       PUT Y IN M3VALUES
         ST    R4,M3XPLUSY         PUT (X+Y) IN M3XPLUSY
         MVC   0(256,R10),RBFM3    MOVE RBFM3 INTO IERRBF (256 CHARS)
         LA    R10,256(,R10)       UPDATE ADDR OF IERRBF
         MVC   0(52,R10),RBFM3+256 MOVE REST OF RBFM3 INTO IERRBF
BFEXIT   L     R14,KSAVE           RESTORE RETURN REGISTER
         BR    R14                 TO IERRC9
*
*        MOVE2 ROUTINE SELECTED
*
BFMOVE2  ST    R2,M2VALUES+8       PUT Y IN M2VALUES
         ST    R4,M2XPLUSY         PUT (X+Y) IN M2VALUES
         MVC   0(256,R10),RBFM2    MOVE RBFM2 INTO IERRBF (256 CHARS)
         LA    R10,256(,R10)       UPDATE ADDR OF IERRBF
         MVC   0(64,R10),RBFM2+256 MOVE REST OF RBFM2 INTO IERRBF
         B     BFEXIT              BRANCH TO RETURN
*
*        MOVE1 ROUTINE SELECTED
*
BFMOVE1  LCR   R5,R2               PUT -Y IN R5
         LCR   R6,R4               PUT -(X+Y) IN R6
         ST    R2,M1VALUES+8       PUT Y IN M1VALUES
         ST    R5,M1VALUES+12      PUT -Y IN M1VALUES
         ST    R4,M1VALUES+16      PUT X+Y IN M1VALUES
         ST    R6,M1VALUES+20      PUT -(X+Y) IN M1VALUES
         ST    R4,M1VALUES+24      PUT X+Y IN M1VALUES
         BCTR  R2,0                Y = Y - 1
         BCTR  R4,0                X+Y = (X+Y) - 1
         STC   R2,M1D008+1         PUT Y IN DEBLOCK MOVE
         STC   R2,M1B008+1         PUT Y IN BLOCK MOVE
         STC   R4,M1D004+1         PUT (X+Y) IN DEBLOCK MOVE
         STC   R4,M1B004+1         PUT (X+Y) IN BLOCK MOVE
         MVC   0(256,R10),RBFM1    MOVE RBFM1 INTO IERRBF (256 CHARS)
         LA    R10,256(,R10)       UPDATE ADDR OF IERRBF
         MVC   0(8,R10),RBFM1+256  MOVE REST OF RBFM1 INTO IERRBF
         B     BFEXIT              BRANCH TO RETURN
*
BFK4     DC    F'4'
BFK256   DC    F'256'
KSAVE    DC    F'0'                REGISTER R14 SAVE AREA
*
         DROP  R11
*
*----------------------------------------------------------------------
*
*        VARIABLE MOVE ROUTINE 1
*
*----------------------------------------------------------------------
*
*        REGISTER USAGE
*
*        R0 -  RECORD LENGTH
*        R1 -  NUMBER OF AVAILABLE BINS
*        R2 -  NOT USED
*        R3 -  NOT USED
*        R4 -  CURRENT BUFFER ADDRESS
*        R5 -  CURRENT BIN ADDRESS
*        R6 -  NOT USED
*        R7 -  BINS USED COUNT
*        R8 -  0
*        R9 -  Y
*        R10 - -Y
*        R11 - (X + Y)
*        R12 - -(X + Y)
*        R13 - (X + Y)
*        R14 - RETURN REGISTER
*        R15 - PROGRAM BASE
*
         DC    0D'0'
*
         USING *,R15
         USING IERRCA,R13
*
RBFM1    STM   R6,R14,PPIWKARE     SAVE REGISTERS 6 THROUGH 14
         LR    R14,R13             SWITCH BASE FOR PPI
         DROP  R13
         USING IERRCA,R14
         LM    R7,R13,M1VALUES     GET INITIAL REGISTER VALUES
         B     M1BRTAB(R1)         BRANCH TO INDEXED BRANCH TABLE
M1BRTAB  B     M1DBLOCK            +00 BRANCH TO DEBLOCK
         B     M1BLOCK             +04 BRANCH TO BLOCK
         L     R1,PPIBDSVA+8       +08 NO FIT LAST TIME
M1NFLAST B     M1D007              BRANCH TO CORRECT ENTRY IN DEBLOCK
         B     M1D006              BRANCH TO CORRECT ENTRY IN DEBLOCK
*
M1DBLOCK L     R1,PPIBDSVA+8       GET NUMBER OF AVAILABLE BINS
         MVC   PPIWKARE+36(2),0(R4)  PUT LENGTH ON PROPER BOUNDARY
         LH    R0,PPIWKARE+36      GET VARIABLE RECORD LENGTH - VRL
         BXLE  R0,R8,M1D001        VRL < Y, BRANCH
M1D008   MVC   0(0,R5),0(R4)       MOVE Y CHARS INTO RSA
         AR    R4,R9               BUF ADDR = CURRENT + Y
         LA    R7,1(,R7)           INCR BINS USED
         BCT   R1,M1D002           AVAIL = CURRENT - 1, IF ¬= 0 BR
         MVI   M1NFLAST+1,X'00'    MAKE NO FIT LAST SWITCH A NOP
M1NOFIT  LR    R1,R7               PUT BINS USED IN R1
         LA    R5,0(R9,R5)         UPDATE R5 TO POINT TO CHAIN ADDRESS
         LM    R6,R14,PPIWKARE     RESTORE R6 - R14
         B     0(,R14)             RETURN TO NO FIT ENTRY
*
M1D002   L     R5,0(R9,R5)         GET ADDR OF NEXT BIN
M1D006   BXLE  R0,R10,M1D005       VRL - Y < X+Y, BRANCH
M1D004   MVC   0(0,R5),0(R4)       MOVE X+Y CHARS INTO RSA
         AR    R4,R13              BUF ADDR = CURRENT + (X+Y)
         LA    R7,1(,R7)           INCR BINS USED
         BCT   R1,M1D003           AVAIL = CURRENT - 1, IF ¬= O BR
         MVI   M1NFLAST+1,X'F0'    MAKE NO FIT LAST SWITCH A BRANCH
         LR    R9,R13              PUT CORRECT UPDATE VALUE IN R9
         B     M1NOFIT             BRANCH TO START EXIT LINKAGE
*
M1D003   L     R5,0(R13,R5)        GET ADDR OF NEXT BIN
M1D007   BXH   R0,R12,M1D004       VRL -(X+Y) >  X+Y, BRANCH
M1D005   LR    R9,R13              PUT CORRECT UPDATE VALUE IN R9
M1D001   BCTR  R0,0                DECR VRL
         STC   R0,*+5              PUT VRL IN LENGTH OF FOLLOWING MOVE
         MVC   0(0,R5),0(R4)       MOVE VRL CHARS INTO RSA
         LA    R1,1(,R7)           PUT UPDATED BINS USED COUNT IN R1
         LA    R5,0(R9,R5)         UPDATE R5 TO POINT TO CHAIN ADDRESS
         LM    R6,R14,PPIWKARE     RESTORE R6 - 14
         B     4(,R14)             RETURN TO FIT ENTRY
*
M1BLOCK  LH    R0,0(,R5)           GET VARIABLE RECORD LENGTH - VRL
         BXLE  R0,R8,M1B001        VRL < Y, BRANCH
M1B008   MVC   0(0,R4),0(R5)       MOVE Y CHARS INTO OUTPUT BUFFER
         AR    R4,R9               BUF ADDR = CURRENT + Y
         LA    R7,1(,R7)           INCR BINS USED
         L     R5,0(R9,R5)         GET ADDR OF NEXT BIN
         BXLE  R0,R10,M1B005       VRL - Y < X+Y, BRANCH
M1B004   MVC   0(0,R4),0(R5)       MOVE X+Y CHARS INTO OUTPUT BUFFER
         AR    R4,R13              BUF ADDR = CURRENT + (X+Y)
         LA    R7,1(,R7)           INCR BINS USED
M1B003   L     R5,0(R13,R5)        GET ADDR OF NEXT BIN
         BXH   R0,R12,M1B004       VRL - (X+Y) > X+Y, BRANCH
M1B005   LR    R9,R13              PUT CORRECT UPDATE VALUE IN R9
M1B001   BCTR  R0,0                VRL = VRL - 1
         STC   R0,*+5              PUT VRL IN LENGTH OF FOLLOWING MOVE
         MVC   0(0,R4),0(R5)       MOVE VRL CHARS INTO OUTPUT BUFFER
         LA    R1,1(,R7)           PUT UPDATED BINS USED COUNT IN R1
         LA    R5,0(R9,R5)         UPDATE R5 TO POINT TO CHAIN ADDRESS
         LM    R6,R14,PPIWKARE     RESTORE REGISTERS 6 THROUGH 14
         B     0(,R14)             RETURN TO CALLER
*
         DROP  R14
*
M1VALUES DC    F'0'                R7 -      0
         DC    F'0'                R8 -      0
         DC    F'0'                R5 -      Y
         DC    F'0'                R10 -    -Y
         DC    F'0'                R11 -   X+Y
         DC    F'0'                R12 - -(X+Y)
         DC    F'0'                R13 -   X+Y
*
RBFM1X   EQU   *-RBFM1             L'RBFM1
*
*
*----------------------------------------------------------------------
*
*        VARIABLE MOVE ROUTINE 2
*
*----------------------------------------------------------------------
*
*        REGISTER USAGE
*
*        R0    RECORD LENGTH
*        R1 -  NUMBER OF AVAILABLE BINS
*        R2 -  NOT USED
*        R3 -  NOT USED
*        R4 -  CURRENT BUFFER ADDRESS
*        R5 -  CHAIN ADDRESS POINTER
*        R6 -  CURRENT BIN ADDRESS
*        R7 -  BINS USED COUNT
*        R8 -  0,  -Y, -(X + Y)
*        R9 -  Y, (X + Y), (X + Y)
*        R10 - 0
*        R11 - 256
*        R12 - -256
*        R13 - 256
*        R14 - RETURN REGISTER
*        R15 - PROGRAM BASE
*
         DC    0D'0'
*
         USING *,R15
         USING IERRCA,R13
*
RBFM2    STM   R6,R14,PPIWKARE     SAVE R6 - R14
         LR    R14,R13             SWITCH BASE FOR PPI
         DROP  R13
         USING IERRCA,R14
         LR    R6,R5               PUT RSA ADDR IN R6
         LM    R7,R13,M2VALUES     GET INITIAL REGISTER VALUES
         B     M2BRTAB(R1)         BRANCH TO INDEXED BRANCH TABLE
M2BRTAB  B     M2DBLOCK            +00 BRANCH TO DEBLOCK
         B     M2BLOCK             +04 BRANCH TO BLOCK
         LM    R8,R9,M2SAVE8       +08 NO FIT LAST TIME
         L     R1,PPIBDSVA+8       GET NUMBER OF AVAILABLE BINS
         B     M2D007              BRANCH TO CORRECT ENTRY IN DEBLOCK
*
M2DBLOCK L     R1,PPIBDSVA+8       GET NUMBER OF AVAILABLE BINS
         AR    R5,R9               UPDATE R5 TO POINT TO CHAIN ADDRESS
         MVC   PPIWKARE+36(2),0(R4)  PUT LENGTH ON PROPER BOUNDARY
         LH    R0,PPIWKARE+36      GET VARIABLE RECORD LENGTH - VRL
         BXLE  R0,R8,M2D005        VRL < Y, BRANCH
         LCR   R8,R9               PUT -Y IN R8
         B     M2D008              BRANCH TO MOVE Y CHARS
*
M2D004   LCR   R8,R9               PUT -(X+Y) IN R8
M2D002   MVC   0(256,R6),0(R4)     MOVE 256 CHARS INTO RSA
         AR    R6,R13              RSA ADD = CURRENT + 256
         AR    R4,R13              BUF ADD = CURRENT + 256
         BXH   R9,R12,M2D002       Y OR X+Y - 256 > 256, BRANCH
M2D008   BCTR  R9,0                L = Y OR X+] MOD(256) - 1
         STC   R9,*+5              PUT L IN LENGTH OF FOLLOWING MOVE
         MVC   0(0,R6),0(R4)       MOVE L CHARS INTO RSA
         LA    R4,1(R9,R4)         BUF ADDR = CURRENT + L + 1
         LA    R7,1(,R7)           INCR BINS USED
         BCT   R1,M2D003           AVAIL = CURRENT - 1, IF ¬= 0 BR
M2NOFIT  LR    R1,R7               PUT BINS USED IN R1
         ST    R8,M2SAVE8          SAVE CURRENT INDEX VALUE
         LM    R6,R14,PPIWKARE     RESTORE R6 - R14
         B     0(,R14)             RETURN TO NO FIT ENTRY
*
M2D003   L     R9,M2XPLUSY         GET X+Y
         L     R6,0(,R5)           GET ADDR OF NEXT BIN
M2D007   LA    R5,0(R9,R6)         UPDATE R5 TO POINT TO CHAIN ADDR
         BXH   R0,R8,M2D004        VRL - Y OR X+] >  X+], BRANCH
M2D001   BXLE  R0,R10,M2D005       VRL < 256, BRANCH
M2D006   MVC   0(256,R6),0(R4)     MOVE 256 CHARS INTO RSA
         AR    R6,R13              RSA ADD = CURRENT + 256
         AR    R4,R13              BUF ADD = CURRENT + 256
         BXH   R0,R12,M2D006       VRL - 256 > 256, BRANCH
M2D005   BCTR  R0,0                DECR VRL
         STC   R0,*+5              PUT VRL IN LENGTH OF FOLLOWING MOVE
         MVC   0(0,R6),0(R4)       MOVE VRL CHARS INTO RSA
         LA    R1,1(0,R7)          PUT UPDATED BINS USED COUNT IN R1
         LM    R6,R14,PPIWKARE     RESTORE R6 - R14
         B     4(0,R14)            RETURN TO FIT ENTRY
*
M2BLOCK  AR    R5,R9               UPDATE R5 TO POINT TO CHAIN ADDR
         LH    R0,0(0,R6)          GET VARIABLE RECORD LENGTH - VRL
         BXLE  R0,R8,M2B005        VRL < Y, BRANCH
         LCR   R8,R9               PUT -Y IN R8
         B     M2B008              BRANCH TO MOVE Y CHARS
*
M2B004   LCR   R8,R9               PUT -(X+4) IN R8
M2B002   MVC   0(256,R4),0(R6)     MOVE 256 CHARS INTO OUTPUT BUFFER
         AR    R4,R13              BUF ADDR = CURRENT + 256
         AR    R6,R13              RSA ADDR = CURRENT + 256
         BXH   R9,R12,M2B002       Y OR X+Y - 256 > 256, BRANCH
M2B008   BCTR  R9,0                L = Y OR X+Y MOD(256) - 1
         STC   R9,*+5              PUT L IN LENGTH OF FOLLOWING MOVE
         MVC   0(0,R4),0(R6)       MOVE L CHARS INTO OUTPUT BUFFER
         LA    R4,1(R9,R4)         BUF ADDR = CURRENT + L + 1
         LA    R7,1(,R7)           INCR BINS USED
         L     R9,M2XPLUSY         GET X+Y
         L     R6,0(,R5)           GET ADDR OF NEXT BIN
         LA    R5,0(R9,R6)         UPDATE R5 TO POINT TO CHAIN ADDR
         BXH   R0,R8,M2B004        VRL - Y OR X+Y > X+Y, BRANCH
M2B001   BXLE  R0,R10,M2B005       VRL < 256, BRANCH
M2B006   MVC   0(256,R4),0(R6)     MOVE 256 CHARS INTO OUTPUT BUFFER
         AR    R4,R13              BUF ADDR = CURRENT + 256
         AR    R6,R13              RSA ADDR = CURRENT + 256
         BXH   R0,R12,M2B006       VRL - 256 > 256 BRANCH
M2B005   BCTR  R0,0                VRL = VRL - 1
         STC   R0,*+5              PUT VRL IN LENGTH OF FOLLOWING MOVE
         MVC   0(0,R4),0(R6)       MOVE VRL CHARS INTO OUTPUT BUFFER
         LA    R1,1(,R7)           PUT UPDATED BINS USED COUNT IN R1
         LM    R6,R14,PPIWKARE     RESTORE REGISTERS 6 THROUGH 14
         B     0(,R14)             RETURN TO CALLER
*
         DROP  R14
*
M2VALUES DC    F'0'                R7 -    0
         DC    F'0'                R8 -    0
         DC    F'0'                R9 -    Y
         DC    F'0'                R10 -   0
         DC    F'256'              R11 - 256
         DC    F'-256'             R12 - -256
         DC    F'256'              R13 - 256
M2SAVE8  DC    F'0'                R8 SAVE AREA
M2XPLUSY DC    F'0'                X+Y
*
RBFM2X   EQU   *-RBFM2             L'RBFM2
*
*----------------------------------------------------------------------
*
*        VARIABLE MOVE ROUTINE 3
*
*----------------------------------------------------------------------
*
*        REGISTER USAGE
*
*        R0    RECORD LENGTH
*        R1 -  NUMBER OF AVAILABLE BINS
*        R2 -  NOT USED
*        R3 -  NOT USED
*        R4 -  CURRENT BUFFER ADDRESS
*        R5 -  CHAIN ADDRESS POINTER
*        R6 -  CURRENT BIN ADDRESS
*        R7 -  BINS USED COUNT
*        R8 -  0,  -Y, -(X + Y)
*        R9 -  Y, (X + Y), (X + Y)
*        R10 - 0
*        R11 - 256
*        R12 - -256
*        R13 - 256
*        R14 - RETURN REGISTER
*        R15 - PROGRAM BASE
*
         DC    0D'0'
*
         USING *,R15
         USING IERRCA,R13
*
RBFM3    STM   R6,R14,PPIWKARE     SAVE R6 - R14
         LR    R14,R13             SWITCH BASE FOR PPI
         DROP  R13
         USING IERRCA,R14
         LR    R6,R5               PUT RSA ADDR IN R6
         LM    R7,R13,M3VALUES     GET INITIAL REGISTER VALUES
         B     M3BRTAB(R1)         BRANCH TO INDEXED BRANCH TABLE
M3BRTAB  B     M3DBLOCK            +00 BRANCH TO DEBLOCK
         B     M3BLOCK             +04 BRANCH TO BLOCK
         LM    R8,R9,M3SAVE8       +08 NO FIT LAST TIME
         L     R1,PPIBDSVA+8       GET NUMBER OF AVAILABLE BINS
         B     M3D007              BRANCH TO CORRECT ENTRY IN DEBLOCK
*
M3DBLOCK L     R1,PPIBDSVA+8       GET NUMBER OF AVAILABLE BINS
         AR    R5,R9               UPDATE R5 TO POINT TO CHAIN ADDR
         MVC   PPIWKARE+36(2),0(R4)  PUT LENGTH ON PROPER BOUNDARY
         LH    R0,PPIWKARE+36      GET VARIABLE RECORD LENGTH - VRL
         BXLE  R0,R8,M3D001        VRL < Y, BRANCH
M3D004   LCR   R8,R9               PUT -Y OR -(X+Y) IN R8
M3D002   MVC   0(256,R6),0(R4)     MOVE 256 CHARS INTO RSA
         AR    R6,R13              RSA ADDR = CURRENT + 256
         AR    R4,R13              BUF ADDR = CURRENT + 256
         BXH   R9,R12,M3D002       Y OR X+Y - 256 > 256, BRANCH
         BCTR  R9,0                L = Y OR X+Y MOD(256) - 1
         STC   R9,*+5              PUT L IN LENGTH OF FOLLOWING MOVE
         MVC   0(0,R6),0(R4)       MOVE L CHARS INTO RSA
         LA    R4,1(R9,R4)         BUF ADDR = CURRENT + L + 1
         LA    R7,1(,R7)           INCR BINS USED
         BCT   R1,M3D003           AVAIL = CURRENT - 1, IF ¬= 0 BR
M3NOFIT  LR    R1,R7               PUT BINS USED IN R1
         ST    R8,M3SAVE8          SAVE CURRENT INDEX VALUE
         LM    R6,R14,PPIWKARE     RESTORE R6 - R14
         B     0(,R14)             RETURN TO NO FIT ENTRY
*
M3D003   L     R9,M3XPLUSY         GET X+Y
         L     R6,0(,R5)           GET ADDR OF NEXT BIN
M3D007   LA    R5,0(R9,R6)         UPDATE R5 TO POINT TO CHAIN ADDR
         BXH   R0,R8,M3D004        VRL - Y OR X+Y > X+Y, BRANCH
M3D001   BXLE  R0,R10,M3D005       VRL < 256, BRANCH
M3D006   MVC   0(256,R6),0(R4)     MOVE 256 CHARS INTO RSA
         AR    R6,R13              RSA ADDR = CURRENT + 256
         AR    R4,R13              BUF ADDR = CURRENT + 256
         BXH   R0,R12,M3D006       VRL - 256 > 256, BRANCH
M3D005   BCTR  R0,0                VRL = VRL - 1
         STC   R0,*+5              PUT VRL IN LENGTH OF FOLLOWING MOVE
         MVC   0(0,R6),0(R4)       MOVE VRL CHARS INTO RSA
         LA    R1,1(,R7)           PUT UPDATED BINS USED COUNT IN R1
         LM    R6,R14,PPIWKARE     RESTORE R6 - R14
         B     4(0,R14)            RETURN TO FIT ENTRY
*
M3BLOCK  AR    R5,R9               UPDATE R5 TO POINT TO CHAIN ADDR
         LH    R0,0(,R6)           GET VARIABLE RECORD LENGTH - VRL
         BXLE  R0,R8,M3B001        VRL < Y, BRANCH
M3B004   LCR   R8,R9               PUT -Y OR -(X+Y) IN R8
M3B002   MVC   0(256,R4),0(R6)     MOVE 256 CHARS INTO OUTPUT BUFFER
         AR    R4,R13              BUF ADDR = CURRENT + 256
         AR    R6,R13              RSA ADDR = CURRENT + 256
         BXH   R9,R12,M3B002       Y OR X+Y - 256 > 256, BRANCH
         BCTR  R9,0                L = Y OR X+Y MOD(256) - 1
         STC   R9,*+5              PUT L IN LENGTH OF FOLLOWING MOVE
         MVC   0(0,R4),0(R6)       MOVE L CHARS INTO OUTPUT BUFFER
         LA    R4,1(R9,R4)         BUF ADDR = CURRENT + L + 1
         LA    R7,1(0,R7)          INCR BINS USED
         L     R9,M3XPLUSY         GET X+Y
         L     R6,0(,R5)           GET ADDR OF NEXT BIN
         LA    R5,0(R9,R6)         UPDATE R5 TO POINT TO CHAIN ADDR
         BXH   R0,R8,M3B004        VRL - Y OR X+Y > X+Y, BRANCH
M3B001   BXLE  R0,R10,M3B005       VRL < 256, BRANCH
M3B006   MVC   0(256,R4),0(R6)     MOVE 256 CHARS INTO OUTPUT BUFFER
         AR    R4,R13              BUF ADDR = CURRENT + 256
         AR    R6,R13              RSA ADDR = CURRENT + 256
         BXH   R0,R12,M3B006       VRL - 256 > 256, BRANCH
M3B005   BCTR  R0,0                VRL = VRL - 1
         STC   R0,*+5              PUT VRL IN LENGTH OF FOLLOWING MOVE
         MVC   0(0,R4),0(R6)       MOVE VRL CHARS INTO OUTPUT BUFFER
         LA    R1,1(,R7)           PUT UPDATED BINS USED COUNT IN R1
         LM    R6,R14,PPIWKARE     RESTORE R6 THROUGH R14
         B     0(,R14)             RETURN TO CALLER
*
         DROP  R14
*
M3VALUES DC    F'0'                R7 -    0
         DC    F'0'                R8 -    0
         DC    F'0'                R9 -    Y
         DC    F'0'                R10 -   0
         DC    F'256'              R11 - 256
         DC    F'-256'             R12 - -256
         DC    F'256'              R13 - 256
M3SAVE8  DC    F'0'                R8 SAVE AREA
M3XPLUSY DC    F'0'                X+Y
*
RBFM3X   EQU   *-RBFM3             L'RBFM3
*
DIERAMA  DSECT
*
         COPY  AMAMAIN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERABG   0101-20211-20211-1200-00117-00117-00000-RELEASE 00
ABG      TITLE 'IERABG - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERABG
*
*        MODULE FUNCTION/OPERATION -
*        THIS MODULE IS AN ASSIGNMENT ROUTINE FOR MODULE IERRBG
*        A BLOCK/ DEBLOCK MODULE FOR FIXED LENGTH RECORDS IN THE
*        MERGE PHASE. IT ADJUSTS BUFFER POINTERS IN RUNNING
*        PROGRAM FOR DASD OR TAPE. FOR DIRECT ACCESS DEVICE OR A
*        FORWARD READ PASS, IT ALSO MAKES OVERLAYS IN THE BLOCK
*        PORTION OF THE RUNNING PROGRAM
*
*        USED AS A DSECT IN - N/A
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                       CALLING SEQUENCE -
*                           L    R15,ASSG
*                           BR   R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPISRTBL   PPIRCDL2   PPILAB07
*        PPILAB04   PPICNTL
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPICOUNT - SET TO 0
*
*        INITIALIZES CONSTANTS AND CODE IN RUNNING PROGRAM
*
*        EXTERNAL ROUTINES -
*        N/A
*
*        EXTERNAL PARAMETERS -
*        PPIBLK2 - ADDR OF RUNNING PROGRAM DSECT
*
*        EXITS - NORMAL -
*        IERRC9 - RETURN TO LOAD MODULE
*                 BR R14
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS - N/A
*
*        NOTES -
*        THIS MODULE IS USED FOR FIXED LENGTH RECORDS LESS THAN
*        OR EQUAL TO 256 BYTES LONG
*
IERABG   CSECT
*
         USING *,R11
         USING DIERRBG,R4
         USING IERRCA,R13
*
IERMBG   LR    R11,R15
         L     R4,PPIBLK2+4        SET DSECT BASE REG
         SR    R8,R8               ZERO OUT RECORD COUNT IN PPI
         ST    R8,PPICOUNT
         LH    R5,PPISRTBL         SET OUTPUT BLK CNT = SORT BLOCKING
         ST    R5,KOBLKCNT
         LH    R5,PPIRCDL2         SET RCD LENGTH - 1 IN
         BCTR  R5,0                INLINE MOVE INSTR
         STC   R5,RBG2025+1
         STC   R5,KRBGMOD1+1
         LH    R6,PPILAB07+2       SET R6 = OUTPUT BUFFER SIZE
         ST    R6,KBUFSIZ          SET BUFF SIZE IN RUNNING PROGRAM
         SR    R5,R5
         ICM   R5,B'0111',PPILAB04+1  R5 -> FIRST OUTPUT BUFFER
         PPITEST  PPITAPE          TAPE SORT ?
         BZ    ABG2020             NO, DASD
         PPITEST  PPIBLKF          YES, TAPE, BLOCK FORWARD SW ON ?
         BO    ABG2020             YES
ABG2010  AR    R5,R6               NO, SET CONSTANTS
         ST    R5,KBLKPTR          SET BLOCK POINTER AND
         ST    R5,KIBLKPTR         INITIAL BLOCK POINTER
         BR    R14                 RETURN TO LOAD MODULE
*
*        MAKE OVERLAYS IN RUNNING PROGRAM FOR BLOCKING FORWARD
*
ABG2020  LA    R6,4                  ADJUST FOR EOS INDICATION
         MVC   RBG2020(14),KRBGMOD1  OVERLAY INSTRUCTIONS IN RUNNING
*                                    PROG TO MOVE RCD BEFORE BLK PTR
*                                    IS INCREMENTED
         MVC   RBG2053(4),KRBGMOD2   LOAD INITIAL
         MVC   RBG2090(4),KRBGMOD2   BLOCK POINTER
         B     ABG2010
*
*        CONSTANTS
*
         DROP  R11
         DROP  R4
*
         USING DIERRBG,R11
KRBGMOD1 MVC   0(1,R2),0(R3)       MOVE WINNER RCD TO OUTPUT BUFFER
         AH    R2,PPIRCDL2         INCREMENT BLK PTR BY RCD LENGTH
         ST    R2,KBLKPTR
KRBGMOD2 L     R2,KIBLKPTR         LOAD INITIAL POINTER
*
DIERRBG  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRBG SOURCE
*
*----------------------------------------------------------------------
*
         COPY IERRBGI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERABH   0101-20211-20211-1200-00116-00116-00000-RELEASE 00
ABH      TITLE 'IERABH - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERABH
*
*        MODULE FUNCTION/OPERATION -
*        MODULE IS AN ASSIGNMENT ROUTINE FOR MODULE IERRBH,
*        A BLOCK/ DEBLOCK ROUTINE FOR FIXED LENGTH RECORDS
*        GREATER THAN 256 BYTES IN THE MERGE PHASE. IT ADJUSTS
*        BUFFER POINTERS IN THE RUNNING PROGRAM. FOR DIRECT
*        ACCESS DEVICES BLOCKING FOR A FORWARD READ PASS, IT ALSO
*        MAKES OVERLAYS IN THE BLOCK PORTION OF THE RUNNING
*        PROGRAM
*
*        MODULES IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                       CALLING SEQUENCE -
*                           L    R15,ASSG
*                           BR   R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPISRTBL   PPILAB07   PPILAB04   PPICNTL
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPICOUNT - SET TO 0
*        CONSTANTS AND CODE IN RUNNING PROGRAM ARE INITIALIZED
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS -
*        PPIBLK2 - ADDR FOR DSECT
*
*        EXITS - NORMAL - IERRC9
*              - BR  R14 - RETURN TO LOAD MODULE
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS - N/A
*
*        NOTES -
*        THIS MODULE IS USED FOR FIXED LENGTH RECORDS > 256 BYTES
*
IERABH   CSECT
*
         USING *,R11
         USING DIERRBH,R4
         USING IERRCA,R13
*
IERMBG   LR    R11,R15
         L     R4,PPIBLK2+4        SET DSECT BASE REG
         SR    R8,R8
         ST    R8,PPICOUNT         ZERO OUT RCD COUNT IN PPI
         LH    R5,PPISRTBL         SET OUTPUT BLK CNT=SORT BLKING
         ST    R5,KOBLKCNT
         LH    R6,PPILAB07+2       SET R6=OUTPUT BUFFER SIZE
         ST    R6,KBUFSIZ          SET BUFF SIZE IN RUNNING PROG
         SR    R5,R5
         ICM   R5,B'0111',PPILAB04+1  R5 -> FIRST OUTPUT BUFFER
         PPITEST  PPITAPE          TAPE SORT ?
         BZ    ABH2020             NO, DASD
         PPITEST  PPIBLKF          TAPE SORT, BLOCK FORWARD SW ON ?
         BO    ABH2020             YES
ABH2010  AR    R5,R6               NO, SET CONSTANTS
         ST    R5,KBLKPTR          SET BLOCK POINTER AND
         ST    R5,KIBLKPTR         INITIAL BLOCK POINTER
         BR    R14                 RETURN TO LOAD MODULE
*
*        DASD SORT
*        MAKE OVERLAYS IN RUNNING PROGRAM FOR BLOCKING FORWARD
*
ABH2020  LA    R6,4                  ADJUST FOR EOS INDICATION
         MVC   RBH2020(18),KRBHMOD1  OVERLAY INSTR IN RUNNING PROG
*                                    SO THAT RCD WILL BE MOVED TO
*                                    OUTPUT BUFFER BEFORE BLK PTR IS
*                                    INCREMENTED
         MVC   RBH2053(4),KRBHMOD2   LOAD INITIAL
         MVC   RBH2090(4),KRBHMOD2   BLOCK POINTER
         B     ABH2010
*
*        CONSTANTS
*
         DROP  R11
         DROP  R4
*
         USING DIERRBH,R11
KRBHMOD1 LR    R4,R3
         LR    R5,R2
         L     R15,PPIBDSVA+8      LINK TO MOVE LIST TO MOVE RECORD TO
         BASR  R14,R15             OUTPUT BUFFER
         AH    R2,PPIRCDL2         INCREMENT BLK PTR BY RCD LENGTH
         ST    R2,KBLKPTR
KRBHMOD2 L     R2,KIBLKPTR         LOAD PARAM REG WITH BUFFER ADDR
*
*        IERRBH
*
DIERRBH  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRBH SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRBHI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERABI   0101-20211-20211-1200-00117-00117-00000-RELEASE 00
ABI      TITLE 'IERABI - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERABI
*
*        MODULE FUNCTION/OPERATION -
*        ASSIGNMENT FOR THE RUNNING PROGRAM IERRBI, BLOCK, PHASE 2
*        THIS MODULE TESTS WHETHER IT IS A DASD SORT OR TAPE
*        SORT AND OVERLAYS THE RUNNING PROGRAM WHEREVER
*        NECESSARY. IT ALSO SETS WORK AREAS AND CONSTANTS TO
*        SPECIFIC VALUES IN THE RUNNING PROGRAM.THE ASSIGNMENT
*        PROGRAM UTILIZES THE DISK SORT ROUTINE FOR THE FORWARD
*        BLOCK TAPE SORT
*
*        THE OPERATION OF THIS MODULE DOES NOT DEPEND UPON A
*        PARTICULAR INTERNAL REPRESENTATION OF THE EXTERNAL
*        CHARACTER SET
*
*        MODULES IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                       CALLING SEQUENCE -
*                            LOAD   EP=IERABI,DCB=
*                            LR     R15,R0
*                            BALR   R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPILAB04   PPILAB07   PPICNTL
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        CONSTANTS AND CODE IN THE RUNNING PROGRAM ARE
*        INITIALIZED
*
*        EXTERNAL ROUTINES - NONE
*
*        EXTERNAL PARAMETERS - NONE
*
*        EXITS - NORMAL -
*        BR R14 - RETURN TO IERRC9
*
*        EXITS - ERROR - NONE
*
*        TABLES/WORK AREAS - NONE
*
*        NOTES -
*        THIS MODULE IS USED FOR VARIABLE LENGTH RECORDS WITHOUT
*        USER EXITS IN THE MERGE PHASE
*
IERABI   CSECT
*
         USING *,R11               MODULE BASE REG LOADED EXTERNALLY
         USING IERRBID,R10         ADDR OF RUNNING PROGRAM DUMMY MOD
         USING IERRCA,R13          PPI COMMON MODULE BASE REGISTER
*
IERMBG   LR    R11,R15             LOAD MODULE BASE REG
         L     R10,PPIBLK2+4       LOAD ADDRESS OF RUNNING PROGRAM
         MVC   WBLKCCNT,KEIGHT     SET BLOCK CHARACTER CTR TO 8
         SR    R5,R5
         ICM   R5,B'0111',PPILAB04+1  R5 -> OUTPUT BUFFER 1
         PPITEST  PPITAPE          TAPE SORT ?
         BZ    ABDISK              DASD, BRANCH
*
*        FORWARD BLOCK TAPE SORT ?
*
         PPITEST  PPIBLKF          FORWARD BLOCK TAPE SORT ?
         BO    ABDISK              YES, BRANCH TO DISK ROUTINE
*
*        TAPE SORT ROUTINE
*
         AH    R5,PPILAB07+2       ADD ROUNDED LENGTH OF OUTPUT BLOCK
         ST    R5,WLSTPTR          OUTPUT BLOCK ENDING ADDR+1
         ST    R5,WLSTPTRD         CURRENT OUTPUT BLK ENDING ADDR+1
         BR    R14                 RETURN TO LOAD MODULE
*
*        DISK SORT ROUTINE
*
ABDISK   LA    R5,8(,R5)           EQUALS OUTPUT BLOCK STARTING ADDR+8
         ST    R5,WLSTPTR          STORE IN RP AS OUTPUT BLK LIST PTR
         ST    R5,WLSTPTRD         CURRENT OUTPUT BLOCK STRTG ADDR+8
         MVC   RBSUBRLT(2),KNOP    NOP RP TAPE INSTR
         MVC   RBSUBRLD(2),KNOP    NOP RP TAPE INSTR
         MVC   RBLSTPTR(4),KON1    OVERLAY RP INSTR WITH KON1
         MVC   RBEOS(4),KON2       OVERLAY RP INSTR WITH KON2
         BR    R14                 RETURN TO LOAD MODULE
*
*        CONSTANTS
*
KNOP     DC    X'4700'             NOP
*
         DROP  R10
*
         USING IERRBID,R11
KON1     L     R2,WLSTPTRD
KON2     L     R4,WLSTPTRD
*
*        IERRBI
*
IERRBID  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRBI SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRBII
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERABJ   0101-20211-20211-1200-00120-00120-00000-RELEASE 00
ABJ      TITLE 'IERABJ - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERABJ
*
*        MODULE FUNCTION/OPERATION -
*        ASSIGNMENT ROUTINE FOR MODULE IERRBJ
*        A BLOCK/ DEBLOCK MODULE FOR FIXED LENGTH RECORDS WITH
*        USER MODIFICATIONS IN MERGE PHASE. IT ADJUSTS BUFFER
*        POINTERS IN RUNNING PROGRAM. FOR DIRECT ACCESS DEVICE OR
*        BLOCKING FOR A READ FORWARD PASS, IT ALSO MAKES
*        OVERLAYS IN THE BLOCK PORTION OF THE RUNNING PROGRAM
*
*        MODULES IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM
*                       CALLING SEQUENCE -
*                           L   R15,ASSG
*                           R   R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPISRTBL   PPILAB07   PPILAB04   PPICNTL
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPICOUNT - SET TO 0
*        CONSTANTS AND CODE IN RUNNING PROGRAM ARE INITIALIZED
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS -
*        PPIBLK2 - ADDR FOR DSECT
*        PPIX25  - USER ADDR FOR EXIT E15
*
*        EXITS - NORMAL -
*                BR R14 - RETURN TO IERRC9
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS - N/A
*
*        NOTES -
*        THIS MODULE IS USED FOR FIXED LENGTH RECORDS WHEN E25
*        IS ACTIVE
*
IERABJ   CSECT
*
         USING *,R11
         USING DIERRBJ,R4
         USING IERRCA,R13
*
IERMBG   LR    R11,R15
         L     R4,PPIBLK2+4        SET BASE REG FOR DSECT
         SPACE 3
         SR    R8,R8               ZERO OUT RECORD AND
         ST    R8,PPICOUNT         DELETE COUNTERS IN PPI
         LH    R5,PPISRTBL         SET OUTPUT BLK CNT = SORT BLOCKING
         ST    R5,KOBLKCNT
         LH    R6,PPILAB07+2       SET R6 = OUTPUT BUFFER SIZE
         ST    R6,KBUFSIZ          SET BUFF SIZE IN RUNNING PROGRAM
         SR    R5,R5
         ICM   R5,B'0111',PPILAB04+1  R5 -> FIRST OUTPUT BUFFER
         PPITEST  PPITAPE          TAPE SORT ?
         BZ    ABJ2020             NO, DASD
         PPITEST  PPIBLKF          TAPE, BLOCK FORWARD SW ON ?
         BO    ABJ2020             YES
ABJ2010  AR    R5,R6               NO, SET CONSTANTS
         ST    R5,KBLKPTR          SET BLOCK POINTER AND
         ST    R5,KIBLKPTR         INITIAL BLOCK POINTER
         BR    R14                 RETURN TO LOAD MODULE
*
*        MAKE OVERLAYS IN RUNNING PROGRAM FOR BLOCKING FORWARD
*
ABJ2020  LA    R6,4                ADJUST FOR EOS INDICATION
*
*        OVERLAY INSTRUCTIONS IN RUNNING PROGRAM SO THAT RECORD
*        WILL BE MOVED TO THE OUTPUT BUFFER BEFORE BLOCK POINTER
*        IS INCREMENTED AND SO THAT INITIAL POINTER IS LOADED IN
*        PARAMETER REG FOR WRITE ROUTINE
*
         MVC   RBJ2020(18),KRBJMOD1
         MVC   RBJ2053(4),KRBJMOD2
         MVC   RBJ2090(4),KRBJMOD2
         B     ABJ2010
*
*        CONSTANTS
*
         DROP  R11
         DROP  R4
*
         USING DIERRBJ,R11
KRBJMOD1 LR    R4,R1
         LR    R5,R2
         L     R15,PPIBDSVA+8      LINK TO MOVE LIST TO MOVE RECORD TO
         BASR  R14,R15             OUTPUT BUFFER
         ST    R2,KPARLST+4
         AH    R2,PPIRCDL2
KRBJMOD2 L     R2,KIBLKPTR
*
*        IERRBJ
*
DIERRBJ  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRBJ SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRBJI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERABK   0101-20211-20211-1200-00115-00115-00000-RELEASE 00
ABK      TITLE 'IERABK - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERABK
*
*        MODULE FUNCTION/OPERATION -
*        ASSIGNMENT FOR THE RUNNING PROG IERRBK, BLOCK, PHASE 2
*        THIS MODULE TESTS WHETHER IT IS A DISK SORT OR TAPE
*        SORT AND OVERLAYS THE RUNNING PROGRAM WHEREVER
*        NECESSARY. IT ALSO SETS WORK AREAS AND CONSTANTS TO
*        SPECIFIC VALUES IN THE RUNNING PROGRAM. THE ASSIGNMENT
*        PROGRAM UTILIZES THE DISK SORT ROUTINE FOR THE FORWARD
*        BLOCK TAPE SORT
*
*        THE OPERATION OF THIS MODULE DOES NOT DEPEND UPON A
*        PARTICULAR INTERNAL REPRESENTATION OF THE EXTERNAL
*        CHARACTER SET
*
*        MODULES IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                       CALLING SEQUENCE -
*                            LOAD   EP=IERABK,DCB=
*                            LR     R15,R0
*                            BALR   R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPILAB04   PPILAB07   PPICNTL
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        CONSTANTS AND CODE IN THE RUNNING PROGRAM ARE
*        INITIALIZED
*
*        EXTERNAL ROUTINES - NONE
*
*        EXTERNAL PARAMETERS - NONE
*
*        EXITS - NORMAL -
*        BR R14 - RETURN TO IERRC9
*
*        EXITS - ERROR - NONE
*
*        TABLES/WORK AREAS - NONE
*
*        NOTES -
*        THIS MODULE IS USED FOR VARIABLE LENGTH RECORDS WITH
*        USER EXIT E25 IN THE MERGE PHASE
*
IERABK   CSECT
*
         USING *,R11               MODULE BASE REG LOADED EXTERNALLY
         USING IERRBKD,R10         ADDR OF RUNNING PROGRAM DUMMY MOD
         USING IERRCA,R13          PPI COMMON MODULE BASE REGISTER
*
IERMBG   LR    R11,R15             LOAD MODULE BASE REG
         L     R10,PPIBLK2+4       LOAD ADDR OF RUNNING PROGRAM
         MVC   WBLKCCNT,KEIGHT     SET BLOCK CHARACTER CTR TO 8
         SR    R5,R5
         ICM   R5,B'0111',PPILAB04+1  R5 -> OUTPUT BUFFER 1
         PPITEST  PPITAPE          TAPE SORT ?
         BZ    ABDISK              NO, DASD
*
*        TEST FORWARD BLOCK BIT IN PPI
*
         PPITEST  PPIBLKF          FORWARD BLOCK SET ?
         BO    ABDISK              YES, BRANCH TO DISK SORT ROUTINE
*
*        TAPE SORT ROUTINE
*
         AH    R5,PPILAB07+2       ADD ROUNDED LENGTH OF OUTPUT BLOCK
         ST    R5,WLSTPTR          OUTPUT BLOCK ENDING ADDR+1
         ST    R5,WLSTPTRD         CURRENT OUTPUT BLK ENDING ADDR+1
         BR    R14                 RETURN TO LOAD MODULE
*
*        DISK SORT ROUTINE
*
ABDISK   LA    R5,8(,R5)           EQUALS OUTPUT BLOCK STRTG ADDR+8
         ST    R5,WLSTPTR          STORE IN RP AS OUTPUT BLK LIST PTR
         ST    R5,WLSTPTRD         CURRENT OUTPUT BLOCK ADDR+8
         MVC   RBSUBRLT(2),KNOP    NOP RP TAPE INSTR
         MVC   RBSUBRLD(2),KNOP    NOP RP TAPE INSTR
         MVC   RBLSTPTR(4),KON1    OVERLAY RP INSTR WITH KON1
         MVC   RBEOS(4),KON2       OVERLAY RP INSTR WITH KON2
         BR    R14                 RETURN TO LOAD MODULE
*
*        CONSTANTS
*
KNOP     DC    X'4700'             NOP
         DROP  R10
         USING IERRBKD,R11
KON1     L     R2,WLSTPTRD
KON2     L     R4,WLSTPTRD
*
*        MODULE NAME - IERRBK
*
IERRBKD  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRBK SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRBKI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERABL   0101-20211-20211-1200-00102-00102-00000-RELEASE 00
ABL      TITLE 'IERABL - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERABL
*
*        MODULE FUNCTION/OPERATION -
*        ASSIGNMENT ROUTINE FOR MODULE IERRBL
*        IT IS USED IN FINAL MERGE PHASE OR MERGE ONLY FOR FIXED
*        LENGTH RECORDS LESS THAN 256 BYTES LONG
*
*        MODULES IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                       CALLING SEQUENCE -
*                           L    R15,ASSG
*                           BALR R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPISTDCB
*        PPIRCDL3
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED - N/A
*        CONSTANTS IN RUNNING PROGRAM ARE INITIALIZED
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS -
*        PPIBLK - ADDR OF RUNNING PROGRAM USED TO ADDR DSECT
*
*        EXITS - NORMAL -
*                BR R14 - RETURN TO IERRC9
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS - N/A
*
*        NOTES -
*        THIS MODULE IS USED FOR FIXED LENGTH RECORDS LESS THAN
*        256 BYTES
*
IERABL   CSECT
*
         USING *,R11
         USING DIERRBL,R8
         USING IERRCA,R13
         USING DIERAMC,R2          MESSAGE MODULE BASE REG
*
IERMB34  LR    R11,R15
         L     R8,PPIBLK+4
         L     R2,PPIAMC+4         SET MESSAGE BASE REG
         L     R7,PPISTDCB         ACCESS ADDR OF OUTPUT DCB AND
         L     R5,0(,R7)           STORE IN RUNNING
         ST    R5,KADCB            PROGRAM
         LH    R5,PPIRCDL3         SET RCD LENGTH - 1 IN
         BCTR  R5,0                RUNNING PROGRAM
         STC   R5,RBL34010+1
         PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTICS ?
         BZ    ABLRTN              NO, BRANCH TO RETURN
         ST    R14,ABLSAVO         SAVE R14
         SR    R0,R0
         ICM   R0,B'0111',PPILAB04+1  R0 -> OB1 FOR CONVERSION
         L     R15,PPICONV+4       LOAD ADDR OF CONVERSION ROUTINE
         BAS   R14,4(,R15)         CONVERT
         MVC   IER942A,2(R1)       MOVE FORMATTED ADDR INTO MSG
         L     R0,PPILAB05         LOAD ADDR OF OB2 FOR CONVERSION
         L     R15,PPICONV+4       LOAD ADDR OF CONVERSION ROUTINE
         BAS   R14,4(,R15)         CONVERT
         MVC   IER942B,2(R1)       MOVE FORMATTED ADDR INTO MSG
         LM    R0,R1,IER942        IER942I OUTPUT BUFFER ADDR
         L     R15,PPIADSSC        LOAD ADDR OF PRINT ROUTINE
         BAS   R14,12(,R15)        PRINT
         L     R14,ABLSAVO         RESTORE R14
ABLRTN   BR    R14                 RETURN TO LOAD MODULE
*
ABLSAVO  DC    F'0'
*
DIERAMC  DSECT
*
         COPY  AMCMAIN
*
*        IERRBL
*
DIERRBL  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRBL SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRBLI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERABM   0101-20211-20211-1200-00113-00113-00000-RELEASE 00
ABM      TITLE 'IERABM - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERABM
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 3 ASSIGNMENT MODULE - FIXED LENGTH RECORDS WITH E35
*        THE FUNCTION OF THIS MODULE IS TO INSERT THE ADDRESS OF
*        THE OUTPUT DCB IN IERRBM. IT ALSO CHECKS TO SEE IF
*        ATTACHED IN PHASE 3 AND IF ATTACHED, INSERTS THIS
*        ADDRESS FROM PPIATP3E IN PPIX35. IF NOT ATTACHED EXIT
*        E35 HAS BEEN ACTIVATED THROUGH THE CONTROL STATEMENTS
*
*        MODULES IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACROS USED BY THE MODULE - SMPPI
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                       CALLING SEQUENCE -
*                           LOAD  EP=IERABM,DCB=SORTLIB
*                           LR    R15,R0
*                           BALR  R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPISTDCB   PPIATP3E
*        STARTING ADDR OF THE DCBS AND USER ATTACHED EXIT
*        ADDRESS
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED - NONE
*
*        EXTERNAL ROUTINES - NONE
*
*        EXTERNAL PARAMETERS - SEE REGISTERS
*
*        EXITS - NORMAL - TO IERRC9
*                         CALLING SEQUENCE -
*                         BR R14
*
*        EXITS - ERROR - NONE
*
*        TABLES/WORK AREAS - NONE
*
*        NOTES -
*        THIS MODULE IS USED FOR ANY FIXED LENGTH SORT WITH EXIT
*        E35 ACTIVE IN IERRBM
*
IERABM   CSECT
*
         USING *,R11
         USING IERRBMD,R10         ADDR OF IERRBM DSECT
         USING IERRCA,R13
         USING DIERAMC,R9          MESSAGE MODULE BASE REG
*
IERMB34  LR    R11,R15             LOAD MODULE BASE REGISTER
         L     R10,PPIBLK+4        ADDR OF IERRBM (RP) FOR DSECT BASE
*
*        DETERMINE ADDR OF OUTPUT DCB AND STORE IN IERRBM
*
         L     R4,PPISTDCB         R4 -> LIST OF DCB ADDR
         MVC   WDCB,0(R4)          STORE DCB ADDR IN RP
         PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTICS ?
         BZ    ABMNOMES            NO, BRANCH
         ST    R14,ABMSAVO         SAVE R14
         L     R9,PPIAMC+4         SET MESSAGE BASE REG
         SR    R0,R0
         ICM   R0,B'0111',PPILAB04+1  R0 -> OB1 FOR CONVERSION
         L     R15,PPICONV+4       R15 -> CONVERSION ROUTINE
         BAS   R14,4(,R15)         CONVERT
         MVC   IER942A,2(R1)       MOVE FORMATTED ADDR INTO MSG
         L     R0,PPILAB05         LOAD ADDR OF OB2 FOR CONVERSION
         L     R15,PPICONV+4       R15 -> CONVERSION ROUTINE
         BAS   R14,4(,R15)         CONVERT
         MVC   IER942B,2(R1)       MOVE FORMATTED ADDR INTO MSG
         LM    R0,R1,IER942        IER942I OUTPUT BUFFER ADDR
         L     R15,PPIADSSC        R15 -> PRINT ROUTINE
         BAS   R14,12(,R15)        CALL PRINT MSG
         L     R14,ABMSAVO         RESTORE R14
ABMNOMES ICM   R15,B'1111',PPIATP3E  ATTACHED EXIT ?
         BNZ   ABATTEXT            YES, BRANCH TO ATTACH EXIT RTN
*
*        RETURN TO IERRC9 FOR NEXT ASSIGNMENT ROUTINE
*
ABENDMOD BR    R14
*
ABATTEXT ST    R15,PPIX35+4        SET EXIT E35 TO ATTACHED EXIT
         B     ABENDMOD            BRANCH TO NEXT ASSIGNMENT RTN
*
ABMSAVO  DC    F'0'
*
DIERAMC  DSECT
*
         COPY  AMCMAIN
*
*        IERRBM
*
IERRBMD  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRBM SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRBMI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERABN   0101-20211-20211-1200-00105-00105-00000-RELEASE 00
ABN      TITLE 'IERABN - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERABN
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 3 BLOCK ASSIGNMENT MODULE VARIABLE LENGTH RECORDS
*
*        THE FUNCTION OF THIS MODULE IS TO INSERT THE ADDRESS OF
*        THE OUTPUT DCB IN IERRBN, SO THAT IERRBN MAY HAVE THIS
*        ADDRESS DIRECTLY
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY IERABN - ENTRY FROM IERRC9
*                                      CALLING SEQUENCE -
*                                      LOAD    EP=IERABN,DCB=SORTLIB
*                                      LR      R15,R0
*                                      BALR    R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPISTDCB
*        STARTING ADDR OF THE DCBS
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        NONE
*
*        EXTERNAL ROUTINES - NONE
*
*        EXTERNAL PARAMETERS - SEE REGISTERS
*
*        EXITS - NORMAL - IERRC9 - EXIT TO IERRC9
*                                  CALLING SEQUENCE
*                                  BR R14
*
*        EXITS - ERROR - NONE
*
*        TABLES/WORK AREAS - NONE
*
*        NOTES -
*        THIS MODULE IS USED FOR ANY VARIABLE LENGTH SORT
*        WITHOUT EXITS
*
IERABN   CSECT
*
         USING *,R11
         USING DIERRBN,R10         ADDR OF RP DSECT
         USING IERRCA,R13          ADDR OF PPI
         USING DIERAMC,R9          MESSAGE MODULE BASE R9
*
IERMB34  LR    R11,R15             LOAD MODULE BASE REG
         L     R10,PPIBLK+4        ADDR OF IERRBN FOR DSECT BASE
*
*        CALCULATE ADDR OF OUTPUT DCB AND STORE IN IERRBN
*
         L     R4,PPISTDCB         POINTER TO LIST OF DCB ADDRS
         MVC   WDCB,0(R4)          STORE OUTPUT DCB ADDR IN IERRBN
*
*        BRANCH TO NEXT ASSIGNMENT ROUTINE
*
         L     R9,PPIAMC+4         SET MESSAGE BASE REG
         PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTICS REQUESTED ?
         BZ    ABNNOMES            NO, BRANCH
         ST    R14,ABNSAVO         SAVE R14
         SR    R0,R0
         ICM   R0,B'0111',PPILAB04+1  R0 -> OB1 FOR CONVERSION
         L     R15,PPICONV+4       LOAD ADDR OF CONVERSION ROUTINE
         BAS   R14,4(,R15)         CONVERT
         MVC   IER942A,2(R1)       PUT FORMATTED ADDR IN MESSAGE
         L     R0,PPILAB05         LOAD ADDR OF OB2 FOR CONVERSION
         L     R15,PPICONV+4       LOAD ADDR OF CONVERSION ROUTINE
         BAS   R14,4(,R15)         CONVERT
         MVC   IER942B,2(R1)       PUT FORMATTED ADDR IN MESSAGE
         LM    R0,R1,IER942        IER942I OUTPUT BUFFER ADDR
         L     R15,PPIADSSC        LOAD ADDR OF PRINT ROUTINE
         BAS   R14,12(,R15)        PRINT
         L     R14,ABNSAVO         RESTORE R14
ABNNOMES BR    R14                 RETURN TO IERRC9
*
ABNSAVO  DC    F'0'
*
DIERAMC  DSECT
*
         COPY  AMCMAIN
*
DIERRBN  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRBN SOURCE
*
*----------------------------------------------------------------------
*
         COPY IERRBNI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERABO   0101-20211-20211-1200-00122-00122-00000-RELEASE 00
ABO      TITLE 'IERABO - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERABO
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 3 ASSIGNMENT MODULE - VARIABLE LENGTH RECORDS WITH E35
*        THE FUNCTION OF THIS MODULE IS TO INSERT THE ADDRESS OF
*        THE OUTPUT DCB IN IERRBN. IT ALSO CHECKS TO SEE IF
*        ATTACHED IN PHASE 3 AND IF ATTACHED, INSERTS THIS
*        ADDRESS FROM PPIATP3E IN PPIX35. IF NOT ATTACHED EXIT
*        E35 (PPIX35) HAS BEEN ACTIVATED THROUGH CONTROL STMTS
*
*        MODULES IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                       CALLING SEQUENCE -
*                           LOAD  EP=IERABM,DCB=SORTLIB
*                           LR    R15,R0
*                           BALR  R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPISTDCB   PPIATP3E
*        ADDRESS OF DCBS IN GENERATED CORE AND ADDRESS OF
*        ATTACHED EXIT
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPIX35
*        IF ATTACHED WILL HAVE ATTACHED ADDRESS
*
*        EXTERNAL ROUTINES - NONE
*
*        EXTERNAL PARAMETERS - SEE REGISTERS
*
*        EXITS - NORMAL - TO IERRC9
*                         CALLING SEQUENCE -
*                         BR R14
*
*        EXITS - ERROR - NONE
*
*        TABLES/WORK AREAS - NONE
*
*        NOTES -
*        THIS MODULE IS USED FOR ANY VARIABLE LENGTH SORT WITH
*        EXIT E35
*
IERABO   CSECT
*
         USING *,R11
         USING DIERRBO,R10         ADDR OF RP DSECT
         USING IERRCA,R13
         USING DIERAMC,R9          MESSAGE MOD BASE REG
*
IERMB34  LR    R11,R15             LOAD MODULE BASE REG
         L     R10,PPIBLK+4        ADDR OF IERRBO (RP) FOR DSECT BASE
*
*        CALCULATE ADDR OF OUTPUT DCB AND STORE IN RP
*
         L     R4,PPISTDCB         POINTER TO LIST OF DCB ADDRESSES
         L     R4,0(,R4)           R4 -> DCB
         ST    R4,WDCB             STORE DCB ADDR IN RP
         L     R9,PPIAMC+4         SET MESSAGE BASE REG
         PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTICS ?
         BZ    ABONOMES            NO, BRANCH
         ST    R14,ABOSAVO         SAVE R14
         SR    R0,R0
         ICM   R0,B'0111',PPILAB04+1  R0 -> OB1 FOR CONVERSION
         L     R15,PPICONV+4       LOAD ADDR OF CONVERSION ROUTINE
         BAS   R14,4(,R15)         CONVERT
         MVC   IER942A,2(R1)       MOVE FORMATTED ADDR INTO MESSAGE
         L     R0,PPILAB05         LOAD ADDR OF OB2 FOR CONVERSION
         L     R15,PPICONV+4       LOAD ADDR OF CONVERSION ROUTINE
         BAS   R14,4(,R15)         CONVERT
         MVC   IER942B,2(R1)       MOVE FORMATTED ADDR INTO MESSAGE
         LM    R0,R1,IER942        IER942I OUTPUT BUFFER ADDR
         L     R15,PPIADSSC        LOAD ADDR OF PRINT ROUTINE
         BAS   R14,12(,R15)        CALL PRINT
         L     R14,ABOSAVO         RESTORE R14
ABONOMES ICM   R15,B'1111',PPIATP3E  ATTACHED EXIT ?
         BNZ   ABATTEXT            YES, BRANCH TO ATTACH EXIT RTN
*
*        BRANCH TO NEXT ASSIGNMENT RTN
*
ABENDMOD BR    R14                 RETURN TO IERRC9
*
ABATTEXT ST    R15,PPIX35+4        SET EXIT E35 TO ATTACHED EXIT
         B     ABENDMOD
*
ABOSAVO  DC    F'0'
*
DIERAMC  DSECT
*
         COPY  AMCMAIN
*
*        MODULE NAME - IERRBO
*
DIERRBO  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRBO SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRBOI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         PRINT NOGEN
*
         DCBD  DSORG=PS,DEVD=(DA,TA)
*
         PRINT GEN
*
         END
./ ADD NAME=IERABP   0101-20211-20211-1200-00099-00099-00000-RELEASE 00
ABP      TITLE 'IERABP - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERABP
*
*        MODULE FUNCTION/OPERATION -
*        ASSIGNMENT ROUTINE FOR MODULE IERRBP
*        IT IS USED IN FINAL MERGE PHASE OR MERGE ONLY FOR FIXED
*        LENGTH RECORDS GREATER THAN 256 BYTES
*
*        MODULES IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                       CALLING SEQUENCE -
*                           L    R15,ASSG
*                           BALR R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPISTDCB
*
*        OUTPUT -
*        SETS CONSTANT IN RUNNING PROGRAM
*        NO PPI FIELDS ALTERED
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS -
*        PPIBLK - ADDR OF RUNNING PROGRAM TO ADDR DSECT
*
*        EXITS - NORMAL -
*        BR R14 - RETURN TO IERRC9
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS - N/A
*
*        NOTES -
*        THIS MODULE IS USED FOR FIXED LENGTH RECORDS GREATER
*        THAN 256 BYTES
*
IERABP   CSECT
*
         USING *,R11
         USING DIERRBP,R8
         USING IERRCA,R13
         USING DIERAMC,R9          MESSAGE MOD BASE REG
*
IERMB34  LR    R11,R15
         L     R8,PPIBLK+4         SET DSECT BASE REG
         L     R7,PPISTDCB         SET ADDR OF OUTPUT
         L     R5,0(,R7)           DCB IN RUNNING
         ST    R5,KADCB            PROGRAM
         L     R9,PPIAMC+4         SET MESSAGE BASE REG
         PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTICS ?
         BZ    ABPNOMES            NO, BRANCH
         ST    R14,ABPSAVO         SAVE R14
         SR    R0,R0
         ICM   R0,B'0111',PPILAB04+1  R0 -> OB1 FOR CONVERSION
         L     R15,PPICONV+4       LOAD ADDR OF CONVERSION ROUTINE
         BAS   R14,4(,R15)         CONVERT
         MVC   IER942A,2(R1)       PUT FORMATTED ADDR IN MESSAGE
         L     R0,PPILAB05         LOAD ADDR OF OB2 FOR CONVERSION
         L     R15,PPICONV+4       LOAD ADDR OF CONVERSION ROUTINE
         BAS   R14,4(,R15)         CONVERT
         MVC   IER942B,2(R1)       PUT FORMATTED ADDR IN MESSAGE
         LM    R0,R1,IER942        IER942I OUTPUT BUFFER ADDR
         L     R15,PPIADSSC        LOAD ADDR OF PRINT ROUTINE
         BAS   R14,12(,R15)        PRINT
         L     R14,ABPSAVO         RESTORE R14
ABPNOMES BR    R14                 RETURN TO LOAD MODULE
*
ABPSAVO  DC    F'0'
*
DIERAMC  DSECT
*
         COPY  AMCMAIN
*
*        IERRBP
*
DIERRBP  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRBP SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRBPI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERABQ   0101-20211-20211-1200-00204-00204-00000-RELEASE 00
ABQ      TITLE 'IERABQ - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERABQ
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 3 MOVE ASSIGNMENT - FIXED LENGTH RECORDS
*        THIS MODULE CONSTRUCTS THE MOVE LIST FOR FIXED LENGTH
*        OUTPUT RECORDS OF SIZE GREATER THAN 256 BYTES OR
*        MODIFIED VIA E35. THE LIST IS USED TO MOVE DATA FROM
*        BUFFER AREA TO BUFFER AREA AT RUNNING PROGRAM TIME IN
*        THE FINAL MERGE OR MERGE ONLY PHASE.
*        CALLING SEQUENCE IS -
*            L     R15,PPIBDSVA+8  -  STARTING ADDR OF LIST
*            L     R4,PAR1         -> SOURCE DATA
*            L     R5,PAR2         -> TARGET DATA
*            BALR  R14,R15
*
*            THE ROUTINE USES R4, R5, AND R9. THE CALLING
*            ROUTINE CANNOT RELY ON THE INTEGRITY OF THESE
*            REGISTERS WHEN CONTROL IS RETURNED TO IT
*
*        MODULES IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM IERRC9 VIA
*                       LOAD  EP=IERABQ,DCB=SORTLIB
*                          LR    R15,R0
*                          BALR  R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIRCDL3   PPICNTL
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPISPGN1   PPIBDSVA
*
*        EXTERNAL ROUTINES - NONE
*
*        EXTERNAL PARAMETERS - NONE
*
*        EXITS - NORMAL -
*        RETURN TO IERRC9 VIA R14
*
*        EXITS - ERROR - NONE
*
*        TABLES/WORK AREAS -
*        WSIZE   - ACCUMULATE THE SIZE OF THE MOVE LIST
*        WQUO    - SAVE A QUOTIENT
*        PPIPSVA - SAVE RETURN R14
*
*        NOTES -
*        THIS MODULE IS RESTRICTED TO FIXED LENGTH RECORDS ONLY
*
IERABQ   CSECT
*
         USING *,R11
         USING IERRCA,R13          SETTING UP PPIA BASE REGISTER
*
         LR    R11,R15
         ST    R14,PPIPSVA         SAVE RETURN REGISTER
*
*        CHECK TO SEE IF MODULE IS TO BE EXECUTED
*
ABQMV010 PPITEST  PPIVAR           RECORD FORMAT - FIXED OR VARIABLE ?
         BOR   R14                 VARIABLE, RETURN TO IERRC9
         PPITEST  PPIME35          E35 ACTIVATED ?
         BO    ABQMV015            YES, BRANCH
         CLC   PPIRCDL3(2),KON256+2  RECORD LENGTH > 256 ?
         BNHR  R14                   <, RETURN TO IERRC9
ABQMV015 L     R6,PPISPGN1
         LH    R5,PPIRCDL3         OUTPUT RECORD LENGTH
         CH    R5,=H'768'          GOING TO USE MORE THAN 3 MVS INST ?
         BH    ABQMV070            YES, BRANCH
         LR    R14,R5              SAVE RECORD LENGTH
*
*        CALCULATE LIST SIZE
*
         SR    R4,R4
         D     R4,KON256
         LTR   R4,R4               REMAINDER ?
         BZ    ABQMV020            NO, BRANCH
         LA    R5,1(,R5)           ROUND OFF UPWARD
ABQMV020 ST    R5,WQUO
         M     R4,KON6             QUOTIENT*6=NO OF MOVES*SIZE OF MVC
         LA    R5,2(,R5)           2 BYTES FOR BCR INSTR
         ST    R5,WSIZE            LIST SIZE IN BYTES
         CLC   WQUO,KON16          QUOTIENT > 16
         BNH   ABQMV030            <= TO 16, BRANCH
         SR    R4,R4
         L     R5,WQUO
         SRL   R5,4                DIVIDE BY 16=Q1
         M     R4,KON12            Q1*12=NO OF ADDR ADJUSTMENTS*3-LA'S
         A     R5,WSIZE            LIST SIZE IN BYTES
         ST    R5,WSIZE
*
*        ALLOCATION OF SPACE IN GENERATED STORAGE FOR THE LIST
*
ABQMV030 SR    R6,R5
         ST    R6,PPISPGN1         UPDATE GENERATED AREA ADDR
         TM    PPISPGN1+3,X'01'    MAKE SURE THE MOVE
         BZ    ABQMV032            LIST STARTS ON A HALF WORD
         BCTR  R6,0                BOUNDARY
         ST    R6,PPISPGN1
*
*        BLOCK PROGRAM
*
ABQMV032 MVC   PPIBDSVA+8(4),PPISPGN1    ADCON
*
*        GENERATE THE LIST
*
ABQMV040 CL    R14,KON256
         BNH   ABQMV050            <= TO 256
         L     R1,KMOVE+2
         MVC   0(6,R6),KMOVE       MOVE INSTR TO LIST AREA
         A     R1,KONMOVE          UPDATE INSTRS DISPLACEMENTS
         LA    R6,6(,R6)           INCREMENT LIST POINTER
         S     R14,KON256
         CL    R1,KON4096          DISPLACEMENT > 4095 ?
         BH    ABQMV060            YES, BRANCH
         ST    R1,KMOVE+2
         B     ABQMV040            GENERATE ANOTHER MOVE INSTR
*
ABQMV050 BCTR  R14,0               REMAINING RECORD LENGTH
         STC   R14,KMOVE+1         MINUS ONE IN FINAL MVC INSTR
         MVC   0(6,R6),KMOVE
         LA    R6,6(,R6)           UPDATE LIST POINTER
         MVC   0(2,R6),KBRANCH     MOVE BRANCH INSTR TO LIST AREA
ABQMV051 PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTICS ?
         BZ    ABQMVRTN            NO, BRANCH
         USING DIERAMC,R9
         L     R9,PPIAMC+4
         L     R0,PPISPGN1         LOAD NUMBER TO BE CONVERTED
         L     R15,PPICONV+4       LOAD ADDR OF CONVERSION ROUTINE
         BAS   R14,4(,R15)         CONVERT
         MVC   IER943A,2(R1)       MOVE FORMATTED ADDR INTO MSG
         LM    R0,R1,IER943        IER943I MOVE ROUTINE ADDR
         L     R15,PPIADSSC        LOAD ADDR OF PRINT ROUTINE
         BAS   R14,12(,R15)        CALL PRINT
         DROP  R9
ABQMVRTN L     R14,PPIPSVA         RETURN TO IERRC9
         BR    R14
*
ABQMV060 MVC   0(12,R6),KUPDATE    UPDATE DISPLACEMENTS
         LA    R6,12(,R6)          AND REGISTERS IN LIST
         MVC   KMOVE(6),KMOVE1     REINITIALIZE MODEL MOVE INSTR
         B     ABQMV040            GENERATE ANOTHER MOVE INSTR
*
*        MVCL INSTRUCTION ROUTINE WHEN RECORD IS MORE THAN 768 BYTES
*
ABQMV070 SH    R6,=AL2(MVCLRTNX-MVCLRTN)
         ST    R6,PPISPGN1         UPDATE GENERATE AREA ADDR
         TM    PPISPGN1,X'01'      ENSURE INSTRUCTIONS ARE
         BZ    ABQMV071            ON A HALF WORD BOUNDARY
         BCTR  R6,0
         ST    R6,PPISPGN1
ABQMV071 MVC   0(MVCLRTNX-MVCLRTN,R6),MVCLRTN  MOVE IN MVCL ROUTINE
         MVC   PPIBDSVA+8(4),PPISPGN1  SAVE ADDR OF ROUTINE
         B     ABQMV051
*
*        MVCL ROUTINE
*
MVCLRTN  LR    R9,R14              SAVE RETURN ADDR
         LR    R14,R5              R14 -> TARGET
         LH    R5,PPIRCDL3         SET L'RECORD TO BE MOVED
         LR    R15,R5              SET L'TARGET, NO PAD
         MVCL  R14,R4              MOVE RECORD
         BR    R9                  RETURN
MVCLRTNX DC    0H'0'               FOR L'ROUTINE CALC
*
*        CONSTANTS
*
KON256   DC    F'256'
KON6     DC    A(6)
KON16    DC    A(16)
KON12    DC    A(12)
KON4096  DC    X'5FFF4FFF'
KMOVE1   MVC   0(256,R5),0(R4)
KMOVE    MVC   0(256,R5),0(R4)
KONMOVE  DC    X'01000100'
KBRANCH  BR    R14
KUPDATE  LA    R9,1                *
         LA    R5,4095(R5,R9)      |
         LA    R4,4095(R4,R9)      V
*
*        WORK AREAS
*
WQUO     DC    F'0'
WSIZE    DC    F'0'
*
*        AMCMAIN
*
DIERAMC  DSECT
*
         COPY  AMCMAIN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERABR   0101-20211-20211-1200-00206-00206-00000-RELEASE 00
ABR      TITLE 'IERABR - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERABR
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 2 MOVE ASSIGNMENT - FIXED LENGTH RECORDS
*        THIS MODULE CONSTRUCTS THE MOVE LIST FOR FIXED LENGTH
*        SORT RECORDS OF SIZE GREATER THAN 256 BYTES OR MODIFIED
*        VIA E25. THE LIST IS USED TO MOVE DATA FROM BUFFER AREA
*        TO BUFFER AREA AT RUNNING PROGRAM TIME IN THE
*        INTERMEDIATE MERGE PHASE
*        CALLING SEQUENCE IS -
*            L     R15,PPIBDSVA+8  -  STARTING ADDR OF LIST
*            L     R4,PAR1         -> SOURCE DATA
*            L     R5,PAR2         -> TARGET DATA
*            BALR  R14,R15
*            THE LENGTH OF THE MOVE IS SET BY PPIRCDL2
*
*            THE ROUTINE USES R4, R5, AND R9. THE CALLING
*            ROUTINE CANNOT RELY ON THE INTEGRITY OF THESE
*            REGISTERS WHEN CONTROL IS RETURNED TO IT
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                       LOAD  EP=IERABR,DCB=SORTLIB
*                          LR    R15,R0
*                          BALR  R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIRCDL2   PPICNTL
*
*        OUTPUT - PPI FIELDS INIITALIZED OR ALTERED -
*        PPISPGN1   PPIBDSVA
*
*        EXTERNAL ROUTINES - NONE
*
*        EXTERNAL PARAMETERS - NONE
*
*        EXITS - NORMAL -
*        RETURN TO IERRC9 VIA R14
*
*        EXITS - ERROR - NONE
*
*        TABLES/WORK AREAS -
*        WSIZE   - ACCUMULATE THE SIZE OF THE MOVE LIST
*        WQUO    - SAVE A QUOTIENT
*        PPIPSVA - SAVE RETURN R14
*
*        NOTES -
*        THIS MODULE IS RESTRICTED TO FIXED LENGTH RECORDS ONLY
*
IERABR   CSECT
*
         USING *,R11
         USING IERRCA,R13          SETTING UP PPIA BASE REGISTER
*
         LR    R11,R15
         ST    R14,PPIPSVA         SAVE RETURN REGISTER
*
*        DETERMINE IF MODULE IS TO BE EXECUTED
*
ABRMV010 PPITEST  PPIVAR           RECORD FORMAT - FIXED OR VARIABLE ?
         BOR   R14                 VARIABLE, RETURN TO IERRC9
         PPITEST  PPIME25          E25 ACTIVATED ?
         BO    ABRMV015            YES, BRANCH
         CLC   PPIRCDL2,KF256+2    RECORD LENGTH > 256 ?
         BNHR  R14                   <, RETURN TO IERRC9
ABRMV015 L     R6,PPISPGN1
         LH    R5,PPIRCDL2         SORT RECORD LENGTH
         CH    R5,=H'768'          GOING TO USE MORE THAN 3 MVS INST ?
         BH    ABRMV070            YES, BRANCH
         LR    R14,R5              SAVE RECORD LENGTH
*
*        CALCULATE THE LIST SIZE
*
         SR    R4,R4
         D     R4,KF256
         LTR   R4,R4               REMAINDER ?
         BZ    ABRMV020            NO, BRANCH
         LA    R5,1(,R5)           ROUND OFF UPWARD
ABRMV020 ST    R5,WQUO
         M     R4,KF6              QUOTIENT*6=NO OF MOVES*SIZE OF MVC
         LA    R5,2(,R5)           2 BYTES FOR BCR INSTR
         ST    R5,WSIZE
         CLC   WQUO,KF16           QUOTIENT > 16 ?
         BNH   ABRMV030            <= TO 16, BRANCH
         SR    R4,R4
         L     R5,WQUO
         SRL   R5,4                DIVIDE BY 16=Q1
         M     R4,KF12             Q1*12=NO OF ADDR ADJUSTMENTS*3-LA'S
         A     R5,WSIZE            LIST SIZE IN BYTES
         ST    R5,WSIZE
*
*        ALLOCATION OF SPACE IN GENERATED CORE FOR THE LIST
*
ABRMV030 SR    R6,R5
         ST    R6,PPISPGN1         UPDATE GENERATED AREA ADDR
         TM    PPISPGN1+3,X'01'    MAKE SURE THE MOVE
         BZ    ABRMV032            LIST STARTS ON A HALF
         BCTR  R6,0                WORD BOUNDARY
         ST    R6,PPISPGN1
ABRMV032 MVC   PPIBDSVA+8(4),PPISPGN1  SAVE MOVE LIST ADDR FOR
*                                      THE BLOCK RTN
*        GENERATE THE LIST
*
ABRMV040 CL    R14,KF256           <= TO 256 ?
         BNH   ABRMV050            YES, BRANCH
         L     R1,KMOVE+2
         MVC   0(6,R6),KMOVE       MOVE INSTR TO LIST AREA
         A     R1,KONMOVE          UPDATE INSTR DISPLACEMENTS
         LA    R6,6(,R6)           INCREMENT LIST POINTER
         S     R14,KF256
         CL    R1,KON4096          DISPLACEMENT > 4095
         BH    ABRMV060            YES, BRANCH
         ST    R1,KMOVE+2
         B     ABRMV040            GENERATE ANOTHER MOVE INSTR
*
ABRMV050 BCTR  R14,0               REMAINING RCD LENGTH
         STC   R14,KMOVE+1         MINUS ONE IN FINAL MVC INSTR
         MVC   0(6,R6),KMOVE
         LA    R6,6(,R6)           UPDATE LIST POINTER
         MVC   0(2,R6),KBRANCH     MOVE BRANCH INSTR TO LIST AREA
ABRMV051 ST    R14,ABRSAVO         SAVE R14
         ST    R9,ABRSAVJ          SAVE R9
         PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTICS ?
         BZ    ABRNOMES            NO, BRANCH
         USING DIERAMB,R9
         L     R9,PPIAMB+4
         L     R0,PPISPGN1         LOAD NUMBER TO BE CONVERTED
         L     R15,PPICONV+4       LOAD ADDR OF CONVERSION ROUTINE
         BAS   R14,4(,R15)         CONVERT
         MVC   IER923A,2(R1)       MOVE FORMATTED ADDR INTO MSG
         LM    R0,R1,IER923        IER923I MOVE ROUTINE ADDR
         L     R15,PPIADSSC        LOAD ADDR OF PRINT ROUTINE
         BAS   R14,12(,R15)        CALL PRINT
         DROP  R9
ABRNOMES L     R14,ABRSAVO         RESTORE R14
         L     R9,ABRSAVJ          RESTORE R9
ABRMVRTN L     R14,PPIPSVA         RETURN TO IERRC9
         BR    R14
*
ABRMV060 MVC   0(12,R6),KUPDATE    UPDATE DISPLACEMENTS
         LA    R6,12(,R6)          AND REGISTERS IN LIST
         MVC   KMOVE(6),KMOVE1     REINITIALIZE MODEL MOVE INSTR
         B     ABRMV040            GENERATE ANOTHER MOVE INSTR
*
*        MVCL INSTRUCTION ROUTINE WHEN RECORD IS MORE THAN 768 BYTES
*
ABRMV070 SH    R6,=AL2(MVCLRTNX-MVCLRTN)
         ST    R6,PPISPGN1         UPDATE GENERATE AREA ADDR
         TM    PPISPGN1,X'01'      ENSURE INSTRUCTIONS ARE
         BZ    ABRMV071            ON A HALF WORD BOUNDARY
         BCTR  R6,0
         ST    R6,PPISPGN1
ABRMV071 MVC   0(MVCLRTNX-MVCLRTN,R6),MVCLRTN  MOVE IN MVCL ROUTINE
         MVC   PPIBDSVA+8(4),PPISPGN1  SAVE ADDR OF ROUTINE
         B     ABRMV051
*
*        MVCL ROUTINE
*
MVCLRTN  LR    R9,R14              SAVE RETURN ADDR
         LR    R14,R5              R14 -> TARGET
         LH    R5,PPIRCDL2         SET L'RECORD TO BE MOVED
         LR    R15,R5              SET L'TARGET, NO PAD
         MVCL  R14,R4              MOVE RECORD
         BR    R9                  RETURN
MVCLRTNX DC    0H'0'               FOR L'ROUTINE CALC
*
*        CONSTANTS
*
KF256    DC    F'256'
KF6      DC    F'6'
KF16     DC    F'16'
KF12     DC    F'12'
KON4096  DC    X'5FFF4FFF'
KMOVE1   MVC   0(256,R5),0(R4)
KMOVE    MVC   0(256,R5),0(R4)
KONMOVE  DC    X'01000100'
KBRANCH  BR    R14
KUPDATE  LA    R9,1                *
         LA    R5,4095(R5,R9)      |
         LA    R4,4095(R4,R9)      V
*
*        WORK AREAS
*
WQUO     DC    F'0'
WSIZE    DC    F'0'
ABRSAVJ  DC    F'0'
ABRSAVO  DC    F'0'
*
*        AMBMAIN
*
DIERAMB  DSECT
*
         COPY  AMBMAIN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERABS   0101-20211-20211-1200-00203-00203-00000-RELEASE 00
ABS      TITLE 'IERABS - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERABS
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 1 MOVE ASSIGNMENT - FIXED LENGTH RECORDS
*        THIS MODULE CONSTRUCTS THE MOVE LIST FOR FIXED LENGTH
*        SORT RECORDS OF SIZE GREATER THAN 256 BYTES OR MODIFIED
*        VIA E15. THE LIST IS USED TO MOVE DATA FROM/TO BUFFER
*        AREA TO/FROM RSA AT RUNNING PROGRAM TIME IN THE SORT
*        PHASE.
*        THE CALLING SEQUENCE IS -
*            L     R15,PPIBDSVA+8  -  STARTING ADDR OF GENERATED CODE
*            L     R4,PAR1         -> SOURCE DATA
*            L     R5,PAR2         -> TARGET DATA
*            BALR  R14,R15
*            THE LENGTH OF THE MOVE IS SET BY PPIRCDL2
*
*            THE ROUTINE USES R4, R5, AND R9. THE CALLING
*            ROUTINE CANNOT RELY ON THE INTEGRITY OF THESE
*            REGISTERS WHEN CONTROL IS RETURNED TO IT
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACROS USED SMPPI
*
*        ENTRY POINTS - ENTRY FROM IERRC9 VIA
*                       LOAD  EP=IERABS,DCB=SORTLIB
*                       LR    R15,R0
*                       BALR  R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIRCDL2   PPICNTL
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPISPGN1   PPIBDSVA
*
*        EXTERNAL ROUTINES - NONE
*
*        EXTERNAL PARAMETERS - NONE
*
*        EXITS - NORMAL -
*        IERRC9 - RETURN TO LOAD ROUTINE VIA R0
*
*        EXITS - ERROR - NONE
*
*        TABLES/WORK AREAS -
*        WSIZE   - ACCUMULATE THE SIZE OF THE MOVE LIST
*        WQUO    - SAVE A QUOTIENT
*        PPIPSVA - SAVE RETURN R14
*
*        NOTES -
*        THIS MODULE IS RESTRICTED TO FIXED LENGTH RECORDS ONLY
*
IERABS   CSECT
*
         USING *,R11
         USING IERRCA,R13          SETTING UP PPIA BASE REGISTER
*
         USING DIERAMA,R8          MESSAGE BASE REG
*
*        CHECK TO SEE IF MODULE IS TO BE EXECUTED
*
IERMBF   LR    R11,R15
         ST    R14,PPIPSVA         SAVE RETURN REG
ABSNOMES PPITEST  PPIME15+PPIME16  E15 OR E16 ACTIVATED ?
         BNZ   ABSMV010            YES, BRANCH
         CLC   PPIRCDL2,KF256+2    RECORD LENGTH > 256 ?
         BNHR  R14                 NO, RETURN TO IERRC9
ABSMV010 L     R1,PPISPGN1
         LH    R5,PPIRCDL2         R5 = SORT RECORD LENGTH
         LR    R14,R5              SAVE RECORD LENGTH
         CH    R5,=H'768'          GOING TO USE MORE THAN 3 MVS INST ?
         BH    ABSMV070            YES, BRANCH
*
*        CALCULATE LIST SIZE
*
         SR    R4,R4
         D     R4,KF256
         LTR   R4,R4               REMAINDER ?
         BZ    ABSMV020            NO, BRANCH
         LA    R5,1(,R5)           ROUND OFF UPWARD
ABSMV020 ST    R5,WQUO
         M     R4,KON6             QUOTIENT*6=NO OF MOVES*SIZE OF MVC
         LA    R5,2(,R5)           2 BYTES FOR BCR INSTR
         ST    R5,WSIZE
         CLC   WQUO,KON16          QUOTIENT > 16
         BNH   ABSMV030            <= TO 16, BRANCH
         SR    R4,R4
         L     R5,WQUO
         SRL   R5,4                DIVIDE BY 16=Q1
         M     R4,KON12            Q1*12=NO OF ADDR ADJUSTMENTS*3-LA'S
         A     R5,WSIZE
         ST    R5,WSIZE
*
*        ALLOCATION OF SPACE IN GENERATED STORAGE FOR THE INSTRUCTIONS
*
ABSMV030 SR    R1,R5
         ST    R1,PPISPGN1         UPDATE GENERATE AREA ADDR
         TM    PPISPGN1,X'01'      MAKE SURE START MOVE LIST
         BZ    ABSMV032            ON A HALF WORD BOUNDARY
         BCTR  R1,0
         ST    R1,PPISPGN1
ABSMV032 MVC   PPIBDSVA+4(4),PPISPGN1  SAVE MOVE LIST ADDR FOR
*                                      THE RUNNING SORT
*        GENERATE THE INSTRUCTIONS
*
ABSMV040 CL    R14,KF256           <= TO 256 ?
         BNH   ABSMV050            YES, BRANCH
         L     R3,KMOVE+2
         MVC   0(6,R1),KMOVE       MOVE INSTR TO LIST AREA
         A     R3,KONMOVE          UPDATE INSTR DISPLACEMENTS
         LA    R1,6(,R1)           INCREMENT LIST POINTER
         S     R14,KF256
         CL    R3,KON4096          DISPLACEMENT > 4095 ?
         BH    ABSMV060            YES, BRANCH
         ST    R3,KMOVE+2
         B     ABSMV040            GENERATE ANOTHER MOVE INSTR
*
ABSMV050 BCTR  R14,0               DECREMENT BY ONE TO OBTAIN LENGTH
         STC   R14,KMOVE+1         FACTOR FOR THE FINAL MVC INSTR
         MVC   0(6,R1),KMOVE
         LA    R1,6(,R1)           UPDATE LIST POINTER
         MVC   0(2,R1),KBRANCH     MOVE BRANCH INSTR TO LIST AREA
ABSMV051 L     R8,PPIAMA+4         SET MSG BASE REG
         PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTICS ?
         BZ    ABSMVRTN            NO, BRANCH
         L     R0,PPISPGN1         LOAD NUMBER TO BE CONVERTED
         L     R15,PPICONV+4       LOAD ADDR OF CONVERSION ROUTINE
         BAS   R14,4(,R15)         CALL CONVERSION ROUTINE
         MVC   IER905A,2(R1)       MOVE FORMATTED ADDR INTO MSG
         LM    R0,R1,IER905        IER905 MOVE ROUTINE ADDR
         L     R15,PPIADSSC        LOAD ADDR OF PRINT ROUTINE
         BAS   R14,12(,R15)        CALL PRINT RTN
ABSMVRTN L     R14,PPIPSVA         RETURN TO IERRC9
         BR    R14
*
ABSMV060 MVC   0(12,R1),KUPDATE    UPDATE DISPLACEMENTS AND REGISTERS
         LA    R1,12(,R1)          IN THE LIST
         MVC   KMOVE(6),KMOVE1     REINITIALIZE MODEL MOVE INSTR
         B     ABSMV040            GENERATE ANOTHER MOVE INSTR
*
*        MVCL INSTRUCTION ROUTINE WHEN RECORD IS MORE THAN 768 BYTES
*
ABSMV070 SH    R1,=AL2(MVCLRTNX-MVCLRTN)
         ST    R1,PPISPGN1         UPDATE GENERATE AREA ADDR
         TM    PPISPGN1,X'01'      ENSURE INSTRUCTIONS ARE
         BZ    ABSMV071            ON A HALF WORD BOUNDARY
         BCTR  R1,0
         ST    R1,PPISPGN1
ABSMV071 MVC   0(MVCLRTNX-MVCLRTN,R1),MVCLRTN  MOVE IN MVCL ROUTINE
         MVC   PPIBDSVA+4(4),PPISPGN1  SAVE ADDR OF ROUTINE
         B     ABSMV051
*
*        MVCL ROUTINE
*
MVCLRTN  LR    R9,R14              SAVE RETURN ADDR
         LR    R14,R5              R14 -> TARGET
         LH    R5,PPIRCDL2         SET L'RECORD TO BE MOVED
         LR    R15,R5              SET L'TARGET, NO PAD
         MVCL  R14,R4              MOVE RECORD
         BR    R9                  RETURN
MVCLRTNX DC    0H'0'               FOR L'ROUTINE CALC
*
*        CONSTANTS
*
KF256    DC    F'256'
KON6     DC    A(6)
KON16    DC    A(16)
KON12    DC    A(12)
KON4096  DC    X'5FFF4FFF'
KMOVE1   MVC   0(256,R5),0(R4)
KMOVE    MVC   0(256,R5),0(R4)
KONMOVE  DC    X'01000100'
KBRANCH  BR    R14
KUPDATE  LA    R9,1                *
         LA    R5,4095(R5,R9)      |
         LA    R4,4095(R4,R9)      V
*
*        WORK AREAS
*
WQUO     DC    F'0'
WSIZE    DC    F'0'
*
*        LTORG
*
         LTORG
*
*        AMAMAIN
*
DIERAMA  DSECT
*
         COPY  AMAMAIN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERABT   0101-20211-20211-1200-00135-00135-00000-RELEASE 00
ABT      TITLE 'IERABT - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERABT
*
*        MODULE FUNCTION/OPERATION -
*        ASSIGNMENT ROUTINE FOR MODULE IERRBT
*        A BLOCK/ DEBLOCK MODULE FOR FIXED LENGTH RECORDS IN THE
*        MERGE PHASE OF AN OSCL/CRCX SORT. IT ALSO ALLOCATES
*        AREA IN GENERATED STORAGE FOR THE TAPE UNIT COUNTERS WHICH
*        KEEP TRACK OF THE NUMBER OF RECORDS ON EACH UNIT
*
*        USED AS A DSECT IN - N/A
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                       CALLING SEQUENCE -
*                           L    R15,ASSG
*                           BR   R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPISRTBL   PPIRCDL2
*        PPILAB07   PPILAB04
*        PPIBDSVA   PPISPGN1
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPIUNTCT   PPISPGN1
*        ALLOCATES AREA FOR TAPE UNIT COUNTERS IN GENERATED CORE
*        INITIALIZES CONSTANTS AND CODE IN RUNNING PROGRAM
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS -
*        PPIBLK2 - ADDR OF RUNNING PROGRAM DSECT
*
*        EXITS - NORMAL -
*                BR R14 - RETURN TO IERRC9
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS - N/A
*
*        NOTES -
*        THIS MODULE IS USED FOR FIXED LENGTH RECORDS LESS THAN
*        OR EQUAL TO 256 BYTES LONG IN THE MERGE PHASE
*
IERABT   CSECT
*
         USING *,R11
         USING DIERRBT,R4
         USING IERRCA,R13
*
IERMBG   LR    R11,R15
         L     R4,PPIBLK2+4        SET DSECT BASE REG
         LH    R5,PPISRTBL         SET OUTPUT BLK CNT = SORT BLOCKING
         ST    R5,KOBLKCNT
         LH    R5,PPIRCDL2         SET RCD LENGTH - 1 IN
         BCTR  R5,0                INLINE MOVE INSTR
         STC   R5,RBT2025+1
         STC   R5,KABTKON1+1
         LH    R6,PPILAB07+2       SET R6 = OUTPUT BUFFER SIZE
         ST    R6,KBUFSIZ          SET BUFF SIZE IN RUNNING PROGRAM
         SR    R5,R5
         ICM   R5,B'0111',PPILAB04+1  R5 -> FIRST OUTPUT BUFFER
         PPITEST  PPI2314          CRCX SORT ?
         BO    ABT1020             YES, SET UP TO BLOCK FORWARD
ABT1010  AR    R5,R6               SET CONSTANTS
         ST    R5,KBLKPTR          SET BLOCK POINTER AND
         ST    R5,KIBLKPTR         INITIAL BLOCK POINTER
*
*        SET UP TAPE UNIT COUNTERS IN GENERATED CORE
*
         SR    R3,R3
         IC    R3,PPIBDSVA         LOAD NUMBER OF TAPE UNITS
         LA    R3,1(,R3)
         LA    R5,4
         MR    R4,R3               MULTIPLY BY FOUR
         L     R3,PPISPGN1         LOAD ADDR OF GENERATED CORE
         SR    R3,R5               SUBTRACT REQUIRED AMOUNT OF STORAGE
         N     R3,KROUND           PUT ON FULL WORD BOUNDARY
         MVI   0(R3),X'00'         ZERO OUT THE AREA
         S     R5,KTWO
         EX    R5,BTZERO
         ST    R3,PPISPGN1         STORE NEW ADDR OF GEN CORE
         ST    R3,PPIUNTCT         STORE ADDR OF UNIT COUNTERS
         BR    R14                 RETURN TO LOAD MODULE
*
ABT1020  LA    R6,12               ADJUST FOR EOS AND CHAIN BYTES
         STH   R6,K4
         MVC   RBT2020(14),KABTKON1  OVERLAY TO MVC RECORD
         MVC   RBT2053(4),KABTKON2   UPDATE BLOCK POINTER
         MVC   RBT2090(4),KABTKON2   INITIAL BLOCK POINTER
         MVC   RBINCR(4),KABTKON     INCR FOR OUTPUT FILE
         B     ABT1010
*
*        EXECUTED MOVE INSTRUCTION TO ZERO OUT UNIT COUNTER AREA
*
BTZERO   MVC   1(1,R3),0(R3)
*
*        CONSTANTS
*
KTWO     DC    F'2'
KROUND   DC    X'FFFFFFFC'
*
         DROP  R11
         DROP  R4
*
         USING DIERRBT,R11
KABTKON  IC    R6,PPIDEPHO+1       INCR FOR OUTPUT FILE
KABTKON1 MVC   0(1,R2),0(R3)       MOVE RECORD
         AH    R2,PPIRCDL2         UPDATE BLOCK
         ST    R2,KBLKPTR          POINTER
KABTKON2 L     R2,KIBLKPTR         INITIAL BLOCK POINTER
*
*        IERRBT
*
DIERRBT  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRBT SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRBTI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERABU   0101-20211-20211-1200-00139-00139-00000-RELEASE 00
ABU      TITLE 'IERABU - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERABU
*
*        MODULE FUNCTION/OPERATION -
*        ASSIGNMENT ROUTINE FOR MODULE IERRBU
*        BLOCK/DEBLOCK ROUTINE FOR FIXED LENGTH RECORDS GREATER
*        THAN 256 BYTES IN THE MERGE PHASE OF AN OSCL/CRCX SORT.
*        IT ADJUSTS BUFFER POINTERS IN THE RUNNING PROGRAM AND
*        ALLOCATES AN AREA IN GENERATED STORAGE FOR THE TAPE UNIT
*        COUNTERS WHICH KEEP TRACK OF THE NUMBER OF RECORDS ON
*        EACH UNIT.
*
*        USED AS A DSECT IN - N/A
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                       CALLING SEQUENCE -
*                           L    R15,ASSG
*                           BR   R15
*
*        INPUT - PPI FIELDS REFERENCED - PPISRTBL PPIBDSVA
*        PPILAB07   PPISPGN1
*        PPILAB04
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPIUNTCT   PPISPGN1
*        ALLOCATES AREA FOR TAPE UNIT COUNTERS IN GENERATED STORAGE
*        CONSTANTS AND CODE IN RUNNING PROGRAM ARE INITIALIZED
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS -
*        PPIBLK2 - ADDR FOR DSECT
*
*        EXITS - NORMAL -
*        BR R14 - RETURN TO IERRC9
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS - N/A
*
*        NOTES -
*        THIS MODULE IS USED FOR FIXED LENGTH RECORDS GREATER
*        THAN 256 BYTES IN THE MERGE PHASE
*
IERABU   CSECT
*
         USING *,R11
         USING DIERRBU,R4
         USING IERRCA,R13
*
IERMBG   LR    R11,R15
         L     R4,PPIBLK2+4        SET DSECT BASE REG FOR IERRBU
         LH    R5,PPISRTBL         SET OUTPUT BLK CNT = SORT BLOCKING
         ST    R5,KOBLKCNT
         LH    R6,PPILAB07+2       SET R6=OUTPUT BUFFER SIZE
         ST    R6,KBUFSIZ          SET BUFF SIZE IN RUNNING PROG
         SR    R5,R5
         ICM   R5,B'0111',PPILAB04+1  R5 -> FIRST OUTPUT BUFFER
         PPITEST  PPI2314          CRCX SORT ?
         BO    ABU1020             YES, SET UP TO BLOCK FORWARD
ABU1010  AR    R5,R6               SET CONSTANTS
         ST    R5,KBLKPTR          SET BLOCK POINTER AND
         ST    R5,KIBLKPTR         INITIAL BLOCK POINTER
*
*        SET UP TAPE UNIT COUNTERS IN GENERATED STORAGE
*
         SR    R3,R3
         IC    R3,PPIBDSVA          LOAD NUMBER OF TAPE UNITS
         LA    R3,1(,R3)
         LA    R5,4
         MR    R4,R3                MULTIPLY BY FOUR
         L     R3,PPISPGN1          LOAD ADDR OF GENERATED STORAGE
         SR    R3,R5                SUBTRACT REQUIRED AMOUNT OF STORAGE
         N     R3,KROUND            PUT ON FULL WORD BOUNDARY
         MVI   0(R3),X'00'          ZERO OUT THE AREA
         S     R5,KTWO
         EX    R5,BTZERO
         ST    R3,PPISPGN1          STORE NEW ADDR OF GEN STORAGE
         ST    R3,PPIUNTCT          STORE ADDR OF UNIT COUNTERS
         BR    R14                  RETURN TO LOAD MODULE
*
ABU1020  LA    R6,12                ADJUST FOR EOS AND CHAIN BYTES
         STH   R6,K4
         MVC   RBU2020(18),KABUKON1  OVERLAY TO MVC RECORD, THEN UPDATE
         MVC   RBU2053(4),KABUKON2   BLOCK POINTER
         MVC   RBU2090(4),KABUKON2   INITIAL BLOCK POINTER
         MVC   RBINCR(4),KABUKON     INCR FOR OUTPUT FILE
         B     ABU1010
*
*        EXECUTED MOVE INSTRUCTION TO ZERO OUT UNIT COUNTER AREA
*
BTZERO   MVC   1(0,R3),0(R3)
*
*        CONSTANTS
*
KTWO     DC    F'2'
KROUND   DC    X'FFFFFFFC'
*
         DROP  R11
         DROP  R4
*
*        OVERLAY INSTRUCTIONS FOR RUNNING MODULE IERRBU
*
         USING DIERRBU,R11
KABUKON  IC    R6,PPIDEPHO+1       INCR FOR OUTPUT FILE
*
KABUKON1 LR    R4,R3            *
         LR    R5,R2            |
         L     R15,PPIBDSVA+8   |  MOVE RECORD
         BASR  R14,R15          |
         AH    R2,PPIRCDL2      |  UPDATE BLOCK
         ST    R2,KBLKPTR       V  POINTER
*
KABUKON2 L     R2,KIBLKPTR         INITIAL BLOCK POINTER
*
*        IERRBU
*
DIERRBU  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRBU SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRBUI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERABV   0101-20211-20211-1200-00129-00129-00000-RELEASE 00
ABV      TITLE 'IERABV - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERABV
*
*        MODULE FUNCTION/OPERATION -
*        ASSIGNMENT ROUTINE FOR THE RUNNING PROGRAM IERRBV
*        A BLOCK/DEBLOCK ROUTINE FOR VARIABLE LENGTH RECORDS
*        WITHOUT USER EXITS IN THE MERGE PHASE OF AN OSCL/2314
*        SORT. IT SETS WORK AREAS AND CONSTANTS TO SPECIFIC
*        VALUES IN THE RUNNING PROGRAM. IT ALSO ALLOCATES AREA IN
*        GENERATED CORE FOR THE TAPE UNIT COUNTERS WHICH KEEP
*        TRACK OF THE NUMBER OF RECORDS ON EACH UNIT
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                       CALLING SEQUENCE -
*                           LOAD   EP=IERABV,DCB=
*                           LR     R15,R0
*                           BALR   R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPILAB04   PPILAB07   PPIBDSVA   PPIUNTCT
*        PPISPGN1
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPIUNTCT   PPISPGN1
*        CONSTANTS AND CODE IN THE RUNNING PROGRAM ARE INITIALIZED
*        ALLOCATES AREA FOR TAPE UNIT COUNTERS IN GENERATED CORE
*
*        EXTERNAL ROUTINES - NONE
*
*        EXTERNAL PARAMETERS - NONE
*
*        EXITS - NORMAL -
*                BR R14 - RETURN TO IERRC9
*
*        EXITS - ERROR - NONE
*
*        TABLES/WORK AREAS - NONE
*
*        NOTES -
*        THIS MODULE IS USED FOR VARIABLE LENGTH RECORDS WITOUT
*        USER EXITS IN THE MERGE PHASE
*
IERABV   CSECT
*
         USING *,R11               MODULE BASE REG LOADED EXTERNALLY
         USING IERRBVD,R10         ADDR OF RUNNING PROGRAM DUMMY MOD
         USING IERRCA,R13          PPI COMMON MODULE BASE REGISTER
*
IERMBG   LR    R11,R15             LOAD MODULE BASE REG
         L     R10,PPIBLK2+4       LOAD ADDR OF RUNNING PROGRAM
         MVC   WBLKCCNT,KEIGHT     SET BLOCK CHARACTER CTR TO 8
         SR    R5,R5
         ICM   R5,B'0111',PPILAB04+1  R5 -> OUTPUT BUFFER 1
         PPITEST  PPI2314          CRCX SORT ?
         BO    ABV2314             YES, SET UP TO BLOCK FORWARD
         AH    R5,PPILAB07+2       ADD ROUNDED LENGTH OF OUTBLOCK BLOCK
ABV1000  ST    R5,WLSTPTR          OUTPUT BLOCK ADDR
         ST    R5,WLSTPTRD         CURRENT OUTPUT BLK ENDING ADDR+1
*
*        SET UP TAPE UNIT COUNTERS IN GENERATED CORE
*
         SR    R3,R3
         IC    R3,PPIBDSVA          LOAD NUMBER OF TAPE UNITS
         LA    R3,1(,R3)
         LA    R5,4
         MR    R4,R3                MULTIPLY BY FOUR
         L     R3,PPISPGN1          LOAD ADDR OF GENERATED CORE
         SR    R3,R5                SUBTRACT REQUIRED AMOUNT OF CORE
         N     R3,KROUND            PUT ON FULL WORD BOUNDARY
         MVI   0(R3),X'00'          ZERO OUT THE AREA
         S     R5,KTWO
         EX    R5,BTZERO
         ST    R3,PPISPGN1          STORE NEW ADDR OF GEN CORE
         ST    R3,PPIUNTCT          STORE ADDR OF UNIT COUNTERS
         BR    R14                  RETURN TO LOAD MODULE
*
*        DASD SORT
*
ABV2314  LA    R5,16(0,R5)          ADJUST FOR EOS, BCC AND CHAIN BYTES
         MVI   KEIGHT+3,X'10'
         MVI   KFOUR+3,X'0C'        ADJUST BCC BY CHAIN TOO
         MVI   WBLKCCNT+3,X'10'
         MVC   RBSUBRLT(2),KNOP     OVERLAY TO MOVE RECORD, THEN UPDATE
         MVC   RBSUBRLD(2),KNOP     BLOCK POINTER
         MVC   RBLSTPTR(4),KABVKON1  INITIAL BLOCK
         MVC   RBEOS(4),KABVKON2     POINTER
         MVC   RBINCR(4),KABVKON
         B     ABV1000
*
*        EXECUTED MOVE INSTRUCTION TO ZERO OUT UNIT COUNTER AREA
*
BTZERO   MVC   1(1,R3),0(R3)
*
*        CONSTANTS
*
KTWO     DC    F'2'
KROUND   DC    X'FFFFFFFC'
KNOP     DC    X'4700'
         DROP  R11
         DROP  R10
         USING IERRBVD,R11
KABVKON1 L     R2,WLSTPTRD         INITIAL
KABVKON  IC    R6,PPIDEPHO+1
KABVKON2 L     R4,WLSTPTRD
*
*        IERRBV
*
IERRBVD  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRBV SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRBVI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERABW   0101-20211-20211-1200-00143-00143-00000-RELEASE 00
ABW      TITLE 'IERABW - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERABW
*
*        MODULE FUNCTION/OPERATION -
*        ASSIGNMENT ROUTINE FOR MODULE IERRBW
*        A BLOCK/ DEBLOCK MODULE FOR FIXED LENGTH RECORDS WITH
*        USER MODIFICATIONS IN THE MERGE PHASE OF AN OSCL/CRCX
*        SORT. IT ADJUSTS BUFFER POINTERS IN THE RUNNING PROG. IT
*        ALSO ALLOCATES AREA IN GENERATED CORE FOR THE TAPE UNIT
*        COUNTERS WHICH KEEP TRACK OF THE NUMBER OF RECORDS ON
*        EACH UNIT
*
*        USED AS A DSECT IN - N/A
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                       CALLING SEQUENCE -
*                           L   R15,ASSG
*                           BR   R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPISRTBL   PPILAB07
*        PPILAB04   PPIBDSVA
*        PPISPGN1
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPIUNTCT   PPISPGN1
*        ALLOCATES AREA FOR TAPE UNIT COUNTERS IN GENERATED CORE
*
*        CONSTANTS AND CODE IN RUNNING PROGRAM ARE INITIALIZED
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS -
*        PPIBLK2 - ADDR FOR DSECT
*        PPIX25  - USER ADDR FOR EXIT E15
*
*        EXITS - NORMAL -
*                BR R14 - RETURN TO IERRC9
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS - N/A
*
*        NOTES -
*        THIS MODULE IS USED FOR FIXED LENGTH RECORDS WHEN E25
*        IS ACTIVE
*
IERABW   CSECT
*
         ENTRY IERABW
*
         USING *,R11
         USING DIERRBW,R4
         USING IERRCA,R13
*
IERMBG   LR    R11,R15
         L     R4,PPIBLK2+4        SET BASE REG FOR DSECT
         LH    R5,PPISRTBL         SET OUTPUT BLK CNT = SORT BLOCKING
         ST    R5,KOBLKCNT
         LH    R6,PPILAB07+2       SET R6=OUTPUT BUFFER SIZE
         ST    R6,KBUFSIZ          SET BUFF SIZE IN RUNNING PROGRAM
         SR    R5,R5
         ICM   R5,B'0111',PPILAB04+1  R5 -> OUTPUT BUFFER ADDR
         PPITEST  PPI2314          CRCX SORT ?
         BO    ABW2020             YES, SET UP TO BLOCK FORWARD
ABW1010  AR    R5,R6               SET CONSTANTS
         ST    R5,KBLKPTR          SET BLOCK POINTER AND
         ST    R5,KIBLKPTR         INITIAL BLOCK POINTER
*
*        SET UP TAPE UNIT COUNTERS IN GENERATED CORE
*
         SR    R3,R3
         IC    R3,PPIBDSVA         LOAD NUMBER OF TAPE UNITS
         LA    R3,1(,R3)
         LA    R5,4
         MR    R4,R3               MULTIPLY BY FOUR
         L     R3,PPISPGN1         LOAD ADDR OF GENERATED CORE
         SR    R3,R5               SUBTRACT REQUIRED AMOUNT OF CORE
         N     R3,KROUND           PUT ON FULL WORD BOUNDARY
         MVI   0(R3),X'00'         ZERO OUT THE AREA
         S     R5,KTWO
         EX    R5,BTZERO
         ST    R3,PPISPGN1         STORE NEW ADDR OF GEN CORE
         ST    R3,PPIUNTCT         STORE ADDR OF UNIT COUNTERS
         BR    R14                 RETURN TO LOAD MODULE
*
*        DASD SORT
*
ABW2020  LA    R6,12               ADJUST FOR EOS AND CHAIN BYTES
         STH   R6,K4
         MVC   RBW2020(22),KABWKON1  OVERLAY TO MVC RCD THEN UPDATE
         MVC   RBW2053(4),KABWKON2   BLOCK POINTER
         MVC   RBW2090(4),KABWKON2   INITIAL BLOCK POINTER
         MVC   RBINCR(4),KABWKON     INCR FOR OUTPUT FILE
         B     ABW1010
*
*        EXECUTED MOVE INSTRUCTION TO ZERO OUT UNIT COUNTER AREA
*
BTZERO   MVC   1(1,R3),0(R3)
*
*        CONSTANTS
*
KTWO     DC    F'2'
KROUND   DC    X'FFFFFFFC'
*
         DROP  R11
         DROP  R4
*
         USING DIERRBW,R11
KABWKON  IC    R6,PPIDEPHO+1       INCR FOR OUTPUT FILE
KABWKON1 LR    R4,R1
         LR    R5,R2
         L     R15,PPIBDSVA+8      MOVE RECORD
         BASR  R14,R15
         AH    R2,PPIRCDL2         UPDATE BLOCK
         ST    R2,KBLKPTR          POINTER
         ST    R5,KPARLST+4        STORE RCD ADDR IN PARM LIST
KABWKON2 L     R2,KIBLKPTR         INITIAL BLOCK POINTER
*
*        IERRBW
*
DIERRBW  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRBW SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRBWI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERABX   0101-20211-20211-1200-00132-00132-00000-RELEASE 00
ABX      TITLE 'IERABX - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERABX
*
*        MODULE FUNCTION/OPERATION -
*        ASSIGNMENT ROUTINE FOR IERRBW
*        A BLOCK/DEBLOCK ROUTINE FOR VARIABLE LENGTH RECORDS
*        WITH USER MODIFICATION EXIT E25 FOR THE MERGE PHASE OF
*        AN OSCL/CRCX SORT. IT SETS WORK AREAS AND CONSTANTS TO
*        SPECIFIC VALUES IN THE RUNNING PROGRAM. IT ALSO
*        ALLOCATES AREA IN GENERATED CORE FOR THE TAPE UNIT
*        COUNTERS WHICH KEEP TRACK OF THE NUMBER OF RECORDS ON
*        EACH UNIT
*
*        USED AS A DSECT IN - N/A
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                       CALLING SEQUENCE -
*                            LOAD   EP=IERABX,DCB=
*                            LR     R15,R0
*                            BALR   R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPILAB04   PPILAB07
*        PPIBDSVA   PPIUNTCT
*        PPISPGN1
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPIUNTCT   PPISPGN1
*        CONSTANTS AND CODE IN THE RUNNING PROGRAM ARE
*        INITIALIZED
*        ALLOCATES AREA FOR TAPE UNIT COUNTERS IN GENERATED CORE
*
*        EXTERNAL ROUTINES - NONE
*
*        EXTERNAL PARAMETERS - NONE
*
*        EXITS - NORMAL -
*                BR R14 - RETURN TO IERRC9
*
*        EXITS - ERROR - NONE
*
*        TABLES/WORK AREAS - NONE
*
*        NOTES -
*        THIS MODULE IS USED FOR VARIABLE LENGTH RECORDS WITH
*        USER EXIT E25 IN THE MERGE PHASE
*
IERABX   CSECT
*
         USING *,R11               MODULE BASE REG LOADED EXTERNALLY
         USING IERRBXD,R10         ADDR OF RUNNING PROGRAM DUMMY MOD
         USING IERRCA,R13          PPI COMMON MODULE BASE REGISTER
*
IERMBG   LR    R11,R15             LOAD MODULE BASE REG
         L     R10,PPIBLK2+4       LOAD ADDR OF RUNNING PROGRAM
         MVC   WBLKCCNT,KEIGHT     SET BLOCK CHARACTER CTR TO 8
         SR    R5,R5
         ICM   R5,B'0111',PPILAB04+1  R5 -> OUTPUT BUFFER 1
         PPITEST  PPI2314          CRCX SORT ?
         BO    ABX1020             YES, SET UP TO BLOCK FORWARD
         AH    R5,PPILAB07+2       ADD ROUNDED LENGTH OF OUTPUT BLOCK
ABX1010  ST    R5,WLSTPTR          OUTPUT BLOCK ADDR
         ST    R5,WLSTPTRD         CURRENT OUTPUT BLK ENDING ADDR+1
*
*        SET UP TAPE UNIT COUNTERS IN GENERATED CORE
*
         SR    R3,R3
         IC    R3,PPIBDSVA          LOAD NUMBER OF TAPE UNITS
         LA    R3,1(,R3)
         LA    R5,4
         MR    R4,R3                MULTIPLY BY FOUR
         L     R3,PPISPGN1          LOAD ADDR OF GENERATED CORE
         SR    R3,R5                SUBTRACT REQUIRED AMT OF CORE
         N     R3,KROUND            PUT ON FULL WORD BOUNDARY
         MVI   0(R3),X'00'          ZERO OUT THE AREA
         S     R5,KTWO
         EX    R5,BTZERO
         ST    R3,PPISPGN1          STORE NEW ADDR OF GEN STORAGE
         ST    R3,PPIUNTCT          STORE ADDR OF UNIT COUNTERS
         BR    R14                  RETURN TO LOAD MODULE
*        DASD SORT
ABX1020  LA    R5,16(,R5)           ADJUST FOR EOS, BCC AND CHAIN BYTES
         MVI   KEIGHT+3,X'10'
         MVI   KFOUR+3,X'0C'        ADJUST BCC BY CHAIN TOO
         MVI   WBLKCCNT+3,X'10'
         MVC   RBSUBRLT(2),KNOP     OVERLAY TO MOVE RECORD, THEN UPDATE
         MVC   RBSUBRLD(2),KNOP     BLOCK POINTER
         MVC   RBLSTPTR(4),KABXKON1  INITIAL BLOCK
         MVC   RBEOS(4),KABXKON2     POINTER
         MVC   RBINCR(4),KABXKON   INCR FOR OUTPUT FILE
         B     ABX1010
*
*        EXECUTED MOVE INSTRUCTION TO ZERO OUT UNIT COUNTER AREA
*
BTZERO   MVC   1(1,R3),0(R3)
*
*        CONSTANTS
*
KTWO     DC    F'2'
KROUND   DC    X'FFFFFFFC'
KNOP     DC    X'4700'
         DROP  R11
         DROP  R10
         USING IERRBXD,R11
KABXKON  IC    R6,PPIDEPHO+1       INCR FOR OUTPUT UNIT
KABXKON1 L     R2,WLSTPTRD
KABXKON2 L     R4,WLSTPTRD
*
*        MODULE NAME IERRBX
*
IERRBXD  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRBX SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRBXI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERABY   0101-20211-20211-1200-00114-00114-00000-RELEASE 00
ABY      TITLE 'IERABY - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERABY
*
*        MODULE FUNCTION -
*        OSCILLATING/CRCX SORT BLOCK ASSIGNMENT
*        ASSIGNMENT ROUTINE FOR MODULE IERRBY
*        IT IS A SORT PHASE MODULE USED FOR FIXED LENGTH RECORDS
*        LESS THAN 256 BYTES LONG. IT INITIALIZES THE RUNNING
*        PROGRAM AND SETS UP POINTERS TO THE OUTPUT BUFFER
*
*        USED AS A DSECT IN - N/A
*
*        MACROS USED BY THIS MODULE - SMPPI
*
*        ENTRY POINTS - N/A
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPISRTBL   PPILAB07
*        PPIRCDL2   PPILAB04
*        PPICNTL - PPI2314
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        NO PPI FIELDS INITIALIZED OR ALTERED
*        CONSTANTS AND CODE IN RUNNING PROGRAM ARE INITIALIZED
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS -
*        PPIBLK - ADDR OF RUNNING PROGRAM USED TO ADDRESS DSECT
*
*        EXITS - NORMAL - BR R14 RETURN
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS - N/A
*
*        NOTES -
*        THIS MODULE IS USED IN THE OSCILLATING OR 2314 SORT
*        PHASE FOR FIXED LENGTH RECORDS LESS THEN OR EQUAL TO 256
*        BYTES AND NO E15
*
IERABY   CSECT
*
         USING *,R11
         USING DIERRBY,R8
         USING IERRCA,R13
*
         LR    R11,R15
         L     R8,PPIBLK+4         MAKE RUNNING PROGRAM ADDRESSABLE
         LH    R6,PPISRTBL
         STH   R6,KBLKCNT          SET BLK CNT = SORT BLOCKING
         LH    R3,PPILAB07+2       SET R3 = BUFFER SIZE
         ST    R3,KBUFSIZ          STORE BUFSIZ IN RUNNING PROGRAM
         LH    R6,PPIRCDL2
         BCTR  R6,0                DECREMENT RCD LENGTH BY 1
         STC   R6,RBY1030+1        STORE RCD LENGTH - 1 IN MOVE INSTR
         SR    R5,R5
         ICM   R5,B'0111',PPILAB04+1  R5 -> OUTPUT BUFFER
         PPITEST  PPI2314          CRCX SORT ?
         BZ    ABY1010             NO, OSCILLATING
         LA    R3,12               CRCX, ADJUST FOR EOS AND CHAIN
         STC   R6,KABYMOD2+1       SET LENGTH FACTOR IN MVC INSTR
*
*        OVERLAY INSTRUCTIONS IN RUNNING PROGRAM SO THAT RECORD
*        IS MOVED TO THE OUTPUT BUFFER BEFORE BLOCK POINTER IS
*        INCREMENTED AND SO THAT INITIAL POINTER RATHER THAN
*        BLOCK POINTER IS PASSED TO WRITE ROUTINE AS THE BUFFER
*        ADDRESS
*
         MVC   RBYINCR(4),KABYMOD   INCR FROM PPIDEPHO
         STH   R3,K4                K4 = 12 FOR CRCX
         MVC   RBY1055(4),KABYMOD1  INITIAL POINTER
         MVC   RBY1105(4),KABYMOD1
         MVC   RBY1020(14),KABYMOD2  MVC THEN UPDATE BLK PTR
ABY1010  AR    R5,R3               CALCULATE BLK PTR
         ST    R5,KBLKPTR
         ST    R5,KIBLKPTR         SET INITIAL PTR
         BR    R14                 RETURN TO CALLER
*
*        CONSTANTS
*
         DROP  R11
         DROP  R8
*
         USING DIERRBY,R11
*
KABYMOD  IC    R6,PPIDEPHO+1       INCR FOR OUTPUT FILE
KABYMOD1 L     R2,KIBLKPTR         LOAD INITIAL POINTER
KABYMOD2 MVC   0(1,R2),0(R3)       MOVE RCD FROM RSA TO OUTPUT AREA
         AH    R2,PPIRCDL2         INCREMENT BLK PTR BY RCD LENGTH
         ST    R2,KBLKPTR
*
*        IERRBY
*
DIERRBY  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRBY SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRBYI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERABZ   0101-20211-20211-1200-00122-00122-00000-RELEASE 00
ABZ      TITLE 'IERABZ - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERABZ
*
*        MODULE FUNCTION -
*        OSCILLATING/CRCX SORT BLOCK ASSIGNMENT
*        ASSIGNMENT ROUTINE FOR MODULE IERRBZ
*        SORT PHASE MODULE USED FOR FIXED LENGTH RECORDS
*        GREATER THAN 256 BYTES LONG. IT INITIALIZES THE RUNNING
*        PROGRAM AND SETS UP POINTERS TO THE OUTPUT BUFFER
*
*        USED AS A DSECT IN - N/A
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                       CALLING SEQUENCE -
*                           L    R15,ASSG
*                           BALR R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPISRTBL   PPILAB07
*        PPILAB04   PPICNTL - PPI2314
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED - N/A
*        CONSTANTS AND CODE IN RUNNING PROGRAM ARE
*        INITIALIZED
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS -
*        PPIBLK - ADDR OF RUNNING PROGRAM USED TO ADDR DSECT
*
*        EXITS - NORMAL -
*                       BR R14 - RETURN TO IERRC9
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS - N/A
*
*        NOTES -
*        THIS MODULE IS USED FOR FIXED LENGTH RECORDS GREATER
*        THAN 256 BYTES IN THE SORT PHASE OF AN OSCILLATING OR
*        CRCX SORT
*
IERABZ   CSECT
*
         USING *,R11
         USING DIERRBZ,R8
         USING IERRCA,R13
*
         LR    R11,R15
         L     R8,PPIBLK+4         MAKE IERRBZ ADDRESSABLE
         MVC   KBLKCNT,PPISRTBL    INITIALIZE KBLKCNT IN IERRBZ
         SR    R5,R5
         ICM   R5,B'0111',PPILAB04+1  R5 -> BUFFER
         LA    R3,4                SET FOR OSC SORT
         PPITEST  PPI2314          CRCX SORT ?
         BZ    ABZ1010             NO, OSCILLATING TECHNIQUE
*
*        INITIALIZE FOR CRCX PROCESSING
*
         LA    R3,12               CRCX, ADJUST FOR EOS AND CHAIN
         STH   R3,DECRBUFA         DECRBUFA = 12 FOR CRCX
         MVC   RBZINCR(4),KABZMOD  INCR FROM PPIDEPHO
         MVC   RBZ1045(4),KABZMOD1   INITIAL POINTER
         MVC   RBZ1078(4),KABZMOD1
         MVC   RBZ1020(18),KABZMOD2  MVC THEN UPDATE BLK PTR
*
*        OVERLAY INSTRUCTIONS IN RUNNING PROGRAM SO THAT WINNER
*        WILL BE MOVED TO OUTPUT BUFFER BEFORE BLOCK POINTER IS
*        INCREMENTED AND INITIAL POINTER WILL BE PASSED TO WRITE
*        ROUTINE AS BUFFER ADDR
*
ABZ1010  AR    R5,R3               SET BLK PTR AND INITIAL BLK PTR
         ST    R5,KBLKPTR          IN IERRBZ
         ST    R5,KIBLKPTR
         BR    R14                 RETURN TO CALLER
*
*        CONSTANTS
*
         DROP  R11
         DROP  R8
*
*        ALTERNATIVE CODE FOR IERRBZ
*
         USING DIERRBZ,R11
*
KABZMOD  IC    R6,PPIDEPHO+1       INCR FOR OUTPUT FILE
*
KABZMOD1 L     R2,KIBLKPTR         INITIAL BUF PTR
*
KABZMOD2 LR    R4,R3           *
         LR    R5,R2           |   MOVE RECORD FROM RSA TO
         L     R15,PPIBDSVA+4  |
         BASR  R14,R15         |   OUTPUT AREA BY CALLING MOVE RTN
         AH    R2,PPIRCDL2     |   UPDATE BLK PTR
         ST    R2,KBLKPTR      V
*
         DROP  R11
*
*        IERRBZ
*
DIERRBZ  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRBZ SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRBZI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERADB   0101-20211-20211-1200-00122-00122-00000-RELEASE 00
ADB      TITLE 'IERADB - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERADB
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 1 ASSIGNMENT MODULE - FIXED LENGTH SORT W/O E15
*        THIS MODULE BUILDS A TABLE OF RSA ADDRESSES WITH THEIR
*        RESPECTIVE AREA BYTE COUNTS IN IERRDB. THE TABLE IS
*        NEEDED BECAUSE RECORD STORAGE AREA MAY NOT BE
*        CONTIGUOUS. THIS MODULE ALSO BUILDS THE INPUT BUFFERS
*        USING THE BUILD MACRO. IT ALSO OBTAINS THE ADDRESS OF
*        THE INPUT DCB AND PUTS IT IN THE RUNNING PROGRAM IERRDB
*
*        IERADB INSERTS THE RECORD LENGTH OF THE FIXED LENGTH
*        RECORD WHICH <= 256 BYTES IN IERRDB MOVE INSTRUCTION
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - NONE
*
*        MACROS USED BY MODULE -
*        SMPPI
*        BUILD
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                       CALLING SEQUENCE -
*                       LOAD EP=IERADB,DCB=SORTLIB
*                       LR   R15,R0
*                       BALR R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIDEB    PPISTDCB   PPILAB08
*        PPIRCDL1  PPILAB03
*        PPILEXFF  PPILAB06
*
*        INFO IS NEEDED TO BUILD THE RSA TABLE IN IERRDB AND TO
*        BUILD THE INPUT BUFFERS
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED - NONE
*
*        EXTERNAL ROUTINES - NONE
*
*        EXTERNAL PARAMETERS - SEE REGISTERS
*
*        EXITS - NORMAL - EXIT TO IERRC9
*                         CALLING SEQUENCE -
*                         BR   R14        RETURN
*
*        EXITS - ERROR - NONE
*
*        NOTES -
*        THIS MODULE WILL EXECUTE FOR ANY FIXED LENGTH SORT
*        WITHOUT EXIT E15 AND E16. THE FIXED LENGTH INPUT RECORD
*        MUST BE <= 256 BYTES
*
IERADB   CSECT
*
         USING *,R11               MODULE BASE REG
         USING IERRDB,R10
         USING IERRCA,R13
*
IERMDA   LR    R11,R15             SET BASE REGISTER
         L     R10,PPIDEB+4        SET IERRDB DSECT BASE REGISTER
*
*        ESTABLISH ALL RECORD STORAGE AREA ADDRESSES AND THEIR
*        RESPECTIVE BYTE COUNTS AND BUILD RSA TABLE IN IERRDB
*
         LA    R2,TABLRSA          ADDR OF RSA TABLE IN IERRDB
         SR    R3,R3
         SR    R6,R6
         IC    R3,PPILAB08         NO OF RSA AREAS
         LA    R7,4                4 BYTES FOR TREE ADDR
         AH    R7,PPILEXFF         PLUS SIZE OF ROUNDED EXTRACTED
*                                  CONTROL FIELDS
         L     R5,PPILAB08         PTR TO TABLE OF RSA ADDRS WITH THEIR
*                                  RESPECTIVE BYTE COUNTS
ADBRSALP L     R4,0(R6,R5)         STARTING ADDR OF AN RSA AREA
         AR    R4,R7               ADDR OF 1ST RCD IN THIS RSA AREA
         ST    R4,0(R6,R2)         STORE IN IERRDB RSA ADDR TABLE
         L     R4,4(R6,R5)         BYTE COUNT OF THIS RSA AREA
         ST    R4,4(R6,R2)         STORE IN IERRDB RSA ADDR TABLE
         LA    R6,8(,R6)           UPDATE INDEX PTR
         BCT   R3,ADBRSALP         DECR RSA CTR LOOP IF MORE RSA AREAS
*
*        INSERT INPUT DCB ADDR AND RECORD LENGTH IN IERRDB
*        BUILD INPUT BUFFERS
*
         L     R6,PPISTDCB         SET INPUT DCB ADDRS IN RUNNING PROG
         L     R4,0(,R6)
         ST    R4,KADCB            DATA AREA IN IERRDB
         LH    R8,PPIRCDL1         GET RECORD LENGTH
         BCTR  R8,0                SET RCD LENGTH - 1
         STC   R8,RDB1030+1        UPDATE MVC INSTRUCTION IN IERRDB
         L     R1,PPILAB02         R1 -> INPUT BUFFER POOL ADDR TABLE
         LH    R0,PPILAB03+2        SET BUFFER SIZE IN R0
         ICM   R0,B'0100',PPILAB03  NUMBER OF BUFFERS
*
         BUILDS (1),(0)            BUILD INPUT BUFFERS
*
*        INTERFACE TO IERRC9
*
         BR    R14                 RETURN
*
*        WORK AREAS
*
IERRDB   DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRDB SOURCE
*
*----------------------------------------------------------------------
*
         COPY IERRDBI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERADC   0101-20211-20211-1200-00116-00116-00000-RELEASE 00
ADC      TITLE 'IERADC - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERADC
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 1 ASSIGNMENT MODULE - FIXED LENGTH SORT W/O E15
*        THIS MODULE BUILDS A TABLE OF RSA ADDRESSES WITH THEIR
*        RESPECTIVE AREA BYTE COUNTS IN IERRDC. THE TABLE IS
*        NEEDED BECAUSE RECORD STORAGE AREA MAY NOT BE
*        CONTIGUOUS. THIS MODULE ALSO BUILDS THE INPUT BUFFERS
*        USING THE BUILD MACRO. IT ALSO OBTAINS THE ADDRESS OF
*        THE INPUT DCB AND PUTS IT IN THE RUNNING PROGRAM IERRDC
*
*        MODULES IN WHICH THIS MODULE APPEARS AS A DSECT - NONE
*
*        MACROS USED BY MODULE -
*        SMPPI
*        BUILD
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                       CALLING SEQUENCE -
*                           LOAD EP=IERADC,DCB=SORTLIB
*                           LR   R15,R0
*                           BALR R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIDEB    PPILAB08
*        PPILAB03  PPILEXFF
*        PPILAB06  PPISTDCB
*
*        INFO IS NEEDED TO BUILD THE RSA TABLE IN IERRDC AND TO
*        BUILD THE INPUT BUFFERS
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED - NONE
*
*        EXTERNAL ROUTINES - NONE
*
*        EXTERNAL PARAMETERS - SEE REGISTERS
*
*        EXITS - NORMAL - EXIT TO IERRC9
*                         CALLING SEQUENCE -
*                             BR   R14   RETURN
*
*        EXITS - ERROR - NONE
*
*        NOTES -
*        THIS MODULE WILL EXECUTE FOR ANY FIXED LENGTH SORT
*        WITHOUT EXITS E15 AND E16. THE INPUT RCD MUST BE GREATER
*        THAN 256 BYTES
*
IERADC   CSECT
*
         USING *,R11               BASE REGISTER
         USING IERRDC,R10          BASE REG FOR RP DSECT
         USING IERRCA,R13          PPI BASE REG
*
IERMDA   LR    R11,R15             SET BASE REGISTER
         L     R10,PPIDEB+4        SET IERRDC DSECT BASE REGISTER
*
*        ESTABLISH ALL RECORD STORAGE AREA ADDRESSES AND THEIR
*        RESPECTIVE BYTE COUNTS AND BUILD RSA TABLE IN IERRDB
*
         LA    R2,TABLRSA          ADDR OF RSA TABLE IN IERRDC
         SR    R3,R3
         SR    R6,R6
         IC    R3,PPILAB08         NO OF RSA AREAS
         LA    R7,4                4 BYTES FOR TREE ADDR
         AH    R7,PPILEXFF         PLUS SIZE OF ROUNDED EXTRACTED
*                                  CONTROL FIELDS
         L     R5,PPILAB08         PTR TO TABLE OF RSA ADDRS WITH THEIR
*                                  RESPECTIVE BYTE COUNTS
ADCRSALP L     R4,0(R6,R5)         STARTING ADDR OF AN RSA AREA
         AR    R4,R7               EQLS ADDR OF 1ST RCD IN THE RSA AREA
         ST    R4,0(R6,R2)         STORE IN IERRDC RSA ADDR TABLE
         L     R4,4(R6,R5)         BYTE COUNT OF THIS RSA AREA
         ST    R4,4(R6,R2)         STORE IN IERRDC RSA ADDR TABLE
         LA    R6,8(0,R6)          UPDATE INDEX REG
         BCT   R3,ADCRSALP         DECR RSA CTR, LOOP IF MORE RSA AREAS
*
*        INSERT INPUT DCB ADDR IN IERRDC
*        BUILD INPUT BUFFERS
*
         L     R6,PPISTDCB         SET INPUT DCB ADDR IN RUN PROG
         L     R4,0(,R6)
         ST    R4,KADCB
         L     R1,PPILAB02         R1 -> INPUT BUFFER POOL ADDR TABLE
         LH    R0,PPILAB03+2        L'INPUT BUFFERS
         ICM   R0,B'0100',PPILAB03  NO OF INPUT BUFFERS
*
         BUILDS (1),(0)            BUILD INPUT BUFFERS
*
*        RETURN TO IERRC9
*
         BR    R14                 RETURN
*
*        WORK AREAS
*
IERRDC   DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRDC SOURCE
*
*----------------------------------------------------------------------
*
         COPY IERRDCI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERADD   0101-20211-20211-1200-00154-00154-00000-RELEASE 00
ADD      TITLE 'IERADD - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERADD
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 1 ASSIGNMENT MODULE - FIXED LENGTH WITH E15 AND/OR E16
*        THE FUNCTION OF THIS MODULE IS TO INITIALIZE A RECORD
*        STORAGE AREA TABLE IN IERRDD. THIS TABLE WOULD CONSIST
*        OF UP TO 5 ENTRIES FOR 5 NON CONTIGUOUS RSA'S. THIS
*        MODULE BUILDS THE INPUT BUFFER(S) IT ALSO CHECKS TO SEE
*        IF SORT IS ATTACHED, AND IF E15 AND E16 ARE ACTIVATED
*        AND OVERLAYS IERRDD IN APPROPRIATE PLACES. IT ALSO
*        PASSES IERRDD THE STARTING ADDRESS OF THE INPUT DCB
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - NONE
*
*        MACROS USED BY MODULE -
*        SMPPI
*        BUILD
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                       CALLING SEQUENCE -
*                           LOAD EP=IERADD,DCB=SORTLIB
*                           LR   R15,R0
*                           BALR R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIDEB     PPILAB08    PPINMAX
*        PPILAB03   PPILEXFF    PPIATP1E
*        PPILAB06   PPISTDCB
*        INFO IS NEEDED TO BUILD RSA TABLE IN IERRDD, TO BUILD
*        THE INPUT BUFFER(S), TO SEE WHAT USER EXITS ARE
*        ACTIVATED
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED - NONE
*
*        EXTERNAL ROUTINES - NONE
*
*        EXTERNAL PARAMETERS - SEE REGISTERS
*
*        EXITS - NORMAL - EXIT TO IERRC9
*                         CALLING SEQUENCE -
*                              BR   R14  RETURN
*
*        EXITS - ERROR - NONE
*
*        NOTES -
*        THIS MODULE WILL EXECUTE FOR ANY FIXED LENGTH SORT
*        HAVING USER EXITS E15 AND/OR E16, OR ATTACHED
*
IERADD   CSECT
*
         USING *,R11               MODULE BASE REGISTER
         USING IERRDD,R10          BASE REG FOR RP DSECT
         USING IERRCA,R13          PPI BASE REG
*
IERMDA   LR    R11,R15
         L     R10,PPIDEB+4
*
*        ESTABLISH ALL RECORD STORAGE AREA ADDRS AND THEIR
*        RESPECTIVE BYTE COUNTS AND BUILD RSA TABLE IN IERRDD
*
         LA    R2,TABLRSA          ADDR OF RSA TABLE IN IERRDD
         SR    R3,R3
         SR    R6,R6
         IC    R3,PPILAB08         NO OF RSA AREAS
         LA    R7,4                4 BYTES FOR TREE ADDR
         AH    R7,PPILEXFF         PLUS SIZE OF ROUNDED EXTRACTED
*                                  CONTROL FIELDS
         L     R5,PPILAB08         PTR TO TABLE OF RSA ADDRS WITH THEIR
*                                  RESPECTIVE BYTE COUNTS
ADDRSALP L     R4,0(R6,R5)         STARTING ADDR OF AN RSA AREA
         AR    R4,R7               EQLS ADDR OF 1ST RCD IN THE RSA AREA
         ST    R4,0(R6,R2)         STORE IN IERRDD RSA ADDR TABLE
         L     R4,4(R6,R5)         BYTE COUNT OF THIS RSA AREA
         ST    R4,4(R6,R2)         STORE IN IERRDD RSA ADDR TABLE
         LA    R6,8(,R6)           UPDATE INDEX REG
         BCT   R3,ADDRSALP         DECR RSA CTR, LOOP IF MORE RSA AREAS
         ICM   R15,B'1111',PPIATP1E  ATTACHED EXIT ?
         BNZ   ADBYPSB             YES, BYPASS BUILD MACRO
*
*        SET UP AND BUILD THE INPUT BUFFER(S)
*
         L     R1,PPILAB02         ADDR OF INPUT BUFFER POOL ADDR TABLE
         LH    R0,PPILAB03+2        L'INPUT BUFFERS
         ICM   R0,B'0100',PPILAB03  NO OF INPUT BUFFERS
*
         BUILDS (1),(0)            BUILD INPUT BUFFER(S)
*
*        CALCULATE ADDR OF DCB AND STORE IN RP
*
ADBYPSB  L     R4,PPISTDCB         R4 -> LIST OF DCB ADDRS
         MVC   WDCB,0(R4)          STORE DCB ADDR IN RP
         PPITEST  PPIME16          NMAX E16 EXIT ACTIVATED ?
         BO    ADSTONMX            YES, BRANCH TO STORE NMAX IN RP
         MVC   RDTSTNMX(4),K3      OVERLAY NMAX TEST, INSERT RTN OF RP
         MVC   RDOVLAY4(4),K4      OVERLAY NMAX TEST, DO NOTHG,ETC RP
ADTSTATT ICM   R15,B'1111',PPIATP1E  ATTACHED EXIT ?
         BNZ   ADATTEXT            YES, BRANCH TO ATTACH EXIT RTN
         PPITEST  PPIME15          E15 EXIT ACTIVE ?
         BO    ADENDMOD            YES, BRANCH TO LINK TO NEXT RTN
         MVC   RDUSREXT,RDOVLAY4   OVERLAY USER EXIT E15 WITH A BRANCH
*                                  TO DO NOTHING RTN IN IERRDD
         MVI   WUSREOF,X'01'       SET USER EXIT E15 EOF SWITCH
*
*        RETURN TO IERRC9
*
ADENDMOD BR    R14                 RETURN
*
ADATTEXT ST    R15,PPIX15+4        RP EXIT E15 NOW LINKS TO ATTACH RTN
         MVI   WSYSEOF,X'01'       TURN ON SYSTEM EOF SWITCH
         MVC   RDTSTISW(4),K5      OVLAY INSERT SWITCH TEST IN RP
         B     ADENDMOD            BR TO LINK TO NEXT RTN
*
ADSTONMX L     R4,PPINMAX          LOAD NMAX
         LA    R4,1(,R4)           EQUALS NMAX + 1 (TO ALLOW BCT INSTR
*                                  IN RP TO DECR NMAX CTR)
         ST    R4,PPINMAX
         B     ADTSTATT            BRANCH TO TEST IF ATTACHED
*
*        CONSTANTS
*
KZERO    DC    F'0'
*
*        WORK AREAS
*
IERRDD   DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRDD SOURCE
*
*----------------------------------------------------------------------
*
         COPY IERRDDI
*
*        MODULE NAME - IERRMA
*
*        THIS MODULE CONTAINS ALL OF THE MESSAGES THAT ARE
*        REQUIRED FOR PHASE 1 RUNNING PROGRAM
*
IERRMA   DSECT
*
         COPY  RMAMAIN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERADE   0101-20211-20211-1200-00187-00187-00000-RELEASE 00
ADE      TITLE 'IERADE - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERADE
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 1 ASSIGNMENT MODULE VARIABLE LENGTH W/E15 AND OR E16
*        THE FUNCTION OF THIS MODULE IS TO CALCULATE THE
*        NUMBER OF BINS IN UP TO 5 NONCONTIGUOUS RECORD STORAGE
*        AREAS AND CHAIN ALL THESE BINS TOGETHER. IT PUTS THE
*        ADDRESS OF THE FIRST BIN IN THE FIRST RSA IN AVAIL
*        (PPIBDSVA+4). INPUT BUFFERS ARE SET UP VIA THE BUILD
*        MACRO. EXTRACT SIZE+4 IS CALCULATED AND STORED IN THE
*        RUNNING PROGRAM. EXITS E15 AND E16 ARE TESTED AND A TEST
*        IS MADE TO SEE IF SORT HAS BEEN ATTACHED. AS A RESULT
*        OF THESE TESTS PROPER OVERLAYS WILL BE MADE AND NMAX+1
*        MAY BE STORED IN THE RUNNING PROGRAM IERRDE
*
*        MODULES IN WHICH THIS MODULE APPEARS AS A DSECT - NONE
*
*        MACROS USED BY MODULE -
*        SMPPI  BUILDS
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                       CALLING SEQUENCE -
*                           LOAD EP=IERADD,DCB=SORTLIB
*                           LR   R15,R0
*                           BALR R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPINMAX    PPILAB03   PPIBINSZ
*        PPILAB06   PPILEXFF   PPIATPIE
*        PPILAB08   PPICNTL
*        ADDRESSES FOR BUFFERS AND TABLES, INFO FOR USER EXITS
*        AND FOR THE RSA CHAINING ROUTINE AND FOR THE BUILD MACRO
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED - PPIBDSVA
*        INITIALIZE START OF RSA (AVAIL) AND TOTAL NUMBER OF
*        BINS IN ALL THE RSAS
*
*        EXTERNAL ROUTINES - NONE
*
*        EXTERNAL PARAMETERS - SEE REGISTERS
*
*        EXITS - NORMAL - EXIT TO IERRC9
*                         CALLING SEQUENCE -
*                             BR   R14        RETURN
*
*        EXITS - ERROR - NONE
*
*        NOTES -
*        THIS MODULE WILL EXECUTE FOR ANY VARIABLE LENGTH SORT
*        HAVING USER EXITS E15 AND/OR E16, OR ATTACHED
*
IERADE   CSECT
*
         USING *,R11               THIS MODULE BASE REGISTER
         USING IERRDE,R10          IERRDE DSECT BASE REGISTER
         USING IERRCA,R13          PPI ADDR
*
IERMDA   LR    R11,R15             ESTABLISH THIS MODULE BASE REG
         L     R10,PPIDEB+4        ADDR OF IERRDE CSECT
*
*        CHAIN ALL BINS TOGETHER BY PUTTING IN EACH BIN THE ADDR
*        OF THE NEXT AVAILABLE BIN. SAVE THE ADDR OF THE 1ST
*        AVAILABLE BIN IN PPIBDSVA+4,AND THE TOTAL NO OF
*        AVAILABLE BINS IN PPIBDSVA+8
*
         SR    R3,R3
         IC    R3,PPILAB08         NO OF RSA AREAS
         L     R7,PPILAB08         PTR TO RSA TABLE IN PPI
         L     R6,0(,R7)           ADDR OF THIS RSA AREA BIN
         ST    R6,PPIBDSVA+4       SAVE THIS ADDR IN AVAIL (FOR IERRDE)
ADELOOPO L     R5,4(,R7)           NO OF BYTES IN THIS RSA AREA
         C     R5,PPIBINSZ         RSA < BINSIZE ?
         BL    ADELOOPJ            YES, BRANCH
         LA    R8,ADELOOPI         LOAD RETURN REG FOR THIS LOOP CALC
         SR    R4,R4
         D     R4,PPIBINSZ         R4=NO OF BINS IN THIS RSA AREA
         L     R4,PPIBDSVA+8       TOTAL NO OF BINS IN ALL RSA'S SO FAR
         AR    R4,R5               UPDATE BIN COUNT
         ST    R4,PPIBDSVA+8       SAVE UPDATED BIN COUNT
ADELOOPI BCT   R5,ADECHAIN         DECR NO OF BINS CTR FOR THIS RSA
*                                  BRANCH IF MORE BINS IN THIS RSA
ADELOOPJ BCT   R3,ADNXTRSA         DECR NO OF RSA'S CTR BR IF
*                                  RSA'S THE LAST BIN IN LAST RSA
*                                  HAS NO CHAIN ADDR
         ICM   R15,B'1111',PPIATP1E  ATTACHED ?
         BNZ   ADENOBLD            YES, DON'T BUILD BUFFERS
         L     R1,PPILAB02         ADDR OF INPUT BUFFER POOL ADDR TABLE
         LH    R0,PPILAB03+2        L'INPUT BUFFERS
         ICM   R0,B'0100',PPILAB03  NO OF INPUT BUFFERS
*
         BUILDS (1),(0)
*
ADENOBLD LH    R4,PPILEXFF         GET EXTRACT SIZE
         LA    R4,4(,R4)
         STH   R4,EXPLFOUR         STORE EXTRACT SIZE + 4
         PPITEST  PPIME16          NMAX E16 EXIT ACTIVATED ?
         BO    ADESTNM             YES, GO STORE NMAX IN RP
         MVC   RDEMAXCK(4),K2      OVERLAY NMAX TEST IN INSERT LEG
         MVC   RDEDONO(4),K3       OVERLAY NMAX TEST IN ALTER LEG
ADETATT  ICM   R15,B'1111',PPIATP1E  SORT ATTACHED ?
         BNZ   ADEATACH            ATTACHED, BRANCH
         PPITEST  PPIME15          USER RECORD MOD E15 EXIT ACTIVE ?
         BO    ADEEXIT             YES, BRANCH TO EXIT
         MVC   RDEUEXIT(4),K4      OVERLAY USER EXIT 15 WITH A BRANCH
         MVC   RDEMSG(4),K6
         MVI   WUSREOF,X'00'       TURN ON USER EOF SWITCH
         MVI   RDEISWON,X'58'      CHANGE INSTRUCTION TO L R1,ADRHOLD
ADEEXIT  L     R4,PPISTDCB         R4 -> DCB TABLE
         L     R4,0(,R4)           R4 -> SORTIN DCB
         ST    R4,KAWORK+4         INIT DCB IN IERRDE
         PPITEST  PPIMVSI          VBS INPUT ?
         BZ    ADERETUR            NO, BRANCH
         L     R4,PPIGETMN         YES
         L     R4,12(,R4)          GET ADDR OF VBS WORK
         ST    R4,KAWORK           FROM GETMN AND INIT RP
ADERETUR BR    R14                 RETURN TO IERRC9
*
ADESTNM  L     R4,PPINMAX          LOAD NMAX
         LA    R4,1(,R4)           PLUS 1 (FOR USING BCT INSTRUCTION)
         ST    R4,PPINMAX
         B     ADETATT             GO TEST FOR ATTACHED
*
ADEATACH ST    R15,PPIX15+4        E15 NOW IS ATTACHED
         MVI   WINPEOF,X'00'       TURN ON SYSTEM EOF SWITCH
         MVC   RDENORM(4),K5       OVERLAY INSRT SW TEST - BR ARND GET
         B     ADEEXIT             BRANCH TO EXIT
*
ADNXTRSA LA    R8,ADEREAL          RESET RETURN REG FOR THIS LOOP
*
*        INSERT CHAIN ADDR IN EACH BIN OF EACH RSA EXCEPT THE
*        LAST BIN OF THE LAST RSA
*
ADECHAIN A     R6,PPIBINSZ         ADDR OF THIS BIN + BIN SIZE
         LR    R4,R6               SAVE ADDR OF THE NEXT BIN
         S     R4,KFOUR            PTS TO AREA IN PREVIOUS BIN TO PUT
*                                  THE CHAIN ADDR OF NEXT BIN (IN R6)
         ST    R6,0(,R4)           PREVIOUS BIN NOW CHAINED TO NEXT BIN
         BR    R8                  BR TO ADELOOPI ON ALL BINS EXCEPT
*                                  THE LAST BIN IN EACH RSA OTHERWISE
*                                  BR TO ADEREAL ON THIS LAST BIN
*
*        OVERLAY LAST BIN CHAIN ADDR OF THIS RSA WITH PROPER ADDR
*        FIRST BIN ADDR OF NEXT RSA
*
ADEREAL  LA    R7,8(,R7)           UPDATE PPI RSA TABLE PTR TO NEXT
*                                  RSA ENTRY
         L     R6,0(,R7)           ADDR OF FIRST BIN IN NEXT RSA
         ST    R6,0(,R4)           STORE AS CHAIN ADDR IN LAST BIN OF
*                                  PREVIOUS RSA
         B     ADELOOPO            BRANCH TO CHAIN BINS OF THIS RSA
*
*        CONSTANTS
*
KFOUR    DC    F'4'                CONSTANT 4
*
*        IERRDE
*
IERRDE   DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRDE SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRDEI
*
*        MODULE NAME - IERRMA
*
*        THIS MODULE CONTAINS ALL OF THE MESSAGES THAT ARE
*        REQUIRED FOR PHASE 1 RUNNING PROGRAM
*
IERRMA   DSECT
*
         COPY  RMAMAIN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERADG   0101-20211-20211-1200-00151-00151-00000-RELEASE 00
ADG      TITLE 'IERADG - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERADG
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 1 ASSIGNMENT MODULE - VARIABLE LENGTH - NO PH1 EXITS
*        THE FUNCTION OF THIS MODULE IS TO CALCULATE THE NUMBER
*        OF BINS IN UP TO 5 NONCONTIGUOUS RECORD STORAGE AREAS
*        AND CHAIN ALL THESE BINS TOGETHER. IT PUTS THE ADDRESS
*        OF THE FIRST BIN IN THE FIRST RSA IN AVAIL (PPIBDSVA+4).
*        INPUT BUFFERS ARE SET UP VIA THE BUILD MACRO. EXTRACT
*        SIZE+4 IS CALCULATED AND STORED IN THE RUNNING PROGRAM
*        IERRDG
*
*        MODULES IN WHICH THIS MODULE APPEARS AS A DSECT - NONE
*
*        MACROS USED BY MODULE -
*        SMPPI
*        BUILDS
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                       CALLING SEQUENCE -
*                           LOAD EP=IERADG,DCB=SORTLIB
*                           LR   R15,R0
*                           BALR R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIBINSZ   PPILAB08
*        PPILAB03   PPILEXFF
*        PPILAB06
*        ADDRESSES FOR BUFFERS AND TABLES, FOR THE RSA CHAINING
*        ROUTINE AND FOR THE BUILD MACRO
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPIBDSVA
*        INITIALIZE START OF RSA (AVAIL) AND TOTAL NUMBER OF
*        BINS IN ALL THE RSAS
*
*        EXTERNAL ROUTINES - NONE
*
*        EXTERNAL PARAMETERS - SEE REGISTERS
*
*        EXITS - NORMAL - EXIT TO IERRC9
*                         CALLING SEQUENCE -
*                             BR   R14        RETURN
*
*        EXITS - ERROR - NONE
*
*        NOTES -
*        THIS MODULE WILL EXECUTE FOR ANY VARIABLE LENGTH SORT
*        WITH NO PHASE 1 USER EXITS
*
IERADG   CSECT
*
         USING *,R11               THIS MODULE BASE REGISTER
         USING IERRDG,R10          IERRDG DSECT BASE REGISTER
         USING IERRCA,R13          PPI ADDR
*
IERMDA   LR    R11,R15             ESTABLISH THIS MODULE BASE REGISTER
         L     R10,PPIDEB+4        ADDR OF IERRDG CSECT
*
*        CHAIN ALL BINS TOGETHER BY PUTTING IN EACH BIN THE ADDR
*        OF THE NEXT AVAILABLE BIN. SAVE THE ADDR OF THE FIRST
*        AVAILABLE BIN IN PPIBDSVA+4 AND THE TOTAL NO OF
*        AVAILABLE BINS IN PPIBDSVA+8
*
         SR    R3,R3
         IC    R3,PPILAB08         NO OF RSA AREAS
         L     R7,PPILAB08         PTR TO RSA TABLE IN PPI
         L     R6,0(,R7)           ADDR OF THIS RSA AREA BIN
         ST    R6,PPIBDSVA+4       SAVE THIS ADDR IN AVAIL FOR IERRDG
ADELOOPO L     R5,4(,R7)           NO OF BYTES IN THIS RSA AREA
         LA    R8,ADELOOPI         LOAD RETURN REG FOR THIS LOOP CALC
         SR    R4,R4
         D     R4,PPIBINSZ         R5 = NO OF BINS IN THIS RSA AREA
         L     R4,PPIBDSVA+8       TOTAL NO OF BINS IN ALL RSA'S SO FAR
         AR    R4,R5               UPDATE BIN COUNT
         ST    R4,PPIBDSVA+8       SAVE UPDATED BIN COUNT
ADELOOPI BCT   R5,ADECHAIN         DECR NO OF BINS CTR FOR THIS RSA
*                                  BRANCH IF MORE BINS IN THIS RSA
         BCT   R3,ADNXTRSA         DECR NO OF RSA'S CTR BRANCH IF MORE
*                                  RSAS THE LAST BIN IN THE LAST RSA
*                                  HAS NO CHAIN ADDR
         LH    R0,PPILAB03+2        L'INPUT BUFFERS
         ICM   R0,B'0100',PPILAB03  NO OF INPUT BUFFERS
         L     R1,PPILAB02         ADDR OF INPUT BUFFER POOL ADDR TABLE
*
         BUILDS (1),(0)            BUILD THE INPUT BUFFER(S)
*
         LH    R4,PPILEXFF         GET EXTRACT SIZE
         A     R4,KFOUR
         STH   R4,EXPLFOUR         STORE EXTRACT SIZE + 4
         L     R4,PPISTDCB         R4 -> DCB TABLE
         L     R4,0(,R4)           R4 -> INPUT DCB
         ST    R4,KAWORK+4         STORE IN IERRDG WORK AREA
         PPITEST  PPIMVSI          VBS INPUT ?
         BZ    ADGRETUR            NO, BRANCH
         L     R4,PPIGETMN         ADDR OF GETMAIN TABLE OF ADDR
         L     R4,12(,R4)          FETCH ADDR OF VBS WORK AREA
         ST    R4,KAWORK           STORE IN RP WORK AREA
ADGRETUR BR    R14                 RETURN TO IERRC9
*
ADNXTRSA LA    R8,ADEREAL          RESET RETURN REG FOR THIS LOOP
*
*        INSERT CHAIN ADDR IN EACH BIN OF EACH RSA EXCEPT THE
*        LAST BIN OF THE LAST RSA
*
ADECHAIN A     R6,PPIBINSZ         ADDR OF THIS BIN + BIN SIZE
         LR    R4,R6               SAVE ADDR OF THE NEXT BIN
         S     R4,KFOUR            PTS TO AREA IN PREVIOUS BIN TO PUT
*                                  THE CHAIN ADDR OF NEXT BIN (IN R6)
         ST    R6,0(,R4)           PREVIOUS BIN NOW CHAINED TO NEXT BIN
         BR    R8                  BR TO ADELOOPI ON ALL BINS EXCEPT
*                                  THE LAST BIN IN EACH RSA ELSE
*                                  BR TO ADEREAL ON THIS LAST BIN
*
*        OVERLAY LAST BIN CHAIN ADDR OF THIS RSA WITH PROPER ADDR
*        FIRST BIN ADDR OF NEXT RSA
*
ADEREAL  LA    R7,8(,R7)           UPDATE PPI RSA TABLE PTR TO NEXT
*                                  RSA ENTRY
         L     R6,0(,R7)           ADDR OF FIRST BIN IN NEXT RSA
         ST    R6,0(,R4)           STORE AS CHAIN ADDR IN LAST BIN OF
*                                  PREVIOUS RSA
         B     ADELOOPO            BRANCH TO CHAIN BINS OF THIS RSA
*
*        CONSTANTS
*
KFOUR    DC    F'4'                CONSTANT 4
*
*        IERRDG
*
IERRDG   DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRDG SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRDGI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERADH   0101-20211-20211-1200-00148-00148-00000-RELEASE 00
ADH      TITLE 'IERADH - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERADH
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 3 DEBLOCK ASSIGNMENT MODULE - FIXED LENGTH RECORDS
*        THIS MODULE IS A FINAL PHASE ASSIGNMENT ROUTINE FOR
*        FIXED LENGTH RECORDS. THE MODULE DOES ALL THE
*        INITIALIZING NECESSARY FOR IERRDH, THE DEBLOCK RUNNING
*        PROGRAM, IN THE FINAL MERGE
*
*        MODULES IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM IERRC9 VIA
*                       LOAD  EP=IERADH,DCB=SORTLIB
*                       LR    R15,R0
*                       BALR  R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIBDSVA   PPISBLCT
*        PPILAB03   PPISPGN1
*        PPIMRGMX   PPISRTBL
*        PPIPDWA    PPICNTL
*        PPIRCDL2
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPIBDSVA   PPISPGN1
*
*        EXTERNAL ROUTINES - NONE
*
*        EXTERNAL PARAMETERS -
*        PPIPDWA - MERGE PRIME AREA -
*                  CONTAINS FIRST RECORDS TO BE MERGED
*
*        EXITS - NORMAL - RETURN TO IERRC9 VIA R14
*
*        EXITS - ERROR - NONE
*
*        TABLES/WORK AREAS - NONE
*
*        NOTES -
*        THIS MODULE IS USED ONLY FOR FIXED LENGTH RECORDS
*
IERADH   CSECT
*
         USING *,R11
         USING IERRCA,R13
         USING IERRDH,R14
*
IERMD34  LR    R11,R15
         ICM   R4,B'1111',PPIRCDCT  ZERO FILE ?
         BZR   R14                 YES, RETURN TO IERRC9
         ST    R14,KSAVC9          NO, SAVE RETURN REG
         L     R14,PPIDEB+4        RUNNING DEBLOCK ADDR
         L     R4,PPISPGN1         ADDR OF GENERATED STORAGE
         TM    PPISPGN1+3,X'03'    ENSURE TABLES START ON FULL WORD
         BZ    ADHDA020            BOUNDARIES
         LA    R4,3(,R4)           ROUND ADDR TO FULL WORD BOUNDARY
         N     R4,KMASK
         S     R4,KFOUR
ADHDA020 SR    R5,R5
         IC    R5,PPIBDSVA         GET TOTAL NO PHASE 2 AND 3 BUFFERS
*                                  CALCUATE SIZE OF TABLE DEBLAREA
         SLL   R5,2                AND SET ASIDE THE AREA
         LA    R5,4(,R5)
         SR    R4,R5               IN GENERATED STORAGE
         ST    R4,IERDBLSV         TABLE OF INPUT BUFFERS
         ST    R4,PPISPGN1
         MVC   PPIBDSVA+1(3),PPISPGN1+1  USED TO INTERFACE WITH READ
         L     R6,PPISBLCT         R6 -> BLOCK COUNTS TABLE
         LH    R9,PPIMRGMX         R9 = MERGE ORDER
         LA    R5,PPIPDWA          R5 -> PRIME AREA
         SR    R8,R8
         PPITEST  PPITAPE          TAPE SORT ?
         BO    ADHTP045            YES, BRANCH
         PPITEST  PPI2314          CRCX SORT ?
         BZ    ADHDK030            NO, BALN, BRANCH
         MVI   KFOUR+3,12          ADJUST FOR CHAIN BYTES IN BUFFER
*                                  = EOS (4 BYTES) + CHAIN (8 BYTES)
*
*        NO ADDR ADJUSTMENTS ARE NEEDED AS ARE FOR READ BACKWARDS
*        ON TAPE
*
ADHDK030 IC    R8,0(,R5)           DEVICE IS DISK
         L     R7,0(,R5)           MOVE ENTRY IN PRIME AREA TO
         S     R7,KFOUR            (EOS INDICATOR'S 4 BYTES)
         ST    R7,0(R8,R4)         DEBLAREA INDEXED BY INCR STARTING
*                                  BUFFER ADDR IS ADDR IN PRIME
         BCT   R9,ADHLP040         AREA
         L     R14,KSAVC9
         BR    R14                 RETURN TO IERRC9
*
ADHLP040 LA    R5,4(,R5)           UPDATE PRIME AREA POINTER
         B     ADHDK030
*
ADHTP045 PPITEST  PPIREADF         READ FORWARD SWITCH ON ?
         BZ    ADHTP050            NO, BRANCH
         B     ADHDK030            GO USE DISK ROUTINE (READ FORWARD)
*
ADHTP050 IC    R8,0(,R5)           INCR
         L     R7,0(R8,R6)         R7 = BLOCK COUNT
         MH    R7,PPIRCDL2         SORT RECORD LENGTH * BLOCK COUNT
         LH    R15,PPISRTBL        R15 = BLOCKING FACTOR
         MH    R15,PPIRCDL2        INCLUDE EOS 4 BYTES AND
         LA    R15,4(,R15)
         LH    R14,PPILAB03+2
         SR    R14,R15             POSSIBLE BOUNDARY ROUND OFF BYTES
         AR    R7,R14
         BCTR  R7,0                BLOCK CHAR CNT -1
         A     R7,0(,R5)
         ST    R7,0(R8,R4)         STARTING ADDR OF BUFFER FOR READ
         BCT   R9,ADHLP060         BACKWARDS (TAPE ONLY)
         L     R14,KSAVC9
         BR    R14                 RETURN TO IERRC9
*
ADHLP060 LA    R5,4(,R5)           UPDATE PRIME AREA POINTER
         B     ADHTP050
*
*        CONSTANTS
*
KSAVC9   DC    F'0'
KFOUR    DC    F'4'                CONSTANT =4 FOR TAPE AND BALN
*                                           =12 FOR CRCX
KMASK    DC    X'FFFFFFFC'
*
*        IERRDH
*
IERRDH   DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRDH SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRDHI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERADI   0101-20211-20211-1200-00151-00151-00000-RELEASE 00
ADI      TITLE 'IERADI - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERADI
*
*        MODULE FUNCTION/OPERATION -
*        ASSIGNMENT ROUTINE FOR MODULE IERRDI
*        IT IS USED IN THE FINAL MERGE PHASE FOR VARIABLE LENGTH
*        RECORDS. IT BUILDS A TABLE OF INPUT BUFFER ADDRESSES IN
*        GENERATED CORE TO BE USED BY IERRDI IN COMMUNICATING
*        WITH THE READ ROUTINE
*
*        MODULES IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                       CALLING SEQUENCE -
*                           L    R15,ASSG
*                           BALR R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPISPGN1   PPICNTL
*        PPIBDSVA   PPIPDWA
*        PPIMRGMX   PPISBLCT
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPISPGN1 - UPDATED TO LAST BYTE USED
*        PPIBDSVA+1 - SET TO ADDR OF BUFFER TABLE (IN GEN CORE)
*        BUILDS BUFFER ADDR TABLE IN GEN CORE IT CONTAINS ADDR
*        OF EACH INPUT BUFFER IN ORDER ACCORDING TO DCB
*        INCREMENT
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS -
*        PPIDEB - RUNNING PROGRAM ADDR FOR DSECT
*
*        EXITS - NORMAL -
*        EOJ/OPEN OUTPUT RTN - DSPL = 4 TO OPEN OUTPUT
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS - N/A
*
*        NOTES -
*        THIS MODULE IS USED IN THE FINAL MERGE PHASE FOR
*        VARIABLE LENGTH RECORDS
*
IERADI   CSECT
*
         USING *,R11
         USING DIERRDI,R9
         USING IERRCA,R13
*
IERMD34  LR    R11,R15
         ICM   R4,B'1111',PPIRCDCT  ZERO FILE ?
         BZR   R14                  YES, RETURN TO IERRC9
         L     R9,PPIDEB+4
*
*        CALCULATE NUMBER OF BYTES NEEDED FOR BUFFER ADDR TABLE
*        AND BUILD TABLE IN GENERATED CORE
*
         L     R4,PPISPGN1         ACCESS ADDR OF GENERATED CORE
         N     R4,KMASK            ALIGN TO FULL WORD BOUNDARY
         SR    R5,R5
         IC    R5,PPIBDSVA         ACCESS NO OF WORK UNITS
         SLL   R5,2                MULTIPLY BY 4
         LA    R5,4(,R5)           ADD 4
         SR    R4,R5
         ST    R4,PPISPGN1         UPDATE ADDR OF GENERATED CORE
         MVC   PPIBDSVA+1(3),PPISPGN1+1  SET TABLE ADDR IN PPI
         LA    R5,PPIPDWA          SET R5 = PRIME AREA ADDR
         LH    R3,PPIMRGMX         SET R3 = MERGE ORDER
         L     R6,PPISBLCT         R6 -> BLOCK COUNT TABLE
*                                  BLOCK COUNTS INCLUDE BCC BUT NOT
*                                  EOS INDICATION
         SR    R8,R8
         PPITEST  PPITAPE          TAPE SORT ?
         BZ    ADI34030            NO, BRANCH
         PPITEST  PPIREADF         READ FORWARD SWITCH ON ?
         BO    ADI34030            YES, GO USE DISK ROUTINE (READ FWD)
*
*        BUILD TABLE FOR TAPE - ADDR MUST POINT TO LAST BYTE OF
*        BUFFER
*
ADI34010 IC    R8,0(,R5)           SET R8 NO INCREMENT
         L     R7,0(R8,R6)         SET R7 = APPROPRIATE BLOCK COUNT
         SH    R7,KA4              DECREMENT BLOCK COUNT BY 4 FOR BCC
         ST    R7,0(R8,R6)
         A     R7,0(,R5)           ADD BLK CNT TO BUFFER PTR
         BCTR  R7,0                DECREMENT BY 1, R7 NOW POINTS TO
*                                  LAST BYTE IN BUFFER
         ST    R7,0(R8,R4)         STORE BUFFER ADDR IN TABLE
         BCT   R3,ADI34020         DECR MRG ORDER BY 1, DOES IT = 0
*                                  NO, BRANCH
         BR    R14                 RETURN TO IERRC9
*
ADI34020 LA    R5,4(R5)            INCR R5 TO NEXT ENTRY IN PRIME AREA
         B     ADI34010            BUILD NEXT TABLE ENTRY
*
*        BUILD TABLE FOR DISK - ADDR MUST POINT TO FIRST BYTE OF
*        BUFFER
*
ADI34030 PPITEST  PPI2314          CRCX ?
         BZ    ADI34035            NO, 2311/2301
         MVI   KA4+1,X'0C'         WANT BLCNT - BCC - CHAIN FOR CRCX
         MVI   K4+1,X'0C'
         MVI   K8+1,X'10'          ADJUST FOR CHAIN BYTES IN BUFFER TOO
*                                  = EOS (4) + BCC (4) + CHAIN (8)
ADI34035 IC    R8,0(,R5)           SET R8= INCREMENT
         L     R7,0(R8,R6)         DECREMENT BLOCK COUNT BY 4 FOR BCC
         SH    R7,KA4
         ST    R7,0(R8,R6)
         L     R7,0(,R5)           SET R7 = RECORD ADDR
         SH    R7,K8               DECR BY 8 FOR BCC AND EOS INDICATION
         ST    R7,0(R8,R4)         STORE BUFFER ADDR IN TABLE
         BCT   R3,ADI34040         DECR MRG ORDER BY 1, DOES IT = 0 ?
*                                  NO, BRANCH
         BR    R14                 RETURN TO IERRC9
*
ADI34040 LA    R5,4(,R5)           INCR R5 TO NXT ENTRY IN PRIME AREA
         B     ADI34035            BUILD NEXT TABLE ENTRY
*
*        CONSTANTS
*
         DC    0F'0'
KMASK    DC    X'FFFFFFFC'
KA4      DC    X'0004'
K8       DC    X'0008'             CONSTANT = 8 FOR TAPE AND 2311/2301
*
*        IERRDI
*
DIERRDI  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRDI SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRDII
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERADJ   0101-20211-20211-1200-00163-00163-00000-RELEASE 00
ADJ      TITLE 'IERADJ - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERADJ
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 3 (MERGE ONLY) ASSIGNMENT MODULE FIXED LENGTH
*        THE FUNCTION OF THIS MODULE IS TO PRIME THE INPUT
*        BUFFERS AND PUT THE ADDRESS OF THE FIRST RECORD IN EACH
*        PRIMARY INPUT BUFFER IN THE PRIME AREA IN PPI FOR THE
*        MERGE NETWORK. AN INCREMENT IS PLACED IN THE HIGH ORDER
*        BYTE OF EACH RECORD ADDRESS TO INDICATE WHICH INPUT DATA
*        SET THE RECORD CAME FROM. THE INCREMENT IS 4, 8, 12,
*        16....N WHERE N IS 4 TIMES THE NUMBER OF INPUT DATA
*        SETS
*
*        ON ANY INPUT END OF FILE, QSAM BRANCHES DIRECTLY TO
*        IERRGF VIA DCBEODAD. SO THAT IERRGF MAY BRANCH BACK TO
*        THIS MODULE, THIS MODULE INSERTS ITS ADDR (IERADJ) IN
*        PPIPSVA
*
*        THE OPERATION OF THIS MODULE DOES NOT DEPEND UPON A
*        PARTICULAR INTERNAL REPRESENTATION OF THE EXTERNAL
*        CHARACTER SET
*
*        MODULES IN WHICH THIS MODULE APPEARS AS A DSECT - NONE
*
*        MACROS USED BY MODULE -
*        SMPPI   GET
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                       CALLING SEQUENCE -
*                           LOAD EP=IERADJ,DCB=SORTLIB
*                           LR   R15,R0
*                           BALR R14,R15
*
*                     - ENTRY FROM IERRGF
*                       CALLING SEQUENCE -
*                           L    R11,PPIPSVA
*                           B    8(,R11)
*
*                     - ENTRY FROM QSAM GET
*                       CALLING SEQUENCE -
*                           BR   R14   RETURN
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPICNTL    PPIEOF
*        PPISTDCB   PPIPDWA
*        TEST IF USER MOD SWITCH ON IN PPI, OBTAIN STARTING ADDR
*        OF INPUT DCBS, WORK AREA IN PPI FOR INPUT RECORD ADDR
*        TABLE FOR MERGE NETWORK
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPIPSVA    PPICNTL
*        PPIMRGMX
*        SAVE THIS MOD ENTRY POINT, SET PPI SWITCH TO INDICATE
*        R15, RESET MRGMX, IF NEEDED, TO CORRECT INPUT MERGE
*        ORDER
*
*        EXTERNAL ROUTINES - NONE
*
*        EXTERNAL PARAMETERS - SEE REGISTERS
*
*        EXITS - NORMAL - EXIT TO QSAM GET
*                         CALLING SEQUENCE-
*                             GET(R5)       R5 -> INPUT DCB
*
*                         RETURN ON REGISTER R14
*
*        EXITS - ERROR - NONE
*
*        TABLES/WORK AREAS -
*        PPIPDWA - TABLE OF INPUT RECORD ADDR IN PPI
*
*        NOTES -
*        THIS MODULE WILL EXECUTE FOR ANY FIXED LENGTH MERGE
*        ONLY
*
IERADJ   CSECT
*
         USING *,R11               THIS MODULE BASE REG
         USING IERRDJ,R9           IERRDJ DSECT BASE REG
         USING IERRCA,R13          PPI BASE REG
*
IERMD34  LR    R11,R15             +00 NORMAL ENTRY
         B     ADJ4030
*
         L     R9,PPIDEB+4         ADDR OF IERRDJ
*
*        EOF REACHED ON GET - INDICATES NO RECORDS IN THAT FILE
*
         LH    R3,PPIMRGMX         DECREMENT MERGE ORDER BY 1
         SH    R3,K1
         STC   R3,PPIMRGMX+1
         BNP   ADJ4010             MERGE ORDER ZERO ? YES, BRANCH
         BCT   R4,ADJ4070          NO, DECREMENT COUNTER AND BRANCH TO
*                                  PRIME NEXT AREA
         B     ADJ4050             IF COUNTER = 0, BRANCH TO END OF MOD
*
*        ZERO INPUT FILES
*
ADJ4010  L     R14,WROSAV
         BR    R14                 RETURN TO IERRC9
*
*        NORMAL ENTRY TO MODULE
*
ADJ4030  NI    IERMD34+3,X'0F'     NOP NORMAL ENTRY
         ST    R11,PPIPSVA         SAVE THIS MODULE BASE FOR END OF
*                                  FILE RTN
         ST    R14,WROSAV          SAVE RETURN TO IERRC9
         L     R9,PPIDEB+4         LOAD IERRDJ DSECT BASE REG
         L     R7,PPISTDCB         SET DCB TABLE ADDR IN RUNNING PROG
         ST    R7,KADCBTAB
         L     R8,KINCR            INITIALIZE INCR
         LH    R4,PPIMRGMX         SET R4 = MAX MERGE ORDER
         LA    R6,PPIPDWA          SET R6 = PRIME AREA ADDR
ADJ4040  LA    R7,4(,R7)           INCR R7 TO NEXT DCB ADDR IN DCBTAB
         L     R5,0(,R7)           R5 -> DCB
*
         GET   (R5)                ON RETURN R1 -> NEXT RECORD
*
         AR    R1,R8               ADD INCREMENT TO HO BYTE OF NEW RCD
         ST    R1,0(,R6)           STORE RCD ADDR IN PRIME AREA
         BCT   R4,ADJ4060          DECREMENT MERGE ORDER BY 1
*                                  DOES IT = 0 ? NO, BRANCH
ADJ4050  PPISETON PPIPEOF          SET SW TO INDICATE RUNNING PROGRAM
         L     R14,WROSAV
         BR    R14                 RETURN TO IERRC9
*
ADJ4060  LA    R6,4(,R6)           INCREMENT PRIME AREA POINTER
ADJ4070  A     R8,KINCR            ADD 4 TO INCR
         B     ADJ4040
*
*        CONSTANTS
*
         DC    0F'0'
KINCR    DC    X'04000000'
K1       DC    X'0001'
*
*        WORK AREAS
*
WROSAV   DC    F'0'
*
*        IERRDJ
*
IERRDJ   DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRDJ SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRDJI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERADL   0101-20211-20211-1200-00147-00147-00000-RELEASE 00
ADL      TITLE 'IERADL - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERADL
*
*        MODULE FUNCTION/OPERATION -
*        ASSIGNMENT MODULE TO ALLOCATE AREA IN GENERATED STORAGE
*        TO ALLOW IERRDL TO INSERT ADDRESSES OF INPUT BUFFERS IN
*        PROPER POSITIONS IN THE TABLE. THIS MODULE TESTS
*        WHETHER TAPE OR DISK SORT AND OVERLAYS THE IERRDL
*        INSTRUCTIONS WHERE NECESSARY. THE ASSIGNMENT PROGRAM
*        UTILIZES THE DISK SORT ROUTINE FOR THE FORWARD BLOCK
*        TAPE SORT
*
*        MODULES IN WHICH THIS MODULE APPEARS AS A DSECT N/A
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                       CALLING SEQUENCE -
*                       BALR R14,R15
*
*        INPUT - PPI FIELDS REFERENCED - PPISPGN1
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPIBDSVA    PPISRTBL
*        PPIRCDL2    PPILABO3
*        PPISPGN1+3  PPICNTL - PPITAPE
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS -
*        IERRDLD - DUMMY MODULE
*        IERRCA  - PPI MODULE
*
*        EXITS - NORMAL - EXIT TO IERRC9
*                         CALLING SEQUENCE -
*                             BR R14
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS -
*        PPIBDSVA - NUMBER OF WORK UNITS
*
*        NOTES - NONE
*
IERADL   CSECT
*
         USING *,R11               MODULE BASE REG LOADED EXTERNALLY
         USING IERRDL,R10
         USING IERRCA,R13          ADDR OF PPI
*
         LR    R11,R15             LOAD MODULE BASE REG
         L     R10,PPIDEB2+4       R10 -> IERRDL
*
*        INSURE STARTING ADDR OF AVAILABLE STORAGE IS  ON FULL WORD
*        BOUNDARY
*
         NI    PPISPGN1+3,X'FC'    ROUND DOWN TO FULL WORD
         L     R4,PPISPGN1
*
*        RESERVE AREA IN GENERATED STORAGE FOR BUFFER ADDR TABLE
*
         SR    R7,R7
         IC    R7,PPIBDSVA         TOTAL NO OF WORK UNITS IN FIRST BYTE
         SLL   R7,2                MULT BY 4
         LA    R7,4(,R7)           EQUALS TOTAL NO OF BYTES TO RESERVE
         SR    R4,R7               DECR STARTING ADDR OF GENERATED STOR
         ST    R4,PPISPGN1         STORE UPDATED ADDR IN PPI
         STCM  R4,B'0111',PPIBDSVA+1  STORE IN PPI FOR OTHER MODS AS
*                                  STARTING ADDR OF BUFFER ADDR TABLE
         PPITEST  PPITAPE          TAPE SORT ?
         BZ    ADLDIRAC            NO, GOTO DASD PROCESSING
         PPITEST  PPIREADF         YES, FORWARD READ OPTION ON ?
         BZ    ADTAPE              OFF, BRANCH TO TAPE SORT ROUTINE
*
*        DISK SORT RTN
*
ADLDIRAC PPITEST  PPIFIX           FIXED LENGTH RECORDS ?
         BO    ADNOP               YES, BRANCH TO NOP RP INSTR
ADOVLAY  MVC   RDOVLAY,KONSTANT    OVERLAY BRANCH INSTR IN RP
         PPITEST  PPI2314          CRCX SORT ?
         BZR   R14                 NO, RETURN
         MVI   KFOUR+1,X'0C'       ADJUST CONSTANTS TO INCLUDE 8 BYTE
         LH    R4,KEIGHT
         LA    R4,8(,R4)           CHAIN DISK ADDR IN BUFFER
         STH   R4,KEIGHT
*
*        INTERFACE FOR NEXT ASSIGNMENT RTN
*
ADIERAGG BR    R14                 RETURN TO IERRC9
*
ADNOP    MVC   RDDISKV(2),KNOP     NOP VARIABLE LENGTH INSTR IN RP
         MVC   KEIGHT,KFOUR        OVERLAY CONSTANT IN IERRDL
         B     ADOVLAY
*
*        TAPE SORT RTN
*
ADTAPE   MVI   RDBRDISK+1,X'00'    NOP THE BR TO TAPE RTN IN RP
         PPITEST  PPIFIX           FIXED LENGTH RECORDS ?
         BO    ADTAPEFX            YES, SET CONSTANT FOR FIX LEN RCDS
         MVI   RDBRFIXL+1,X'00'    NOP THE BR TO FIXED LGTH RTN IN RP
         B     ADIERAGG            BRANCH TO INTERFACE
*
ADTAPEFX LH    R4,PPISRTBL         OBTAIN POSSIBLE ROUND OFF BYTES
         MH    R4,PPIRCDL2         OF CALC PPI BUFFER SIZE TO
         LA    R4,4(,R4)           (EOS FOUR BYTES)
         PPITEST  PPIOSC           OSCILLATING SORT ?
         BZ    ADLLAB03            USE PPILAB03 FOR BALANCED/POLYPHASE
         LH    R7,PPILAB07+2       USE PPILAB07 FOR OSCILLATING SORT
         B     ADLHERE
*
ADLLAB03 LH    R7,PPILAB03+2       USE IN CALC END OF BUFFER FOR READ
ADLHERE  SR    R7,R4               BACKWARDS
         STH   R7,KBYTES
         B     ADIERAGG
*
*        CONSTANTS
*
KNOP     DC    X'4700'
*
         DROP  R10
         USING IERRDL,R11
KONSTANT B     RDDISK
         USING IERADL,R11
         USING IERRDL,R10
*
*        IERRDL
*
IERRDL   DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRDL SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRDLI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERADM   0101-20211-20211-1200-00099-00099-00000-RELEASE 00
ADM      TITLE 'IERADM - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERADM
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 1 ASSIGNMENT - SKIP OPTION
*        THIS IS THE LAST ASSIGNMENT PROGRAM TO BE EXECUTED IN
*        PHASE 1. IT IS USED WHEN THE USER WISHES SORT TO SKIP A
*        DESIGNATED NUMBER OF INPUT RECORDS BEFORE STARTING TO
*        SORT THE INPUT FILE. THE USER SPECIFIES SUCH ON THE SORT
*        CONTROL STMTS. THE ROUTINE USES THE QSAM GET MACRO IN
*        LOCATE MODE IF UNSPANNED RECORDS AND MOVE MODE IF
*        SPANNED VARIABLE LENGTH RECORDS
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACROS USED -
*        GET
*        SMPPI
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                          LOAD  EP=IERADM,DCB=SORTLIB
*                          LR    R15,R0
*                          BALR  R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIBDSVA   PPIBINSZ
*        PPISKPRD   PPISTDCB
*        PPICNTL
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPIBDSVA - IF THERE IS DATA CHAINING
*
*        EXTERNAL ROUTINES - QSAM GET
*
*        EXTERNAL PARAMETERS - INPUT FILE'S DCB ADDR
*
*        EXITS - NORMAL - RETURN TO IERRC9 VIA R14
*
*        EXITS - ERROR - NONE
*
*        NOTES THIS MODULE IS ONLY APPLICABLE IF THE SKIP OPTION
*        IS SPECIFIED ON THE CONTROL CARDS
*
IERADM   CSECT
*
         USING *,R11
         USING IERRCA,R13
*
         LR    R11,R15
         ICM   R3,B'1111',PPISKPRD  SKIP OPTION ACTIVE ?
         BZR   R14                 NO, RETURN TO IERRC9
         ST    R14,SAVER14         SAVE RETURN REGISTER
         L     R4,PPISTDCB
         L     R4,0(,R4)           R4 -> DCB
         PPITEST  PPIMVSI          VBS INPUT RECORDS ?
         BO    ADMSK025            YES, BRANCH
         PPITEST  PPINODCI         DATA CHAINING SORT INPUT ?
         BO    ADMDC030            YES, BRANCH
*
ADMSK020 GET   (R4)
*
         BCT   R3,ADMSK020         LOOP TO FLUSH RECORDS
ADMSK023 L     R14,SAVER14
         SR    R15,R15
         BR    R14                 RETURN TO IERRC9
*
ADMSK025 L     R5,PPIGETMN         CALCULATE WORKAREA ADDR FOR
         L     R0,12(,R5)          QSAM GET IN MOVE MODE
*
         GET   (4),(0)
*
         BCT   R3,ADMSK025         LOOP
         B     ADMSK023            BRANCH TO RETURN TO IERRC9
*
ADMDC030 L     R5,PPIBDSVA         OBTAIN FIRST RSA ADDR TO BE EXCHGED
*
ADMDC040 GET   (R4),(R5)
*
         LR    R5,R1
         BCT   R3,ADMDC040         LOOP TO FLUSH RECORDS
         L     R5,PPIBDSVA         UPDATE PPIA POINTER TO RSA, FOR
         A     R5,PPIBINSZ         INITIAL ONE MAY BE VALID (IE IN THE
         ST    R5,PPIBDSVA         CCW LIST WAITING TO BE PROCESSED)
         SR    R15,R15
         L     R14,SAVER14
         BR    R14                 RETURN TO IERRC9
*
SAVER14  DC    F'0'                RETURN ADDR
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERADP   0101-20211-20211-1200-00148-00148-00000-RELEASE 00
ADP      TITLE 'IERADP - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERADP
*
*        MODULE FUNCTION -
*        OSCL/CRCX SORT PHASE ASSIGNMENT - FIXED LENGTH W/O USER
*        EXIT E15
*        THE FUNCTION OF THIS MODULE IS TO BUILD A TABLE OF RSA
*        ADDRESSES WITH THEIR RESPECTIVE AREA BYTE COUNTS IN
*        IERRDB. THE TABLE IS NEEDED BECAUSE RECORD STORAGE AREA
*        MAY NOT BE CONTIGUOUS. THIS MODULE ALSO BUILDS THE INPUT
*        BUFFERS USING THE BUILDS MACRO. IT ALSO OBTAINS THE
*        ADDRESS OF THE INPUT DCB AND PUTS IT IN THE RUNNING
*        PROGRAM IERRDB
*
*        IERADB INSERTS THE RECORD LENGTH OF THE FIXED LENGTH
*        RECORD WHICH MUST BE LESS THAN OR EQUAL TO 256 BYTES IN
*        IERRDB MOVE INSTRUCTION
*
*        IF THE CRCX SORTING TECHNIQUE IS BEING USED THE RMAX
*        CHECK IN RP IS OVERLAYED IE RDP1035 BECOMES
*        UNCONDITIONAL BRANCH TO RDP1030-2
*
*        MODULES IN WHICH THIS MODULE APPEARS AS A DSECT - NONE
*
*        MACROS USED BY MODULE -
*        SMPPI
*        BUILDS
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                       CALLING SEQUENCE -
*                           LOAD EP=IERADB,DCB=SORTLIB
*                           LR   R15,R0
*                           BALR R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIDEB     PPISTDCB
*        PPILAB08   PPIRCDL1
*        PPILAB03   PPILEXFF
*        PPILAB02
*        INFO IS NEEDED TO BUILD THE RSA TABLE IN IERRDB AND TO
*        BUILD THE INPUT BUFFERS
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED - PPICNTL
*
*        EXTERNAL ROUTINES - NONE
*
*        EXTERNAL PARAMETERS - SEE REGISTERS
*
*        EXITS - NORMAL - EXIT TO IERRC9
*                         CALLING SEQUENCE -
*                             BR  R14  RETURN
*
*        EXITS - ERROR - NONE
*
*        NOTES -
*        THIS MODULE WILL EXECUTE FOR ANY FIXED LENGTH SORT
*        WITHOUT EXIT E15 AND E16. THE FIXED LENGTH INPUT RECORD
*        LENGTH MUST BE =< 256 BYTES
*
IERADP   CSECT
*
         USING *,R11               MODULE BASE REG
         USING IERRDP,R10
         USING IERRCA,R13
*
IERMDA   LR    R11,R15             SET THIS MODULE BASE REGISTER
         L     R10,PPIDEB+4        SET IERRDB DSECT BASE REGISTER
*
*        ESTABLISH ALL RECORD STORAGE AREA ADDR AND THEIR
*        RESPECTIVE BYTE COUNTS AND BUILD RSA TABLE IN IERRDB
*
         L     R2,PPILAB08         PTR TO TABLE OF RSA ADDR WITH
         ST    R2,ADCONPTR         THEIR RESPECTIVE BYTE COUNTS
         SR    R3,R3
         SR    R6,R6
         IC    R3,PPILAB08         NO OF RSA AREAS
         LA    R7,4                4 BYTES FOR TREE ADDR
         AH    R7,PPILEXFF         PLUS SIZE OF ROUNDED EXTRACTED
*                                  CONTROL FIELDS
         L     R5,PPILAB08         PTR TO TABLE OF RSA ADDR WITH THEIR
*                                  RESPECTIVE BYTE COUNTS
ADPRSALP L     R4,0(R6,R5)         STARTING ADDR OF AN RSA AREA
         AR    R4,R7               ADDR OF FIRST RCD IN THIS RSA AREA
         ST    R4,0(R6,R2)         STORE IN IERRDB RSA ADDR TABLE
         L     R4,4(R6,R5)         BYTE COUNT OF THIS RSA AREA
         S     R4,PPIBINSZ         SUBTRACT LENGTH OF FIRST RECORD
         ST    R4,4(R6,R2)         STORE IN IERRDB RSA ADDR TABLE
         LA    R6,8(,R6)           UPDATE INDEX PTR
         BCT   R3,ADPRSALP         DECR RSA CTR LOOP IF MORE RSA AREAS
         MVC   WADDRSA(8),0(R2)    MOVE PARMS INTO RUNNING PROGRAM
*
*        INSERT INPUT DCB ADDR AND RECORD LENGTH IN IERRDB
*        BUILD INPUT BUFFERS
*
         L     R6,PPISTDCB         SET INPUT DCB ADDR IN RUNNING PROG
         L     R4,0(,R6)
         ST    R4,KADCB
         LH    R8,PPIRCDL1         SET RCD LENGTH - 1 IN INLINE
         BCTR  R8,0                MOVE INSTR IN RUNNING PROG
         STC   R8,RDP1030+1
         L     R1,PPILAB02         R1 -> BUFFER LIST
         LH    R0,PPILAB03+2        L'INPUT BUFFERS
         ICM   R0,B'0100',PPILAB03  NO OF INPUT BUFFERS
*                                  IN R0
         BUILDS (1),(0)
*
*        SET USER EOF SWITCH IN PPI, SINCE THERE IS NO USER EXIT
*
         PPISETON PPIUEOF
*
*        IF 2314 SORT OVERLAY RMAX CHECK IN RP
*        RETURN TO IERRC9
*
         PPITEST  PPI2314          2314 SORT ?
         BZR   R14                 NO, RETURN TO IERRC9
         MVC   RDP1035(4),KADPKON  OVERLAY RMAX CHECK
         BR    R14                 RETURN
*
*        CONSTANTS
*
         DROP  R11
         DROP  R10
*
         USING IERRDP,R11
KADPKON  B     RDP1030-2           OVERLAY RMAX CHECK
*
*        IERRDP
*
IERRDP   DSECT                     DUMMY RUNNING PROGRAM
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRDP SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRDPI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERADQ   0101-20211-20211-1200-00135-00135-00000-RELEASE 00
ADQ      TITLE 'IERADQ - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERADQ
*
*        MODULE FUNCTION -
*        OSCL/CRCX SORT PHASE ASSIGNMENT - FIXED LENGTH WITHOUT
*        USER EXIT E15
*        THE FUNCTION OF THIS MODULE IS TO BUILD A TABLE OF RSA
*        ADDRESSES WITH THEIR RESPECTIVE AREA BYTE COUNTS IN
*        IERRDC. THE TABLE IS NEEDED BECAUSE RECORD STORAGE AREA
*        MAY NOT BE CONTIGUOUS. THIS MODULE ALSO BUILDS THE INPUT
*        BUFFERS USING THE BUILD MACRO. IT ALSO OBTAINS THE
*        ADDRESS OF THE INPUT DCB AND PUTS IT IN THE RUNNING
*        PROGRAM IERRDC
*
*        MODULES IN WHICH THIS MODULE APPEARS AS A DSECT - NONE
*
*
*        MACROS USED BY MODULE -
*        SMPPI
*        BUILDS
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                       CALLING SEQUENCE -
*                           LOAD EP=IERADC,DCB=SORTLIB
*                           LR   R15,R0
*                           BALR R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIDEB     PPILAB08
*        PPILAB03   PPILEXFF
*        PPILAB02   PPISTDCB
*        INFO IS NEEDED TO BUILD THE RSA TABLE IN IERRDC AND TO
*        BUILD THE INPUT BUFFERS
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED - PPICNTL
*
*        EXTERNAL ROUTINES - NONE
*
*        EXTERNAL PARAMETERS - SEE REGISTERS
*
*        EXITS - NORMAL - EXIT TO IERRC9
*                         CALLING SEQUENCE -
*                             BR   R14      RETURN
*
*        EXITS - ERROR - NONE
*
*        NOTES -
*        THIS MODULE WILL EXECUTE FOR ANY FIXED LENGTH SORT
*        WITHOUT EXITS E15 AND E16. THE INPUT RCD MUST BE GREATER
*        THAN 256 BYTES
*
IERADQ   CSECT
*
         USING *,R11               MODULE BASE REGISTER
         USING IERRDQ,R10          BASE REG FOR RP DSECT
         USING IERRCA,R13          PPI BASE REG
*
IERMDA   LR    R11,R15             SET MODULE BASE REGISTER
         L     R10,PPIDEB+4        SET IERRDC DSECT BASE REGISTER
*
*        ESTABLISH ALL RECORD STORAGE AREA ADDR AND THEIR
*        RESPECTIVE BYTE COUNTS AND BUILD RSA TABLE IN IERRDB
*
         L     R2,PPILAB08         R2 -> TABLE OF RSA ADDR WITH
         ST    R2,ADCONPTR         THEIR RESPECTIVE BYTE COUNTS
         SR    R3,R3
         SR    R6,R6
         IC    R3,PPILAB08         NO OF RSA AREAS
         LA    R7,4                4 BYTES FOR TREE ADDR
         AH    R7,PPILEXFF         PLUS SIZE OF ROUNDED EXTRACTED
*                                  CONTROL FIELDS
         L     R5,PPILAB08         PTR TO TABLE OF RSA ADDR WITH THEIR
*                                  RESPECTIVE BYTE COUNTS
ADQRSALP L     R4,0(R6,R5)         STARTING ADDR OF AN RSA AREA
         AR    R4,R7               EQLS ADDR OF 1ST RCD IN THE RSA AREA
         ST    R4,0(R6,R2)         STORE IN IERRDC RSA ADDR TABLE
         L     R4,4(R6,R5)         BYTE COUNT OF THIS RSA AREA
         S     R4,PPIBINSZ         SUBTRACT LENGTH OF FIRST RECORD
         ST    R4,4(R6,R2)         STORE IN IERRDC RSA ADDR TABLE
         LA    R6,8(,R6)           UPDATE INDEX REG
         BCT   R3,ADQRSALP         DECR RSA CTR, LOOP IF MORE RSA AREAS
         MVC   WADDRSA(8),0(R2)    MOVE PARMS INTO RUNNING PROGRAM
*
*        INSERT INPUT DCB ADDR IN IERRDC
*        BUILD INPUT BUFFERS
*
         L     R6,PPISTDCB         SET INPUT DCB ADDR IN RUN PROG
         L     R4,0(,R6)
         ST    R4,KADCB
         L     R1,PPILAB02         R1 -> BUFFER LIST
         LH    R0,PPILAB03+2        L'INPUT BUFFERS
         ICM   R0,B'0100',PPILAB03  NO OF INPUT BUFFERS
*
         BUILDS (1),(0)
*
*        SET USER EOF SWITCH IN PPI, SINCE THERE IS NO USER EXIT
*
         PPISETON PPIUEOF
*
*        IF CRCX, OVERLAY RMAX CHECK IN RP - RETURN TO IERRC9
*
         PPITEST  PPI2314          2314 SORT ?
         BZR   R14                 NO, RETURN TO IERRC9
         MVC   RDQ1035(4),KADQKON  YES, OVERLAY RMAX CHECK
         BR    R14                 RETURN
*
*        CONSTANTS
*
         DROP  R10
         DROP  R11
         USING IERRDQ,R11
KADQKON  B     RDQ1038             OVERLAY RMAX CHECK
*
*        IERRDQ
*
IERRDQ   DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRDQ SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRDQI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERADR   0101-20211-20211-1200-00166-00166-00000-RELEASE 00
ADR      TITLE 'IERADR - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERADR
*
*        MODULE FUNCTION -
*        OSCL/CRCX SORT PHASE DEBLOCK ASSIGNMENT FOR FIXED
*        LENGTH RECORDS WITH E15 AND/OR E16
*        THE FUNCTION OF THIS MODULE IS TO INITIALIZE A RECORD
*        STORAGE AREA TABLE IN IERRDR. THIS TABLE WOULD CONSIST
*        OF UP TO 5 ENTRIES FOR 5 NONCONTIGUOUS RSA'S. THIS
*        MODULE BUILDS THE INPUT BUFFER(S) IT ALSO CHECKS TO SEE
*        IF THE SORT IS ATTACHED, IF E15 AND E16 ARE ACTIVATED
*        AND OVERLAYS IERRDR IN APPROPRIATE PLACES. IT ALSO
*        PASSES IERRDR THE STARTING ADDRESS OF THE INPUT DCB
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - NONE
*
*        MACROS USED BY MODULE -
*        SMPPI
*        BUILDS
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                       CALLING SEQUENCE -
*                           LOAD EP=IERADD,DCB=SORTLIB
*                           LR   R15,R0
*                           BALR R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIDEB     PPILAB08
*        PPINMAX    PPILAB03
*        PPILEXFF   PPIATP1E
*        PPILAB02   PPISTDCB
*        INFO IS NEEDED TO BUILD RSA TABLE IN IERRDR, TO BUILD
*        THE INPUT BUFFER(S) TO SEE WHAT USER EXITS ARE ACTIVATED
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED - PPICNTL
*
*        EXTERNAL ROUTINES - NONE
*
*        EXTERNAL PARAMETERS - SEE REGISTERS
*
*        EXITS - NORMAL - EXIT TO IERRC9
*                         CALLING SEQUENCE -
*                             BR   R14        RETURN
*
*        EXITS - ERROR - NONE
*
*        NOTES -
*        THIS MODULE WILL EXECUTE FOR ANY FIXED LENGTH SORT
*        HAVING USER EXITS E15 AND/OR E16, OR ATTACHED. IT IS
*        USED IN THE OSCILLATING OR CRCX SORT
*
IERADR   CSECT
*
         USING *,R11               MODULE BASE REGISTER
         USING IERRDR,R10          BASE REG FOR RP DSECT
         USING IERRCA,R13          PPI BASE REG
*
IERMDA   LR    R11,R15
         L     R10,PPIDEB+4
*
*        ESTABLISH ALL RECORD STORAGE AREA ADDR AND THEIR
*        RESPECTIVE BYTE COUNTS AND BUILD RSA TABLE IN IERRDR
*
         L     R2,PPILAB08         PTR TO TABLE OF RSA ADDR WITH
         ST    R2,ADCONPTR         THEIR RESPECTIVE BYTE COUNTS
         SR    R3,R3
         SR    R6,R6
         IC    R3,PPILAB08         NO OF RSA AREAS
         LA    R7,4                4 BYTES FOR TREE ADDR
         AH    R7,PPILEXFF         PLUS SIZE OF ROUNDED EXTRACTED
*                                  CONTROL FIELDS
         L     R5,PPILAB08         PTR TO TABLE OF RSA ADDR WITH THEIR
*                                  RESPECTIVE BYTE COUNTS
ADDRSALP L     R4,0(R6,R5)         STARTING ADDR OF AN RSA AREA
         AR    R4,R7               EQLS ADDR OF 1ST RCD IN THE RSA AREA
         ST    R4,0(R6,R2)         STORE IN IERRDR RSA ADDR TABLE
         L     R4,4(R6,R5)         BYTE COUNT OF THIS RSA AREA
         ST    R4,4(R6,R2)         STORE IN IERRDR RSA ADDR TABLE
         LA    R6,8(,R6)           UPDATE INDEX REG
         BCT   R3,ADDRSALP         DECR RSA CTR, LOOP IF MORE RSA AREAS
         MVC   WADDRSA(8),0(R2)    INITIALIZE PARAMETERS IN RUNNING PGM
         ICM   R0,B'1111',PPIATP1E  ATTACHED EXIT ?
         BNZ   ADBYPSB             YES, BYPASS BUILD MACRO
*
*        SET UP AND BUILD THE INPUT BUFFER(S)
*
         L     R1,PPILAB02         R1 -> BUFFER LIST
         LH    R0,PPILAB03+2        L'INPUT BUFFERS
         ICM   R0,B'0100',PPILAB03  NO OF INPUT BUFFERS
*
         BUILDS (1),(0)            BUILD INPUT BUFFER(S)
*
*        CALCULATE ADDR OF DCB AND STORE IN RP
*
ADBYPSB  L     R4,PPISTDCB         POINTER TO LIST OF DCB ADDR
         MVC   WDCB,0(R4)          STORE DCB ADDR IN RP
         PPITEST  PPIME16          NMAX E16 EXIT ACTIVE ?
         BO    ADSTONMX            YES, BRANCH TO STORE NMAX IN RP
         MVC   RDTSTNMX(4),K3      OVERLAY NMAX TEST, INSERT RTN OF RP
         MVC   RDOVLAY4(4),K4      OVERLAY NMAX TEST, DO NOTHG, ETC RP
ADTSTATT ICM   R0,B'1111',PPIATP1E  ATTACHED EXIT ?
         BNZ   ADATTEXT            YES, BRANCH TO ATTACH EXIT RTN
         PPITEST  PPIME15          USER EXIT E15 ACTIVE ?
         BO    ADENDMOD            YES, BRANCH TO LINK TO NEXT RTN
         MVC   RDUSREXT,RDOVLAY4   OVERLAY USER EXIT E15 WITH A BRANCH
*                                  TO DO NOTHING RTN IN RP
         PPISETON PPIUEOF          SET USER EXIT E15 EOF SWITCH IN PPI
*
*        IF CRCX, OVERLAY RMAX CHECK IN RP
*        RETURN TO IERRC9
*
ADENDMOD PPITEST  PPI2314          CRCX SORT ?
         BZR   R14                 NO, RETURN TO IERRC9
         MVC   RDRMXCNT(4),KADRKON OVERLAY RMAX CHECK
         BR    R14                 RETURN TO IERRC9
*
ADATTEXT ST    R0,PPIX15+4         RP EXIT E15 NOW LINKS TO ATTACH RTN
         MVC   RDTSTISW(4),K5      OVERLAY INSERT SWITCH TEST IN RP
         PPISETON PPIPEOF          SET SYSTEM EOF SWITCH IN PPI
         MVI   REALEOF,X'01'       SET SWITCH TO INDICATE REST OF
*                                  EOF'S ARE SIMULATED
         B     ADENDMOD            RETURN TO LOAD MODULE
*
ADSTONMX L     R4,PPINMAX          LOAD NMAX
         LA    R4,1(,R4)           EQUALS NMAX + 1 (TO ALLOW BCT INSTR
*                                  IN RP TO DECR NMAX CTR)
         ST    R4,WNMAX            STORE IN RP
         B     ADTSTATT            BRANCH TO TEST IF ATTACHED
*
         DROP  R11
         DROP  R10
*
         USING IERRDR,R11
KADRKON  B     RDOVLAY5            BYPASS RMAX CHECK
*
*        IERRDR
*
IERRDR   DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRDR SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRDRI
*
*        MODULE NAME - IERRMA
*
*        THIS MODULE CONTAINS ALL OF THE MESSAGES THAT ARE
*        REQUIRED FOR PHASE 1 RUNNING PROGRAM
*
IERRMA   DSECT
*
         COPY  RMAMAIN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERADS   0101-20211-20211-1200-00206-00206-00000-RELEASE 00
ADS      TITLE 'IERADS - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERADS
*
*        MODULE FUNCTION -
*        OSCL/CRCX SORT PHASE DEBLOCK ASSIGNMENT FOR VARIABLE LENGTH
*        RECORDS WITH E15 AND/OR E16
*        THE FUNCTION OF THIS MODULE IS TO CALCULATE THE NUMBER
*        OF BINS IN UP TO 5 NONCONTIGUOUS RECORD STORAGE AREAS
*        AND CHAIN ALL THESE BINS TOGETHER. IT PUTS THE ADDRESS
*        OF THE FIRST BIN IN THE FIRST RSA IN AVAIL (PPIBDSVA+4).
*        INPUT BUFFERS ARE SET UP VIA THE BUILD MACRO. EXTRACT
*        SIZE + 4 IS CALCULATED AND STORED IN THE RUNNING
*        PROGRAM. EXITS E15 AND E16 ARE TESTED AND A TEST IS MADE
*        TO SEE IF SORT HAS BEEN ATTACHED. AS A RESULT OF THESE
*        TESTS PROPER OVERLAYS WILL BE MADE AND NMAX+1 MAY BE
*        STORED IN RUNNING PROGRAM IERRDS
*
*        THE OPERATION OF THIS MODULE DOES NOT DEPEND UPON A
*        PARTICULAR INTERNAL REPRESENTATION OF THE EXTERNAL
*        CHARACTER SET
*
*        MODULES IN WHICH THIS MODULE APPEARS AS A DSECT - NONE
*
*        MACROS USED BY MODULE -
*        SMPPI
*        BUILDS
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                       CALLING SEQUENCE -
*                           LOAD EP=IERADS,DCB=SORTLIB
*                           LR   R15,R0
*                           BALR R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPINMAX    PPILAB03
*        PPICNTL    PPIBINSZ
*        PPILAB02   PPILEXFF
*        PPIATPIE   PPILAB08
*        ADDRESSES FOR BUFFERS AND TABLES, INFO FOR USER EXITS
*        AND FOR THE RSA CHAINING ROUTINE AND FOR THE BUILD MACRO
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPIBDSVA   PPICNTL
*        INITIALIZE START OF RSA (AVAIL) AND TOTAL NUMBER OF
*        BINS IN ALL THE RSA'S
*
*        EXTERNAL ROUTINES - NONE
*
*        EXTERNAL PARAMETERS - SEE REGISTERS
*
*        EXITS - NORMAL - EXIT TO IERRC9
*                         CALLING SEQUENCE -
*                             BR   R14        RETURN
*
*        EXITS - ERROR - NONE
*
*        NOTES -
*        THIS MODULE IS THE ASSIGNMENT ROUTINE FOR THE
*        OSCILLATING/CRCX SORT PHASE DEBLOCK ROUTINE FOR VARIABLE
*        LENGTH RECORDS WITH USER MODIFICATION EXITS E15 AND/OR
*        E16
*
IERADS   CSECT
*
         USING *,R11               MODULE BASE REGISTER
         USING IERRDS,R10          IERRDS DSECT BASE REGISTER
         USING IERRCA,R13          PPI ADDR
*
IERMDA   LR    R11,R15             ESTABLISH THIS MODULE BASE REGISTER
         L     R10,PPIDEB+4        ADDR OF IERRDS CSECT
*
*        CHAIN ALL BINS TOGETHER BY PUTTING IN EACH BIN THE ADDR
*        OF THE NEXT AVAILABLE BIN. SAVE THE ADDR OF THE FIRST
*        AVAILABLE BIN IN PPIBDSVA+4, AND THE TOTAL NO OF
*        AVAILABLE BINS IN PPIBDSVA+8
*
         SR    R3,R3
         IC    R3,PPILAB08         NO OF RSA AREAS
         L     R7,PPILAB08         PTR TO RSA TABLE IN PPI
         L     R6,0(,R7)           ADDR OF THIS RSA AREA BIN
         ST    R6,PPIBDSVA+4       SAVE THIS ADDR IN AVAIL (FOR IERRDS)
ADSLOOPO L     R5,4(,R7)           NO OF BYTES IN THIS RSA AREA
         LA    R8,ADSLOOPI         LOAD RETURN REG FOR THIS LOOP CALC
         SR    R4,R4
         D     R4,PPIBINSZ         R4 = NO OF BINS IN THIS RSA AREA
         L     R4,PPIBDSVA+8       TOTAL NO OF BINS IN ALL RSA'S SO FAR
         AR    R4,R5               UPDATE BIN COUNT
         ST    R4,PPIBDSVA+8       SAVE UPDATED BIN COUNT
ADSLOOPI BCT   R5,ADSCHAIN         DECR NO OF BINS CTR FOR THIS RSA
*                                  BRANCH IF MORE BINS IN THIS RSA
         BCT   R3,ADNXTRSA         DECR NO OF RSA'S CTR BR IF MORE
*                                  RSA'S THE LAST BIN IN THE LAST
*                                  RSA HAS NO CHAIN ADDR
         ICM   R15,B'1111',PPIATP1E  SORT ATTACHED ?
         BNZ   ADSNOBLD            YES, DON'T BUILD BUFFERS
         LH    R0,PPILAB03+2        L'INPUT BUFFERS
         ICM   R0,B'0100',PPILAB03  NO OF INPUT BUFFERS
         L     R1,PPILAB02         R1 -> BUFFER LIST
*
         BUILDS (1),(0)
*
ADSNOBLD LH    R4,PPILEXFF         GET EXTRACT SIZE
         A     R4,KFOUR
         STH   R4,EXPLFOUR         STORE EXTRACT SIZE + 4
         PPITEST  PPIME16          NMAX EXIT E16 ACTIVE ?
         BO    ADSSTNM             YES, GO STORE NMAX IN RP
         MVC   RDSMAXCK(4),K2      OVERLAY NMAX TEST IN INSERT LEG
         MVC   RDSDONO(4),K3       OVERLAY NMAX TEST IN ALTER LEG
ADSTATT  ICM   R15,B'1111',PPIATP1E  SORT ATTACHED ?
         BNZ   ADSATACH            YES, BRANCH
         PPITEST  PPIME15          USER EXIT MOD E15 ACTIVE ?
         BO    ADSEXIT             YES, BRANCH
         MVC   RDSUEXIT(4),K4      OVERLAY USER EXIT E15 WITH A BRANCH
         MVC   RDSMSG,K7
         PPISETON PPIUEOF          SET USER EXIT E15 EOF SWITCH IN PPI
         MVI   RDSISWON,X'58'      CHANGE INSTRUCTION TO L R1,ADRHOLD
ADSEXIT  L     R4,PPISTDCB         DCB ADDR
         L     R4,0(,R4)
         ST    R4,KAWORK+4         STORE IN RP WORK AREA
         PPITEST  PPIMVSI          VBS INPUT ?
         BZ    ADSRETUR            NO BRANCH
         L     R4,PPIGETMN         ADDR OF GETMAIN TABLE OF ADDR
         L     R4,12(,R4)          FETCH ADDR OF VBS WORK AREA
         ST    R4,KAWORK           STORE IN RP WORK AREA
*
*        IF CRCX, OVERLAY RMAX CHECK IN RP
*        RETURN TO IERRC9
*
ADSRETUR PPITEST  PPI2314          CRCX SORT ?
         BZR   R14                 NO, RETURN TO IERRC9
         MVC   RDSRMAX(4),KADSKON  OVERLAY RMAX CHECK
         BR    R14                 RETURN TO IERRC9
*
ADSSTNM  L     R4,PPINMAX          LOAD NMAX
         LA    R4,1(,R4)           PLUS 1 (FOR USING BCT INSTRUCTION)
         ST    R4,WNMAX            STORE IN RP
         B     ADSTATT             GO TEST FOR ATTACHED
*
ADSATACH ST    R15,PPIX15+4        E15 NOW IS ATTACHED
         MVC   RDSNORM(4),K5       OVERLAY INSRT SW TEST BR ARND GET
         PPISETON PPIPEOF          SET SYSTEM EOF SWITCH IN PPI
         MVI   REALEOF,X'01'       SET SWITCH TO INDICATE REST OF
*                                  EOF'S ARE SIMULATED
         B     ADSEXIT             RETURN TO LOAD MODULE
*
ADNXTRSA LA    R8,ADSREAL          RESET RETURN REG FOR THIS LOOP
*
*        INSERT CHAIN ADDR IN EACH BIN OF EACH RSA EXCEPT THE
*        LAST BIN OF THE LAST RSA
*
ADSCHAIN A     R6,PPIBINSZ         ADDR OF THIS BIN + BIN SIZE
         LR    R4,R6               SAVE ADDR OF THE NEXT BIN
         S     R4,KFOUR            PTS TO AREA IN PREVIOUS BIN TO PUT
*                                  THE CHAIN ADDR OF NEXT BIN(IN R6)
         ST    R6,0(0,R4)          PREVIOUS BIN NOW CHAINED TO NEXT BIN
         BR    R8                  BR TO ADELOOPI ON ALL BINS EXCEPT
*                                  THE LAST BIN IN EACH RSA ELSE
*                                  BRANCH TO ADEREAL ON THIS LAST BIN
*
*        OVERLAY LAST BIN CHAIN ADDR OF THIS RSA WITH PROPER ADDR
*        FIRST BIN ADDR OF NEXT RSA
*
ADSREAL  LA    R7,8(,R7)           UPDATE PPI RSA TABLE PTR TO NEXT
*                                  RSA ENTRY
         L     R6,0(,R7)           ADDR OF FIRST BIN IN NEXT RSA
         ST    R6,0(,R4)           STORE AS CHAIN ADDR IN LAST BIN OF
*                                  PREVIOUS RSA
         B     ADSLOOPO            BRANCH TO CHAIN BINS OF THIS RSA
*
         DROP  R11
         DROP  R10
*
         USING IERRDS,R11
KADSKON  B     RDSPTB              BYPASS RMAX CHECK
*
*        IERRDS
*
IERRDS   DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRDS SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRDSI
*
*        MODULE NAME - IERRMA
*
*        THIS MODULE CONTAINS ALL OF THE MESSAGES THAT ARE
*        REQUIRED FOR PHASE 1 RUNNING PROGRAM
*
IERRMA   DSECT
*
         COPY  RMAMAIN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERADT   0101-20211-20211-1200-00164-00164-00000-RELEASE 00
ADT      TITLE 'IERADT - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERADT
*
*        MODULE FUNCTION -
*        OSCILLATING/CRCX SORT PHASE DEBLOCK ASSIGNMENT FOR
*        VARIABLE LENGTH RECORDS WITHOUT USER EXITS
*        THE FUNCTION OF THIS MODULE IS TO CALCULATE THE NUMBER
*        OF BINS IN UP TO 5 NON-CONTIGUOUS RECORD STORAGE AREAS
*        AND CHAIN ALL THESE BINS TOGETHER. IT PUTS THE ADDRESS
*        OF THE FIRST BIN IN THE FIRST RSA IN AVAIL (PPIBDSVA+4).
*        INPUT BUFFERS ARE SET UP VIA THE BUILD MACRO. EXTRACT
*        SIZE+4 IS CALCULATED AND STORED IN IERRDT
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACROS USED -
*        BUILDS
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                       CALLING SEQUENCE -
*                           LOAD EP=IERADG,DCB=SORTLIB
*                           LR   R15,R0
*                           BALR R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIBINSZ   PPILAB08
*        PPILAB03   PPILEXFF
*        PPILAB02   PPICNTL
*        ADDRESSES FOR BUFFERS AND TABLES
*        THE RSA CHAINING ROUTINE
*        AND FOR THE BUILD MACRO
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPIBDSVA PPICNTL
*        INITIALIZE START OF RSA (AVAIL) AND TOTAL NUMBER OF
*        BINS IN ALL THE RSA'S
*
*        EXTERNAL ROUTINES - NONE
*
*        EXTERNAL PARAMETERS - SEE REGISTERS
*
*        EXITS - NORMAL - EXIT TO IERRC9
*                         CALLING SEQUENCE -
*                             BR   R14        RETURN
*
*        EXITS - ERROR - NONE
*
*        NOTES -
*        THIS MODULE IS AN ASSIGNMENT ROUTINE FOR THE OSCL OR
*        2314 SORT PHASE DEBLOCK ROUTINE FOR VARIABLE LENGTH
*        RECORDS WITHOUT USER EXITS
*
IERADT   CSECT
*
         USING *,R11               THIS MODULE BASE REGISTER
         USING IERRDT,R10          IERRDT DSECT BASE REGISTER
         USING IERRCA,R13          PPI ADDR
*
IERMDA   LR    R11,R15             ESTABLISH THIS MODULE BASE REGISTER
         L     R10,PPIDEB+4        ADDR OF IERRDT CSECT
*
*        CHAIN ALL BINS TOGETHER BY PUTTING IN EACH BIN THE ADDR
*        OF THE NEXT AVAILABLE BIN. SAVE THE ADDR OF THE FIRST
*        AVAILABLE BIN IN PPIBDSVA+4, AND THE TOTAL NO OF
*        AVAILABLE BINS IN PPIBDSVA+8
*
         SR    R3,R3
         IC    R3,PPILAB08         NO OF RSA AREAS
         L     R7,PPILAB08         PTR TO RSA TABLE IN PPI
         L     R6,0(,R7)           ADDR OF THIS RSA AREA BIN
         ST    R6,PPIBDSVA+4       SAVE THIS ADDR IN AVAIL (FOR IERRDT)
ADELOOPO L     R5,4(,R7)           NO OF BYTES IN THIS RSA AREA
         LA    R8,ADELOOPI         LOAD RETURN REG FOR THIS LOOP CALC
         SR    R4,R4
         D     R4,PPIBINSZ         R5 = NO OF BINS IN THIS RSA AREA
         L     R4,PPIBDSVA+8       TOTAL NO OF BINS IN ALL RSA'S SO FAR
         AR    R4,R5               UPDATE BIN COUNT
         ST    R4,PPIBDSVA+8       SAVE UPDATED BIN COUNT
ADELOOPI BCT   R5,ADECHAIN         DECR NO OF BINS CTR FOR THIS RSA
*                                  BRANCH IF MORE BINS IN THIS RSA
         BCT   R3,ADNXTRSA         DECR NO OF RSA'S CTR BRANCH IF MORE
*                                  RSA'S. THE LAST BIN IN THE LAST
*                                  RSA HAS NO CHAIN ADDR
         LH    R0,PPILAB03+2        L'INPUT BUFFERS
         ICM   R0,B'0100',PPILAB03  NO OF INPUT BUFFERS
         L     R1,PPILAB02         R1 -> BUFFER LIST
*
         BUILDS (1),(0)
*
         PPISETON PPIUEOF          SET USER EOF SWITCH IN PPI, NO EXIT
         LH    R4,PPILEXFF         GET EXTRACT SIZE
         A     R4,KFOUR
         STH   R4,EXPLFOUR         STORE EXTRACT SIZE + 4
ADTEXIT  L     R4,PPISTDCB         DCB ADDR
         L     R4,0(R4)
         ST    R4,KAWORK+4         STORE IN IERRDT WORD AREA
         PPITEST  PPIMVSI          VBS INPUT ?
         BZ    ADTRETUR            NO, BRANCH
         L     R4,PPIGETMN         ADDR OF GETMAIN TABLE OF ADDR
         L     R4,12(R4)           FETCH ADDR OF VBS WORK AREA
         ST    R4,KAWORK           STORE IN IERRDT WORK AREA
*
*        IF CRCX, OVERLAY RMAX CHECK IN IERRDT RETURN TO IERRC9
*
ADTRETUR PPITEST  PPI2314          CRCX SORT ?
         BZR   R14                 NO, RETURN TO IERRC9
         MVC   RDTRMAX(4),KADTKON  YES, OVERLAY RMAX CHECK
         BR    R14                 RETURN TO IERRC9
*
ADNXTRSA LA    R8,ADEREAL          RESET RETURN REG FOR THIS LOOP
*
*        INSERT CHAIN ADDR IN EACH BIN OF EACH RSA EXCEPT THE
*        LAST BIN OF THE LAST RSA
*
ADECHAIN A     R6,PPIBINSZ         ADDR OF THIS BIN + BIN SIZE
         LR    R4,R6               SAVE ADDR OF THE NEXT BIN
         S     R4,KFOUR            PTS TO AREA IN PREVIOUS BIN TO PUT
*                                  THE CHAIN ADDR OF NEXT BIN (IN R6)
         ST    R6,0(,R4)           PREVIOUS BIN NOW CHAINED TO NEXT BIN
         BR    R8                  BR TO ADELOOPI ON ALL BINS EXCEPT
*                                  THE LAST BIN IN EACH RSA OTHERWISE
*                                  BR TO ADEREAL ON THIS LAST BIN
*
*        OVERLAY LAST BIN CHAIN ADDR OF THIS RSA WITH PROPER ADDR
*        FIRST BIN ADDR OF NEXT RSA
*
ADEREAL  LA    R7,8(,R7)           UPDATE PPI RSA TABLE PTR TO NEXT
*                                  RSA ENTRY
         L     R6,0(,R7)           ADDR OF 1ST BIN IN NEXT RSA
         ST    R6,0(,R4)           STORE AS CHAIN ADDR IN LAST BIN OF
*                                  PREVIOUS RSA
         B     ADELOOPO            BRANCH TO CHAIN BINS OF THIS RSA
*
*        CONSTANTS
*
         DROP  R11
         DROP  R10
*
         USING IERRDT,R11
*
KADTKON  B     RDTMOVE             BYPASS RMAX CHECK
*
*        IERRDT
*
IERRDT   DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRDT SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRDTI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERADX   0101-20211-20211-1200-00149-00149-00000-RELEASE 00
ADX      TITLE 'IERADX - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERADX
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 3 ASSIGNMENT MODULE - FIXED LENGTH TAPE SORT
*        THE FUNCTION OF THIS MODULE IS TO RESERVE AREA IN
*        GENERATED CORE FOR THE TABLE OF INPUT BUFFER ADDRESSES
*        AND FILL IN EACH ENTRY IN THE TABLE WITH THE STARTING
*        ADDRESS (LOWER CORE) OF EACH INPUT BUFFER. SINCE THE
*        READ ASSIGNMENT MODULE HAS PRIMED THE INPUT BUFFERS AND
*        PUT THE STARTING ADDRESSES+4 (FOR THE NETWORK) IN
*        PPIPDWA TABLE THIS MODULE MOVES THE ADDRESSES TO THE
*        APPROPRIATE ENTRY IN THE TABLE OF INPUT BUFFER ADDRESSES
*        (AFTER ADJUSTING THE ADDRESSES TO POINT TO THE START OF
*        EACH BUFFER). THESE ADDRESSES WILL BE USED BY IERRDX TO
*        PASS AS A PARAMETER TO THE READ FORWARD MODULE. THE
*        ADDRESSES IN PPIPDWA WILL NOW HAVE TO BE CHANGED TO
*        POINT TO THE LAST RECORD (HI CORE) IN EACH BUFFER. THIS
*        IS SO THE MERGE NETWORK WILL BE ABLE TO COMPARE EACH
*        BUFFER FROM HI TO LOW. IERRDX WILL CONTINUE DEBLOCKING
*        EACH BUFFER FROM HI TO LOW CORE
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACROS USED BY THE MODULE - SMPPI
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                       CALLING SEQUENCE -
*                           LOAD EP=IERADX,DCB=SORTLIB
*                           LR   R15,R0
*                           BALR R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIDEB     PPIRCDL2
*        PPISPGN1   PPIPDWA
*        PPISBLCT
*        VARIOUS ADDRESSES OF TABLES, AND RECORD LENGTHS FOR
*        CALCULATIONS
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPISPGN1   PPIBDSVA
*        UPDATE POINTER IN GEN CORE AND INITIALIZE BUFFER ADDR
*        TABLE POINTER
*
*        EXTERNAL ROUTINES - NONE
*
*        EXTERNAL PARAMETERS - SEE REGISTERS
*
*        EXITS - NORMAL - TO ASSIGNMENT LOADER
*                         EXIT TO IERRC9
*                         CALLING SEQUENCE -
*                             BR   R14        RETURN
*
*        EXITS - ERROR - NONE
*
*        TABLES/WORK AREAS - NONE
*
*        NOTES -
*        THIS MODULE IS EXECUTED FOR FIXED LENGTH RECORDS AND TO
*        SAVE A COPY PASS. IT IS EXECUTED ALONG WITH THE READ
*        FORWARD TAPE MODULE
*
IERADX   CSECT
*
         USING *,R11
         USING IERRCA,R13          ADDR OF PPI DSECT
         USING DIERRDX,R10         ADDR OF IERRDX DSECT
*
         LR    R11,R15             ESTABLISH THIS MODULE BASE REG
         L     R10,PPIDEB+4        ESTABLISH IERRDX DSECT BASE REG
*
*        INSURE STARTING ADDR OF AVAILABLE CORE ON FULL WORD
*        BOUNDARY
*
         NI    PPISPGN1+3,X'FC'    ROUND TO NEXT LOWEST FULL WORD
         L     R4,PPISPGN1
*
*        CALCULATE SIZE OF INPUT BUFFER ADDR TABLE AND RESERVE
*        AREA IN GEN CORE
*
ADHDA020 SR    R5,R5
         IC    R5,PPIBDSVA         TOTAL NO OF WORK UNITS
         SLL   R5,2                *4
         LA    R5,4(,R5)           ALIGN TABLE FOR PROPER INCR
         SR    R4,R5               RESERVE THE SPACE IN GEN CORE
         ST    R4,WDBLSV           SAVE START OF TABLE IN IERRDX
         ST    R4,PPISPGN1         RESTORE PTR IN PPI
         MVC   PPIBDSVA+1(3),PPISPGN1+1  SAVE ADDR IN COMMON SAVE AREA
*                                        IN PPI (BLOCK/DEBLK SAVE AREA)
         LH    R9,PPIMRGMX         INPUT MERGE ORDER
         L     R6,PPISBLCT         R6 -> INPUT BUFFER BLOCK COUNTERS
         LA    R5,PPIPDWA          R5 -> PRIME AREA TABLE HAVING THE
*                                  STARTING ADDR+4 OF PRIMARY INPUT
*                                  BUFFERS
         SR    R8,R8
*
*        INSERT THE STARTING ADDRS OF EACH INPUT BUFFER IN THE
*        CORRECT LOCATION IN THE TABLE OF INPUT BUFFER ADDRS
*
ADHDK030 IC    R8,0(,R5)           INCR OF THE FILE
         L     R7,0(,R5)           ADDR+4 OF THE INPUT BFR
         S     R7,KFOUR            -4 FOR EOS BYTES
         ST    R7,0(R8,R4)         STARTING ADDR OF BFR TO BUFFER TABLE
*                                  FOR READ FORWARD
*
*        UPDATE THE ADDRS IN PPIPDWA TO POINT TO THE FIRST RECORD
*        (HI CORE) IN EACH BUFFER FOR THE MERGE ROUTINE TO
*        COMPARE
*
         L     R7,0(R8,R6)         BLOCK COUNT OF THIS FILES BUFFER
         BCTR  R7,0                -1
         MH    R7,PPIRCDL2         EQUALS CHARACTER COUNT OF THE RCDS
*                                  IN THE BUFFER MINUS 1 RCD
         A     R7,0(,R5)           ADD STARTING ADDR+4 OF THE BUFFER
         ST    R7,0(,R5)           STARTING ADDR OF 1ST RCD TO COMPARE
*                                  (REBUILDING  PPIPDWA TABLE)
         LA    R5,4(,R5)           UPDATE PPIPDWA PTR
         BCT   R9,ADHDK030         DECR MERGE ORDER, BRANCH ¬= 0
*
*        EXIT TO NEXT ROUTINE
*
         BR    R14                 RETURN TO IERRC9
*
*        CONSTANTS
*
KFOUR    DC    A(4)
*
*        IERRDX
*
DIERRDX  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRDX SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRDXI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERAGA   0101-20211-20211-1200-00521-00521-00000-RELEASE 00
AGA      TITLE 'IERAGA - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERAGA
*
*        MODULE FUNCTION/OPERATION -
*        GENERATE ONE (1) INPUT DCB AND ONE (1) OUTPUT DCB FOR
*        EACH ACTIVATED ENTRY OF THE TAPE TABLE. A SINGLE ECB AND
*        IOB WILL BE GENERATED AND ALL OUTPUT DCBS WILL POINT TO
*        IT. THE IOB WILL POINT TO THE DCB SPECIFIED BY THE
*        DEPHO INCREMENT. THE MODULE WILL ALSO INTERROGATE PPI TO
*        DETERMINE IF USER EXITS HAVE BEEN ACTIVATED. IF EXITS
*        HAVE BEEN SPECIFIED, THE MODULE WILL GO TO THE USER FOR
*        THE OPTION LISTS. THE OPTIONS WILL THEN BE USED TO
*        MODIFY THE APPROPRIATE DCB BLOCK FIELDS IN THE GENERATED
*        DCBS. THE ADDRESSES OF ALL DCBS GENERATED WILL BE
*        PLACED IN BOTH THE OPEN LIST AND THE DCB ADDRESS TABLE
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACROS USED BY MODULE -
*        SMPPI
*        DCB
*        DCBD
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                       CALLING SEQUENCE -
*                          LOAD EP=IERAGA,DCB=
*                          LR    R15,R0
*                          BALR  R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPITPTBL   PPICNTL   PPIMRGMX
*        PPIBDSVA   PPILAB03
*        PPIADSSC   PPILAB06
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPISPGN1   PPISTIOB
*        PPISTDCB   PPIDEPHO
*
*        EXTERNAL ROUTINES - NONE
*
*        EXTERNAL PARAMETERS -
*        PPIOPEN+4 - OPEN LIST ADDR
*        PPIAMA+4  - MESSAGE MODULE ADDR
*
*        EXITS - NORMAL -
*                BR R14 - RETURN TO LOAD MODULE IERRC9
*
*                L R15,PPIX18+4 - EXIT TO USER READ OPTION ROUTINE
*                BR R15
*
*                L R15,PPIX19+4 - EXIT TO USER WRITE OPTION ROUTINE
*                BR R15
*
*        EXITS - ERROR -
*        DCBSYNAD - UNCORRECTABLE QSAM READ ERROR
*        PPIAMA+4 - ILLEGAL OPTION NUMBER SPECIFIED BY USER
*
*        TABLES/WORK AREAS - N/A
*
*        NOTES THIS MODULE IS RESTRICTED TO TAPE ONLY OPERATION
*
IERAGA   CSECT
*
         USING *,R11               MODULE BASE REG
         USING IHADCB,R12          BASE REGISTER FOR DCB DSECT
         USING IERRCA,R13          PPI COMMON MODULE BASE REGISTER
         USING DIERAMA,R14         BASE REG FOR MESSAGE MODULE DSECT
         USING DIERAP1,R15         BASE REG FOR OPEN LIST DSECT
*
         LR    R11,R15             SET BASE REGISTER
         STM   R14,R12,WREGSVR     SAVE REGISTERS FOR RETURN
*
*        SET UP WORKING PARAMETERS FOR TAPE OPERATION
*
         LH    R4,PPIMRGMX         NO OF OUTPUT DCBS TO GENERATE
         ST    R4,WNUMDCB
*
*        STORE TOTAL NUMBER OF DCBS TO OPEN AS THE FIRST ENTRY OF
*        THE OPEN LIST
*
         L     R2,PPIOPEN+4        OPEN LIST ADDR
         LA    R4,1(,R4)           INCR NO OF DCBS
         ST    R4,0(,R2)
         LA    R2,4(,R2)           UPDATE OPEN LIST POINTER
         ST    R2,WPARLST
*
*        COMPUTE STORAGE REQUIRED FOR DCBS, IOBS AND TABLES
*
         L     R4,PPISPGN1         STARTING ADDR OF GENERATED CORE
         SRL   R4,2                ROUND TO WORD BOUNDARY
         SLL   R4,2
         LA    R1,SORTINL          L'INPUT DCB
         SR    R6,R6
         L     R7,WNUMDCB
         LA    R8,SORTWKL          L'SORTWK DCB
         MR    R6,R8               L'SORTWK DCB * WNUMDCB
         AR    R1,R7               ADD TO L'SORTIN DCB
         SR    R4,R1               CALC START ADDR
         ST    R4,WDCBADR          STORE IN DCB ADDR PTR
         S     R4,WIOBSZ
         ST    R4,WIOBADR
         LA    R3,8                ALLOW FOR 8 BYTE S/M PREFIX
         SR    R4,R3
         ST    R4,WECBADR          SET ADDR FOR START OF IOBS
         SR    R3,R3
         IC    R3,PPIBDSVA         TOTAL NO WORK UNITS
         LA    R3,1(,R3)
         SLL   R3,2
         SR    R4,R3
         ST    R4,PPISPGN1
         ST    R4,PPISTDCB
*
*        GENERATE OPTIONAL DIAGNOSTIC MESSAGES
*
         L     R14,PPIAMA+4
         PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTICS ?
         BZ    AGANOMES            NO, BRANCH
         LR    R0,R4               LOAD ADDR TO BE CONVERTED
         L     R15,PPICONV+4       R15 -> CONVERSION ROUTINE
         BAS   R14,4(,R15)         CALL CONVERSION ROUTINE
         L     R14,PPIAMA+4
         MVC   IER906A,2(R1)       MOVE FORMATTED ADDR INTO MESSAGE
         LM    R0,R1,IER906        IER906 DCB TABLE ADDR
         L     R15,PPIADSSC        R15 -> MSG PRINT RTN
         BAS   R14,12(,R15)        CALL MSG PRINT RTN
*
*        SET INDICATOR BIT IN FIRST BYTE OF ALL DCB ADDR TABLE
*        SLOTS
*
AGANOMES LA    R6,X'800'
         SLL   R6,20               R6 = X'80000000'
         SR    R3,R3
         IC    R3,PPIBDSVA         TOTAL NO WORK UNITS
         LA    R3,1(,R3)
AGA05    ST    R6,0(,R4)
         LA    R4,4(,R4)           INCR TO NEXT DCB TABLE ADDR
         BCT   R3,AGA05            GO ADD 4 TO REG 4
*
*        CONVERT WORK UNIT NUMBERS IN THE TAPE TABLE TO AN
*        OFFSET USED TO REFERENCE THE DCB ADDR IN THE DCB
*        ADDR TABLE
*
         LA    R6,PPITPTBL         R6 -> TAPE TABLE
         SR    R10,R10
         IC    R10,PPIBDSVA        NO OF ENTRIES IN TABLE
AGA07    IC    R4,1(R6)            GET BINARY DDNAME SUFFIX FROM TABLE
         SLL   R4,2                CONVERT TO OFFSET
         STC   R4,1(,R6)           PLACE INCREMENT BACK INTO TABLE
         LA    R6,2(,R6)           UPDATE TAPE TABLE POINTER
         BCT   R10,AGA07           LOOP TO CONVERT ALL TABLE ENTRIES
*
         IC    R4,PPIDEPHO+3
         SLL   R4,2                CONVERT DDNAME SUFFIX TO OFFSET
         STC   R4,PPIDEPHO+3
*
*        GENERATE INPUT DCB, CHECK FOR USER MODIFICATION OPTIONS,
*        MOVE COMPLETED DCB INTO ALLOCATED CORE, STORE ADDRS AND
*        UPDATE PROPER POINTERS
*
         MVI   WINDIC,X'01'        SET INDICATOR FOR INPUT DCB
         B     AGAINITL            GO OUT AND RETURN FROM THE DCB
*                                  INITIALIZATION SUBROUTINE
*
*        CHECK IF USER READ OPTION EXIT E18 IS ACTIVE
*
AGARTRN1 PPITEST  PPIME18          EXIT E18 ACTIVATE ?
         BO    AGAGOUSR            YES
*
*        SET UP PARAMETERS AND MOVE GENERATED DCB INTO ALLOCATED
*        CORE
*
AGAMVIN  L     R1,PPISTDCB         R1 -> DCB ADDR TABLE
         L     R2,WPARLST          NEXT USABLE SLOT IN OPEN LIST
         L     R4,WDCBADR          NEXT USABLE ACTUAL DCB ADDR
         MVC   0(SORTINL,R4),SORTIN  MOVE DCB INTO ALLOCATED STORAGE
*
*        STORE DCB ADDR INTO PROPER LISTS
*        UPDATE PARAMETERS
*
         ST    R4,0(,R1)           STORE DCB ADDR IN DCB ADDR TABLE
         ST    R4,0(,R2)           STORE DCB ADDR IN OPEN LIST
         LA    R2,4(,R2)           UPDATE OPEN LIST POINTER
         ST    R2,WPARLST
         LA    R4,SORTINL(,R4)     UPDATE DCB ACTUAL ADDR
*
*        SET INDICATOR BIT TO OUTPUT DCB GENERATION
*
         MVI   WINDIC,X'00'        SET INDICATOR FOR OUTPUT DCB
         B     AGAINITL            GO OUT AND RETURN FROM THE DCB
*                                  INITIALIZATION SUBROUTINE
*
*        CHECK IF USER WRITE OPTION EXIT E19 ACTIVE
*
AGARTRN3 PPITEST  PPIME19          EXIT ACTIVATED ?
         BO    AGAGOUSR            YES, BRANCH
*
*        SET UP PARAMETERS, ASSIGN PROPER SORTWK IDENTITIES AND
*        MOVE OUTPUT DCBS INTO ALLOCATED CORE
*
AGAMVOUT LA    R6,PPITPTBL         R6 -> TAPE TABLE
         L     R10,WNUMDCB
         L     R2,WPARLST
*
*        TAPE OPERATION
*
*        TEST ENTRY FOR PRESENCE OF OPEN BIT
*
AGA08A   TM    0(R6),X'40'         OPEN BIT SET ?
         BO    AGA08B              YES
         B     AGARPT              NO
*
*        GET INCREMENT FROM TABLE TO SET UP DCB DDNAME
*
AGA08B   SR    R9,R9
         IC    R9,1(,R6)           GET OFFSET FROM TAPE TABLE
AGA10    SRL   R9,1                CONVERT OFFSET TO SORTWKXX OFFSET
         LH    R9,DDTABLE(R9)
         STH   R9,DCBDDNAM+6       STORE DDNAME SUFFIX IN DDNAME
         MVC   0(SORTWKL,R4),SORTWK  MOVE MODEL DCB
*
*        STORE DCB ADDR AND UPDATE TABLE AND ADDR POINTERS
*
         SR    R9,R9
         IC    R9,1(,R6)           GET OFFSET FROM TAPE TABLE
         ST    R4,0(R1,R9)         STORE ADDR IN DCB TABLE
         ST    R4,0(,R2)           STORE ADDR INTO OPEN LIST
         LA    R2,4(,R2)           UPDATE OPEN LIST POINTER
         LA    R4,SORTWKL(,R4)     UPDATE ACTUAL DCB ADDR
*
*        CHECK IF ALL DCBS HAVE BEEN GENERATED
*
AGARPT   LA    R6,2(,R6)           UPDATE TAPE TABLE POINTER
         BCT   R10,AGA08A
         B     AGA11               ALL DCBS HAVE BEEN GENERATED
*
*        CALL USER EXIT E18/E19
*
*        THE EXIT RETURNS WITH THE ADDR OF THE USER OPTION LIST IN R1
*        THE MODEL DCB WILL BE MODIFIED ACCORDING TO THE OPTIONS
*        SPECIFIED ON THE LIST
*
*        R1 -> USER OPTION LIST
*
*          BYTE 1      BYTE 2      BYTE 3      BYTE 4
*         _______________________________________________
*        |           |                                   |
*        | X'01'     | ADDR OF USER PROVIDED SYNAD I/O   |
*        |           | ERROR ROUTINE                     |
*        |___________|___________________________________|
*        |           |                                   |
*        | X'02'     | ADDR OF USER PROVIDED DCB DCBEXLSA|
*        |           | LIST                              |
*        |___________|___________________________________|
*        |           |           |           |           |
*        | X'03'     | 0         | 0         | DCBERROPT |
*        |           |           |           | FLAG BYTE |
*        |___________|___________|___________|___________|
*        |           |                                   |
*        | X'04'     | DCB EODAD ROUTINE                 |
*        |           |                                   |
*        |___________|___________________________________|
*        |           |                                   |
*        | X'00'     | TERMINATING ENTRY IN LIST         |
*        |           |                                   |
*        |___________|___________________________________|
*
*
AGAGOUSR STM   R1,R10,WREGSAVE     SAVE REGS PRIOR TO INVOKING EXIT
         TM    WINDIC,X'01'        INPUT DCB EXIT ?
         BO    AGAUSR01            YES
         L     R15,PPIX19+4        NO, USER WRITE OPTION ADDR
         B     AGAUSR02            GOTO SET UP RETURN FROM USER
*
AGAUSR01 L     R15,PPIX18+4        USER READ OPTION ADDR
AGAUSR02 BASR  R14,R15             CALL USER EXIT
*
*        RETURN POINT FROM THE USER MODIFICATION PROGRAM
*
         LR    R8,R1               R8 -> USER LIST RETURNED BY EXIT
         L     R15,PPIOPEN+4       OPEN LIST ADDR
*
AGASTUOP SR    R4,R4               START OF USER OPTION PROCESSING
         ICM   R4,B'0001',0(R8)    GET OPTION NUMBER
         BZ    AGAUSRET            TERMINATING ENTRY ? BRANCH
         CH    R4,WOPTMAX          USER OPTION NO > LEGAL VALUE ?
         BH    AGAUSR6A            INVALID OPTION, BRANCH
         SLL   R4,2                CONVERT OPTION NO INTO OFFSET
         B     *(R4)               BRANCH TO PROCESS USER OPTION
         B     AGATRECH            +04 SYNAD (OPTION 01)
         B     AGATREA             +08 EXLST (OPTION 02)
         B     AGAONECH            +12 EROPT (OPTION 03)
         B     AGAUSR05            +16 EODAD (OPTION 04 - INPUT ONLY)
*
AGAUSR06 LA    R8,4(,R8)           UPDATE USER PARAMETER LIST POINTER
         B     AGASTUOP            TO PROCESS NEXT ENTRY ON LIST
*
AGAUSR6A TM    WFRSTERR,X'01'      FIRST OPTION ERROR ?
         BO    AGAUSR06            NO
         MVI   WFRSTERR,X'01'      YES, SET INDICATOR
         B     AGAERR              GOTO ERROR MSG RTN
*
*        MODIFICATION COMPLETE, RETURN TO MAIN PROGRAM
*
AGAUSRET LM    R1,R10,WREGSAVE     RESTORE REGISTERS
         MVI   WFRSTERR,X'00'      RESTORE FIRST OPTION ERROR INDIC
         TM    WINDIC,X'01'        RETURN TO INPUT ROUTINE ?
         BO    AGAMVIN             YES
         B     AGAMVOUT            NO
*
*        SYNAD OPTION
*
AGATRECH TM    WINDIC,X'01'        INPUT DCB ?
         BO    AGATRECA            YES
         MVC   AP1WRT1+1(3),1(R8)  MOVE SYNAD ADDR TO IERAP1
         B     AGAUSR06            GOTO PROCESS NEXT OPTION
*
AGATRECA MVC   DCBSYNA,1(R8)       MOVE SYNAD ADDR INTO DCB
         B     AGAUSR06            GOTO PROCESS NEXT OPTION
*
*        EXLST OPTION
*
AGATREA  MVC   DCBEXLSA,1(R8)      UPDATE DCBEXLSA
         B     AGAUSR06            GOTO PROCESS NEXT OPTION
*
*        EROPT OPTION
*
AGAONECH TM    WINDIC,X'01'        INPUT DCB ?
         BO    AGAONEA             YES
         B     AGAUSR6A            NO, ILLEGAL OPTION
*
AGAONEA  MVC   DCBEROPT,3(R8)      MOVE EROPT CODE INTO DCB
         B     AGAUSR06            GOTO PROCESS NEXT OPTION
*
*        EODAD OPTION
*
AGAUSR05 TM    WINDIC,X'01'        INPUT DCB ?
         BO    AGAUSR5A            YES
         B     AGAUSR6A            ERROR, EODAD ON OUTPUT
*
AGAUSR5A L     R6,PPIEOF+4         EOD READ ROUTINE ADDR
         LA    R6,9(,R6)           ADDR IN EOD ROUTINE
         MVC   0(3,R6),1(R8)       MOVE EODAD INTO PPIEOF AREA
         B     AGAUSR06            GOTO PROCESS NEXT OPTION
*
*        DCB INITIALIZATION SUBROUTINE
*
*        USED TO INITIALIZE BOTH INPUT AND OUTPUT DCBS
*
AGAINITL STM   R1,R10,WREGSAVE     SAVE REGISTERS
         TM    WINDIC,X'01'        INPUT DCB ?
         BO    AGAINT02            YES
*
*        OUTPUT DCB INITIALIZATION SUBROUTINE
*
         LA    R12,SORTWK          R12 -> EXCP DCB MODEL
         MVC   DCBDDNAM(L'PPIDDSRT),PPIDDSRT  MOVE IN DDNAME PREFIX
         MVC   DCBIOBAD,WIOBADR    IOB ADDR
         MVI   DCBBFTEK,DCBBFTS    SIMPLE BUFFERING
         B     AGACOMM             GOTO INIT DCB
*
*        INPUT DCB INITIALIZATION SUBROUTINE
*
AGAINT02 LA    R12,SORTIN          R12 -> QSAM DCB MODEL
         MVC   DCBDDNAM(L'PPIDDSRT),PPIDDSRT  SET DDNAME PREFIX
         MVC   DCBBUFNO,PPILAB03   NO OF INPUT BUFFERS
         MVC   DCBBUFCA,PPILAB06+1  8 BYTE CONTROL BUFFER ADDR
         MVC   DCBBUFL,PPILAB03+2   L'INPUT BUFFER
         L     R1,PPIEOF+4         EOD READ ROUTINE ADDR
         STCM  R1,B'0111',DCBEODA
         MVI   DCBEROPT,DCBERABE   ABNORMAL END OF TASK
         L     R1,PPIADSSC         INPUT READ ERROR
         MVC   DCBSYNAD(4),24(R1)  MOVE SYNAD RTN ADDR INTO DCB
         MVI   DCBBFTEK,DCBBFTS    SIMPLE BUFFERING
         PPITEST  PPIMVSI          VBS INPUT ?
         BO    AGAVRE              YES, GOTO SET GET MOVE MODE
         OI    DCBMACR,DCBMRGET+DCBMRLCG    SET GET LOCATE
         B     AGACOMM             GOTO INIT DCB
*
AGAVRE   OI    DCBMACR,DCBMRGET+DCBMRMVG  SET MOVE DATA MODE
         NI    DCBMACR,255-DCBMRLCG       TURN OFF LOCATE MODE
*
*        INITIALIZE FIELDS COMMON TO BOTH EXCP AND QSAM DCBS
*
AGACOMM  MVI   DCBIFLG,X'00'       USE IOS ERROR ROUTINES
         PPITEST  PPISWA           FULL WORD BUFFER ALIGNMENT ?
         BO    AGAINT04            YES
         OI    DCBBFTEK,DCBBFAD    SET DOUBLE WORD ALIGNMENT
         B     AGAINT05            GOTO RESTORE REGS
*
AGAINT04 OI    DCBBFTEK,DCBBFAF1   SET WORD BUFFER ALIGNMENT
*
*        RESTORE REGISTERS AND RETURN TO MAIN PROGRAM
*
AGAINT05 LM    R1,R10,WREGSAVE
         TM    WINDIC,X'01'        INPUT DCB ?
         BO    AGARTRN1            YES
         B     AGARTRN3            GO SEE IF EXIT ACTIVATED
*
*        PUT ECB AND DCB ADDR INTO IOB
*
         DROP  R12
         USING IERIOB,R12
         LA    R12,MODIOB          R12 -> MODEL IOB
         MVI   IOBM,1              SET EXTENT
AGA11    L     R4,WECBADR          GET ADDR FOR IOB STORAGE
         ST    R4,IOBECBPT         ECB ADDR IN IOB MODEL
         LR    R1,R4
         LA    R1,8(,R1)
         ST    R1,PPISTIOB         OUTPUT IOB ADDR IN PPI
         L     R1,PPISTDCB         R1 -> DCB ADDR TABLE
         SR    R2,R2
         IC    R2,PPIDEPHO+3       PRIMARY OUTPUT WORK UNIT
         L     R2,0(R2,R1)
         ST    R2,IOBDCBPT         PROPER DCB ADDR IN IOB MODEL
         MVC   0(MODIOBL,R4),MODIOB  MOVE IOB MODEL INTO STORAGE
*
*        RETURN TO CALLER
*
         LM    R14,R12,WREGSVR
         BR    R14                 RETURN TO IERRC9
*
*        GENERATE ERROR MESSAGE
*
AGAERR   L     R14,PPIAMA+4        R14 -> MESSAGE MODULE ADDR
         LM    R0,R1,IER044        IER044I EXIT EXX INVALID
         TM    WINDIC,X'01'        INPUT DCB ?
         BO    AGAERR01            YES
         MVC   IER044A,KTAG+2      MOVE EXIT NO 19 INTO MSG
         B     AGAERR02
*
AGAERR01 MVC   IER044A,KTAG        MOVE EXIT NO 18 INTO MSG
AGAERR02 L     R15,PPIADSSC        R15 -> MSG RTN
         BAS   R14,12(,R15)        CALL MSG WRITER
         B     AGAUSR06            RETURN TO USER MODIFICATION PROG
*
*        WORK AREAS
*
WNUMDCB  DC    F'0'                NUMBER OF DCBS TO GENERATE
WIOBSZ   DC    A(32)               L'TAPE IOB
WDCBADR  DC    F'0'                STARTING ADDR OF DCB AREA
WECBADR  DC    F'0'                STARTING ADDR OF ECB AREA
WIOBADR  DC    F'0'                STARTING ADDR OF IOB AREA
WPARLST  DC    F'0'                STORAGE FOR NEXT OPEN LIST SLOT
WINDIC   DC    F'0'                INDICATOR WORD - INPUT OR OUTPUT
WFRSTERR DC    F'0'                FIRST OPTION ERROR INDICATOR
WREGSAVE DC    11F'0'              REG SAVE AREA ACROSS USER EXITS
WREGSVR  DC    15F'0'
WOPTMAX  DC    H'4'                HIGHEST LEGAL USER OPTION NUMBER
*
*        CONSTANTS
*
DDTABLE  DC    C'0001020304050607080910111213141516171819'
         DC    C'20212223242526272829303132'
*
KTAG     DC    C'1819'             EXIT IDENTITIES FOR MSGS
*
*        IOB MODEL USED BY THE PROGRAM
*
MODIOB   DC    12F'0'              STANDARD 32 BYTES FOR TAPE PLUS
*                                  SORT/MERGE 8 BYTE PREFIX
MODIOBL  EQU   *-MODIOB            L'MODIOB
         ORG   MODIOB+36           (IOBINCAM-IERIOB)
         DC    H'1'                SET THE TAPE BLOCK INCREMENT
         ORG
*
*        GENERATE DATA CONTROL BLOCK MODELS USED BY THE PROGRAM
*
SORTIN   DCB   MACRF=(GL),DSORG=PS,DDNAME=SORTIN
*
SORTINL  EQU   *-SORTIN            L'SORTIN DCB
*
SORTWK   DCB   MACRF=(E),DSORG=PS,DDNAME=SORTWK,REPOS=Y
*
         DC    F'0'                WORKAREA APPENDED TO EXCP DCB
*                                  REFERENCED AS DCBOPTCD
*
SORTWKL  EQU   *-SORTWK            L'SORTWK DCB
*
*        OPEN LIST DSECT USED BY MODULE
*
DIERAP1  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERAP1 SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERAP1I
*
*        MODULE NAME - IERAMA
*
*        THIS MODULE CONTAINS ALL OF THE MESSAGES THAT ARE
*        REQUIRED FOR PHASE 1 ASSIGNMENT MODULES
*
DIERAMA  DSECT
*
         COPY AMAMAIN
*
*        DCB DSECT
*
         PRINT NOGEN
*
         DCBD  DSORG=PS,DEVD=(DA,TA)
*
         PRINT GEN
*
*        IERIOB
*
         IERIOB
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERAGB   0101-20211-20211-1200-00311-00311-00000-RELEASE 00
AGB      TITLE 'IERAGB - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERAGB
*
*        MODULE FUNCTION/OPERATION -
*        THIS ASSIGNMENT ROUTINE GENERATES THE CCW'S AND
*        ATTACHES THE BUFFERS TO THE IOBS FOR THE READ TAPE
*        ROUTINE IN THE INTERMEDIATE MERGE PHASE. IF THE RECORD
*        FORMAT IS VARIABLE THE ROUTINE ADJUSTS THE INSTRUCTIONS
*        LABELED RGBBRVR AND RGBBRVAR IN IERRGB. THE MODULE ALSO
*        ALLOCATES THE SPACE NEEDED FOR THE TABLE OF BLOCK
*        COUNTERS AND STORES THE TABLE'S STARTING ADDRESS IN
*        PPISBLCT
*
*        MODULES IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                       CALLING SEQUENCE -
*                           LOAD    EP=IERAGB,DCB=
*                           LR      R15,R0
*                           BALR    R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIBDSVA   PPILAB03   PPISTDCB
*        PPILAB02   PPIMRGMX   PPICNTL
*        PPILAB10   PPISPGN1   PPITPTBL
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPILAB02   PPIPSVA    PPISPGN1
*        PPILAB10   PPISBLCT   PPIWKARE
*        PPILAB03
*        CCW'S ARE GENERATED
*        ALLOCATES SPACE FOR THE TABLE OF BLOCK COUNTERS
*        MAY MODIFY INSTRUCTIONS IN THE RUNNING PROGRAM
*
*        EXTERNAL ROUTINES - NONE
*
*        EXTERNAL PARAMETERS - NONE
*
*        EXITS - NORMAL -
*        BR R14 - RETURN TO LOAD ROUTINE
*
*        EXITS - ERROR - NONE
*
*        TABLES/WORK AREAS - NONE
*
*        NOTES -
*        MERGE PHASE READ ASSIGNMENT PROGRAM
*
IERAGB   CSECT
*
         USING *,R11
         USING IERAP22,R1
         USING IERRCA,R13          PPIA DSECT
         USING DIERRGB,R10         IERRGB DSECT
         USING IOBSTDRD,R5         IOB DSECT
         USING IHADCB,R6           DCB DSECT
         USING AGBAMB,R2
*
IERMGB   LR    R11,R15
         L     R10,PPIRD+4         LOAD ADDR FOR IERRGB DSECT
         SR    R3,R3
         L     R1,PPIOPEN+4        LOAD ADDR FOR OPEN LIST DSECT
*
*        INSTRUCTION MODIFICATIONS ARE REQUIRED FOR AN
*        OSCILLATING SORT
*
         PPITEST  PPIOSC           OSCILLATING SORT ?
         BZ    AGBBEGIN            NO, BRANCH
         MVC   AGBBEGIN+2(2),KMOD1+2  OVERLAY REFERENCES TO LAB02 WITH
*                                     PPILAB10 FOR OSC SORT EACH PHASE
*                                     NEEDS SEPARATE INPUT BUFFER ADDR
         MVC   AGBMOD4+2(2),KMOD1+2   OVERLAY REFERENCES TO PPILAB03
         MVC   AGBMOD5+2(2),KMOD1+2   WITH PPILAB10 FOR NO INPUT
         MVC   AGBMOD6+2(2),KMOD2+2   BUFFERS FOR MERGE AND WITH
         MVC   AGBGN010+4(2),KMOD2+2  PPILAB07 FOR SIZE OF INPUT
         MVC   AGBMOD7+2(2),KMOD1+2   BUFFERS FOR MERGE
         S     R1,KSIXTY              BASE ADDR FOR OPEN LIST MUST BE
*                                     MODIFIED TO REFER TO PHASE 1 OPEN
*                                     LIST INSTEAD OF PHASE 2 OPEN LIST
*
*        ERROR OPTIONS
*
AGBBEGIN L     R6,PPILAB02
         ST    R6,KSIXTY
         CLC   WRDOPT+1(3),KCCW+1  EXIT ADDRESS PRESENT ?
         BE    AGBNOADR            NO, BRANCH
         MVC   AE28+1(3),WRDOPT+1  YES, STORE IN IERRGB
         PPISETON PPIACCPT         SET ACCEPT SKIP SWITCH
         CLI   WRDOPT,X'40'        CHECK OPTION
         BL    AGBTERM             LOW, TURN OFF SKIP/ACCEPT
         BE    AGBSTRT             EQUAL, NO RESETS
         MVC   RGBACCPT(2),AGBRAN  THE 47F0 OF FOLLOWING BRANCH SET R15
AGBRAN   B     AGBSTRT             USED BOTH AS BRANCH & CONSTANT
*
AGBNOADR MVI   RGBTERM+1,X'F0'     SET BYPASS NOP TO B
AGBTERM  PPISETOF PPIACCPT         TURN OFF SKIP ACCEPT SWITCH
         DROP  R1
*
*        BALANCED TECHNIQUE OVERLAYS
*
AGBSTRT  PPITEST  PPIBALN          BALANCED SORT ?
         BZ    AGBPOLY             NO, BRANCH
         MVC   KSAVE(2),PPIMRGMX   NO OF INPUT FILES=MERGE ORDER
         MVI   RGBPRBAL+1,X'F0'    OF IOB ADDR
         MVI   RGBBAL+1,X'00'      BALANCED, CLOSE FILE
*
*        CALC AND ALLOCATE SPACE FOR CCW'S AND BLOCK COUNT TABLE
*
AGBST001 L     R1,PPISPGN1         ADDR OF GENERATED CORE
         LA    R1,0(,R1)           ON A DOUBLE WORD BOUNDARY
         LH    R2,KSAVE            NO OF CCW'S NEEDED
         LR    R0,R2
         SLL   R2,4                SIZE OF CCWS EACH CCW IS 8 BYTES
         SR    R1,R2               AND WANT 2*MERGE ORDER OF THEM
         SLL   R0,1
AGBMOD4  IC    R3,PPILAB03         IF NO BUFFERS > (2*M), RESET NO
         CLR   R3,R0
         BNH   *+8                 <=, THEN (2*M)
AGBMOD5  STC   R0,PPILAB03         OF BUFFERS TO 2*M
         IC    R3,PPIBDSVA         TOTAL NO WORK UNITS
         LA    R3,1(,R3)
         SLL   R3,2                CALC SIZE OF BLOCK COUNTER TABLE
         LR    R4,R1
         PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTICS ?
         BZ    AGBGN009            NO, BRANCH
*
*        WRITE DIAGNOSTIC MESSAGE
*
         STM   R14,R2,PPILAB01     SAVE REGS
         LR    R0,R1               LOAD PARAM REG FOR CONVERSION
         L     R15,PPICONV+4       LOAD ADDR OF CONVERSION ROUTINE
         BAS   R14,4(,R15)         CALL CONVERSION RTN
         L     R2,PPIAMB+4         LOAD BASE REG
         MVC   IER927A,2(R1)       MOVE FORMATTED ADDR INTO MESSAGE
         LM    R0,R1,IER927        IER927I INPUT CCW ADDR
         L     R15,PPIADSSC        LOAD ADDR OF PRINT ROUTINE
         BAS   R14,12(R15)         CALL PRINT RTN
         LM    R14,R2,PPILAB01     RESTORE REGS
*
*        ALLOCATE STORAGE FOR THE BLOCK COUNT TABLE
*
AGBGN009 SR    R1,R3               DECR AVAILABLE STORAGE
         ST    R1,PPISPGN1         SAVE UPDATED
         ST    R1,PPISBLCT         SET ADDR OF BLOCK COUNT TABLE
AGBMOD6  LH    R3,PPILAB03+2       INPUT BUFFER SIZE
         BCTR  R3,0                BR TILL NO OF WORK UNITS = 0
         STH   R3,PPIPSVA
         PPITEST  PPIVAR           VARIABLE LENGTH RECORDS ?
         BO    AGBVR020            YES, BRANCH
         SR    R3,R3               FLAG BITS OFF FOR FIX LEN RCD FORMAT
AGBGN010 MVC   KCCW+6(2),PPILAB03+2  COUNT
         STC   R3,KCCW+4             FLAGS
         LR    R3,R4               GENERATE 2*MERGE ORDER CCW'S
AGBCCWLP MVC   0(8,R4),KCCW
         LA    R4,8(,R4)           UPDATE GENERATE AREA POINTER
         BCT   R0,AGBCCWLP         BRANCH TILL CCW AREA GENERATED
         LR    R0,R3               ATTACH THE CCW'S AND BUFFERS TO
         LH    R2,KSAVE            THE INPUT IOBS SPECIFIED
         L     R1,PPISTDCB         BY THE TAPE TABLE VIA THE INPUT
         LA    R4,PPITPTBL         BIT AND INCR
         LA    R7,PPIDSKED
AGBGN030 TM    0(R4),X'80'         SEARCH THE TAPE TABLE FOR THE
         BO    AGBGN040            INPUT FILES
         LA    R4,2(,R4)
         B     AGBGN030            CONTINUE SCAN
*
*        OVERLAYS FOR VARIABLE RECORD FORMAT
*
AGBVR020 LA    R3,SLI              SLI BIT ON FOR VAR LEN RCD FORMAT
         MVI   RGBBRVR+1,X'F0'     VAR LEN RCD FORMAT OVERLAYS IN THE
         MVI   RGBRTRNV+3,X'08'
         MVI   RGBEOSV+3,X'05'     RUNNING PROGRAM
         MVI   RGBPREOS+3,X'05'
         MVI   RGBEREOS+3,X'05'
         MVI   RGBBRVAR+3,X'08'
         MVI   RGBBCCV+1,X'F0'
         B     AGBGN010            BUILD CCW AREA
*
*        ATTACH BUFFERS AND CCWS TO THE IOB'S
*
AGBGN040 SR    R6,R6               ATTACH M CCWS  AND BUFFERS
         IC    R6,1(,R4)           INCR
         STC   R6,0(,R7)
         L     R6,0(R6,R1)
         MVI   DCBBUFNO,1          BUFNO IN DCB
         MVC   1(3,R7),DCBIOBAA    SAVE IOB ADDR TO ATTACH THE
         L     R5,DCBIOBAD         ALTERNATE BUFFERS IF THERE ARE ANY
         ST    R3,IOBSTART         ATTACH CCW TO IOB
AGBMOD1  L     R6,KSIXTY
         L     R8,0(,R6)
         AH    R8,PPIPSVA          ATTACH BUFFER
         ST    R8,PPIPSVA+4        TO CCW
         MVC   1(3,R3),PPIPSVA+5
         LA    R6,4(,R6)           UPDATE THE
         ST    R6,KSIXTY
         LA    R3,8(,R3)           POINTERS
         LA    R4,2(,R4)
         LA    R7,4(,R7)
         L     R8,IOBECBPT         ATTACH SECOND CCW
         ST    R3,4(,R8)           TO IOB
         LA    R3,8(,R3)
         BCT   R2,AGBGN030         SEARCH FOR NO OF INPUT FILES
AGBMOD7  IC    R2,PPILAB03         TOTAL NO OF INPUT BUFFERS
         SH    R2,KSAVE            MINUS MAX MERGE = NO OF ALT BUFS
         BZ    AGBLK070            NO OVERLAP
*
*        PARTIAL OR FULL OVERLAP
*        ATTACH THE ALTERNATE BUFFERS TO THE IOBS ALTERNATE CCWS
*
         LA    R7,PPIDSKED
         L     R4,KSIXTY           ALTERNATE BUFFER POINTER
         CH    R2,KSAVE            IF ONLY HAVE PARTIAL OVERLAP
         BE    AGBAL060            SET UNCOND BRANCH IN
         MVI   RGBRFBF+1,X'F0'     IERRGB
AGBAL060 L     R5,0(,R7)           IOB ADDR
         L     R8,IOBECBPT
         L     R6,IOBDCBPT
         L     R8,4(,R8)           IOB'S ALTERNATE CCW ADDR
         L     R5,0(,R4)           ADJUST BUFFER ADDR
         AH    R5,PPIPSVA          FOR USE IN THE RREAD BACKWARDS
         ST    R5,PPIPSVA+4        COMMAND
         MVC   1(3,R8),PPIPSVA+5   STORE BUFFER ADDR IN CCW
         MVI   DCBBUFNO,2          BUFNO IN DCB
         LA    R7,4(,R7)           UPDATE
         LA    R4,4(,R4)           POINTERS
         BCT   R2,AGBAL060         BUILD IOB AREAS
AGBLK070 BR    R14                 RETURN TO LOAD MODULE
*
AGBPOLY  IC    R3,PPIBDSVA         POLY AND OSC ADJUSTMENTS
         BCTR  R3,0                TO CREATE CCW'S AND ATTACH
         SR    R1,R1               THEM ARE -
         LA    R4,PPITPTBL
AGBPOLY1 TM    0(R4),X'40'         1. NO OF INPUT FILES = NO OF
         BO    AGBPOLY2               ENTRIES IN TABLE WITH OPEN
AGBPEND  LA    R4,2(,R4)
         BCT   R3,AGBPOLY1            BIT ON MINUS ONE
         STH   R1,KSAVE
         MVI   AGBGN030+1,X'40'
         B     AGBST001               (FOR BALANCED= MERGE ORDER)
*                                  2. SEARCH TAPE TABLE'S OPEN BITS
*                                     AND NOT INPUT BITS, FOR MAY
*                                     HAVE ENDING DUMMIES. THUS
*                                     THE INPUT BITS WOULD NOT BE ON
*                                     FOR ALL THE INPUT FILES UPON
*                                     ENTERING THE FIRST SUBPASS
*                                     OF PHASE TWO NOR MERGE ORDER
*                                     SET TO TOTAL
AGBPOLY2 LA    R1,1(,R1)
         B     AGBPEND             SCAN FOR INPUT FILES-POLY
*
*        CONSTANTS
*
KMOD1    L     R0,PPILAB10         CONSTANTS FROM WHICH THE CORRECT
KMOD2    LH    R0,PPILAB07+2       DISPLACEMENTS CAN BE USED TO
*                                  OVERLAY REFERENCES TO PPILAB02
*                                  AND PPILAB03
KSIXTY   DC    F'56'               SIXTY
KCCW     CCW   READBT,0,SLI,0
KEIGHT   DC    H'8'
*
*        IERRGB
*
DIERRGB  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRGB SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRGBI
*
*        IERAP22
*
IERAP22  DSECT
         DC    33F'0'              OPEN LIST
WRDOPT   DC    F'0'                OPEN LIST
         DC    11F'0'              OPEN LIST
*
AGBAMB   DSECT
*
         COPY AMBMAIN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
*        IERCCWEQ
*
         IERCCWEQ
*
*        IERIOB
*
         IERIOB
*
         PRINT NOGEN
*
         DCBD  DSORG=PS,DEVD=(DA,TA)
*
         IEZDEB LIST=NO
*
         PRINT GEN
*
         SMPPI
*
         END
./ ADD NAME=IERAGC   0101-20211-20211-1200-00261-00261-00000-RELEASE 00
AGC      TITLE 'IERAGC - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERAGC
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 2 READ ASSIGNMENT MODULE - DISK
*        ASSIGNMENT ROUTINE GENERATES THE CCW'S AND
*        ATTACHES THE BUFFERS TO THE IOBS FOR THE READ DISK
*        ROUTINE IN THE INTERMEDIATE MERGE PHASE. IF THE RECORD
*        FORMAT IS VARIABLE, THE ROUTINE TURNS THE SLI BIT ON IN
*        THE READ CCW AND DOES SEVERAL OVERLAYS IN IERRGC. THE
*        MODULE ALSO ALLOCATES THE SPACE NEEDED FOR THE TABLE OF
*        BLOCK COUNTERS AND STORES THE TABLE'S STARTING ADDRESS
*        IN PPISBLCT. THIS MODULE SETS UP THE READ ERROR OPTION
*        AS INDICATED TO THE SORT BY EXIT E28
*
*        MODULES IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACROS USED -
*        SMPPI
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                          LOAD  EP=IERAGC,DCB=SORTLIB
*                          LR    R15,R0
*                          BALR  R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIBDSVA   PPILAB02
*        PPIBPTRK   PPILAB03
*        PPILAB01   PPIMRGOP
*        PPISPGN1   PPISTIOB
*        PPICNTL
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPILAB03   PPISBLCT   PPISPGN1
*
*        EXTERNAL ROUTINES -
*        IERAP2 - OPEN LIST
*
*        EXTERNAL PARAMETERS -
*        IERAP2 - USER READ ERROR OPTION
*
*        EXITS - NORMAL -
*        IERRC9 - RETURN VIA R14
*
*        EXITS - ERROR - NONE
*
*        TABLES/WORK AREAS - NONE
*
*        NOTES -
*        THIS MODULE IS RESTRICTED TO DISK OPERATION ONLY
*
IERAGC   CSECT
*
         USING *,R11
         USING IERAP22,R1          OPEN LIST DSECT
         USING IOBSTDRD,R5         IOB DSECT
         USING DIERRGC,R10         IERRGC DSECT
         USING IERRCA,R13          PPIA DSECT
*
IERMGB   LR    R11,R15
         L     R10,PPIRD+4         R10 -> READ ROUTINE
         L     R1,PPIOPEN+4        R1 -> OPEN LIST
         ST    R14,SAVER14         SAVE RETURN REGISTER
*
*        ERROR OPTION
*
AGC100   CLC   WRDOPT+1(3),AE28+1
         BE    AGCNOADR            LINK TO USER IF E28 ACTIVATED
         MVC   AE28+1(3),WRDOPT+1
         PPISETON PPIACCPT         SET ACCEPT SKIP SWITCH
         CLI   WRDOPT,X'40'        TEST SYNAD CODE
         BL    AGCTERMX            LOW   - TERMINATE
         BE    AGCST001            EQUAL - SKIP
         MVC   RGCACCPT(4),RGCBR   SET ACCEPT INTO IERRGC
         B     AGCST001
*
AGCNOADR MVI   RGCTERM+1,X'F0'     SET IMMEDIATE TERMINATE
AGCTERMX PPISETOF PPIACCPT         TURN OFF SKIP ACCEPT SWITCH
         DROP  R1
*
*        DIRECTORY READ OVERLAYS
*
AGCST001 LA    R1,PPILAB01         PLACE DIRECTORY BUFFER AREA ADDR
         STCM  R1,B'0111',KRDDIR+17  IN THE DIRECTORY'S READ CCW
*
*        CALCULATE AND ALLOCATE SPACE FOR CCW'S AND BLOCK COUNT
*        TABLE
*
         L     R1,PPISPGN1         GENERATE CORE ADDR
         LA    R1,7(,R1)           MAKE SURE CCW'S
         N     R1,KMASK
         SH    R1,KEIGHT           START ON DOUBLE WORD BOUNDARY
         LH    R2,PPIMRGOP         MERGE ORDER
         LR    R0,R2               COPY MERGE ORDER TO R0
         SLL   R2,4                SPACE FOR CCW'S
         LR    R3,R2               =3(16*M)  -EACH CCW IS 8 BYTES
         AR    R2,R3               AND NEED 6*M OF THEM
         AR    R2,R3
         SR    R14,R14
         IC    R14,PPILAB03        IF NO BUFFERS > (2*M) RESET NO
         LR    R15,R0
         SLL   R15,1
         CLR   R15,R14
         BNL   *+8                 NO BUFFERS OK
         STC   R15,PPILAB03        OF BUFFERS TO 2*M
         SR    R1,R2
         SR    R3,R3
         IC    R3,PPIBDSVA         TOTAL NO OF WORK UNITS
         LA    R3,1(,R3)
         SLL   R3,2                BLOCK COUNTER TABLE IN
         LR    R4,R1               R4 -> GENERATED CORE =(#UNITS+1)*4
         SR    R1,R3
         ST    R1,PPISPGN1         SAVE UPDATED FREE STORAGE
         ST    R1,PPISBLCT         SET ADDR OF BLOCK COUNT TABLE
*
*        GENERATE OPTIONAL DIAGNOSTIC MESSAGE
*
         PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTICS ?
         BZ    AGCNOMES            NO, BRANCH
         STM   R14,R1,PPILAB01     SAVE REGISTERS
         LR    R0,R4               LOAD ADDR TO BE CONVERTED
         L     R15,PPICONV+4       LOAD ADDR OF CONVERSION ROUTINE
         BAS   R14,4(,R15)         CALL CONVERSION RTN
         L     R15,PPIAMB+4        R15 -> MSG CSECT
         USING DIERAMB,R15
         MVC   IER927A,2(R1)       MOVE ADDR INTO MESSAGE
         LM    R0,R1,IER927        IER927I INPUT CCW ADDR
         L     R15,PPIADSSC        LOAD ADDR OF PRINT ROUTINE
         BAS   R14,12(,R15)        CALL PRINT RTN
         LM    R14,R1,PPILAB01     RESTORE REGISTERS
         DROP  R15
AGCNOMES PPITEST  PPIVAR           VARIABLE LENGTH RECORDS ?
         BO    AGCVR100            YES, BRANCH
*
*        ATTACH BUFFERS AND CCW'S TO THE IOB'S
*
AGCGN010 MVC   KCCWLST+22(2),PPILAB03+2  BYTE COUNT
         MVI   KCCWLST+20,SLI            FLAGS
         L     R6,PPISTIOB         R6 -> IOB ADDR LIST
         L     R3,PPILAB02         R3 -> INPUT BUFFER ADDR
         LA    R6,4(,R6)           BYPASS THE OUTPUT IOB
AGECCWGN L     R5,0(,R6)           R5 -> IOB
         LA    R15,IOBCC           SET UP THE CCW LIST, MOVE TO
         STCM  R15,B'0111',KCCWLST+1   GENERATED CORE AREA ATTACH TWO
         STCM  R4,B'0111',KCCWLST+9    SET UP FIRST LIST
         ST    R4,IOBSTART         ATTACH FIRST LIST TO IOB
         MVC   0(24,R4),KCCWLST
         MVC   17(3,R4),1(R3)      STORE BUFFER ADDR IN CCW LIST
         LA    R4,24(,R4)
         STCM  R4,B'0111',KCCWLST+9  SET UP 2ND LIST
         MVC   0(24,R4),KCCWLST
         L     R14,IOBECBPT        SAVE ALTERNATE LIST ADDR AT ECB+4
         ST    R4,4(,R14)
         MVI   4(R14),X'01'        NO OF BUFFERS ATTACHED
         LA    R4,24(,R4)          UPDATE - GEN AREA FOR CCW'S
         LA    R6,4(,R6)                    IOB TABLE
         LA    R3,4(,R3)                    BUFFER TABLE
         BCT   R0,AGECCWGN         HAVE M BUFFERS BEEN ATTACHED ?
         IC    R0,PPILAB03         TOTAL NO OF INPUT BUFFERS
         SH    R0,PPIMRGOP         MINUS MERGE ORDER = NO OF ALT BUFS
         BZ    AGCLK030            IF ZERO NO OVERLAP
*
*        PARTIAL OR FULL OVERLAP
*
*        ATTACH THE ALTERNATE BUFFERS TO THE IOBS' ALTERNATE CCW
*        LISTS
*
         L     R6,PPISTIOB         IOB TABLE ADDR
         LA    R6,4(,R6)           BYPASS OUTPUT IOB
AGCAL020 L     R5,0(,R6)           IOB ADDR
         L     R1,IOBECBPT
         L     R4,4(,R1)           ALTERNATE CCW LIST ADDR
         MVC   17(3,R4),1(R3)      STORE BUFFER ADDR IN READ CCW
         MVI   4(R1),X'02'         SET NO OF BUFFERS ATTACHED TO IOB=2
         LA    R3,4(,R3)           UPDATE - BUFFER TABLE
         LA    R6,4(,R6)                    IOB TABLE
         BCT   R0,AGCAL020         ALL OF THE ALTERNATE BUFFERS
*                                  BEEN ATTACHED ?
AGCLK030 L     R14,SAVER14         RETURN TO
         BR    R14                 IERRC9
*
*        OVERLAYS FOR VARIABLE RECORD FORMAT
*
AGCVR100 MVI   IERDGB2D+11,X'05'   VARIABLE RECORD FORMAT OVERLAYS
         MVI   IERDGB2D+11,X'05'   VARIABLE RECORD FORMAT OVERLAYS
         MVI   RGCRTRN+7,X'08'
         MVI   RGCEOSV+3,X'05'     IN IERRGC TO INCLUDE THE 4 BYTE
         MVI   RGCFBV+3,X'05'
         MVI   RGCBRVR+1,X'F0'     BCC WHEN CONSIDERING THE
         MVI   RGCACCV+3,X'05'
         MVI   RGCBRVAR+3,X'08'    DISPLACEMENT FROM THE START OF
         MVI   RGCPR250+3,X'05'
         B     AGCGN010            A BUFFER
*
*        CONSTANTS
*
SAVER14  DC    F'0'                RETURN ADDR
KMASK    DC    X'FFFFFFF8'
KEIGHT   DC    H'8'
*
*        READ DATA CCW LIST
*
KCCWLST  CCW   SEARIDEQ,0,SLI+CC,5
         CCW   TIC,0,SLI+CC,0
         CCW   READDATA,0,0,0
*
         DROP  R10,R11
*
*        IERAMB
*
DIERAMB  DSECT
*
         COPY  AMBMAIN
*
*        IERRGC
*
DIERRGC  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRGC SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRGCI
*
*        IERAP22
*
IERAP22  DSECT
         DC    33F'0'              OPEN LIST DSECT
WRDOPT   DC    F'0'                E28 PAR LIST
         DC    11F'0'              E28 PAR LIST
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
*        IERCCWEQ
*
         IERCCWEQ
*
*        IERIOB
*
         IERIOB
*
         PRINT NOGEN
*
         DCBD  DSORG=PS,DEVD=(DA,TA)
*
         IHAECB DSECT=NO,EXT=NO
*
         IEZDEB LIST=NO
*
         PRINT GEN
*
         SMPPI
*
         END
./ ADD NAME=IERAGD   0101-20211-20211-1200-00400-00400-00000-RELEASE 00
AGD      TITLE 'IERAGD - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERAGD
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 3 READ ASSIGNMENT - TAPE
*        THIS ASSIGNMENT MODULE SETS UP THE CCW'S AND PRIMES THE
*        INPUT BUFFERS FOR THE READ TAPE ROUTINE. IF THE RECORD
*        FORMAT IS VARIABLE, THE ROUTINE ADJUSTS SEVERAL
*        INSTRUCTIONS (EG THAT LABELED RGDBRVR) IN IERRGD. THE
*        MODULE ALSO SETS UP THE TABLE OF BLOCK COUNTERS FOR THE
*        DEBLOCK ROUTINE, AND IT STORES THE TABLE ADDRESS IN
*        PPISBLCT. THE ROUTINE USES AN EOF/ERROR CHECK SUBROUTINE
*        LIKE THAT OF IERRGD. IERAGD SETS UP THE READ ERROR
*        OPTION AS INDICATED TO THE SORT BY EXIT E38
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACROS USED -
*        SMPPI   EXCP
*        WAIT    CLOSE
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                          LOAD  EP=IERAGD,DCB=SORTLIB
*                          LR    R15,R0
*                          BALR  R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIADSSC   PPIMRGMX
*        PPIBDSVA   PPIRCDCT
*        PPILAB02   PPIRCDL2
*        PPILAB03   PPISPGN1
*        PPITPTBL   PPISRTBL
*        PPISTDCB   PPICNTL
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPILAB01   PPISPGN1
*        PPILAB02   PPISAVEA
*        PPILAB03   PPIWKARE
*        PPISBLCT
*
*        EXTERNAL ROUTINES -
*        IERAP3 - OPEN LIST
*
*        EXTERNAL PARAMETERS -
*        IERAP3 - USER READ OPTION
*
*        EXITS - NORMAL -
*        IERRC9 - RETURN VIA R14
*
*        EXITS - ERROR - SORT SYSTEM CONTROL (PPIADSSC)
*                        READ ERROR IF USER OPTION IS TERMINATE
*
*        TABLES/WORK AREAS -
*        PPILAB01 - SAVE CALCULATED VALUES
*        PPISAVEA - ALIGN A CONSTANT
*        TFCNT    - TABLE OF FILE COUNTS
*
*        NOTES -
*        THIS MODULE IS FOR TAPE ONLY
*
IERAGD   CSECT
*
         USING IERAP33,R1
         USING *,R11
         USING IERRCA,R13
         USING DIERRGD,R10
         USING IOBSTDRD,R5
         USING IHADCB,R6
*
IERMGD   LR    R11,R15
         ICM   R10,B'1111',PPIRCDCT  ZERO FILE ?
         BZR   R14                 YES, RETURN
         ST    R14,SAVER14         NO, SAVE RETURN REGISTER
         L     R10,PPIRD+4         READ ROUTINE
         SR    R3,R3
*
*        ERROR OPTION OVERLAYS
*
         L     R1,PPIOPEN+4        SET UP ERROR OPTION AND
         LA    R15,RGDERROR+4
         LA    R14,AGDERROR+4      LINK TO USER IF E38 ACTIVATED
         CLC   WRDOPT+1(3),KCCW+1
         BE    AGDNOADR            FOR READ ERROR HANDLING
         PPISETON PPIACCPT         SET ACCEPT SKIP SWITCH
         MVC   AE38+1(3),WRDOPT+1  GET ADDR OF USER RTN
         CLI   WRDOPT,X'40'        GET SYNAD CODE
         BL    AGDTERMX            LOW   - TERMINATE
         BE    AGDST001            EQUAL - SKIP
         MVC   AGDACCPT(4),AGDBR   SET ACCEPT IN AP
         MVC   RGDACCPT(4),RGDBR   SET ACCEPT IN R15
         B     AGDST001
*
AGDNOADR MVI   AGDTERM+1,X'F0'     SET TERMINATE IMMEDIATELY
         MVI   RGDTERM+1,X'F0'     IN AP & R15
AGDTERMX PPISETOF PPIACCPT         TURN OFF SKIP ACCEPT SWITCH
         DROP  R1
*
*        CALCULATE AND ALLOCATE SPACE FOR CCW'S AND BLOCK COUNT
*        TABLE
*
AGDST001 L     R1,PPISPGN1
         LA    R1,7(,R1)           MAKE SURE GENERATE CCW'S
         N     R1,KMASK            ON A DOUBLE WORD BOUNDARY
         SH    R1,KEIGHT
         LH    R2,PPIMRGMX         MERGE ORDER
         LR    R0,R2
         SLL   R2,4                SIZE OF CCW'S
         SR    R1,R2
         SLL   R0,1
         STC   R0,RGDK2M+1
         IC    R3,PPILAB03         IF NO BUFFERS > (2*M), RESET NO
         CLR   R3,R0               OF BUFFERS TO 2*M
         BNH   AGDST010
         STC   R0,PPILAB03
AGDST010 IC    R3,PPIBDSVA         TOTAL WORK UNITS
         LA    R3,1(,R3)
         SLL   R3,2                BLOCK COUNTERS AREA IN GENERATED
         LR    R4,R1               CORE
         SR    R1,R3
         ST    R1,PPISPGN1         SAVE UPDATED FREE STORAGE
         ST    R1,PPISBLCT         SET ADDR OF BLOCK COUNT TABLE
*
*        GENERATE OPTIONAL DIAGNOSTIC MESSAGE
*
         PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTICS ?
         BZ    AGDNOMES            NO, BRANCH
         STM   R14,R1,PPILAB01     SAVE REGS
         LR    R0,R4               LOAD NO TO BE CONVERTED
         L     R15,PPICONV+4       LOAD ADDR OF CONVERSION ROUTINE
         BAS   R14,4(R15)          CALL CONVERT RTN
         L     R15,PPIAMC+4
         USING DIERAMC,R15
         MVC   IER945A,2(R1)       MOVE FORMATTED ADDR INTO MSG
         LM    R0,R1,IER945        IER945I INPUT CCW ADDR
         L     R15,PPIADSSC        LOAD ADDR OF PRINT ROUTINE
         BAS   R14,12(,R15)        CALL PRINT RTN
         LM    R14,R1,PPILAB01     RESTORE REGS
         DROP  R15
*
AGDNOMES PPITEST  PPIVAR           VARIABLE LENGTH RECORDS ?
         BO    AGDVR020            YES, BRANCH
         SR    R3,R3               ALL FLAG BITS OFF FOR FIX FORMAT
AGDCCWGN MVC   KCCW+6(2),PPILAB03+2    COUNT
         MVC   KBLKCHR+2(2),PPILAB03+2
         MVI   KCCW+4,SLI          FLAGS
         LR    R3,R4               GENERATE 2*M CCW'S
AGDCCWLP MVC   0(8,R4),KCCW
         LA    R4,8(,R4)           UPDATE GEN AREA POINTER BY SIZE
         BCT   R0,AGDCCWLP         OF A CCW
         LH    R2,PPIMRGMX         MERGE ORDER
         L     R1,PPISTDCB
         LA    R4,PPITPTBL         TAPE TABLE POINTER
         LA    R9,PPIWKARE         SORT WORK AREA
AGDIN030 TM    0(R4),X'80'         SEARCH TAPE TABLE FOR
         BO    AGDIN040            INPUT FILES
         LA    R4,2(,R4)
         B     AGDIN030
*
*        OVERLAYS FOR VARIABLE RECORD FORMAT
*
AGDVR020 MVI   AGDBRVR+1,X'F0'     VARIABLE LENGTH RCD  OVERLAYS
         MVI   RGDBRVR+1,X'F0'     IN ASSG AND IERRGD
         MVI   AGDVRDSP+3,X'08'    FOR THE MERGE RCD ADDR - BYPASS BCC
         MVI   RGDRTRNV+3,X'08'    AND EOS INDICATOR
         B     AGDCCWGN
*
AGDIN040 SR    R6,R6
         IC    R6,1(,R4)          INCR
         STC   R6,0(,R9)          SAVE INCR
         L     R6,0(R6,R1)
         MVI   DCBBUFNO,1         BUFNO IN DCB
         MVC   1(3,R9),DCBIOBAA   SAVE IOB ADDR IN SORT WORK AREA
         LA    R9,4(,R9)          FOR LATER USE TO ATTACH CCW'S
*                                 AND TO PRIME THE BUFFERS
         LA    R4,2(,R4)          UPDATE TAPE TABLE POINTER
         BCT   R2,AGDIN030
*
*        ATTACH THE CCW'S AND START PRIMING THE BUFFERS
*
         LA    R4,PPIWKARE         SORT WORK AREA
         L     R6,PPILAB02         INPUT BUFFER TABLE ADDR
         LH    R7,PPILAB03+2       INPUT BUFFER SIZE
         BCTR  R7,0
         STH   R7,PPILAB01
         LH    R7,PPIMRGMX
AGDIN050 L     R5,0(,R4)           IOB ADDR
         ST    R3,IOBSTART         STORE CCW ADDR IN THE IOB
         L     R1,0(,R6)           STORE DATA ADDR IN
         AH    R1,PPILAB01         CCW (FOR READ BACKWARDS)
         ST    R1,PPISAVEA
         MVC   1(3,R3),PPISAVEA+1
         MVI   4(R3),SLI           TURN SLI BIT ON FOR SHORT BLOCK
*
         IEREXCP  (R5)             READ BACKWARDS
*
         LA    R3,8(,R3)
         L     R15,IOBECBPT        SAVE ALTERNATE CCW
         ST    R3,4(,R15)          ADDR
         LA    R3,8(,R3)           UPDATE CCW, BUFFER,
         LA    R6,4(,R6)           AND IOB POINTERS
         LA    R4,4(,R4)
         BCT   R7,AGDIN050
         LA    R4,PPIWKARE         IOBS IN SORT WORK AREA
         LA    R8,TFCNT            FILE COUNTERS
         IC    R7,PPILAB03         NO OF INPUT BUFFERS MINUS MERGE
         STC   R7,KTOTAL
         SH    R7,PPIMRGMX         ORDER = NO OF ALTERNATE BUFFERS
         BZ    AGDNOVLP            NO OVERLAP
         STH   R7,PPILAB01+12
*
*        PRIME ALTERNATE BUFFERS
*
         LR    R3,R7
         LH    R0,PPISRTBL         FILE COUNTER
         SLL   R0,1                ENTRY IS 2*SORTBLKING
         ST    R0,PPILAB01+4
AGDOVLP  ST    R6,PPILAB01+8       SAVE BUFFER POINTER
         BAS   R9,AGDLK060         WAIT ADDR N SORT WORK AREA BLCNT
         L     R2,PPILAB01+8       BUFFER POINTER
         ST    R4,PPILAB01+16
         L     R6,IOBDCBPT         DCB ADDR
         L     R4,IOBSTART         ATTACH THE ALTERNATE BUFFER TO
         L     R14,IOBECBPT
         MVC   IOBSTART(4),4(R14)  THE FILE
         ST    R4,4(,R14)
         L     R4,IOBSTART         STORE BUFFER ADDR IN
         L     R14,0(,R2)          THE CCW (READ BACKWARDS)
         AH    R14,PPILAB01
         ST    R14,PPISAVEA
         MVC   1(3,R4),PPISAVEA+1
         MVI   DCBBUFNO,2          UPDATE BUFNO
*
         IEREXCP  (R5)             READ BACKWARDS
*
         L     R4,PPILAB01+16
         L     R6,PPILAB01+8
         LA    R6,4(,R6)           UPDATE BUFFER POINTER
AGDOVEND LA    R4,4(,R4)           UPDATE IOB POINTER
         BCT   R3,AGDOVLP
         ST    R6,PPILAB02         SAVE BUFFER POINTER FOR IERRGD USE
         CLC   PPILAB01+12(2),PPIMRGMX
         BZ    AGDRTN              FULL OVERLAP ALL WAITS ISSUED
*
*        PARTIAL OVERLAP ONLY
*
         LH    R3,PPIMRGMX         NEED TO ISSUE WAITS AND PASS ADDR
         SH    R3,PPILAB01+12      IN SORT WORK AREA ON THE FILES
         B     AGDNOVLP+8          WITH NO ALTERNATE BUFFERS
*
AGDNOVLP LH    R3,PPIMRGMX
         ST    R6,PPILAB02         SAVE BUFFER POINTER FOR IERRGD USE
         MVC   PPILAB01+6(2),PPISRTBL  FILE COUNTER ENTRY IS SORTBLK
         BAS   R9,AGDLK060         WAIT ON EACH FILE AND PASS INITIAL
         LA    R4,4(,R4)           UPDATE IOB POINTER
         BCT   R3,AGDLP070         ADDR OF RCDS TO MERGE IN
*                                  SORT WORK AREA SET UP BLCNT
AGDRTN   MVC   KMRGMX(2),PPIMRGMX
         L     R14,SAVER14
         BR    R14                 RETURN TO IERRC9
*
*        WAIT ON M BUFFERS AND ERROR CHECK
*
AGDLK060 L     R6,PPISBLCT         TABLE OF BLOCK COUNTERS FOR DEBLOCK
AGDLP070 L     R5,0(,R4)           IOB ADDR
         L     R1,IOBECBPT
*
         IERWAIT  1,ECB=(1)        WAIT ON IOB COMPLETION
*
         NI    IOBCSTAT,255-IL     TURN OFF INCORRECT LENGTH FLAG
*
*        EOF - ERROR CHECK
*
AGDEE100 TM    IOBUSTAT,UE+UC      UNIT EXCEPTION OR UNIT CHECK ?
         BNZ   RGDEOF              YES, BRANCH
         TM    IOBCSTAT,CDC        CHANNEL DATA CHECK ?
         BO    AGDERROR            YES, BRANCH
AGDEE110 L     R1,KBLKCHR
         L     R2,IOBSTART         STARTING BUFFER ADDR FOR
         LR    R15,R2
         SH    R1,IOBCSW+5         SUBTRACT CSW RESIDUAL COUNT
         L     R2,0(,R2)
         LA    R2,1(,R2)
         SR    R2,R1
         SH    R1,KFOUR
AGDBRVR  NOP   AGDLP075            UNCOND BRANCH IF VAR RCD FORMAT
         MVI   4(R15),X'00'        TURN OFF SLI BIT USED ON SHORT BLOCK
         SR    R14,R14             NEED BLOCK COUNT IF FIX RCD FORMAT
AGDFIX   SH    R1,PPIRCDL2
         LA    R14,1(,R14)
         CH    R1,PPIRCDL2
         BNL   AGDFIX
         LR    R1,R14
*
*        PLACE M RCD ADDRS IN PPI FOR THE MERGE AND M BLOCK
*        COUNTS IN TABL
*
AGDLP075 SR    R15,R15
         IC    R15,0(,R4)          INCR
         MVC   1(3,R8),PPILAB01+5  READ'S FILE COUNTER ENTRY WITH INCR
         STC   R15,0(,R8)          IN HIGH ORDER POSITION
         ST    R1,0(R15,R6)        STORE BLOCK COUNTER IN BLCNT TABLE
         LA    R8,4(,R8)           VIA INCR FOR DEBLOCK
AGDVRDSP LA    R2,4(,R2)           BYPASS EOS INDICATOR PASS ADDR TO
         ST    R2,0(,R4)           MERGE IN SORT WORK AREA
         STC   R15,0(,R4)          STORE INCR IN THE HIGH ORDER BYTE
         BR    R9
*
*        READ ERROR HAS OCCURRED
*
AGDERROR PPISETON PPIREADE         TURN ON ERROR BIT IN PPI
AGDTERM  NOP   AGDSSCBR            SET BY AP IF IMMEDIATE TERM
         L     R1,IOBDCBPT         DCB ADDR
         ST    R5,KCCW             SET IOB ADDR WITH
         MVI   KCCW,X'10'          INCREMENT TO CCW ADDR IN
         L     R0,KCCW             THE HIGH ORDER BYTE
*
*        CALL E38 EXIT
*
*        TERMINATE RTN WILL MAKE SYNAD ERROR MSG CODE THE ABEND CODE
*
         L     R15,AE38
         BASR  R14,R15
AGDSSCBR L     R15,PPIADSSC
         BAS   R14,16(,R15)        TERMINATE RTN, NO RETURN
*
AGDSKIP  OI    IOBFLAG1,IOBCMDCH   ERROR ACCEPTED, RESET ERROR BITS
         NI    IOBCSTAT,255-CDC    IN THE IOB AND DCB
         LR    R15,R6              SAVE REGISTER
         L     R6,IOBDCBPT
         NI    DCBIFLGS,255-DCBIFPEC
         LR    R6,R15
*
AGDACCPT IEREXCP  (R5)             READ NEXT BLOCK INTO
*
         L     R1,IOBECBPT         SAME BUFFER AREA
*
         IERWAIT 1,ECB=(1)
*
AGDBR    B     AGDEE100
*
*        CONSTANTS
*
SAVER14  DC    F'0'
KMASK    DC    X'FFFFFFF8'
KCCW     CCW   READBT,0,SLI,0
KEIGHT   DC    H'8'
*
*        IERAMC
*
DIERAMC  DSECT
*
         COPY  AMCMAIN
*
*        IERRGD
*
DIERRGD  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRGD SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRGDI
*
*        IERAP33
*
IERAP33  DSECT
         DC    23F'0'
WRDOPT   DC    F'0'
         DC    8F'0'
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
*        IERCCWEQ
*
         IERCCWEQ
*
*        IERIOB
*
         IERIOB
*
         PRINT NOGEN
*
         DCBD  DSORG=PS,DEVD=(DA,TA)
*
         IHAECB DSECT=NO,EXT=NO
*
         IEZDEB LIST=NO
*
         PRINT GEN
*
         SMPPI
*
         END
./ ADD NAME=IERAGE   0101-20211-20211-1200-00580-00580-00000-RELEASE 00
AGE      TITLE 'IERAGE - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERAGE
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 3 READ ASSIGNMENT - DISK
*        THIS ASSIGNMENT ROUTINE READS THE DIRECTORY, SETS UP
*        THE CCW'S AND PRIMES THE BUFFERS FOR THE READ DISK
*        ROUTINE. IF THE RECORD FORMAT IS VARIABLE, THE ROUTINE
*        ADJUSTS THE INSTRUCTION LABELED RGEBCC, ETC IN IERRGE.
*        THE MODULE ALSO SETS UP THE TABLE OF BLOCK COUNTERS FOR
*        THE DEBLOCK ROUTINE, AND IT STORES THE TABLE ADDRESS IN
*        PPISBLCT. THE ROUTINE USES AN ERROR CHECK SUBROUTINE
*        LIKE IERRGE. IERAGE SETS UP THE READ ERROR OPTION AS
*        INDICATED TO THE SORT BY EXIT E38
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACROS USED -
*        SMPPI   EXCP   DCBD   WAIT
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                          LOAD  EP=IERAGE,DCB=SORTLIB
*                          LR    R15,R0
*                          BALR  R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIADSSC   PPILAB02
*        PPIBDSVA   PPILAB03
*        PPIBPTRK   PPICNTL
*        PPIENDAR   PPINDSKA
*        PPILAB01   PPIRCDL2
*        PPISEQCT   PPISPGN1
*        PPISRTBL   PPISTDCB
*        PPISTIOB   PPINTL
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPILAB01   PPISBLCT
*        PPILAB02   PPISPGN1
*        PPILAB03   PPIWKARE
*        PPIMRGMX
*
*        EXTERNAL ROUTINES -
*        IERAP3 - OPEN LIST
*
*        EXTERNAL PARAMETERS -
*        IERAP3  - USER READ OPTION
*        PPIPDWA - MERGE PRIME AREA - CONTAINS FIRST RECORDS TO
*                                     BE MERGED
*
*        EXITS - NORMAL -
*        IERRC9 - RETURN VIA R14
*
*        EXITS - ERROR -
*        SORT SYSTEM CONTROL (PPIADSSC) - READ ERROR IF USER
*        OPTION IS TERMINATE
*
*        TABLES/WORK AREAS -
*        PPILAB01 - READING DIRECTORY
*        TFCNT    - TABLE OF FILE COUNTS
*
*        NOTES - THIS MODULE IS FOR DISK ONLY. IT CONTAINS A
*        DSECT OF IERAP3
*
IERAGE   CSECT
*
         USING *,R11
         USING IERAP33,R1          OPEN DSECT
         USING IERRCA,R13          PPIA DSECT
         USING IERRGE,R10          RUNNING PGM DSECT
         USING IOBSTDRD,R5         IOB DSECT
*
         LR    R11,R15
         L     R10,PPIRD+4         READ ROUTINE
         L     R1,PPIOPEN+4        OPEN LIST
         ST    R14,SAVER14         SAVE RETURN REGISTER
*
*        ERROR OPTION OVERLAYS
*
         CLC   WRDOPT+1(3),AE38+1  E38 ACTIVATED ? (WRDOPT HAS ADDR)
         BE    AGENOADR            NO, BRANCH
         MVC   AE38+1(3),WRDOPT+1  YES, MOVE ADDR OF USER ROUTINE
*                                  INTO IERRGE
         PPISETON PPIACCPT         SET ACCEPT SKIP SWITCH
         CLI   WRDOPT,X'40'        TEST SYNAD CODE
         BL    AGETERMX            LOW,   TERMINATION
         BE    AGEST001            EQUAL, SKIP
         MVC   AGEACCPT(4),AGEBR   SET ACCEPT IN AP
         MVC   RGEACCPT(4),RGEBR   SET ACCEPT IN R15
         B     AGEST001            START HSKPING
*
AGENOADR MVI   RGETERM+1,X'F0'     SET IMMEDIATE TERMINATE
         MVI   AGETERM+1,X'F0'     IN AP & IERRGE
AGETERMX PPISETOF PPIACCPT         TURN OFF SKIP ACCEPT SWITCH
         DROP  R1
*
*        ALGORITHM FUNCTION - READ DIRECTORY
*
*        THE ALGORITHM FUNCTIONS OF PHASE TWO ARE BUILT INTO
*        THIS ASSIGNMENT ROUTINE
*
AGEST001 LA    R7,PPIWKARE         R7 -> PPIWKARE FOR WORK AREA
         LA    R8,PPILAB01         R8 -> 64 BYTE DIRECTORY READIN AREA
         STCM  R8,B'0111',KCCWLST+17   STORE IN READ CCW
         LH    R6,PPINDSKA         R6 = NO OF DISK AREAS
         LA    R9,PPISEQCT         R9 -> SEQUENCE COUNT ENTRIES
         SR    R2,R2               ZERO ACCUMULATOR
         LA    R3,PPIENDAR
AGEAREA  LH    R4,0(,R9)           LOAD SEQ CNT FOR THE AREA
         LTR   R4,R4               SEQ CNT ZERO ?
         BZ    AGEUPDTE            YES, BRANCH
         SR    R1,R1
         IC    R1,0(,R3)           GET M INCREMENT FROM PPIENDAR
         L     R5,PPISTDCB         R5 -> DCB LIST TABLE
         L     R15,0(R1,R5)        R15 -> DCB
         USING IHADCB,R15
         L     R5,DCBIOBAD         R5 -> IOB
*
*        SETUP FOR EXCP
*        CONVERT TTR -> MBBCCHHR
*
         STM   R14,12,12(R13)      SAVE REGS ACROSS RTN
         LR    R6,R13              SAVE R13
         SR    R0,R0
         ICM   R0,B'1110',5(R3)    R0 = TTR0 FROM PPIENDAR ENTRY
         L     R1,DCBDEBAD         R1 -> DEB
         LA    R2,DCBFDAD          R2 -> MBBCCHHR RESULT
         L     R15,PPIPCNVT        R15 -> CONVERSION RTN
         BASR  R14,R15             CONVERT TTR -> MBBCCHHR
         LR    R13,R6
         LTR   R15,R15          *  SET CC
         LM    R14,R12,12(R13)  |  RESTORE REGS
         BNZ   AGESSCBR         V  CONVERSION FAILED, TERMINATE SORT
         MVC   IOBSEEK,DCBFDAD     MOVE SEARCH ADDR TO IOB
         DROP  R15
         LA    R1,IOBCC            FOR SEARCH ID
         STCM  R1,B'0111',KCCWLST+1
         AR    R2,R4
         LA    R1,KCCWLST          BE READ
         ST    R1,IOBSTART         STORE CCW LIST ADDR IN THE IOB
*
AGERDDIR IEREXCP  (R5)             READ DIRECTORY INTO PPILAB01
*
         L     R1,IOBECBPT
*
         IERWAIT  1,ECB=(1)        WAIT ON ABOVE READ
*
         L     R1,IOBECBPT
         CLI   0(R1),ECBNORM       SUCCESSFULLY COMPLETED W/O ERROR ?
         BNE   AGESSCBR            NO, TERMINATE JOB
AGENOERR LA    R14,8               BLOCKING FACTOR FOR THE DIRECTORY
AGENOERA MVC   0(8,R7),0(R8)       MOVE DIR ENTRY TO PPIWKARE
         BCT   R4,AGENOERB         SEQ COUNT ZERO ?
         LA    R7,8(,R7)
         B     AGEUPDTE            FINISHED WITH THIS AREA GOTO NEXT
*
AGENOERB LA    R7,8(,R7)           UPDATE WORK AND
         LA    R8,8(,R8)           READ AREA POINTERS
         BCT   R14,AGENOERA        BLOCK PROCESSED ?
         LA    R8,PPILAB01         REINITIALIZE READ AREA POINTER
         MVI   IOBR,2              UPDATE DIR ADDR TO READ SEC BLOCK
         B     AGERDDIR            GOTO READ
*
AGEUPDTE LA    R9,2(,R9)           UPDATE SEQUENCE COUNT
         LA    R3,8(,R3)           UPDATE PPIENDAR ENTRY
         LA    R8,PPILAB01         REINITIALIZE READ AREA POINTER
         BCT   R6,AGEAREA          ALL AREAS PROCESSED ?
         STH   R2,PPIMRGMX         SUM OF SEQ CNTS IS THE MERGE ORDER
*
*        END OF ALG FUNCTION AND READING OF THE DIRECTORY
*
         LTR   R2,R2               ZERO INPUT FILE ?
         BNZ   AGEST010            NO, BRANCH
AGEZERO  L     R14,SAVER14         YES, RETURN TO
         BR    R14                 IERRC9
*
*        CALCULATE AND ALLOCATE SPACE FOR CCW'S AND BLOCK COUNT TABLE
*
AGEST010 L     R1,PPISPGN1         GENERATED CORE ADDR
         LA    R1,7(,R1)           MAKE SURE CCW'S
         N     R1,KMASK
         SH    R1,KEIGHT           START ON DOUBLE WORD BOUNDARY
         LR    R0,R2               MERGE ORDER
         SLL   R2,4                SPACE FOR CCW'S
         LR    R3,R2               =3(16*M)
         AR    R2,R3
         AR    R2,R3
         SR    R1,R2
         SLL   R0,1
         STC   R0,RGEK2M+1         2*M FOR OVERLAP TEST IN R.PGM.
         SR    R3,R3
         IC    R3,PPILAB03         IF NO. OF BUFFERS.G.(2*M),RESET NO.
         CLR   R0,R3                 TO (2*M)
         BNL   *+8                 BR AROUND <=
         STC   R0,PPILAB03
         IC    R3,PPIBDSVA         TOTAL WORK UNITS
         LA    R3,1(,R3)
         SLL   R3,2                ALLOCATE SPACE IN GENERATED CORE
         LR    R4,R1               FOR THE TABLE OF BLOCK COUNTERS
         LH    R9,PPIMRGMX
         SR    R1,R3
         ST    R1,PPISPGN1         SAVE UPDATED ADDR OF FREE STORAGE
         ST    R1,PPISBLCT         SET ADDR OF BLOCK COUNT TABLE
*
*        GENERATE OPTIONAL DIAGNOSTIC MESSAGE
*
         PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTICS ?
         BZ    AGENOMES            NO, BRANCH
         STM   R14,R1,PPILAB01     SAVE REGISTERS
         LR    R0,R4               LOAD NO TO BE CONVERTED
         L     R15,PPICONV+4       LOAD ADDR OF CONVERSION ROUTINE
         BAS   R14,4(,R15)         CALL CONVERT
         L     R15,PPIAMC+4
         USING DIERAMC,R15
         MVC   IER945A,2(R1)       MOVE FORMATTED ADDR INTO MSG
         LM    R0,R1,IER945        IER945I INPUT CCW ADDR
         L     R15,PPIADSSC        LOAD ADDR OF PRINT ROUTINE
         BAS   R14,12(,R15)        CALL MESSAGE WRITER
         LM    R14,R1,PPILAB01     RESTORE REGISTERS
         DROP  R15
*
AGENOMES PPITEST  PPIVAR           VARIABLE LENGTH RECORDS ?
         BO    AGEVR050            YES, BRANCH
AGECCW   L     R6,PPISTIOB         TABLE OF INPUT IOBS
         MVC   KCCWLST+22(2),PPILAB03+2
         L     R7,PPILAB02         TABLE OF INPUT BUFFER ADDR
         LA    R8,PPIWKARE         DISK ADDR FOR READING DIR
*
*        BEGIN PRIMING LOOP
*
AGECCWGN L     R5,0(,R6)           IOB ADDR
*
*        INITIALIZE CCW STRING
*
         LA    R15,IOBCC           SET IOBCC FOR SEARCH ID EQ
         STCM  R15,B'0111',KCCWLST+1
         STCM  R4,B'0111',KCCWLST+9   SET UP FIRST LIST
         ST    R4,IOBSTART         ATTACH FIRST LIST TO IOB
         MVC   0(24,R4),KCCWLST
         MVC   17(3,R4),1(R7)      STORE BUFFER ADDR IN CCW LIST
         LA    R4,24(,R4)
         STCM  R4,B'0111',KCCWLST+9  SET UP SECOND LIST
         MVC   0(24,R4),KCCWLST
         L     R14,IOBECBPT        SAVE ALTERNATE LIST ADDR AT ECB+4
         ST    R4,4(,R14)
         MVI   4(R14),1            NO OF BUFFERS ATTACHED
         LA    R4,24(,R4)          UPDATE GEN AREA FOR CCW'S
         LA    R6,4(,R6)                  IOB TABLE
         LA    R7,4(,R7)                  BUFFER TABLE
*
*        LOCATE DCB
*
         L     R15,IOBDCBPT        R15 -> DCB FROM IOB
         USING IHADCB,R15
*
*        SETUP FOR EXCP
*        CONVERT TTR -> MBBCCHHR
*
         STM   R14,12,12(R13)      SAVE REGS ACROSS RTN
         LR    R3,R13              SAVE R13
         SR    R0,R0
         ICM   R0,B'1110',5(R8)    R0 = TTR0 DISK ADDR FOR READING DIR
         L     R1,DCBDEBAD         R1 -> DEB
         LA    R2,DCBFDAD          R2 -> MBBCCHHR RESULT
         L     R15,PPIPCNVT        R15 -> CONVERSION RTN
         BASR  R14,R15             CONVERT TTR -> MBBCCHHR
         LR    R13,R3
         LTR   R15,R15          *  SET CC
         LM    R14,R12,12(R13)  |  RESTORE REGS
         BNZ   AGESSCBR         V  CONVERSION FAILED, TERMINATE SORT
         MVC   IOBSEEK,DCBFDAD     MOVE SEARCH ADDR TO IOB
         DROP  R15
*
         IEREXCP  (R5)             PRIME THE BUFFER
*
         LA    R8,8(,R8)           INCR DISK ADDR IN PPIWKARE
         BCT   R9,AGECCWGN         ALL M FILES BEEN PRIMED ?
*
*        TEST FOR NO OF ALTERNATE BUFFERS AVAILABLE
*        WAIT ON M BUFFERS, CHECK FOR ERRORS, PASS RECORD ADDR TO
*        MERGE, PLACE BLOCK COUNT IN TABLE VIA INCR (RANGES FROM
*        0 TO 4M-4), AND PRIME ALTERNATES
*
         SR    R2,R2               INCR FOR ACCESSING IOB'S AND BLCNT
*                                  (RANGES FROM 0 TO 4M-4)
         L     R6,PPISTIOB         TABLE OF INPUT IOBS
         LA    R3,PPIWKARE         POINTER TO PPI WHERE STORE RCD ADDR
         LA    R4,TFCNT            TABLE OF FILE COUNTERS
         IC    R9,PPILAB03
         STC   R9,KTOTAL
         SH    R9,PPIMRGMX
         STH   R9,PPILAB01         NO OF ALTERNATES
         BZ    AGENOVLP            NO OVERLAP
*
*        PRIME ALTERNATE BUFFERS
*
         LH    R0,PPISRTBL         FILE COUNTER
         SLL   R0,1                ENTRY IS 2*SORT BLKING
         ST    R0,PPILAB01+4
AGEAL020 BAS   R8,AGEWAIT          WAIT ON PREVIOUS EXCP REQUEST
         L     R15,IOBSTART
         L     R14,16(,R15)        R14 -> READDATA CCW I/O BUFFER
AGEEOS   CLI   1(R14),C'G'         EOS INDICATOR SET IN I/O BUFFER ?
         BE    AGENEXTO            YES, DON'T ISSUE ANOTHER READ
         L     R14,IOBECBPT        NO, ATTACH THE ALTERNATE BUFFER
         MVC   IOBSTRTB,5(R14)     TO THE FILE VIA THE ALTERNATE
         ST    R15,4(0,R14)        CCW LIST
         MVI   4(R14),X'02'        UPDATE NO OF BUFFERS ATTACHED
         L     R15,IOBSTART
         MVC   17(3,R15),1(R7)     STORE BUFFER ADDR IN CCW LIST
*
         IEREXCP  (R5)             READ
*
         LA    R7,4(,R7)           BUFFER POINTER
AGENEXTO LA    R6,4(,R6)           UPDATE IOB POINTER
         BCT   R9,AGEAL020         WAIT FOR EACH OVERLAP
         ST    R7,PPILAB02         SAVE BUFFER POINTER FOR RP'S USE
         CLC   PPILAB01(2),PPIMRGMX  IF FULL OVERLAP
         BE    AGERTN                ALL WAITS HAVE BEEN ISSUED
*
*        PARTIAL OVERLAP ONLY
*
         LH    R9,PPIMRGMX         NEED TO ISSUE WAITS AND PASS ADDR
         SH    R9,PPILAB01         IN PPI ON THOSE FILES WITH NO
         B     AGENOVLP+8          ALTERNATE BUFFERS
*
AGENOVLP LH    R9,PPIMRGMX
         ST    R7,PPILAB02         SAVE BUFFER POINTER FOR RP'S USE
         MVC   PPILAB01+6(2),PPISRTBL  FILE COUNTER ENTRY IS SRTBLK
         BAS   R8,AGEWAIT          WAIT ON PREVIOUS EXCP REQUEST
AGENEXT  LA    R6,4(,R6)           UPDATE IOB ADDR
         BCT   R9,AGEWAIT          WAIT FOR EACH SINGLE
AGERTN   L     R14,SAVER14         RETURN TO
         MVC   KMRGMX,PPIMRGMX     MOVE INTO IERRGE
         BR    R14                 IERRC9
*
*        WAIT ROUTINE
*
AGEWAIT  L     R5,0(,R6)           IOB ADDR
         L     R1,IOBECBPT
*
         IERWAIT  1,ECB=(1)        WAIT ON IOB
*
*        ERROR CHECK
*
         L     R1,IOBECBPT
         CLI   0(R1),ECBNORM       SUCCESSFULLY COMPLETED W/O ERROR ?
         BNE   AGERESET            NO, CHECK FOR PURGE
AGEWT035 MVC   1(3,R4),PPILAB01+5  YES, READ'S FILE COUNTER ENTRY WITH
         STC   R2,0(,R4)           INCR IN HIGH ORDER POSITION
         LH    R1,PPILAB03+2       OBTAIN
         SH    R1,IOBCSW+5         SUBTRACT CSW RESIDUAL COUNT
         SH    R1,KFOUR            (EOS'S 4 BYTES)
AGEVR    NOP   AGELP040            UNCOND BRANCH IF VAR RCD FORMAT
         SR    R14,R14
AGEFIX   SH    R1,PPIRCDL2         NEED BLOCK CNT IF FIX RCD FORMAT
         LA    R14,1(,R14)
         CH    R1,PPIRCDL2
         BNL   AGEFIX              CONTINUE TILL ZERO
         LR    R1,R14
AGELP040 L     R15,PPISBLCT
         ST    R1,0(R2,R15)        STORE BLOCK COUNTER IN BLCNT TABLE
         L     R15,IOBSTART
         L     R15,16(,R15)        OBTAIN BUFFER ADDR
AGEVRDSP LA    R15,4(,R15)         BYPASS EOS (AND BCC IF VAR)
         ST    R15,0(,R3)          STORE ADDR IN PPI FOR MERGE
         STC   R2,0(,R3)           STORE INCR IN HIGH ORDER BYTE OF
         LA    R2,4(,R2)           RCD ADDR
         LA    R3,4(,R3)           UPDATE INCR, PPIWKARE, AND
         LA    R4,4(,R4)           TFCNT POINTER
*
*        DISK ADDR - MBBCCHHR
*        UPDATE THE IOB'S DISK ADDR FOR THE NEXT READ ON IT
*
AGETRKNO CLC   IOBR,PPIBPTRK+1     TRACK FULL ?
         BE    AGEUPH              YES, BRANCH
AGEUPR   IC    R15,IOBR            NO, JUST UPDATE RECORD NUMBER
         LA    R15,1(,R15)
         STC   R15,IOBR
         BR    R8                  RETURN TO CALLER
*
AGEUPH   MVI   IOBR,X'01'          RESET RECORD TO 1 ON NEXT TRACK
*
*        LOCATE THE DCB
*
         L     R15,IOBDCBPT        R15 -> DCB
         USING IHADCB,R15
*
*        SETUP FOR EXCP
*        CONVERT MBBCCHHR -> TTR
*
         STM   R14,12,12(R13)      SAVE REGS ACROSS RTN
         LR    R3,R13              SAVE R13
         L     R1,DCBDEBAD         R1 -> DEB
         LA    R2,IOBSEEK          R2 -> MBBCCHHR
         L     R15,PPIPRLTV        R15 -> CONVERSION RTN
         BASR  R14,R15             CONVERT MBBCCHHR -> TTR
         LR    R13,R3              RESTORE R13
         LTR   R15,R15          *  SET CC
         LM    R14,R15,12(R13)  |  RESTORE REGS, DO NOT RESTORE R0
         LM    R1,R12,24(R13)   |
         BNZ   AGESSCBR         V  CONVERSION FAILED, TERMINATE SORT
*
*        INCR TT
*
         AL    R0,ADDTRKA          INCR TT ONLY IN TTRN
*
*        SETUP FOR EXCP
*        CONVERT TTR -> MBBCCHHR
*
         STM   R14,12,12(R13)      SAVE REGS ACROSS RTN
         LR    R3,R13              SAVE R13
         L     R1,DCBDEBAD         R1 -> DEB
         LA    R2,DCBFDAD          R2 -> MBBCCHHR RESULT
         L     R15,PPIPCNVT        R15 -> CONVERSION RTN
         BASR  R14,R15             CONVERT TTR -> MBBCCHHR
         LR    R13,R3
         LTR   R15,R15          *  SET CC
         LM    R14,R12,12(R13)  |  RESTORE REGS
         BNZ   AGESSCBR         V  CONVERSION FAILED, TERMINATE SORT
         MVC   IOBSEEK,DCBFDAD     MOVE UPDATED SEARCH ADDR TO IOB
         BR    R8                  RETURN TO MAINLINE
*
         DROP  R15
*
*        OVERLAYS FOR VARIABLE RECORD FORMAT
*
AGEVR050 MVI   AGEVR+1,X'F0'       VARIABLE LENGTH RCD OVERLAYS
         MVI   AGEEOS+3,X'05'
         MVI   AGEVRDSP+3,X'08'    IN THE ASSG AND RUNNING PGM
         MVI   RGEEOSCK+3,X'05'    TO INCLUDE THE 4 BYTE BCC
         MVI   RGEFBV+3,X'05'      WHEN CONSIDERING THE DISPLACEMENT
         MVI   RGERTRNV+3,X'08'    FROM THE START OF A BUFFER
         MVC   RGEVBCC+2(2),RGEINST1+2
         MVI   RGEACCV+3,X'05'
         MVI   AGEACCV+3,X'05'
         MVI   RGEVBCC+9,X'F0'
         MVI   RGEBF010+3,X'05'
         MVI   RGEAL025+11,X'05'
         B     AGECCW              RETURN TO MAINLINE
*
AGEERROR PPISETON PPIREADE         TURN ON ERROR BIT IN PPI
AGETERM  NOP   AGESSCBR
         L     R1,IOBDCBPT         DCB ADDR
         ST    R5,KCCWLST          SET IOB ADDR WITH
         MVI   KCCWLST,X'10'       INCREMENT TO CCW ADDR IN
         L     R0,KCCWLST          THE HIGH ORDER BYTE
*                                  LINK TO USER IS OVERLAYED IF NOT
*        CALL  E38                 ACTIVATED
*
         L     R15,AE38
         BASR  R14,R15
AGESSCBR L     R4,20(R5)           PICK UP DCB ADDR FROM IOB
         L     R15,PPIADSSC
         BAS   R14,16(,R15)        EXIT TO TERMINATE, NO RETURN
*
AGESKIP  NI    IOBUSTAT,255-UC-UE  ERROR ACCEPTED
         NI    IOBCSTAT,255-CDC
         L     R15,IOBDCBPT        RESET ALL ERROR BITS SET BY IOS
         USING IHADCB,R15
         NI    DCBIFLGS,255-DCBIFPEC IN THE IOB AND DCB
         L     R1,DCBDEBAD         R1 -> DEB
         USING DEBBASIC,R1
         LA    R1,DEBUSRPG         POINT TO FIRST PURGED IOB ADDR
         DROP  R1,R15
*
         IERESTOR (1)              RESTORE SVC
*
         OI    IOBFLAG1,IOBCMDCH   SET COMMAND CHAINING ON
AGEACCPT L     R1,IOBSTART
         L     R1,16(,R1)          THE BLOCK TO BE
AGEACCV  CLI   1(R1),C'$'
         BE    AGEEOSER            EQUAL, BRANCH
*
         IEREXCP  (R5)             READ NEXT BLOCK INTO
*
         B     AGEWAIT+4           GOTO WAIT
AGEBR    B     AGEWT035            USED FOR OVERLAY WITH ACCEPT OPT
*
AGEEOSER LH    R15,PPIMRGMX        CHECK FOR ZERO
         BCT   R15,*+4             MERGE
         B     AGEZERO             YES, EXIT TO RC9
         STH   R15,PPIMRGMX        ALLOW UNUSED BUFFER TO BE
         LH    R15,KCOUNT          PUT ON LIST TO BE USED BY IERRGE
         LA    R15,1(,R15)         TO ATTACH TO FILE'S WITH NO ALT
         STH   R15,KCOUNT          UPDATE LIST'S COUNT
         SH    R7,KFOUR            AND POINTER
         ST    R7,PPILAB02
         L     R15,IOBSTART        OBTAIN BUFFER ADDR FROM CCW LIST
         L     R15,16(,R15)        R15 -> READDATA CCW I/O BUFFER
         ST    R15,0(,R7)          PLACE BUFFER ADDR ON LIST
         LH    R15,PPILAB01
         BCTR  R15,0               DECREMENT
         STH   R15,PPILAB01
         CLC   PPILAB01+6(2),PPISRTBL
         BNE   AGENEXTO            GOTO NEXT IOB
         B     AGENEXT             UPDATE IOB ADDR AND LINK TO WAIT
*                                  ON THE NEXT FILE R8 STILL CONTAINS
*                                  ITS RETURN ADDR
AGERESET CLI   0(R1),ECBREPRG      I/O REQUEST PURGED ?
         BNE   AGEERROR            NO, ERROR CONDITION
*
*        REQUEST PURGED DUE TO I/O ERROR ON OTHER READ
*        RESTORE REQUEST QUEUE
*
         L     R15,IOBDCBPT
         USING IHADCB,R15
         NI    DCBIFLGS,255-DCBIFPEC  RESET I/O ERROR FLAGS
         OI    IOBFLAG1,IOBCMDCH   SET COMMAND CHAINING ON
         L     R1,DCBDEBAD         R1 -> DEB
         USING DEBBASIC,R1
         LA    R1,DEBUSRPG         POINT TO FIRST PURGED IOB ADDR
         DROP  R1
         IERESTOR (1)              RESTORE SVC
         B     AGEWAIT+4           GOTO WAIT
*
*        CONSTANTS
*
KCCWLST  CCW   SEARIDEQ,0,SLI+CC,5     +00
         CCW   TIC,KCCWLST,SLI+CC,0    +08
         CCW   READDATA,0,SLI,64       +16
*
SAVER14  DC    F'0'                SAVE RETURN ADDR
ADDTRKA  DC    X'00010000'         ADD 1 TO TTRN
KMASK    DC    X'FFFFFFF8'         DOUBLE WORD ALIGN
KEIGHT   DC    H'8'                EIGHT
*
         DROP  R10,R11
*
*        IERAMC
*
DIERAMC  DSECT
*
         COPY  AMCMAIN
*
*        IERRGE
*
IERRGE   DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRGE SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRGEI
*
*        IERAP33
*
IERAP33  DSECT
         DC    23F'0'              OPEN LIST
WRDOPT   DC    9F'0'               OPEN DSECT
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
*        IERCCWEQ
*
         IERCCWEQ
*
*        IERIOB
*
         IERIOB
*
         PRINT NOGEN
*
         DCBD  DSORG=PS,DEVD=(DA,TA)
*
         IHAECB DSECT=NO,EXT=NO
*
         IEZDEB LIST=NO
*
         PRINT GEN
*
         SMPPI
*
         END
./ ADD NAME=IERAGF   0101-20211-20211-1200-00148-00148-00000-RELEASE 00
AGF      TITLE 'IERAGF - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERAGF
*
*        MODULE FUNCTION/OPERATION-
*        THIS MODULE IS A MERGE ONLY ASSIGNMENT ROUTINE. IT
*        OPENS ALL OF THE INPUT FILES
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACROS USED BY MODULE -
*        BUILDS
*        OPEN
*        DCBD
*        SMPPI
*
*        ENTRY POINTS - ENTRY FROM LOAD MODULE
*                       CALLING SEQUENCE -
*                         LOAD  EP=IERAGF,DCB=(1)
*                         LR    R15,R0
*                         BALR  R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIMRGMX   PPISTDCB   PPILAB03
*        PPILAB02   PPIWKARE   PPIAMC
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED - PPIWKARE
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL - RETURN TO IERRC9
*
*        EXITS - ERROR -
*        IERRCV - GOTO TERMINATE JOB ON AN UNSUCCESSFUL OPEN
*
*        TABLES/WORK AREAS -
*        PPIWKARE - WORK AREA
*        WSAVE    - SAVE AREA FOR THE IERRC9 RETURN ADDR
*
*        NOTES - THIS MODULE IS FOR ALL MERGE ONLY RUNS
*
IERAGF   CSECT
*
         USING *,R11
         USING IERRCA,R13
         USING IHADCB,R2           DCB DSECT
         USING IERAMC,R15          MESSAGE MODULE
*
         LR    R11,R15
         ST    R14,SAVER14         SAVE RETURN ADDR
         LH    R4,PPIMRGMX         MERGE ORDER
         L     R5,PPISTDCB         ADDR OF DCB TABLE
         SR    R3,R3
         IC    R3,PPILAB03         TOTAL NO OF INPUT BUFFERS
         LH    R6,PPILAB03+2       L'INPUT BUFFERS
         ICM   R6,B'0100',KBUFF2   SET TWO BUFFERS
         L     R7,PPILAB02         ADDR OF INPUT BUFFER TABLE
*
*        BUILD 2 BUFFERS FOR EACH INPUT FILE THAT IS OPENED
*
AGFOP010 LA    R5,4(,R5)           UPDATE DCB TABLE POINTER
         CLR   R3,R4               NO OF INPUT BUFFERS TO MERGE ORDER
         BE    AGFOP020            BRANCH TO BUILD 1 BUFFER
         BAS   R8,AGFBUILD         BUILD 2 BUFFERS FOR THIS FILE
         MVI   PPIWKARE,2
         BAS   R8,AGFOPEN          OPEN THE INPUT FILE
         LA    R7,8(,R7)           UPDATE BUFFER TABLE POINTER
         BCTR  R3,0
         BCTR  R3,0
         BCT   R4,AGFOP010
*
         B     AGFEXIT             BRANCH TO EXIT
*
*        BUILD 1 BUFFER FOR EACH INPUT FILE THAT IS OPENED
*
AGFOP020 ICM   R6,B'0100',KBUFF1   SET ONE BUFFER
         BAS   R8,AGFBUILD         BUILD 1 BUFFER FOR THIS FILE
         MVI   PPIWKARE,1
         BAS   R8,AGFOPEN          OPEN THE INPUT FILE
         LA    R7,4(,R7)           UPDATE THE BUFFER AND DCB
         LA    R5,4(,R5)           TABLE POINTERS
         BCT   R4,AGFOP020+4
AGFEXIT  L     R14,SAVER14         RESTORE RETURN ADDR
         BR    R14                 RETURN TO IERRC9
*
*        BUILD ROUTINE
*
AGFBUILD LR    R1,R7               BUFFER ADDR LIST
         ST    R1,PPIWKARE
         LR    R0,R6               NO OF BUFFERS AND L'BUFFERS
*
         BUILDS (1),(0)            BUILD THE BUFFERS
*
         BR    R8
*
*        OPEN ROUTINE
*
AGFOPEN  L     R2,0(,R5)           OBTAIN THE FILE'S DCB ADDR
         L     R9,PPIWKARE
         MVC   DCBBUFCA,1(R9)      CONTROL BLOCK ADDR TO DCB
         MVC   DCBBUFNO,PPIWKARE   NUMBER OF BUFFERS TO DCB
         L     R15,PPIAMC+4        LOAD BASE REGISTER FOR MSG CSECT
         MVC   IER063B,DCBDDNAM    MOVE DDNAME INTO MESSAGE
*
         OPEN  ((R2))              OPEN THE FILE
*
         LTR   R15,R15             OPEN SUCCESSFUL ?
         BZR   R8                  YES, BRANCH
*
*        OPEN UNSUCCESSFUL
*
         L     R15,PPIAMC+4        LOAD BASE REGISTER FOR MESSAGE MOD
         L     R1,IER063
         MVC   PPIABMNO,3(R1)      MOVE MSG NO INTO ABEND NO
         LM    R0,R1,IER063        R0 -> MSG, R1 = L'MSG
         L     R15,PPIADSSC        R15 -> MSG PRINT ROUTINE
         BAS   R14,12(,R15)        CALL PRINT MESSAGE RTN
         L     R15,PPIADSSC        LOAD ADDR OF TERMINATE ROUTINE
         BAS   R14,16(,R15)        BRANCH TO ABORT THE JOB, NO RETURN
*
*        CONSTANTS
*
KBUFF1   DC    X'01'
KBUFF2   DC    X'02'
*
SAVER14  DC    F'0'                SAVE AREA FOR IERRC9 RETURN ADDR
*
*        DSECTS
*
IERAMC   DSECT
*
         COPY  AMCMAIN
*
*        REGISTERA AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         PRINT NOGEN
*
         DCBD  DSORG=PS
*
         PRINT GEN
*
         END
./ ADD NAME=IERAGG   0101-20211-20211-1200-00619-00619-00000-RELEASE 00
AGG      TITLE 'IERAGG - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERAGG
*
*        MODULE FUNCTION/OPERATION -
*        THE FUNCTION OF THIS MODULE IS TO GENERATE ONE DATA
*        CONTROL BLOCK FOR EACH WORK UNIT ON THE TAPE TABLE.
*        THE TABLE WILL BE INTERROGATED TO DETERMINE IF THE DATA
*        CONTROL BLOCK IS FOR AN INPUT OR OUTPUT DEVICE
*
*        ONE IOB AND ONE ECB WILL BE GENERATED FOR EACH INPUT
*        FILE WITH THE INTERNAL ADDRESS POINTERS SET. THERE WILL
*        BE A SINGLE IOB AND ECB GENERATED FOR ALL OUTPUT FILES.
*        THE IOB WILL POINT TO THE FIRST OUTPUT DCB GENERATED AND
*        ALL OUTPUT DATA CONTROL BLOCKS WILL POINT TO THE SINGLE
*        OUTPUT IOB
*
*        THE MODULE WILL ALSO INTERROGATE THE PPI TO DETERMINE
*        IF USER EXITS HAVE BEEN ACTIVATED. IF EXITS HAVE BEEN
*        ACTIVATED, THE MODULE WILL GO TO THE USER FOR THE OPTION
*        LISTS. THE OPTIONS WILL THEN BE USED TO MODIFY THE
*        APPROPRIATE DATA CONTROL BLOCK FIELDS
*
*        THE ADDRESSES OF ALL DATA CONTROL BLOCKS GENERATED WILL
*        BE PLACED ON BOTH THE OPEN LIST AND DCB ADDRESS TABLE
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT N/A
*
*        MACROS USED BY MODULE - SMPPI DCB
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                       CALLING SEQUENCE -
*                           LOAD EP=IERAGG,DCB=
*                           LR      R15,R0
*                           BALR    R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIBDSVA   PPITPTBL   PPIADSSC
*        PPICNTL    PPIDDSRT   PPIAMA
*        PPIDEPHO   PPIX28     PPIX29
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPISPGN1   PPISTDCB
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS -
*        PPIOPEN+4 - OPEN LIST ADDR
*        PPIAMB+4  - MESSAGE MODULE ADDR
*
*        EXITS - NORMAL - RETURN TO LOAD MODULE IERRC9
*                         BR    R14
*
*                       - EXIT TO USER READ OPTION ROUTINE
*                         L     R15,PPIX28+4
*                         BR    R15
*
*                       - EXIT TO USER WRITE OPTION ROUTINE
*                         L     R15,PPIX29+4
*                         BR    R15
*
*        EXITS - ERROR -
*        PPIAMB+4 - ILLEGAL OPTION NUMBER SPECIFIED BY USER
*
*        TABLES/WORK AREAS - N/A
*
*        NOTES -
*        THIS MODULE IS RESTRICTED TO TAPE OPERATION ONLY
*
IERAGG   CSECT
*
         USING *,R11               MODULE BASE REG
         USING IERRCA,R13          PPI
         USING DIERAMB,R14         BASE REG FOR MESSAGE MODULE DSECT
         USING OPENLST,R15         BASE REG FOR OPEN LIST DSECT
*
         LR    R11,R15             SET BASE REGISTER
         ST    R12,SAVER14         SAVE RETURN ADDR
         PPITEST  PPIREADF         READ FORWARD PASS ?
         BZ    AGGXDD              NO, BYPASS OVERLAY
         MVC   MODIOB+36(2),K1     SET TAPE BLOCK CNT INCR
*                                  IN MODEL IOB (IOBINCAM-IERIOB)
*
*        SET UP WORKING PARAMETERS FOR TAPE OPERATION
*
AGGXDD   LA    R5,PPITPTBL         R5 -> TAPE TABLE
         SR    R2,R2               INPUT FLAG COUNTER
         SR    R3,R3               OPEN FLAG COUNTER
         SR    R1,R1
         IC    R1,PPIBDSVA         NO OF SLOTS IN DCB ADDR TABLE
AGG100   TM    0(R5),X'80'         INPUT FLAG ON ?
         BZ    AGG102              NO, BRANCH
         LA    R2,1(,R2)           INCREMENT INPUT FLAG COUNT
AGG102   TM    0(R5),X'40'         OPEN FLAG ON ?
         BZ    AGG104              YES, INCREMENT COUNT
         LA    R3,1(,R3)           INCREMENT OPEN FLAG COUNT
AGG104   LA    R5,2(,R5)           UPDATE TAPE TABLE POINTER
         BCT   R1,AGG100           ENTIRE TABLE BEEN CHECKED ?
*
*        ENTIRE TAPE TABLE HAS BEEN CHECKED FOR INPUT AND OPEN FLAGS
*
*        CHECK IF BALANCED OR POLYPHASE OPERATION
*
AGG106   PPITEST  PPIBALN          BALANCED SORT ?
         BO    AGG107              YES, BRANCH
*
*        SET PARAMETERS FOR A POLYPHASE SORT
*
         ST    R3,WNUMDCB          NO OF DCBS TO GENERATE
         ST    R3,WNUMIOB          NO OF IOBS TO GENERATE
         B     AGG108              BUILD OPEN LIST
*
*        SET PARAMETERS FOR A BALANCED SORT
*
AGG107   ST    R3,WNUMDCB          NO OF DCBS TO GENERATE
         ST    R2,WINPDCB          NO OF INPUT DCBS TO GENERATE
         LA    R2,1(,R2)
         ST    R2,WNUMIOB          NO OF IOBS TO GENERATE
*
*        PUT TOTAL NUMBER OF DCBS TO BE OPENED AS THE FIRST ENTRY
*        IN THE OPEN LIST
*
AGG108   L     R2,PPIOPEN+4        OPEN LIST ADDR
         ST    R3,0(,R2)           NO OF ENTRIES TO OPEN
         LA    R2,4(,R2)
         ST    R2,WPARLST          R2 = FIRST ADDR SLOT OF OPEN LIST
*
*        ALIGN START OF GENERATED CORE TO A FULL WORD BOUNDRY
*
         L     R4,PPISPGN1
         SRL   R4,2
         SLL   R4,2
*
*        ALLOCATE CORE FOR DCBS, IOBS, ECBS AND TABLES
*
*        COMPUTE CORE REQUIRED FOR DATA CONTROL BLOCKS
*
         SR    R6,R6
         L     R7,WNUMDCB          NO OF DCBS TO GENERATE
         LA    R8,SORTWKL          L'SORTWK DCB
         MR    R6,R8
         SR    R4,R7               R7 = TOTAL DCB BYTES REQUIRED
         ST    R4,WDCBADR          START OF DCB CORE AREA
*
*        COMPUTE CORE REQUIRED FOR IOBS, ECBS AND ALT CCW
*        POINTERS
*
         SR    R6,R6
         L     R7,WNUMIOB          NO OF IOBS TO GENERATE
         LA    R8,MODIOBL          SIZE OF EACH IOB WITH PREFIX
         MR    R6,R8
         SR    R4,R7               R7 = TOTAL BYTES REQUIRED
         ST    R4,WIOBPREA         START OF PREFIXED IOB CORE AREA
         LR    R3,R1               SAVE R1
*
*        COMPUTE CORE REQUIRED FOR DCB ADDR TABLE
*
         SR    R1,R1
         IC    R1,PPIBDSVA         TOTAL NO OF WORK UNITS
         LA    R1,1(,R1)           INCREASE BY ONE
         SLL   R1,2
         SR    R4,R1
         ST    R4,WDCBTAB          START OF DCB ADDR TABLE
         ST    R4,PPISPGN1         UPDATE PPI
         ST    R4,PPISTDCB         UPDATE PPI
*
*        GENERATE OPTIONAL IER924 DIAGNOSTIC MESSAGE
*
         PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTICS ?
         BZ    AGGNOMES            NO, BRANCH
         L     R14,PPIAMB+4
         LR    R0,R4               LOAD ADDR TO BE CONVERTED
         L     R15,PPICONV+4       LOAD ADDR OF CONVERSION ROUTINE
         BAS   R14,4(,R15)         CALL CONVERT RTN
         L     R14,PPIAMB+4
         MVC   IER924A,2(R1)       MOVE FORMATTED ADDR INTO MSG
         LM    R0,R1,IER924        IER924I DCB TABLE ADDR
         L     R15,PPIADSSC        LOAD ADDR OF PRINT ROUTINE
         BAS   R14,12(,R15)        CALL PRINT MSG RTN
*
*        SET INDICATOR BIT IN FIRST BYTE OF ALL DCB ADDR TABLE
*        SLOTS
*
AGGNOMES LA    R6,X'800'
         SLL   R6,20               R6 = X'80000000'
         SR    R1,R1
         IC    R1,PPIBDSVA         TOTAL NO OF WORK UNITS
         LA    R1,1(,R1)           INCREASE BY ONE
AGGMARK  ST    R6,0(,R4)
         LA    R4,4(,R4)           UPDATE DCB TABLE POINTER
         BCT   R1,AGGMARK          ALL INDICATORS STORED ?
*
*        SET ECB ADDR IN ASSOCIATED IOB
*
AGGECB   L     R10,WNUMIOB         NO OF IOBS TO GENERATE
         L     R4,WIOBPREA         START OF PREFIXED IOB AREA
         LA    R8,MODIOB           R8 -> IOB
         USING IERIOB,R8
AGG01    ST    R4,IOBECBPT         ECB ADDR IN IOB MODEL
         MVC   0(MODIOBL,R4),MODIOB    MOVE PREFIXED IOB MODEL INTO
*                                  ALLOCATED CORE
         BCT   R10,AGG02           ALL IOB MODELS STORED ?
         B     AGG03               YES
*
AGG02    LA    R4,MODIOBL(,R4)     UPDATE IOB ADDR POINTER
         B     AGG01               LOOP CONTINUE IOB GENERATION
*
*        STORE START OF INPUT IOBS AND THE ADDR OF THE SINGLE
*        OUTPUT IOB FOR LATER REFERENCE
*
AGG03    LR    R8,R4               R8 -> IOB PREFIX AREA
         LA    R4,8(,R4)           INCREMENT PAST PREFIX
         ST    R4,WIOBOUT          ACTUAL OUTPUT IOB ADDR W/O PREFIX
         MVC   IOBINCAM,K1         MOVE PLUS 1 INTO IOB BLK INCREMENT
         L     R4,WIOBPREA
         LA    R4,8(,R4)           INCR PAST IOB PREFIX
         ST    R4,WIOBIN           START OF INPUT IOBS
         MVI   WINDIC,X'01'        SET FLAG TO IND INPUT DCB GEN PHASE
*
*        SETUP FOR DCB INITIALIZATION
*
         LA    R5,SORTWK           R5 -> MODEL DCB
         USING IHADCB,R5
         MVC   DCBDDNAM(L'PPIDDSRT),PPIDDSRT  SET DDNAME PREFIX
*
*        GOTO INPUT DCB INITIALIZATION SUBROUTINE AND RETURN
*
         BAS   R14,AGGINITL        GOTO DCB INIT
*
*        RETURN POINT FROM INPUT DCB INITIALIZATION SUBROUTINE
*
*        CHECK IF USER EXIT E28 IS ACTIVATE
*
AGGRTRN1 PPITEST  PPIME28          USER EXIT E28 ACTIVATE ?
         BO    AGGGOUSR            YES, SET UP LINKAGE
*
*        SET UP PARAMETERS AND BEGIN DCB GENERATION
*
AGGRTRN2 L     R1,WDCBTAB          DCB ADDR TABLE
         L     R2,WPARLST          OPEN LIST ENTRY SLOT
         L     R4,WDCBADR          R4 -> DCB ADDR
         L     R8,WIOBIN           R8 -> INPUT IOBS
         USING IOBSTDRD,R8         SET IOB ADDRESSING PAST PREFIX
*
*        BALANCED OR POLYPHASE SORT OPERATION ?
*
         PPITEST  PPIBALN          BALANCED SORT ?
         BO    AGGBAL01            YES, BRANCH
*
*        POLYPHASE OPERATION - BEGIN DCB GENERATION
*
AGGPOL04 SR    R10,R10
         IC    R10,PPIBDSVA        NO OF WORK UNITS TO CHECK
         LA    R6,PPITPTBL         R6 -> TAPE TABLE
         BCTR  R10,0               REDUCE COUNT BY 1
AGGPOL05 TM    0(R6),X'40'         OPEN FLAG ON ?
         BO    AGGPOL76            YES
         B     AGGPOL10            NO
*
*        PUT IOB ADDR INTO DCB MODEL
*        PUT DCB ADDR INTO IOB
*
AGGPOL76 ST    R4,IOBDCBPT         DCB ADDR IN IOB
AGGPOL77 ST    R8,DCBIOBAD         IOB ADDR IN DCB
*
*        GET OFFSET FROM TAPE TABLE AND CONVERT IT TO DCB DDNAME
*
AGGPOL07 SR    R14,R14
         IC    R14,1(R6)           GET OFFSET FROM TAPE TABLE
         SRL   R14,1
         LH    R14,DDTABLE(R14)    GET DDNAME CHAR SUFFIX FROM DDTABLE
         STH   R14,DCBDDNAM+6      STORE DD SUFFIX INTO DCBDDNAM
         SR    R14,R14
         IC    R14,1(R6)           GET OFFSET FROM TAPE TABLE
         ST    R4,0(R1,R14)        DCB ADDR IN TABLE+OFFSET
         ST    R4,0(,R2)           DCB ADDR IN OPEN LIST
         TM    WINDIC,X'01'        INPUT DCB GENERATION PHASE ?
         BO    AGGPOL20            YES
         B     AGGPOL21            NO
*
AGGPOL20 MVI   0(R2),X'80'         INPUT DCB ADDR FLAG
AGGPOL21 MVC   0(SORTWKL,R4),SORTWK  MOVE DCB INTO ALLOCATED CORE
         TM    WINDIC,X'01'        INPUT DCB GENERATION PHASE ?
         BO    AGGPOL22            YES
         PPITEST  PPIBALN          BALANCED SORT ?
         BO    AGGBAL07            YES
         B     AGGFIN              NO, SET UP LINKAGE TO NEXT
*                                  SEQUENTIAL MODULE
AGGPOL22 LA    R2,4(,R2)           UPDATE OPEN LIST POINTER
         LA    R8,MODIOBL(,R8)     UPDATE IOB ADDR POINTER
         LA    R4,SORTWKL(,R4)     UPDATE DCB ADDR POINTER
AGGPOL10 LA    R6,2(,R6)           UPDATE TAPE TABLE POINTER
         PPITEST  PPIBALN          BALANCED SORT ?
         BO    AGGBAL04            YES
         BCT   R10,AGGPOL05        ALL INPUT DCBS GENERATED ?
*
*        SET FLAG TO INDICATE OUTPUT DCB GENERATION PHASE
*
         MVI   WINDIC,X'00'
*
*        GOTO OUTPUT DCB GENERATION SUBROUTINE AND RETURN
*
         LA    R14,AGGRTRN5
         B     AGGINITL            GOTO OUTPUT DCB INIT
*
*        RETURN POINT FROM OUTPUT DCB GENERATION SUBROUTINE
*
*        CHECK IF USER EXIT E29 IS ACTIVE
*
AGGRTRN5 PPITEST  PPIME29          USER EXIT E29 ACTIVATE ?
         BO    AGGGOUSR            YES, BRANCH
*
*        RETURN POINT FROM USER OPTION ROUTINE
*
AGGPOL70 L     R8,WIOBOUT          OUTPUT IOB ADDR
         B     AGGPOL76            STORE IOB ADDR
*
*        SET UP LINKAGE TO NEXT SEQUENTIAL MODULE AND BRANCH
*
AGGFIN   L     R14,SAVER14         RESTORE RETURN ADDR
         BR    R14                 RETURN TO IERRC9
*
*        BALANCED SORT OPERATION - BEGIN DCB GENERATION
*
AGGBAL01 L     R10,WINPDCB         NO OF INPUT DCBS TO GENERATE
         LA    R6,PPITPTBL         R6 -> TAPE TABLE
*
*        BEGIN SCANNING THE TAPE TABLE FOR PROPER BITS
*
AGGBAL02 TM    0(R6),X'80'         INPUT FLAG ON ?
         BO    AGGBAL03            YES, BRANCH
         LA    R6,2(,R6)           NO, UPDATE TABLE POINTER
         B     AGGBAL02            CONTINUE CHECKING
*
*        PUT IOB ADDR IN DCB MODEL PUT DCB ADDR IN IOB
*
AGGBAL03 B     AGGPOL76            STORE IOB ADDR
*
AGGBAL04 BCT   R10,AGGBAL02        ALL INPUT DCBS GENERATED ?
*
*        SET FLAG TO INDICATE OUTPUT DCB GENERATION PHASE
*
         MVI   WINDIC,X'00'
*
*        GOTO OUTPUT DCB GENERATION SUBROUTINE AND RETURN
*
         LA    R14,AGGRTRN6
         B     AGGINITL            GOTO OUTPUT DCB INIT
*
*        RETURN POINT FROM OUTPUT DCB GENERATION SUBROUTINE
*
*        CHECK IF USER EXIT E29 IS ACTIVE
*
AGGRTRN6 PPITEST  PPIME29          USER EXIT E29 ACTIVATE ?
         BO    AGGGOUSR            YES, BRANCH
AGGBAL05 LA    R6,PPITPTBL         R6 -> TAPE TABLE
         L     R10,WNUMDCB         TOTAL NO OF DCBS
         S     R10,WINPDCB         R10 = NO OF OUTPUT DCBS TO GEN
AGGBAL06 TM    0(R6),X'80'         INPUT FLAG ON ?
         BO    AGGBAL09            YES, BRANCH
         TM    0(R6),X'40'         OPEN FLAG ON ?
         BO    AGGPOL77            YES, BRANCH
         B     AGGBAL09            NO
*
AGGBAL07 BCT   R10,AGGBAL08        ALL OUTPUT DCBS GENERATED ?
         B     AGGBAL10            YES
*
AGGBAL08 LA    R4,SORTWKL(,R4)     UPDATE DCB ADDR POINTER
         LA    R2,4(,R2)           UPDATE OPEN LIST POINTER
AGGBAL09 LA    R6,2(,R6)           UPDATE TAPE TABLE POINTER
         B     AGGBAL06            CONTINUE TABLE CHECK
*
*        ALL OUTPUT DCBS GENERATED, PUT DCB ADDR INTO IOB
*
AGGBAL10 SR    R2,R2
         IC    R2,PPIDEPHO+3
         L     R6,WDCBTAB          DCB ADDR TABLE STARTING ADDR
         L     R3,0(R2,R6)         R3 = DEPHO DCB ADDR
         L     R8,WIOBOUT          OUTPUT IOB ADDR
         ST    R3,IOBDCBPT         DCB ADDR IN OUTPUT IOB
         B     AGGFIN              BARNCH TO RETURN PROCESSING
*
*        DCB INITIALIZATION SUBROUTINE
*
*        USED FOR BOTH INPUT AND OUTPUT DCB GENERATION
*
AGGINITL STM   R1,R10,WREGSAVE     SAVE REGS
         TM    WINDIC,X'01'        INPUT GENERATION PHASE ?
         BO    AGGINT01            YES, BRANCH
*
*        OUTPUT DCB INITIALIZATION SUBROUTINE
*
*        ZERO OUT USER MODIFICATION FIELDS
*
         XC    DCBEXLSA,DCBEXLSA
         XC    DCBEODAD,DCBEODAD
*
*        SET UP BFTEK AND BFALN FIELDS
*
         MVI   DCBBFTEK,DCBBFTS    SIMPLE BUFFERING
         PPITEST  PPISWA           SINGLE WORD BUFFER ALIGNMENT ?
         BO    AGGOUT04            YES, BRANCH
         OI    DCBBFTEK,DCBBFAD    NO, DOUBLE WORD ALIGNMENT
         B     AGGCOMM             RETURN
*
AGGOUT04 OI    DCBBFTEK,DCBBFAF1   FULL WORD ALIGNMENT
         B     AGGCOMM             RETURN
*
*        INPUT DCB INITIALIZATION SUBROUTINE
*
AGGINT01 MVI   DCBIFLG,DCBIFER     USE IOS ERROR ROUTINES
*
*        SET UP BFTEK AND BFALN FIELDS
*
         OI    DCBBFTEK,DCBBFTS    SIMPLE BUFFERING
         PPITEST  PPISWA           SINGLE WORD BUFFER ALIGNMENT ?
         BO    AGGINT06            YES, BRANCH
         OI    DCBBFTEK,DCBBFAD    NO, DOUBLE WORD ALIGNMENT
         B     AGGCOMM             RETURN
*
AGGINT06 OI    DCBBFTEK,DCBBFAF1   FULL WORD ALIGNMENT
AGGCOMM  LM    R1,R10,WREGSAVE     RESTORE REGISTERS
         BR    R14                 RETURN TO MAIN PROGRAM
*
*        CALL USER EXIT E28/E29
*
*        THE EXIT RETURNS WITH THE ADDR OF THE USER OPTION LIST
*        THE MODEL DCB WILL BE MODIFIED ACCORDING TO THE OPTIONS
*        SPECIFIED ON THE LIST
*
*        USER OPTION LIST
*
*          BYTE 1      BYTE 2      BYTE 3      BYTE 4
*         _______________________________________________
*        |           |                                   |
*        | X'01'     | ADDR OF USER PROVIDED SYNAD I/O   |
*        |           | ERROR ROUTINE                     |
*        |___________|___________________________________|
*        |           |                                   |
*        | X'02'     | ADDR OF USER PROVIDED DCB DCBEXLSA|
*        |           | LIST                              |
*        |___________|___________________________________|
*        |           |           |           |           |
*        | X'03'     | 0         | 0         | DCBERROPT |
*        |           |           |           | FLAG BYTE |
*        |___________|___________|___________|___________|
*        |           |                                   |
*        | X'04'     | DCB EODAD ROUTINE                 |
*        |           |                                   |
*        |___________|___________________________________|
*        |           |                                   |
*        | X'00'     | TERMINATING ENTRY IN LIST         |
*        |           |                                   |
*        |___________|___________________________________|
*
*
AGGGOUSR STM   R1,R10,WREGSAVE     SAVE REGS ACROSS USER EXIT CALL
         TM    WINDIC,X'01'        INPUT DCB EXIT ?
         BO    AGGUSR01            YES, BRANCH
         L     R15,PPIX29+4        NO, USER WRITE OPTION ADDR
         B     AGGUSR02            SKIP USER READ OPTION
*
AGGUSR01 L     R15,PPIX28+4        USER READ OPTION ADDR
AGGUSR02 BASR  R14,R15             CALL USER EXIT
*
         LR    R8,R1               R8 -> OPTION LIST
         L     R15,PPIOPEN+4       OPEN LIST ADDR
AGGSTMOD SR    R4,R4
         ICM   R4,B'0001',0(R8)    GET USER OPTION NUMBER FROM LIST
         BZ    AGGUSR04            TERMINATING ENTRY ? BRANCH
         CH    R4,KOPTMAX          CHECK OPTION NUMBER > LEGAL VALUE ?
         BH    AGGUSR3A            NOT LEGAL - CHECK IF FIRST OPTION
*                                  ERROR
         SLL   R4,2                CONVERT TO OFFSET FOR BRANCH TABLE
         B     *(R4)               BRANCH TABLE
         B     AGGTREA             +04 SYNAD (OPTION 01)
         B     AGGTRECH            +08 EXLST (OPTION 02)
         B     AGGONECH            +12 EROPT (OPTION 03)
*
AGGUSR03 LA    R8,4(,R8)           UPDATE USER LIST POINTER
         B     AGGSTMOD            CONTINUE MODIFICATIONS
*
AGGUSR3A TM    WFRSTERR,X'01'      FIRST OPTION ERROR ?
         BO    AGGUSR03            NO, BRANCH
         MVI   WFRSTERR,X'01'      YES, SET INDICATOR
         B     AGGERR              GOTO MESSAGE MOD
*
*        MODIFICATIONS COMPLETE, RETURN TO CALLER
*
AGGUSR04 LM    R1,R10,WREGSAVE     RESTORE REGS
         MVI   WFRSTERR,X'00'      RESTORE FIRST OPTION ERROR INDIC
         TM    WINDIC,X'01'        RETURN TO INPUT ROUTINE ?
         BO    AGGRTRN2            YES, BRANCH
         PPITEST  PPIBALN          BALANCED SORT OPERATION ?
         BO    AGGBAL05            YES, BRANCH
         B     AGGPOL70            NO
*
*        SYNAD OPTION
*
AGGTREA  TM    WINDIC,X'01'        INPUT DCB ?
         BO    AGGTREB             YES, BRANCH
         MVC   WRTOPT+1(3),1(R8)   MOVE ADDR TO OPENLST
         B     AGGUSR03
*
AGGTREB  MVC   WRDOPT+1(3),1(R8)   MOVE ADDR TO OPENLST
         B     AGGUSR03
*
*        EXLST OPTION
*
AGGTRECH MVC   DCBEXLSA,1(R8)      UPDATE DCBEXLSA
         B     AGGUSR03
*
*        EROPT OPTION
*
AGGONECH TM    WINDIC,X'01'        INPUT DCB ?
         BO    AGGONEA             YES, BRANCH
         B     AGGUSR3A            ILLEGAL OPTION
*                                  EROPT OPTION
AGGONEA  MVC   WRDOPT(1),3(R8)     MOVE ERROPT TO OPENLST
         B     AGGUSR03
*
*        GENERATE ERROR MESSAGE IER044
*
AGGERR   L     R14,PPIAMB+4        MESSAGE MODULE ADDR
         LM    R0,R1,IER044
         TM    WINDIC,X'01'        INPUT DCB ?
         BO    AGGERR01            YES, BRANCH
         MVC   IER044A,KTAG+2
         B     AGGERR02            EXIT
*
AGGERR01 MVC   IER044A,KTAG
AGGERR02 L     R15,PPIADSSC
         BAS   R14,12(,R15)        CALL MESSAGE WRITER
         B     AGGUSR03            RETURN TO USER MODIFICATION RTN
*
*        CONSTANTS
*
KOPTMAX  DC    H'3'                MAXIUM USER OPTION NUMBER
*
DDTABLE  DC    C'0001020304050607080910111213141516171819'
         DC    C'20212223242526272829303132'
*
KTAG     DC    C'2829'             EXIT IDENTITIES FOR MSGS
*
*        IOB MODEL USED BY THE PROGRAM
*
MODIOB   DC    10F'0'              STANDARD 32 BYTE TAPE IOB PLUS
*                                  SORT/MERGE 8 BYTE PREFIX
MODIOBL  EQU   *-MODIOB            L'MODIOB
         ORG   MODIOB+36           (IOBINCAM-IERIOB)
         DC    H'-1'               TAPE BLOCK INCREMENT
         ORG
*
K1       DC    H'1'
*
*        WORK AREAS
*
WINPDCB  DC    F'0'                NO OF INPUT DCBS TO GENERATE
WNUMDCB  DC    F'0'                NUMBER OF DCBS TO GENERATE
WPARLST  DC    F'0'                NEXT OPEN SLOT IN OPEN LIST
WDCBADR  DC    F'0'                START OF DCB AREA
WIOBPREA DC    F'0'                START OF PREFIXED IOB CORE AREA
WIOBOUT  DC    F'0'                ADDR OF OUTPUT IOB
WIOBIN   DC    F'0'                START OF INPUT IOB CORE AREA
WINDIC   DC    F'0'                INDICATOR FOR INPUT OR OUTPUT
*                                  GENERATION PHASE
WFIRST   DC    F'0'                INDICATOR FOR FIRST OUTPUT DCB
WUSRLST  DC    F'0'                TEMP STORAGE FOR USER OPTION WORD
WNUMIOB  DC    F'0'                NO OF IOBS TO GENERATE
WDCBTAB  DC    F'0'                STARTING ADDR OF DCB ADDR TABLE
WFRSTERR DC    F'0'                FIRST OPTION ERROR INDICATOR
WREGSAVE DC    12F'0'              REG SAVE AREA
SAVER14  DC    F'0'                R14 SAVE AREA
*
*        GENERATE MODEL SORTWK DCB TO BE USED WITH THE PROGRAM
*
SORTWK   DCB   MACRF=(E),DSORG=PS,DDNAME=SORTWK,REPOS=Y
*
         DC    F'0'                AREA APPENDED TO EXCP DCB
*                                  REFERENCED AS DCBOPTCD
*
SORTWKL  EQU   *-SORTWK            L'SORTWK DCB
*
*        MODULE NAME - IERAMB
*
*        THIS MODULE CONTAINS ALL OF THE MESSAGES THAT ARE
*        REQUIRED FOR PHASE 2 ASSIGNMENT MODULES
*
DIERAMB  DSECT
*
         COPY  AMBMAIN
*
*        OPEN LIST DSECT USED BY MODULE
*
OPENLST  DSECT
         DC    33F'0'              OPEN LIST
WRDOPT   DC    F'0'                OPEN LIST
WRTOPT   DC    F'0'                OPEN LIST
         DC    10F'0'              OPEN LIST
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         IERIOB
*
         SMPPI
*
*        DATA CONTROL BLOCK DSECT USED BY MODULE
*
         PRINT NOGEN
*
         DCBD  DSORG=(PS),DEVD=(TA)
*
         PRINT GEN
*
         END
./ ADD NAME=IERAGH   0101-20211-20211-1200-00199-00199-00000-RELEASE 00
AGH      TITLE 'IERAGH - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERAGH
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 3 ASSIGNMENT MODULE - TAPE OR DISK
*        INTERROGATE PPI AND INITIATE A CHECKPOINT OPERATION IF
*        IT HAS BEEN SPECIFIED. THE MODULE WILL THEN OPEN ALL
*        INPUT FILES ASSOCIATED WITH THE FINAL MERGE PHASE. THE
*        MODULE IS USED FOR TAPE READ BACKWARDS AND TAPE/DISK
*        READ FORWARDS DEVICE HANDLING
*
*        MODULES IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACROS USED - CHKPT
*        OPEN
*        SMPPI
*        DCB
*        DCBD
*
*        ENTRY POINTS - ENTRY FROM IERRC9 VIA
*                          LOAD  EP=IERAGH,DCB=SORTLIB
*                          LR    R15,R0
*                          BALR  R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIRCDCT PPICNTL
*
*        OUTPUT - ALL INPUT FILES ARE OPEN
*
*        EXTERNAL ROUTINES -
*        IERAP3 - OPEN LIST
*        IERAMC - MESSAGE MODULE
*        IERRCV - SORT SYSTEM CONTROL
*
*        EXTERNAL PARAMETERS -
*        IERAP3 - OPEN LIST
*        IERRCV - R0 -> MESSAGE
*                 R1 = L'MESSAGE
*
*        EXITS - NORMAL -
*        IERRC9 - RETURN TO LOAD ROUTINE VIA R0
*
*        EXITS - ERROR - IERRCV - OPEN UNSUCCESSFUL
*
*        TABLES/WORK AREAS -
*        IERAP3  - LIST OF DCB ADDRS
*        RETADDR - RETURN ADDR
*
*        NOTES - THIS MODULE IS ALWAYS EXECUTED IN PHASE 3
*
IERAGH   CSECT
*
         USING *,R11               MODULE BASE REG
         USING IERRCA,R13          PPI COMMON MODULE BASE REGISTER
         USING IHADCB,R2           DCB MAPPING
         USING IERAMC,R15          MESSAGE MODULE
*
         IERENTRY 'IERAGH &SYSDATE &SYSTIME'
*
IERMGH   LR    R11,R15             SET BASE REG
         ST    R14,RETADDR         SAVE RETURN REG
         LA    R2,SORTCKPT
         MVC   DCBDDNAM(4),PPIDDSRT   PLACE DDNAME PREFIX INTO DCB
*
*        SET UP FOR THE NUMBER OF INPUT FILES TO BE OPENED
*
AGH02    L     R4,PPIOPEN+4        OPEN LIST ADDR (SEE IERAP3)
         LA    R4,16(,R4)          UPDATE IERAP3 POINTER TO THE NUMBER
*                                  OF ENTRIES SLOT IN OPEN LIST
         L     R3,0(,R4)           R3 = NO OF ENTRIES IN OPEN LIST
         BCTR  R3,0                REDUCE LIST COUNT BY 1
*
*        CHECK FOR ZERO RECORDS
*
         ICM   R1,B'1111',PPIRCDCT  GET RECORD COUNT, ZERO ?
         BZ    AGHCOMM             BYPASS THE OPEN ROUTINE
         LA    R4,4(,R4)           UPDATE IERAP3 LIST POINTER
*                                  TO ADDR OF FIRST DCB TO OPEN
*
*        TAPE OR DISK OPERATION SPECIFIED
*
AGH04    PPITEST  PPITAPE          TAPE OPERATION ?
         BO    AGH06               YES, BRANCH
*
*        DISK OPERATION
*
*        BEGIN OPENING THE SPECIFIED INPUT FILES
*
AGH05    LA    R4,4(,R4)           UPDATE IERAP3 OPEN LIST POINTER TO
*                                  BYPASS FIRST ENTRY
         L     R2,0(,R4)           R2 -> INPUT DCB
         L     R15,PPIAMC+4        MOVE DDNAME TO ERROR MESSAGE IN CASE
         MVC   IER063B,DCBDDNAM    OF OPEN FAILURE
*
         OPEN  ((R2),(INPUT,REREAD))   OPEN SORTWKXX
*
         TM    DCBOFLGS,DCBOFOPN   OPEN SUCCESSFULL ?
         BZ    AGHERR              NO, ERROR
         BCT   R3,AGH05            YES, OPEN LIST COMPLETED ?
         B     AGHCOMM             ALL COMPLETE, BRANCH
*
*        TAPE OPERATION
*
*        BEGIN OPENING THE SPECIFIED INPUT FILES
*
AGH06    PPITEST  PPIREADF         READ FORWARD ?
         BO    AGH05               YES, OPEN WITH REREAD OPTION AS
*                                       WITH DIRECT ACCESS
AGH06A   LA    R4,4(,R4)           UPDATE OPEN LIST POINTER
         L     R2,0(,R4)           R2 -> INPUT DCB
         L     R15,PPIAMC+4        MOVE DDNAME TO ERROR MESSAGE IN CASE
         MVC   IER063B,DCBDDNAM    OF OPEN FAILURE
*
         OPEN  ((R2),RDBACK)
*
         TM    DCBOFLGS,DCBOFOPN   OPEN SUCCESSFULL ?
         BZ    AGHERR              NO, ERROR
         BCT   R3,AGH06A           YES, OPEN LIST COMPLETED ?
*                                  YES
         DROP  R2
*
*        ENTIRE LIST HAS BEEN COMPLETED - LINK TO NEXT MODULE
*
*        THIS SECTION OF CODE RESTORES THE BLOCK COUNTS IF IT IS
*        A TAPE SORT AND LINKS TO THE CHECKPOINT MODULE IF
*        CHECKPOINT HAS BEEN INDICATED
*
AGHCOMM  PPITEST  PPITAPE          TAPE SORT ?
         BZ    AGH400              NO, NO BLOCK COUNTS TO BE RESTORED
         PPITEST  PPIREADF         READ FORWARD ?
         BO    AGH400              YES, DO NOT RESTORE BLOCK COUNTS
         SR    R1,R1               ZERO REGISTER
         IC    R1,PPIBDSVA         LOAD NUMBER OF WORK UNITS
         LA    R2,PPITPTBL         LOAD START ADDR OF TAPE TABLE
*
*        LOOP TESTING THE INPUT BIT FOR EACH UNIT
*
*        IF THE INPUT BIT IS ON, THE BLOCK COUNT FOR THAT UNIT IS
*        MOVED INTO THE DCBBLKCT FIELD OF THE DCB ASSOCIATED
*        WITH THAT UNIT
*
AGH100   PPITEST  PPIPOLY          POLYPHASE ?
         BO    AGH200              YES, DON'T TEST INPUT BIT
         TM    0(R2),X'80'         INPUT BIT ON FOR THIS UNIT ?
         BZ    AGH300              NO, BRANCH TO TEST NEXT UNIT
AGH200   TM    0(R2),X'40'         OPEN BIT SET FOR THIS UNIT ?
         BZ    AGH300              NO, DO NOT RESTORE BLOCK COUNT
         SR    R3,R3
         L     R4,PPISTDCB         R4 -> DCB TABLE
         IC    R3,1(,R2)           LOAD INCREMENT
         L     R4,0(R3,R4)         R4 -> DCB
         LA    R5,PPIENDAR         LOAD STARTING ADDR OF SAVE AREA
         AR    R5,R3               GET ADDR OF BLOCK COUNT FOR UNIT
         USING IHADCB,R4
         MVC   DCBBLKCT,0(R5)      MOVE BLK CNT FROM SAVE AREA TO DCB
AGH300   LA    R2,2(,R2)           INCR TAPE TABLE ADDR
         BCT   R1,AGH100           ALL UNITS TESTED ? LOOP AGAIN
AGH400   PPITEST  PPICHKPT         CHECKPOINT ACTIVATED ?
         BZ    AGHCOMM1            NO CHECKPOINT
         L     R15,PPICHKAD        R15 -> CHECKPOINT MODULE
         BASR  R14,R15             CALL CHECKPOINT
AGHCOMM1 L     R14,RETADDR         RETURN TO
         BR    R14                 IERRC9
*
*        GENERATE ERROR MESSAGE
*
AGHERR   L     R15,PPIAMC+4        OPEN UNSUCCESSFUL
         L     R1,IER063           R1 -> MSG TEXT
         MVC   PPIABMNO,3(R1)      MOVE MSG NO INTO ABEND NO
         LM    R0,R1,IER063        IER063A OPEN ERROR
         L     R15,PPIADSSC
         BAS   R14,12(,R15)        CALL MSG WRITER
         L     R15,PPIADSSC
         BAS   R14,16(,R15)        TERMINATE THE JOB, NO RETURN
*
RETADDR  DC    F'0'                RETURN ADDR
*
SORTCKPT DCB   MACRF=(W),DSORG=PS,DDNAME=SORTCKPT
*
         PRINT NOGEN
*
         DCBD  DEVD=(DA,TA),DSORG=(XA,XE)
*
         PRINT GEN
*
IERAMC   DSECT
*
         COPY  AMCMAIN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERAGI   0101-20211-20211-1200-00501-00501-00000-RELEASE 00
AGI      TITLE 'IERAGI - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERAGI
*
*        MODULE FUNCTION/OPERATION -
*        THE FUNCTION OF THIS MODULE IS TO GENERATE ONE
*        INPUT DCB AND ONE OUTPUT DCB FOR EACH ACTIVATED
*        ENTRY OF THE DISK TABLE. A SINGLE ECB AND IOB WILL BE
*        GENERATED AND ALL OUTPUT DCBS WILL POINT TO IT. THE IOB
*        WILL POINT TO THE DCB SPECIFIED BY THE DEPHO INCREMENT
*
*        THE MODULE WILL ALSO INTERROGATE PPI TO DETERMINE IF
*        USER EXITS HAVE BEEN ACTIVATED. IF EXITS HAVE BEEN
*        SPECIFIED, THE MODULE WILL GOTO THE USER FOR THE OPTION
*        LISTS. THE OPTIONS WILL THEN BE USED TO MODIFY THE
*        APPROPRIATE DCB FIELDS IN THE GENERATED DCBS
*
*        THE ADDRESSES OF ALL DCBS GENERATED WILL BE PLACED
*        IN BOTH THE OPEN LIST AND THE DCB ADDR TABLE
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACROS USED BY THIS MODULE -
*        SMPPI   DCB
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                       CALLING SEQUENCE -
*                          LOAD EP=IERAGI, DCB=
*                          LR    R15,R0
*                          BALR  R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPILAB03   PPILAB06   PPICNTL
*        PPISTAR    PPINDSKA   PPIADSSC
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPISPGN1   PPISTDCB   PPISTIOB
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS -
*        PPIOPEN+4 - OPEN LIST ADDRESS
*        PPIAMA+4  - MESSAGE MODULE ADDR
*
*        EXITS - NORMAL - RETURN TO IERRC9
*                         BR    R14
*
*                       - EXIT TO USER READ OPTION ROUTINE
*                         L     R15,PPIX18+4
*                         BR    R15
*
*                       - EXIT TO USER WRITE OPTION ROUTINE
*                         L     R15,PPIX19+4
*                         BR    R15
*
*        EXITS - ERROR -
*        DCBSYNAD - UNCORRECTABLE QSAM READ ERROR
*        PPIAMA+4 - ILLEGAL OPTION NUMBER SPECIFIED BY USER
*
*        TABLES/WORK AREAS -
*        DDTABLE - TABLE OF SORTWK DDNAME SUFFIXES
*        WDCBADR - STARTING ADDR OF DCB AREA
*        WIOBADR - STARTING ADDR OF IOB AREA
*        WECBADR - STARTING ADDR OF ECB AREA
*        WDCBTAB - ADDR OF DCB ADDR TABLE
*
*        NOTES -
*        THIS MODULE IS RESTRICTED TO DASD OPERATION ONLY
*
IERAGI   CSECT
*
         USING *,R11               MODULE BASE REG LOADED EXTERNALLY
         USING IHADCB,R12          BASE REGISTER FOR DCB DSECT
         USING IERRCA,R13          PPI COMMON MODULE BASE REGISTER
         USING DIERAMA,R14         BASE REG FOR MESSAGE MODULE DSECT
         USING DIERAP1,R15         BASE REG FOR OPEN LIST DSECT
*
         IERENTRY 'IERAGI &SYSDATE &SYSTIME'
*
*
         LR    R11,R15             SET BASE REGISTER
         ST    R14,SAVER14         SAVE RETURN ADDR
*
*        SET UP WORKING PARAMETERS FOR DASD OPERATION
*
         L     R4,PPIOPEN+4        R4 -> OPEN LIST ADDR (IERAP1)
         LH    R1,PPINDSKA         R1 = NO OF DISK AREAS SPECIFIED
         ST    R1,0(,R4)           NO OF DCBS TO OPEN IN FIRST WORD OF
*                                  IERAP1
         LA    R4,4(,R4)           UPDATE OPEN LIST POINTER LOCATION
         ST    R4,WPARLST          FIRST OPEN ENTRY IN OPEN LIST
         BCTR  R1,0                DECR NO OF SORTWORK DCBS
         ST    R1,WNUMDCB          NO OF SORTWORK DCBS TO GENERATE
*
*        COMPUTE STORAGE REQUIRED FOR DCBS, IOBS, ECBS AND TABLES
*
         L     R4,PPISPGN1         START OF GENERATED CORE
         SRL   R4,2
         SLL   R4,2                ALIGN TO FULL WORD BOUNDRY
         LA    R1,SORTINL          L'SORTIN DCB SIZE
         SR    R6,R6
         L     R7,WNUMDCB          NO OF SORTWK DCBS
         LA    R8,SORTWKL          SORTWK DCB SIZE
         MR    R6,R8               R7 = TOTAL SORTWK DCB BYTES
         AR    R1,R7               R1=TOTAL SORTIN AND SORTWK DCB BYTES
         SR    R4,R1
         ST    R4,WDCBADR          START OF DCB AREA
         LA    R0,MODIOBL-8        L'IOB MINUS S/M PREFIX
         SR    R4,R0
         ST    R4,WIOBADR          START OF IOB PROPER AREA
         LA    R3,8
         SR    R4,R3
         ST    R4,WECBADR          START OF IOB PREFIX AREA
         LA    R3,7*4              MAX NO OF DCB ADDR TABLE SLOTS
*                                  CONVERTED TO WORDS
         SR    R4,R3
         ST    R4,WDCBTAB          START OF DCB ADDR TABLE
         ST    R4,PPISPGN1         UPDATE START OF GEN CORE
         ST    R4,PPISTDCB         STORE STARTING ADDR OF DCB TABLE
*
*        GENERATE OPTIONAL IER906I DCB TABLE ADDR MSG
*
         PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTICS ?
         BZ    AGINOMES            NO, BRANCH
         LR    R0,R4               LOAD ADDR TO BE CONVERTED
         L     R15,PPICONV+4       LOAD ADDR OF CONVERSION ROUTINE
         BAS   R14,4(,R15)         CALL CONVERSION ROUTINE
         L     R14,PPIAMA+4        MSG MODULE
         MVC   IER906A,2(R1)       MOVE FORMATTED ADDR INTO MSG
         LM    R0,R1,IER906        IER906I DCB TABLE ADDR
         L     R15,PPIADSSC        LOAD ADDR OF PRINT ROUTINE
         BAS   R14,12(,R15)        CALL PRINT MSG RTN
*
*        SET INDICATOR BIT IN FIRST BYTE OF ALL DCB ADDR TABLE
*        SLOTS
*
AGINOMES L     R0,INDWORD          X'80000000'
         LA    R3,7                7 DCB TABLE ADDR SLOTS
AGI03    ST    R0,0(,R4)
         LA    R4,4(,R4)           UPDATE POINTER
         BCT   R3,AGI03            LOOP THROUGH TABLE
*
*        GENERATE SORTIN DCB, CHECK FOR USER MODIFICATION
*        OPTIONS, MOVE COMPLETED DCB INTO ALLOCATED CORE, STORE
*        ADDRS AND UPDATE PROPER POINTERS
*
AGI05    MVI   WINDIC,X'01'        SET INDICATOR FOR SORTIN DCB
         B     AGIINITL            GO OUT AND RETURN FROM THE DCB
*                                  INITIALIZATION SUBROUTINE
*
*        CHECK IF USER EXIT E18 IS ACTIVE
*
AGIRTRN1 PPITEST  PPIME18          EXIT E18 ACTIVE ?
         BO    AGIGOUSR            YES, BRANCH
*
*        SET UP PARAMETERS AND MOVE GENERATED DCB INTO ALLOCATED
*        STORAGE
*
AGIMVIN  L     R1,WDCBTAB          START OF DCB ADDR TABLE
         L     R2,WPARLST          FIRST ADDR SLOT OF OPEN LIST
         L     R4,WDCBADR          FIRST ACTUAL DCB ADDR
         MVC   0(SORTINL,R4),SORTIN  MOVE INPUT DCB INTO ALLOCATED CORE
*
*        STORE DCB ADDR INTO PROPER LISTS AND UPDATE PARAMETERS
*
         ST    R4,0(,R1)           ADDR IN DCB ADDR TABLE
         ST    R4,0(,R2)           ADDR IN OPEN LIST
         LA    R2,4(,R2)           UPDATE OPEN LIST POINTER
         ST    R2,WPARLST
         LA    R4,SORTINL(,R4)     UPDATE ACTUAL DCB ADDR
*
*        SET INDICATOR BIT FOR OUTPUT DCB GENERATION
*
         MVI   WINDIC,X'00'
         B     AGIINITL            GO OUT AND RETURN FROM DCB
*                                  INITIALIZATION SUBROUTINE
*
*        CHECK IF USER EXIT E19 IS ACTIVE
*
AGIRTRN3 PPITEST  PPIME19          EXIT E19 ACTIVE ?
         BO    AGIGOUSR            YES, BRANCH
*
*        SET UP PARAMETERS, ASSIGN PROPER SORTWK IDENTITIES AND
*        MOVE OUTPUT DCBS INTO ALLOCATED STORAGE
*
AGIMVOUT LA    R6,PPISTAR          R6 -> PPISTAR
         L     R10,WNUMDCB         NO OF OUTPUT DCB TO GENERATE
         L     R2,WPARLST          ADDR OF OPEN LIST
         LA    R12,SORTWK          R12 -> SORTWK DCB MODEL
*
*        GET M OFFSET FROM PPISTAR TO SET UP DCB DDNAME
*
AGI09    SR    R9,R9
         ICM   R9,B'0001',0(R6)    R9 =  OFFSET FROM PPISTAR ENTRY
         BZ    AGIRPT              NO INCREMENT FOUND
         SRL   R9,1                CONVERT DCB OFFSET TO DDTABLE OFFSET
         LH    R9,DDTABLE(R9)      GET DDNAME SUFFIX NO
         STH   R9,DCBDDNAM+6       STORE SUFFIX INTO DCB DDNAME
         MVC   0(SORTWKL,R4),SORTWK  MOVE DCB INTO STORAGE
*
*        STORE DCB ADDR AND UPDATE TABLE AND ADDR POINTERS
*
         SR    R9,R9
         IC    R9,0(,R6)           GET OFFSET FROM PPISTAR
         ST    R4,0(R1,R9)         ADDR IN DCB ADDR TABLE
         ST    R4,0(,R2)           ADDR IN OPEN LIST
         LA    R2,4(,R2)           UPDATE OPEN LIST POINTER
         LA    R4,SORTWKL(,R4)     UPDATE DCB ACTUAL ADDR
         LA    R6,8(,R6)           INCR TO NEXT ENTRY IN PPISTAR
AGIRPT   BCT   R10,AGI09           LOOP TO GENERATE ALL DCBS
*
*        PUT ECB AND DCB ADDR INTO IOB MODEL
*
         L     R4,WECBADR
         ST    R4,MODIOB+IOBECBPT-IERIOB  ECB ADDR IN IOB MODEL
         LR    R1,R4
         LA    R1,8(,R1)
         ST    R1,PPISTIOB         OUTPUT IOB PROPER ADDR IN PPI
         L     R1,WDCBTAB          DCB ADDR TABLE
         SR    R2,R2
         IC    R2,PPIDEPHO
         L     R2,0(R2,R1)
         ST    R2,MODIOB+IOBDCBPT-IERIOB  DCB ADDR IN IOB MODEL
*
*        MOVE IOB MODEL INTO ALLOCATED STORAGE
*
         MVC   0(MODIOBL,R4),MODIOB
*
*        RETURN TO IERRC9
*
         L     R14,SAVER14         RESTORE R14
         SR    R15,R15
         BR    R14                 RETURN TO IERRC9
*
*        CALL USER EXIT E18/E19
*
*        THE EXIT RETURNS WITH THE ADDR OF THE USER OPTION LIST IN R1
*        THE MODEL DCB WILL BE MODIFIED ACCORDING TO THE OPTIONS
*        SPECIFIED ON THE LIST
*
*        USER OPTION LIST
*
*          BYTE 1      BYTE 2      BYTE 3      BYTE 4
*         _______________________________________________
*        |           |                                   |
*        | X'01'     | ADDR OF USER PROVIDED SYNAD I/O   |
*        |           | ERROR ROUTINE                     |
*        |___________|___________________________________|
*        |           |                                   |
*        | X'02'     | ADDR OF USER PROVIDED DCB DCBEXLSA|
*        |           | LIST                              |
*        |___________|___________________________________|
*        |           |           |           |           |
*        | X'03'     | 0         | 0         | DCBERROPT |
*        |           |           |           | FLAG BYTE |
*        |___________|___________|___________|___________|
*        |           |                                   |
*        | X'04'     | DCB EODAD ROUTINE (INPUT ONLY)    |
*        |           |                                   |
*        |___________|___________________________________|
*        |           |                                   |
*        | X'00'     | TERMINATING ENTRY IN LIST         |
*        |           |                                   |
*        |___________|___________________________________|
*
*
AGIGOUSR STM   R1,R10,WREGSAVE     SAVE REGS ACROSS USER EXIT
         TM    WINDIC,X'01'        INPUT DCB EXIT ?
         BO    AGIUSR01            YES, BRANCH
         L     R15,PPIX19+4        NO, USER WRITE OPTION ADDR
         B     AGIUSR02            GO SET UP RETURN FROM USER
*
AGIUSR01 L     R15,PPIX18+4        USER READ OPTION ROUTINE ADDR
AGIUSR02 BASR  R14,R15             CALL USER EXIT
*
*        RETURN POINT FROM USER EXIT
*
         LR    R8,R1               R8 -> USER LIST
         L     R15,PPIOPEN+4       OPEN LIST ADDR
*
AGISTUOP SR    R4,R4
         ICM   R4,B'0001',0(R8)    GET OPTION NUMBER FROM USER LIST
         BZ    AGIUSR07            TERMINATING ENTRY ? BRANCH
         CH    R4,KOPTMAX          USER OPTION NO > LEGAL VALUE ?
         BH    AGIUSR6A            YES, VALUE NOT LEGAL
         SLL   R4,2                CONVERT TO BRANCH OFFSET
         B     *(R4)               BRANCH TABLE
         B     AGITRECH            +04 SYNAD (OPTION 01)
         B     AGITREA             +08 EXLST (OPTION 02)
         B     AGIONECH            +12 EROPT (OPTION 03)
         B     AGIUSR05            +16 EODAD (OPTION 04 - INPUT ONLY)
*
AGIUSR06 LA    R8,4(,R8)           UPDATE USER PARAMETER LIST POINTER
*                                  TO GET NEXT ENTRY ON LIST
         B     AGISTUOP            GOTO GET WORD FROM OPTION LIST
*
AGIUSR6A TM    WFRSTERR,X'01'      FIRST OPTION ERROR ?
         BO    AGIUSR06            NO, BRANCH
         MVI   WFRSTERR,X'01'      YES, SET INDICATOR
         B     AGIERR              GOTO SAVE REGS
*
*        MODIFICATIONS COMPLETED, RETURN TO MAIN PROGRAM
*
AGIUSR07 LM    R1,R10,WREGSAVE     RESTORE REGS
         MVI   WFRSTERR,X'00'      RESTORE FIRST OPTION ERROR INDIC
         TM    WINDIC,X'01'        RETURN TO INPUT ROUTINE ?
         BO    AGIMVIN             YES, BRANCH
         B     AGIMVOUT            NO -
*
*        SYNAD OPTION
*
AGITRECH TM    WINDIC,X'01'        INPUT DCB ?
         BO    AGITREB             YES, BRANCH
         MVC   AP1WRT1+1(3),1(R8)
         B     AGIUSR06            GOTO PROCESS NEXT OPTION
*
AGITREB  MVC   DCBSYNA,1(R8)       MOVE SYNAD ADDR INTO DCB
         B     AGIUSR06            GOTO PROCESS NEXT OPTION
*
*        EXLST OPTION
*
AGITREA  MVC   DCBEXLSA,1(R8)      UPDATE DCBEXLSA
         B     AGIUSR06            GOTO PROCESS NEXT OPTION
*
*        EROPT OPTION
*
AGIONECH TM    WINDIC,X'01'        INPUT DCB ?
         BO    AGIONEA             YES, BRANCH
         B     AGIUSR6A            NO, ILLEGAL OPTION
*
AGIONEA  MVC   DCBEROPT,3(R8)      MOVE EROPT CODE INTO DCB
         B     AGIUSR06            GOTO PROCESS NEXT OPTION
*
*        EODAD OPTION
*
AGIUSR05 TM    WINDIC,X'01'        INPUT DCB ?
         BO    AGIUSR5A            YES, BRANCH
         B     AGIUSR6A            NO, ERROR BRANCH
*
AGIUSR5A L     R6,PPIEOF+4         EOD READ ROUTINE ADDR
         LA    R6,9(,R6)           ADDR IN EOD ROUTINE
         MVC   0(3,R6),1(R8)       MOVE EODAD INTO PPIEOF AREA
         B     AGIUSR06            GOTO PROCESS NEXT OPTION
*
*        DCB INITIALIZATION SUBROUTINE
*
*        USED TO INITIALIZE BOTH INPUT AND OUTPUT DCBS
*
AGIINITL STM   R1,R10,WREGSAVE     SAVE REGS
         TM    WINDIC,X'01'        INPUT DCB ?
         BO    AGIINT02            YES, BRANCH
*
*        SORTWK DCB INITIALIZATION SUBROUTINE
*
         LA    R12,SORTWK          R12 -> SORTWK DCB
         MVC   DCBDDNAM(L'PPIDDSRT),PPIDDSRT  MOVE IN DDNAME PREFIX
         MVC   DCBIOBAD,WIOBADR    SET THE IOB ADDR
         MVI   DCBBFTEK,DCBBFTS    SIMPLE BUFFERING
         B     AGICOMM             GO INIT FIELDS OF DCBS
*
*        SORTIN DCB INITIALIZATION SUBROUTINE
*
AGIINT02 LA    R12,SORTIN          R12 -> SORTIN DCB
         MVC   DCBDDNAM(L'PPIDDSRT),PPIDDSRT  MOVE IN DDNAME PREFIX
         MVC   DCBBUFNO,PPILAB03   NO OF INPUT BUFFERS
         MVC   DCBBUFCA,PPILAB06+1  8 BYTE CONTROL BUFFER ADDR
         MVC   DCBBUFL,PPILAB03+2  SIZE OF INPUT BUFFER
         L     R1,PPIADSSC         INPUT READ ERROR
         MVC   DCBSYNAD,24(R1)     MOVE SYNAD RTN ADDR INTO DCB
         L     R1,PPIEOF+4         EOD READ ROUTINE ADDR
         STCM  R1,B'0111',DCBEODA
         MVI   DCBEROPT,DCBERABE   ABNORMAL END OF TASK
         MVI   DCBBFTEK,DCBBFTS    NO DATA CHAINING
         PPITEST  PPIMVSI          VBS INPUT ?
         BO    AGIVBS              YES, GO SET GET MOVE MODE
         OI    DCBMACR,DCBMRGET+DCBMRLCG
         B     AGICOMM             GO INIT FIELDS OF DCBS
*
AGIVBS   OI    DCBMACR,DCBMRGET+DCBMRMVG  SET DATA MOVE MODE
         NI    DCBMACR,255-DCBMRLCG       TURN OFF LOCATE MODE
*
*        INITIALIZE FIELDS COMMON TO BOTH EXCP AND QSAM DCBS
*
AGICOMM  MVI   DCBIFLG,DCBIFER     USE IOS ERROR ROUTINES
         PPITEST  PPISWA           FULL WORD BUFFER ALIGNMENT ?
         BO    AGIINT04            YES, BRANCH
         OI    DCBBFTEK,DCBBFAD    DOUBLE WORD ALIGNMENT
         B     AGIINT05            GOTO RESTORE REGS
*
AGIINT04 OI    DCBBFTEK,DCBBFAF1   FULL WORD BUFFER ALIGNMENT
*
*        RESTORE REGISTERS AND RETURN TO CALLER
*
AGIINT05 LM    R1,R10,WREGSAVE
         TM    WINDIC,X'01'        RETURN TO INPUT ROUTINE ?
         BO    AGIRTRN1            YES, BRANCH
         B     AGIRTRN3            NO
*
*        GENERATE ERROR MESSAGE
*
AGIERR   STM   R0,R1,WREGSV2       SAVE REGISTERS
         L     R14,PPIAMA+4        MESSAGE MODULE ADDR
         LM    R0,R1,IER044        IER044I - EXIT E
         TM    WINDIC,X'01'        INPUT DCB ?
         BO    AGIERR01            YES -
         MVC   IER044A,KTAG+2
         B     AGIERR02            GOTO ERROR 2
*
AGIERR01 MVC   IER044A,KTAG
AGIERR02 L     R15,PPIADSSC
         BAS   R14,12(,R15)        CALL MESSAGE WRITER
         LM    R0,R1,WREGSV2       RESTORE REGISTERS
         B     AGIUSR06            RETURN TO USER MODIFICATION RTN
*
*        WORK LOCATIONS
*
WNUMDCB  DC    F'0'                NO OF OUTPUT DCBS TO GENERATE
WDCBADR  DC    F'0'                STARTING ADDR OF DCB AREA
WIOBADR  DC    F'0'                STARTING ADDR OF IOB AREA
WECBADR  DC    F'0'                STARTING ADDR OF ECB AREA
WDCBTAB  DC    F'0'                STARTING ADDR OF DCB ADDR TABLE
WPARLST  DC    F'0'                STORAGE FOR NEXT ENTRY ON OPEN LIST
WINDIC   DC    F'0'                INDICATOR WORD - INPUT OR OUTPUT
WFRSTERR DC    F'0'                FIRST OPTION ERROR INDICATOR
WREGSAVE DC    12F'0'              SAVE AREA FOR GENERAL REGS
WREGSV2  DC    2F'0'
SAVER14  DC    F'0'                RETURN ADDR TO IERRC9
INDWORD  DC    XL4'80000000'
*
*        CONSTANTS
*
KOPTMAX  DC    H'4'                HIGHEST LEGAL OPTION NUMBER
*
DDTABLE  DC    C'0001020304050607080910111213141516000000'
*
KTAG     DC    C'1819'             EXIT IDENTITIES FOR MSGS
*
*        GENERATE MODEL IOB
*
MODIOB   DC    12F'0'              STANDARD DASD 40 BYTE IOB
*                                  PLUS 8 BYTE S/M PREFIX
MODIOBL  EQU   *-MODIOB            L'MODIOB
         ORG   MODIOB+8            (IOBFLAG1-IERIOB)
         DC    AL1(IOBCMDCH)       SET IOB CMD CHAINING FLAG
         ORG
*
*        GENERATE MODEL DCBS
*
SORTIN   DCB   MACRF=(GL),DSORG=PS,DDNAME=SORTIN
*
SORTINL  EQU   *-SORTIN            L'SORTIN QSAM DCB
*
SORTWK   DCB   MACRF=(E),DSORG=PS,DDNAME=SORTWKXX
*
         DC    F'0'                AREA APPENDED TO EXCP DCB
*                                  REFERENCED AS DCBOPTCD
*
SORTWKL  EQU   *-SORTWK            L'SORTWK EXCP DCB
*
*        OPEN LIST DSECT
*
DIERAP1  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERAP1 SOURCE
*
*----------------------------------------------------------------------
*
         COPY IERAP1I
*
*        IERAMA
*
*        THIS MODULE CONTAINS ALL OF THE MESSAGES THAT ARE
*        REQUIRED FOR PHASE 1 ASSIGNMENT MODULES
*
DIERAMA  DSECT
*
         COPY  AMAMAIN
*
*        DCB DSECT
*
         PRINT NOGEN
*
         DCBD  DSORG=(PS),DEVD=(DA)
*
         PRINT GEN
*
*        IERIOB
*
         IERIOB
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERAGJ   0101-20211-20211-1200-00509-00509-00000-RELEASE 00
AGJ      TITLE 'IERAGJ - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERAGJ
*
*        MODULE FUNCTION/OPERATION -
*        THE FUNCTION OF THIS MODULE IS TO GENERATE ONE OUTPUT
*        DCB AND ONE OUTPUT IOB. ONE INPUT DCB WILL BE GENERATED
*        FOR EACH ENTRY ON THE DISK TABLE LESS THE SPECIFIED
*        OUTPUT ENTRY. ALL INPUT DCBS WILL POINT TO THE FIRST
*        INPUT IOB GENERATED
*
*        THE ADDRS OF ALL DATA CONTROL BLOCKS GENERATED WILL BE
*        PLACED IN BOTH THE OPEN LIST AND THE DCB ADDR TABLE.
*        THE ADDRS OF ALL IOBS GENERATED WILL BE PLACED IN THE
*        IOB ADDR TABLE
*
*        THE MODULE WILL ALSO INTERROGATE PPI TO DETERMINE IF
*        USER EXITS HAVE BEEN ACTIVATED. IF EXITS HAVE BEEN
*        SPECIFIED, THE MODULE WILL GO TO THE USER FOR THE OPTION
*        LIST. THE OPTIONS WILL THEN BE USED TO MODIFY THE
*        APPROPRIATE DCB FIELDS IN THE GENERATED DCBS
*
*        MODULES IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACROS USED BY MODULE -
*        SMPPI
*        DCB
*
*        ENTRY POINTS - ENTRY IERMGG - ENTRY FROM IERRC9
*                                      CALLING SEQUENCE -
*                                      LOAD EP=IERAGJ,DCB=
*                                      LR      R15,R0
*                                      BALR    R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPISTAR    PPIMRGOP   PPIADSSC   PPICNTL
*        PPINDSKA   PPIAMB     PPIDDSRT
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPISTDCB   PPISTIOB   PPISPGN1
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS -
*        PPIOPEN+4 - OPEN LIST ADDR
*        PPIAMB+4  - MESSAGE MODULE ADDR
*
*        EXITS - NORMAL -
*        BR R14 - RETURN TO LOAD MODULE IERRC9
*
*        L  R15,PPIX28+4 EXIT TI USER READ OPTION ROUTINE
*        BR R15
*
*        L  R15,PPIX29+4 EXIT TO USER WRITE OPTION ROUTINE
*        BR R15
*
*        EXITS - ERROR -
*        PPIAMB+4 - ILLEGAL OPTION NUMBER SPECIFIED BY USER
*
*        TABLES/WORK AREAS -
*        MODIOB - MODEL PREFIXED IOB
*        SORTWK - MODEL SORTWKXX DCB
*
*        NOTES -
*        THIS MODULE IS RESTRICTED TO DISK OPERATION ONLY
*
IERAGJ   CSECT
*
         USING *,R11               MODULE BASE REG
         USING IHADCB,R12          BASE REGISTER FOR DCB DSECT
         USING IERRCA,R13          PPI
         USING DIERAMB,R14         BASE REG FOR MESSAGE MODULE DSECT
         USING OPENLST,R15         BASE REG FOR OPEN LIST DSECT
*
         LR    R11,R15             SET BASE REGISTER
         STM   R12,R14,WREGSV3     SAVE ORIGINAL REGS
*
*        SETUP PATTERN SORKWKXX DCB
*
         LA    R12,SORTWK          R12 -> SORTWKXX PATTERN DCB
         MVC   DCBDDNAM(L'PPIDDSRT),PPIDDSRT  MOVE IN 4 LETTER PREFIX
*
*        SET UP WORKING PARAMETERS FOR DISK OPERATION
*
         LH    R1,PPINDSKA         R1 = NUMBER OF SORTWORK DATASETS
         L     R2,PPIOPEN+4        R2 -> OPEN LIST
         ST    R1,0(,R2)           STORE NO OF SORTWKXX DCBS TO OPEN
*                                  IN FIRST LIST ENTRY
         LA    R2,4(,R2)           R2 -> FIRST DCB TO OPEN SLOT
         ST    R2,WPARLST          R2 = FIRST ADDR SLOT OF OPEN LIST
         LH    R3,PPIMRGOP         OPTIMUM MERGE ORDER
         LA    R3,1(,R3)           CALC NO OF IOBS REQUIRED
         ST    R3,WNUMIOB          R3 = TOTAL NUMBER OF IOBS
*
*        ROUND START OF GENERATED STORAGE TO A FULL WORD BOUNDRY
*
         L     R4,PPISPGN1
         SRL   R4,2
         SLL   R4,2                ALIGN TO WORD BOUNDARY
*
*        COMPUTE STORAGE REQUIREMENTS FOR DCBS
*
         SR    R6,R6
         LH    R7,PPINDSKA         NUMBER OF SORTWORK DCBS
         LA    R8,SORTWKL          L'SORTWK DCB
         MR    R6,R8               R7 = TOTAL DCB BYTE REQUIREMENTS
         SR    R4,R7               SUBTRACT L'DCBS FROM START ADDR
         ST    R4,WDCBADR          R4 -> DCB AREA
*
*        COMPUTE STORAGE REQUIREMENTS FOR IOBS, ECBS AND ALTERNATE CCW
*
         SR    R6,R6
         L     R7,WNUMIOB          NUMBER OF IOBS TOTAL
         LA    R8,MODIOBL          L'MODIOB PREFIXED IOB
         MR    R6,R8               R7 = TOTAL BYTES REQUIRED
         SR    R4,R7
         ST    R4,WECBADR          START OF PREFIXED IOB AREA
*
*        COMPUTE DCB ADDR TABLE STORAGE REQUIREMENTS
*
         LA    R1,7*4              PROVIDE FOR 7 ENTRIES
         SR    R4,R1               SUBTRACT FROM AVAILABLE STORAGE
         ST    R4,PPISTDCB         UPDATE PPISTDCB (DCB ADDR TABLE)
*
*        GENERATE OPTIONAL DIAGNOSTIC MESSAGE TO IDENTIFY PPISTDCB ADDR
*
         PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTICS ?
         BZ    AGJNOMES            NO, BRANCH
         LR    R0,R4               LOAD NUMBER TO BE CONVERTED
         L     R15,PPICONV+4       LOAD ADDR OF CONVERSION ROUTINE
         BAS   R14,4(,R15)         CONVERT
         L     R14,PPIAMB+4        R14 -> IERAMB
         MVC   IER924A,2(R1)       MOVE FORMATTED ADDR INTO MSG
         LM    R0,R1,IER924        IER924I DCB TABLE ADDR
         L     R15,PPIADSSC        R15 -> PRINT ROUTINE
         BAS   R14,12(,R15)        PRINT
*
*        IOB ADDR TABLE STORAGE REQUIREMENTS
*
AGJNOMES L     R1,WNUMIOB          R1 = NUMBER OF IOBS REQUIRED
         SLL   R1,2                CALCULATE NO OF BYTES NEEDED
*                                  FOR IOB ADDR TABLE
         SR    R4,R1               SUBTRACT FROM AVAILABLE STORAGE
         ST    R4,PPISTIOB         UPDATE PPI WITH ADDR OF IOB TABLE
         ST    R4,PPISPGN1         UPDATE PPI
*
*        GENERATE IOBS AND PLACE ECB ADDR INTO ASSOCIATED IOB
*
         L     R10,WNUMIOB         R10 = NO OF IOBS TO GENERATE
         L     R4,WECBADR          START OF IOB STORAGE AREA
AGJ01    ST    R4,MODIOB+IOBECBPT-IERIOB
         MVC   0(MODIOBL,R4),MODIOB  MOVE MODEL IOB INTO IOB AREA
         LA    R4,MODIOBL(,R4)     UPDATE ADDR POINTER
         BCT   R10,AGJ01           ALL ADDRS STORED ?
*
*        STORE OUTPUT IOB ADDR FOR LATER REFERENCE
*
AGJ02A   L     R4,WECBADR
         LA    R4,8(,R4)           INCR PAST PREFIX
         ST    R4,WIOBOUT          OUTPUT IOB ADDR
*
*        SET UP TABLE OF IOB ADDRS
*
         L     R1,PPISTIOB
         ST    R4,0(,R1)
         L     R2,WNUMIOB          NUMBER OF INPUT IOBS
AGJRPT   LA    R1,4(,R1)           UPDATE IOB TABLE POINTER
         LA    R4,MODIOBL(,R4)     UPDATE IOB ADDR POINTER
         ST    R4,0(,R1)           PUT IOB ADDR INTO TABLE
         BCT   R2,AGJRPT           ALL IOB ADDRS STORED ?
*
*        SET INDICATOR BIT IN FIRST BYTE OF ALL DCB ADDR TABLE
*        ENTRY SLOTS
*
         LA    R0,X'800'
         SLL   R0,20               R0 = X'80000000'
         L     R1,PPISTDCB
         LA    R3,7                MAXIMUM OF 7 DCB TABLE ENTRIES
AGJ02AA  ST    R0,0(,R1)
         LA    R1,4(,R1)           INCR DCB TABLE POINTER
         BCT   R3,AGJ02AA          ALL INDICATORS BEEN STORED ?
*
*        SET FLAG TO INDICATE OUTPUT DCB GENERATION
*
AGJ02C   MVI   WINDIC,X'00'
*
*        GOTO DCB INITIALIZATION SUBROUTINE AND RETURN
*
         LA    R14,AGJRTRN3
         B     AGJINITL
*
*        RETURN POINT FROM DCB INITIALIZATION
*
*        CHECK IF USER EXIT E29 IS ACTIVE
*
AGJRTRN3 PPITEST  PPIME29          USER EXIT E29 ACTIVATED ?
         BO    AGJGOUSR            YES, BRANCH
*
*        SET UP PARAMETERS AND BEGIN OUTPUT DCB GENERATION
*
AGJRTRN4 L     R1,PPISTDCB         DCB ADDR TABLE
         L     R2,WPARLST          OPEN LIST ADDR
         L     R4,WDCBADR          R4 -> START OF DCB ADDR
         L     R8,WIOBOUT
*
*        PLACE OUTPUT IOB ADDR INTO OUTPUT DCB MODEL
*        AND CROSSLINK WITH IOB WITH DCB
*
         ST    R8,DCBIOBAD         STORE IOB ADDR IN DCB
         USING IOBSTDRD,R8
         ST    R4,IOBDCBPT         STORE DCB ADDR IN IOB
         LA    R8,MODIOBL(,R8)     UPDATE IOB ADDR POINTER
*
*        GET PRIMARY OUTPUT INCREMENT AND CONVERT IT TO THE
*        PROPER DCB SORTWK DDNAME NUMBER
*
         SR    R9,R9
         PPITEST  PPIDMCO          PHASE 2 EVEN NUMBER PASS ?
         BO    AGJ02D              YES, BRANCH
         LH    R9,PPINDSKA         NUMBER OF DISK AREAS
         BCTR  R9,0                REDUCE COUNT BY ONE
         SLL   R9,3                MULTIPLY BY 8
AGJ02D   SR    R14,R14
         IC    R14,PPISTAR(R9)     PRIMARY OUTPUT OFFSET FROM PPISTAR
         STC   R14,OUTSTAR         SAVE FOR LATER COMPARISON
         SRL   R14,1               CONVERT DCB TABLE OFFSET TO DDTABLE
         LH    R14,DDTABLE(R14)
         STH   R14,DCBDDNAM+6      STORE DDNAME SUFFIX INTO DDNAME
         SR    R14,R14
         IC    R14,PPISTAR(R9)     PRIMARY OUTPUT INCREMENT
         ST    R4,0(R1,R14)        DCB ADDR IN TABLE + OFFSET
         ST    R4,0(,R2)           DCB ADDR IN OPEN LIST
         MVC   0(SORTWKL,R4),SORTWK  MOVE DCB INTO ALLOCATED AREA
         LA    R4,SORTWKL(,R4)     UPDATE DCB POINTER
         LA    R2,4(,R2)           UPDATE OPEN LIST POINTER
*
*        TURN ON FLAG TO INDICATE START OF INPUT DCB GENERATION
*
         MVI   WINDIC,X'01'
*
*        GOTO DCB INITIALIZATION SUBROUTINE AND RETURN
*
         LA    R14,AGJRTRN1
         B     AGJINITL
*
*        RETURN POINT FROM DCB INITIALIZATION
*
*        CHECK IF USER E28 READ EXIT SPECIFIED
*
AGJRTRN1 PPITEST  PPIME28          USER EXIT E28 ACTIVATED ?
         BO    AGJGOUSR            YES, BRANCH
AGJRTRN2 LH    R10,PPINDSKA        R10 = NO OF SORTWKXX DCBS
         LA    R6,PPISTAR          R6 -> DISK TABLE
*
*        GET OFFSET FROM DISK TABLE AND CONVERT TO SORTWK DDNAME
*
AGJ03    SR    R14,R14
         IC    R14,0(,R6)          GET OFFSET FROM PPISTAR ENTRY
         CLM   R14,B'0001',OUTSTAR  OUTPUT DCB ?
         BE    AGJ05A              YES, BRANCH
         SRL   R14,1               CONVERT DCB TABLE OFFSET TO DDTABLE
         LH    R14,DDTABLE(R14)    R14 = TWO BYTE DDNAME SUFFIX
         STH   R14,DCBDDNAM+6      MOVE DDNAME SUFFIX INTO DDNAME
         SR    R14,R14
         IC    R14,0(,R6)          GET OFFSET FROM TABLE
         ST    R4,0(R1,R14)        DCB ADDR IN TABLE + OFFSET
         ST    R4,0(,R2)           DCB ADDR IN OPEN LIST
         ST    R8,DCBIOBAD         IOB ADDR IN DCB
         MVC   0(SORTWKL,R4),SORTWK  MOVE DCB INTO ALLOCATED AREA
         LA    R4,SORTWKL(,R4)     INCR R4 TO NEXT DCB AREA
         LA    R2,4(,R2)           UPDATE OPEN LIST POINTER
AGJ05A   LA    R6,8(,R6)           INCR PPISTAR POINTER TO NEXT ENTRY
         BCT   R10,AGJ03           ALL DCBS BEEN GENERATED ?
*
*        EXIT TO CALLER
*
         LM    R12,R14,WREGSV3     RESTORE ORIGINAL REG SETTINGS
         BR    R14                 RETURN TO LOAD MODULE IERRC9
*
*        COMMON DCB INITIALIZATION SUBROUTINE
*
*        USED FOR BOTH INPUT AND OUTPUT DCB GENERATION
*
AGJINITL STM   R1,R10,WREGSAVE     SAVE REGISTERS
         TM    WINDIC,X'01'        INPUT GENERATION PHASE ?
         BO    AGJINT01            YES
*
*        OUTPUT DCB GENERATION SUBROUTINE
*
         MVI   DCBIFLG,DCBIFER     USE IOS ERROR ROUTINES
*
*        SET UP BFTEK AND BFALN FIELD
*
         MVI   DCBBFTEK,DCBBFTS    SIMPLE BUFFERING
         PPITEST  PPISWA           FULL WORD BUFFER ALIGNMENT ?
         BO    AGJOUT4             YES
         OI    DCBBFTEK,DCBBFAD    NO, DOUBLE WORD ALIGNMENT
         B     AGJCOMM
*
AGJOUT4  OI    DCBBFTEK,DCBBFAF1   FULL WORD ALIGNMENT
         B     AGJCOMM
*
*        INPUT DCB INITIALIZATION SUBROUTINE
*
AGJINT01 XC    DCBEXLSA,DCBEXLSA   ZERO OUT USER MODIFICATION FIELDS
*
*        SET UP BFTEK AND BFALN FIELD
*
         MVI   DCBBFTEK,DCBBFTS    SIMPLE BUFFERING
         PPITEST  PPISWA           SINGLE WORD BUFFER ALIGNMENT ?
         BO    AGJINT06            YES
         OI    DCBBFTEK,DCBBFAD    NO, DOUBLE WORD ALIGNMENT
         B     AGJCOMM
*
AGJINT06 OI    DCBBFTEK,DCBBFAF1   FULL WORD ALIGNMENT
AGJCOMM  LM    R1,R10,WREGSAVE     RESTORE REGISTERS
         BR    R14                 RETURN TO MAIN PROGRAM
*
*        CALL USER EXIT E28/E29
*
*        THE EXIT RETURNS WITH THE ADDR OF THE USER OPTION LIST
*        THE MODEL DCB WILL BE MODIFIED ACCORDING TO THE OPTIONS
*        SPECIFIED ON THE LIST
*
*        R1 -> USER OPTION LIST
*
*          BYTE 1      BYTE 2      BYTE 3      BYTE 4
*         _______________________________________________
*        |           |                                   |
*        | X'01'     | ADDR OF USER PROVIDED SYNAD I/O   |
*        |           | ERROR ROUTINE                     |
*        |___________|___________________________________|
*        |           |                                   |
*        | X'02'     | ADDR OF USER PROVIDED DCB DCBEXLSA|
*        |           | LIST                              |
*        |___________|___________________________________|
*        |           |           |           |           |
*        | X'03'     | 0         | 0         | DCBERROPT |
*        |           |           |           | FLAG BYTE |
*        |___________|___________|___________|___________|
*        |           |                                   |
*        | X'04'     | DCB EODAD ROUTINE (INPUT ONLY)    |
*        |           |                                   |
*        |___________|___________________________________|
*        |           |                                   |
*        | X'00'     | TERMINATING ENTRY IN LIST         |
*        |           |                                   |
*        |___________|___________________________________|
*
*
AGJGOUSR STM   R1,R10,WREGSAVE     SAVE REGS ACROSS USER EXIT CALL
         TM    WINDIC,X'01'        INPUT DCB EXIT ?
         BO    AGJUSR01            YES
         L     R15,PPIX29+4        NO, USER WRITE OPTION ADDR
         B     AGJUSR02
*
AGJUSR01 L     R15,PPIX28+4        USER READ OPTION ADDR
AGJUSR02 BASR  R14,R15             CALL USER EXIT
*
*        RETURN POINT FROM USER MODIFICATION PROGRAM
*
         LR    R8,R1               R8 = ADDR OF OPTION LIST
         L     R15,PPIOPEN+4       OPEN LIST ADDR
AGJSTMOD SR    R4,R4
         ICM   R4,B'0001',0(R8)    GET USER OPTION NUMBER FROM LIST
         BZ    AGJUSR04            TERMINATING ENTRY ? BRANCH
         CH    R4,KOPTMAX          CHECK OPTION NUMBER > LEGAL VALUE ?
         BH    AGJUSR3A            NOT LEGAL, CHECK IF FIRST OPTION
         SLL   R4,2                CONVERT TO OFFSET FOR BRANCH TABLE
         B     *(R4)               BRANCH TABLE
         B     AGJTREA             +04 SYNAD (OPTION 01)
         B     AGJTRECH            +08 EXLST (OPTION 02)
         B     AGJONECH            +12 EROPT (OPTION 03)
*
AGJUSR03 LA    R8,4(,R8)           UPDATE USER LIST POINTER
         B     AGJSTMOD            CONTINUE MODIFICATIONS
*
AGJUSR3A TM    WFRSTERR,X'01'      FIRST OPTION ERROR ?
         BO    AGJUSR03            NO
         MVI   WFRSTERR,X'01'      SET INDICATOR
         B     AGJERR
*
*        MODIFICATIONS COMPLETE - RETURN TO MAIN PROGRAM
*
AGJUSR04 LM    R1,R10,WREGSAVE     RESTORE REGISTERS
         MVI   WFRSTERR,X'00'      RESTORE FIRST OPTION ERROR INDIC
         TM    WINDIC,X'01'        RETURN TO INPUT ROUTINE ?
         BO    AGJRTRN2            YES
         B     AGJRTRN4            NO
*
*        SYNAD (OPTION 01)
*
AGJTREA  TM    WINDIC,X'01'        INPUT DCB MODIFICATION ?
         BO    AGJTREB             YES
         MVC   WRTOPT+1(3),1(R8)
         B     AGJUSR03
*
AGJTREB  MVC   WRDOPT+1(3),1(R8)
         B     AGJUSR03
*
*        EXLST (OPTION 02)
*
AGJTRECH MVC   DCBEXLSA,1(R8)      UPDATE DCBEXLSA
         B     AGJUSR03
*
*        EROPT (OPTION 03)
*
AGJONECH TM    WINDIC,X'01'        INPUT DCB MODIFICATION ?
         BO    AGJONEA             YES
         B     AGJUSR3A            ILLEGAL OPTION
*
AGJONEA  MVC   WRDOPT(1),3(R8)
         B     AGJUSR03
*
*        GENERATE ERROR MESSAGE
*
AGJERR   STM   R0,R1,WREGSV2       SAVE REGISTERS
         L     R14,PPIAMB+4        MESSAGE MODULE ADDR
         LM    R0,R1,IER044
         TM    WINDIC,X'01'        INPUT OPTION ERROR ?
         BO    AGJERR01            YES
         MVC   IER044A,KTAG+2
         B     AGJERR02
*
AGJERR01 MVC   IER044A,KTAG
AGJERR02 L     R15,PPIADSSC
         BAS   R14,12(,R15)
         LM    R0,R1,WREGSV2       RESTORE REGISTERS
         B     AGJUSR03            CONTINUE DCB MODIFICATIONS
*
*        CONSTANTS
*
KOPTMAX  DC    H'3'                MAX LEGAL OPTION NUMBER
*
DDTABLE  DC    C'000102030405060708091011121314151617181920212223'
         DC    C'242526272829303132000000'
*
KTAG     DC    C'2829'             USER EXIT NUMBERS
*
*        MODEL IOB
*
MODIOB   DC    12F'0'              STANDARD DASD IOB PLUS S/M PREFIX
*
MODIOBL  EQU   *-MODIOB            L'MODIOB
         ORG   MODIOB+8            (IOBFLAG1-IERIOB)
         DC    AL1(IOBCMDCH)       SET ON COMMAND CHAINING
         ORG
*
*        IERAGJ WORK AREAS
*
WPARLST  DC    A(0)                NEXT OPEN SLOT IN OPEN LIST
WDCBADR  DC    A(0)                START OF DCB CORE AREA
WECBADR  DC    A(0)                START OF PREFIXED IOB CORE AREA
WIOBOUT  DC    A(0)                ADDR OF OUTPUT IOB
WINDIC   DC    F'0'                INDICATOR FOR INPUT OR OUTPUT
WNUMIOB  DC    F'0'                NUMBER OF IOBS TO GENERATE
WFRSTERR DC    F'0'                FIRST OPTION ERROR INDICATOR
WREGSAVE DC    14F'0'              SAVE AREA FOR GENERAL REGS
WREGSV3  DC    3F'0'
WREGSV2  DC    2F'0'
OUTSTAR  DC    X'00'               OUTPUT DCB PPISTAR OFFSET
*
*        SORKWKXX PATTERN DCB
*
SORTWK   DCB   MACRF=(E),DSORG=PS,DDNAME=SORTWKXX
*
         DC    F'0'                AREA APPENDED TO EXCP DCB
*                                  REFERENCED AS DCBOPTCD
*
SORTWKL  EQU   *-SORTWK            L'SORTWK DCB
*
*        IERIOB
*
         IERIOB
*
*        OPEN LIST DSECT
*
OPENLST  DSECT
         DC    33F'0'
WRDOPT   DC    F'0'                STORAGE FOR USER READ OPTIONS
WRTOPT   DC    F'0'                STORAGE FOR USER WRITE OPTIONS
         DC    10F'0'
*
*        MODULE NAME - IERAMB
*
*        THIS MODULE CONTAINS ALL OF THE MESSAGES THAT ARE
*        REQUIRED FOR PHASE 2 ASSIGNMENT MODULES
*
DIERAMB  DSECT
*
         COPY  AMBMAIN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
*        DCBD
*
         PRINT NOGEN
*
         DCBD  DSORG=(PS),DEVD=(DA)
*
         PRINT GEN
*
         END
./ ADD NAME=IERAGK   0101-20211-20211-1200-00544-00544-00000-RELEASE 00
AGK      TITLE 'IERAGK - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERAGK
*
*        MODULE FUNCTION/OPERATION -
*        GENERATE A QSAM DCB FOR SORTOUT AND AN INPUT DCB FOR
*        EACH DISK SORTWORK AREA CONTAINING A SEQUENCE COUNT IE
*        RECORDS. ONE IOB WILL BE GENERATED FOR EACH UNIT FOUND
*        IN ANY SEQUENCE COUNT. ALL IOBS GENERATED FOR A GIVEN
*        DISK AREA WILL POINT TO THEIR RESPECTIVE DCB. THE DCB IN
*        TURN WILL POINT TO THE FIRST IOB GENERATED FOR IT'S
*        DISK AREA
*
*        THE MODULE HAS BEEN SLIGHTLY MODIFIED FOR THE CRCX
*        SORT. FOR THIS TECHNIQUE IT GENERATES PPINDSKA INPUT
*        DCBS AND IOB/ECBS, PLUS ONE QSAM DCB FOR OUTPUT
*
*        THE ADDRESS OF ALL DCBS GENERATED WILL BE PLACED IN
*        BOTH THE OPEN LIST AND THE DCB ADDRESS TABLE. THE
*        ADDRESSES OF ALL IOBS GENERATED WILL BE PLACED IN THE
*        IOB ADDRESS TABLE
*
*        THE MODULE WILL INTERROGATE THE PPI TO DETERMINE IF
*        USER EXITS HAVE BEEN ACTIVATED. IF EXITS HAVE BEEN
*        SPECIFIED, THE MODULE WILL GOTO THE USER FOR THE OPTION
*        LIST. THE OPTIONS WILL THEN BE USED TO MODIFY THE
*        APPROPRIATE DCB FIELDS IN THE GENERATED DCBS
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACROS USED BY MODULE -
*        SMPPI  DCB
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                       CALLING SEQUENCE -
*                       LOAD    EP=IERAGK,DCB=
*                       LR      R15,R0
*                       BALR    R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPISEQCT   PPINDSKA    PPISTAR
*        PILAB06    PPILAB07    PPICNTL
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPISTIOB   PPISTDCB   PPISPGN1
*
*        EXTERNAL ROUTINES - NONE
*
*        EXTERNAL PARAMETERS -
*        PPIOPEN+4 - OPEN LIST ADDR
*        PPIAMC+4  - MESSAGE MODULE ADDR
*
*        EXITS - NORMAL - RETURN TO IERRC9
*                         BR    R14
*
*                       - USER READ OPTION EXIT
*                         L     R15,PPIX38+4
*                         BR    R15
*
*                       - USER WRITE OPTION EXIT
*                         L     R15,PPIX39+4
*                         BR    R15
*
*        EXITS - ERROR -
*        PPIAMC+4 - ILLEGAL OPTION NUMBER SPECIFIED BY USER
*        DCBSYNAD - QSAM WRITE ERROR
*
*        TABLES/WORK AREAS -
*        MODIOB  - PREFIXED IOB MODEL
*        SORTOUT - DCB MODEL
*        SORTWK  - DCB MODEL
*
*        NOTES -
*        THIS MODULE IS RESTRICTED TO DISK OPERATION ONLY
*
IERAGK   CSECT
*
         USING *,R11               MODULE BASE REG LOADED EXTERNALLY
         USING IHADCB,R12          BASE REGISTER FOR DCB DSECT
         USING IERRCA,R13          PPI COMMON MODULE BASE REGISTER
         USING DIERAMC,R9          BASE REG FOR MESSAGE MODULE
         USING OPENLST,R15         BASE REG FOR OPEN LIST DSECT
*
         LR    R11,R15             SET BASE REGISTER
         STM   R12,R14,WREGSV3     SAVE ORIGINAL REGS
*
*        COMPUTE THE NUMBER OF DCBS AND IOBS REQUIRED
*
         PPITEST  PPI2314          CRCX SORT ?
         BZ    AGK00               NO, IT IS BALN
         LH    R4,PPINDSKA         GET NO OF DISK AREAS
         LR    R5,R4               INPUT DCBS = NO OF PPINDSKA
         B     AGK04               JUMP OVER BALN IOB/DCB CALC
*
AGK00    SR    R4,R4               CLEAR IOB COUNTER
         SR    R5,R5               CLEAR DCB COUNTER
         LH    R2,PPINDSKA         NO OF SEQ COUNTERS TO CHECK
         SR    R1,R1               CLEAR SEQUENCE COUNTERS OFFSET
AGK01    LH    R3,PPISEQCT(R1)     LOAD SEQUENCE COUNTER VALUE
         LTR   R3,R3               ZERO ENTRY ?
         BZ    AGK03               YES, BRANCH
         AR    R4,R3               NO, UPDATE TOTAL IOB COUNT
         LA    R5,1(,R5)               UPDATE TOTAL DCB COUNT
AGK03    LA    R1,2(,R1)           UPDATE SEQ COUNTER OFFSET
         BCT   R2,AGK01            GO TEST NEXT SEQ COUNTER ENTRY
*
AGK04    ST    R4,WNUMIOB          TOTAL NUMBER OF IOBS
         ST    R5,WNUMDCB          TOTAL NUMBER OF INPUT DCBS
         L     R15,PPIOPEN+4       OPEN LIST ADDR
         LA    R1,IERAP3A          R1 -> DCB ENTRIES SLOT
         LA    R5,1(,R5)           TOTAL NUMBER OF DCBS TO OPEN
         ST    R5,0(,R1)
         LA    R1,4(,R1)           UPDATE OPEN LIST POINTER
         ST    R1,WPARLST
*
*        COMPUTE STORAGE REQUIREMENTS FOR DCBS, IOBS, ECBS AND TABLES
*
         L     R4,PPISPGN1         R4 = NEXT AVAILABLE STORAGE
         SRL   R4,2
         SLL   R4,2                ALIGN STORAGE ON WORD BOUNDARY
*
*        COMPUTE STORAGE REQUIREMENTS FOR DCBS
*
         LA    R1,SORTOUTL         L'SORTOUT DCB
         SR    R6,R6               ZERO REG
         ICM   R8,B'1111',WNUMDCB  NO OF SORTWK DCBS, CHECK FOR ZERO
         BZ    AGK04A              NO OF INPUT DCBS TO GENERATE
         LA    R7,SORTWKL          R7 = L'SORTWK DCB
         MR    R6,R8
         AR    R1,R7               R1 = TOTAL DCB BYTES REQUIRED
AGK04A   SR    R4,R1               UPDATE ADDR POINTER
         ST    R4,WDCBADR          START OF DCB STORAGE AREA
*
*        COMPUTE PREFIXED IOB STORAGE REQUIREMENTS
*
         ICM   R8,B'1111',WNUMIOB  NO OF IOBS TO GENERATE, CHK FOR ZERO
         BZ    AGK04B              NO IOBS REQUIRED
         LA    R7,MODIOBL          R7 = L'PREFIXED IOB
         SR    R6,R6               FOR MULT
         MR    R6,R8               R7 = L'IOB * TOTAL NO OF IOBS
         SR    R4,R7               UPDATE ADDR POINTER
         ST    R4,WECBADR          START OF PREFIXED IOB STORAGE AREA
*
*        COMPUTE IOB TABLE STORAGE REQUIREMENTS
*
         L     R6,WNUMIOB          NO OF IOBS
         SLL   R6,2                NO OF IOBS TIMES 4
         SR    R4,R6               UPDATE ADDR POINTER
         ST    R4,PPISTIOB         STORE ADDR IN PPI
*
*        COMPUTE DCB ADDR TABLE STORAGE REQUIREMENTS
*
AGK04B   LA    R6,7                SET BALN DEFAULT VALUE
         PPITEST  PPI2314          CRCX SORT ?
         BZ    AGK04C              NO, BALN
         L     R6,WNUMDCB          YES, CRCX, USE ACTUAL NO OF DCBS
         LA    R6,1(,R6)           ADD 1 FOR OUTPUT DCB
AGK04C   SLL   R6,2                MULTIPLY NUMBER OF DCBS BY 4
         SR    R4,R6               UPDATE ADDR POINTER
         ST    R4,PPISTDCB         UPDATE PPI DCB TABLE ADDR
         ST    R4,PPISPGN1         UPDATE PPI
*
*        DIAGNOSTIC MESSAGE GENERATION
*
         PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTICS ?
         BZ    NODIAG              NO, BRANCH
         L     R9,PPIAMC+4
         LR    R0,R4               LOAD ADDR TO BE CONVERTED
         L     R15,PPICONV+4       LOAD ADDR OF CONVERSION ROUTINE
         BAS   R14,4(,R15)         CONVERT
         MVC   IER944A,2(R1)       MOVE FORMATTED ADDR INTO MSG
         LM    R0,R1,IER944        IER944I DCB TABLE ADDR
         L     R15,PPIADSSC        LOAD ADDR OF PRINT ROUTINE
         BAS   R14,12(,R15)        CALL PRINT RTN
*
*        SET INDICATOR IN ALL DCB ADDR TABLE SLOTS
*
NODIAG   LA    R0,X'800'
         SLL   R0,20               R0 = X'80000000'
         LA    R3,7                ASSUME IT IS A BALN SORT (MAX 7)
         PPITEST  PPI2314          CRCX ?
         BZ    AGK05               NO, IT IS A BALN SORT
         L     R3,WNUMDCB          YES, CHANGE R3 TO PPINDSKA+1 ENTRIES
         LA    R3,1(,R3)           INCR FOR SORTOUT QSAM DCB
AGK05    ST    R0,0(,R4)           STORE INDICATOR
         LA    R4,4(,R4)           UPDATE POINTER
         BCT   R3,AGK05            LOOP CONTINUE STORING INDICATORS
*
*        SET UP TABLE OF IOB ADDRS
*        STORE ALL REQUIRED ECBS AND IOBS WITH ECB POINTERS
*
AGK06A   ICM   R5,B'1111',WNUMIOB  NO OF IOBS TO GENERATE, CHK FOR ZERO
         BZ    AGK09               ZERO, BYPASS IOB GENERATION
         L     R1,PPISTIOB         R1 -> IOB ADDR TABLE
         L     R2,WECBADR          START OF PREFIXED IOB STORAGE AREA
         LR    R3,R2
         LA    R3,8(,R3)           R3 -> IOB PROPER ADDR
         LA    R4,MODIOBL          L'PREFIXED IOB
AGK07    ST    R3,0(,R1)           IOB ADDR IN TABLE
         ST    R2,MODIOB+IOBECBPT-IERIOB  ECB ADDR IN IOB MODEL
         MVC   0(MODIOBL,R2),MODIOB  MOVE PREFIXED IOB INTO STORAGE
         BCT   R5,AGK08            GO UPDATE IOB ADDR PTR
         B     AGK09               ALL IOBS ARE GENERATED
*
AGK08    LA    R3,MODIOBL(,R3)     UPDATE IOB ADDR POINTER
         LA    R2,MODIOBL(,R2)     UPDATE ECB ADDR POINTER
         LA    R1,4(,R1)           UPDATE IOB ADDR TABLE POINTER
         B     AGK07               CONTINUE IOB GENERATION
*
*        SET UP DCB GENERATION PARAMETERS
*
AGK09    L     R1,PPISTDCB         DCB ADDR TABLE
         L     R2,WPARLST          OPEN LIST ADDR
         L     R4,WDCBADR          START OF DCB STORAGE AREA
         LA    R7,SORTOUTL         L'SORTOUT DCB
         MVI   WINDIC,X'00'        SET INDICATOR FOR SORTOUT DCB
         B     AGKINITL            GO OUT AND RETURN FROM THE DCB
*                                  INITIALIZATION SUBROUTINE
*
*        CHECK IF USER EXIT E39 IS ACTIVE
*
AGKRTRN3 PPITEST  PPIME39          EXIT E39 ACTIVE ?
         BO    AGKGOUSR            YES, BRANCH
*
*        RETURN POINT FROM DCB MODIFICATION ROUTINE
*
AGKMVOUT MVC   0(SORTOUTL,R4),SORTOUT  MOVE SORTOUT DCB INTO STORAGE
*
*        STORE SORTOUT DCB ADDR INTO LISTS AND UPDATE POINTERS
*
         ST    R4,0(,R1)           DCB ADDR IN DCB ADDR TABLE
         ST    R4,0(,R2)           DCB ADDR IN OPEN LIST
         LA    R2,4(,R2)           UPDATE OPEN LIST POINTER
         ST    R2,WPARLST
         LA    R4,SORTOUTL(,R4)    UPDATE DCB ADDR PTR TO NEXT LOCATION
*
*        SET INDICATOR FOR INPUT DCB GENERATION
*
         ICM   R3,B'1111',WNUMDCB  NO OF INPUT DCBS TO GEN, CHECK FOR
         BZ    AGKEXIT             ZERO, BYPASS THE INPUT
*                                  DCB GENERATION ROUTINE
         MVI   WINDIC,X'01'
         B     AGKINITL            GO OUT AND RETURN FROM THE DCB
*                                  INITIALIZATION SUBROUTINE
*
*        CHECK IF USER EXIT E38 IS ACTIVE
*
AGKRTRN1 PPITEST  PPIME38          EXIT E38 ACTIVE ?
         BO    AGKGOUSR            YES, BRANCH
*
*        RETURN POINT FROM DCB MODIFICATION ROUTINE
*
AGKMVIN  L     R3,WNUMDCB          R3 = NO OF DCBS TO GENERATE
         LA    R6,PPISTAR          R6 -> DISK TABLE
         L     R8,PPISTIOB         R8 -> IOB ADDR TABLE
         L     R14,0(,R8)          R14 -> FIRST IOB
         LA    R9,PPISEQCT         R9 -> SEQUENCE COUNTERS
AGK10    PPITEST  PPI2314          CRCX SORT ?
         BZ    AGK10A              NO, BRANCH
         LA    R0,1                YES, SET P=1
         B     AGK10B              GOTO SAVE REGS
*
AGK10A   SR    R0,R0
         ICM   R0,B'0011',0(R9)    GET SEQ COUNTER VALUE
         BZ    AGK14               VALUE = 0, BRANCH
AGK10B   SR    R5,R5
         IC    R5,0(,R6)           R5 = M FROM PPISTAR ENTRY
         SRL   R5,1                CONVERT FROM DCB OFFSET TO OFFSET
*                                  INTO DDNAME SUFFIX TABLE
         LH    R5,DDTABLE(R5)      GET DDNAME SUFFIX FROM DDTABLE
         STH   R5,DCBDDNAM+6       STORE IN DCB MODEL
         ST    R14,DCBIOBAD        IOB ADDR IN DCB MODEL
         MVC   0(SORTWKL,R4),SORTWK  MOVE DCB INTO ALLOCATED STORAGE
         SR    R5,R5
         IC    R5,0(,R6)           R5 = M FROM PPISTAR ENTRY
         ST    R4,0(R1,R5)         DCB ADDR IN TABLE + OFFSET
         ST    R4,0(,R2)           DCB ADDR IN OPEN LIST
AGK11    ST    R4,IOBDCBPT-IOBSTDRD(,R14)  DCB ADDR IN IOB
         LA    R8,4(,R8)           UPDATE IOB TABLE POINTER
         L     R14,0(,R8)          GET NEXT IN IOB ADDR
         BCT   R0,AGK11            IOBS COMPLETED ?
         BCT   R3,AGK13            YES, ALL DCBS COMPLETED ?
         B     AGKEXIT             GO TO RESTORE REGS
*
AGK13    LA    R4,SORTWKL(,R4)     UPDATE DCB ADDR
         LA    R2,4(,R2)           UPDATE OPEN LIST POINTER
AGK14    LA    R6,8(,R6)           UPDATE PPISTAR POINTER
         LA    R9,2(,R9)           UPDATE SEQ COUNTER POINTER
         B     AGK10               CONTINUE CHECK OF SEQUENCE
*                                  COUNTERS
*
*        RETURN TO CALLER - IERRC9
*
AGKEXIT  LM    R12,R14,WREGSV3     RESTORE CALLERS REGS
         BR    R14                 RETURN TO IERRC9
*
*        DCB INITIALIZATION SUBROUTINE
*
*        USED FOR BOTH INPUT AND OUTPUT DCBS
*
AGKINITL STM   R1,R10,WREGSAVE     SAVE REGS
         TM    WINDIC,X'01'        SORTWKXX INPUT DCB ?
         BO    AGKINT05            YES, BRANCH
*
*        SORTOUT DCB INITIALIZATION SUBROUTINE
*
         LA    R12,SORTOUT         L'SORTOUT QSAM DCB MODEL
         MVC   DCBDDNAM(L'PPIDDSRT),PPIDDSRT  MOVE IN DDNAME PREFIX
         MVC   DCBBUFNO,PPILAB07   NUMBER OF OUTPUT BUFFERS
         MVC   DCBBUFCA,PPILAB06+1  8 BYTE CONTROL BUFFER ADDR
         MVC   DCBBUFL,PPILAB07+2  SIZE OF EACH OUTPUT BUFFER
         MVI   DCBEROPT,DCBERABE   ABNORMAL END OF TASK
         L     R1,PPIADSSC
         MVC   DCBSYNAD,24(R1)     MOVE ADDR OF SYNAD RTN INTO DCB
*
*        SET UP BFTEK, BFALN AND MACRF FIELDS
*
         MVI   DCBBFTEK,DCBBFTS    SIMPLE BUFFERING
         PPITEST  PPIMVSO          VBS OUTPUT ?
         BZ    AGKINT03            NO, GO TEST DBLE WORD BUF ALIGNMENT
*
AGKVBS   OI    DCBMACR2,DCBMRPUT+DCBMRMVP  SET MOVE DATA FOR VBS OUTPUT
         NI    DCBMACR2,255-DCBMRLCP       SET OFF LOCATE MODE
*
AGKINT03 PPITEST  PPIDWA           DOUBLE WORD BUFFER ALIGNMENT ?
         BO    AGKINT04            YES, BRANCH
         OI    DCBBFALN,DCBBFAF1   NO, FULL WORD ALIGNMENT
         B     AGKCOMM             GOTO COMM RTN
*
AGKINT04 OI    DCBBFALN,DCBBFAD    DOUBLE WORD ALIGNMENT
         B     AGKCOMM             GOTO COMM RTN
*
*        INPUT DCB INITIALIZATION SUBROUTINE
*
AGKINT05 LA    R12,SORTWK          R12 -> SORTWK MODEL DCB
         MVC   DCBDDNAM(L'PPIDDSRT),PPIDDSRT  MOVE IN DDNAME PREFIX
*
*        SET UP BFALN FIELD
*
         PPITEST  PPIDWA           DOUBLE WORD BUFFER ALIGNMENT ?
         BO    AGKINT08            YES, BRANCH
         OI    DCBBFALN,DCBBFAF1   NO, FULL WORD ALIGNMENT
         B     AGKCOMM             GOTO COMM RTN
*
AGKINT08 OI    DCBBFALN,DCBBFAD    DOUBLE WORD BUFFER ALIGNMENT
*
*        INITIALIZE FIELDS COMMON TO BOTH EXCP AND QSAM DCBS
*
AGKCOMM  MVI   DCBIFLG,DCBIFER     USE IOS ERROR ROUTINES
*
*        INITIALIZATION COMPLETE - RETURN TO MAIN PROGRAM
*
AGKINT10 LM    R1,R10,WREGSAVE     RESTORE REGS
         TM    WINDIC,X'01'        INPUT DCB ?
         BO    AGKRTRN1            YES, BRANCH
         B     AGKRTRN3            NO
*
*        CALL USER EXIT E38/E39
*
*        THE EXIT RETURNS WITH THE ADDR OF THE USER OPTION LIST IN R1
*        THE MODEL DCB WILL BE MODIFIED ACCORDING TO THE OPTIONS
*        SPECIFIED ON THE LIST
*
*        R1 -> USER OPTION LIST
*
*          BYTE 1      BYTE 2      BYTE 3      BYTE 4
*         _______________________________________________
*        |           |                                   |
*        | X'01'     | ADDR OF USER PROVIDED SYNAD I/O   |
*        |           | ERROR ROUTINE                     |
*        |___________|___________________________________|
*        |           |                                   |
*        | X'02'     | ADDR OF USER PROVIDED DCB DCBEXLSA|
*        |           | LIST                              |
*        |___________|___________________________________|
*        |           |           |           |           |
*        | X'03'     | 0         | 0         | DCBERROPT |
*        |           |           |           | FLAG BYTE |
*        |___________|___________|___________|___________|
*        |           |                                   |
*        | X'04'     | DCB EODAD ROUTINE (INPUT ONLY)    |
*        |           |                                   |
*        |___________|___________________________________|
*        |           |                                   |
*        | X'00'     | TERMINATING ENTRY IN LIST         |
*        |           |                                   |
*        |___________|___________________________________|
*
*
AGKGOUSR STM   R1,R10,WREGSAVE     SAVE REGS
         TM    WINDIC,X'01'        INPUT DCB EXIT ?
         BO    AGKUSR01            YES, BRANCH
         L     R15,PPIX39+4        NO, USER WRITE OPTION ADDR
         B     AGKUSR02            GO SET UP RETURN FROM USER
*
AGKUSR01 L     R15,PPIX38+4        USER READ OPTION ADDR
AGKUSR02 BASR  R14,R15             CALL USER EXIT ROUTINE
*
*        RETURN FROM THE USER MODIFICATION ROUTINE
*
         LR    R8,R1               R8 -> USER OPTION LIST
         L     R15,PPIOPEN+4       OPEN LIST ADDR
AGKSTMOD SR    R4,R4
         ICM   R4,B'0001',0(R8)    GET OPTION NUMBER FROM USER LIST
         BZ    AGKUSR08            TERMINATING ENTRY ? BRANCH
         CH    R4,KOPTMAX          USER OPTION NO > LEGAL VALUE ?
         BH    AGKUSR06            YES, VALUE NOT LEGAL
         SLL   R4,2                CONVERT TO BRANCH OFFSET
         B     *(R4)               BRANCH TABLE
         B     AGKTREB             +04 SYNAD (OPTION 01)
         B     AGKTRECH            +08 EXLST (OPTION 02)
         B     AGKONECH            +12 EROPT (OPTION 03)
*
AGKUSR06 TM    WFRSTERR,X'01'      FIRST OPTION ERROR ?
         BO    AGKUSR07            NO, BRANCH
         MVI   WFRSTERR,X'01'      YES, SET INDICATOR
         B     AGKERR              SET UP ERROR MESSAGE
*
AGKUSR07 LA    R8,4(,R8)           UPDATE USER LIST POINTER
         B     AGKSTMOD            CONTINUE MODIFICATIONS
*
*        MODIFICATIONS COMPLETE - RETURN TO MAIN PROGRAM
*
AGKUSR08 LM    R1,R10,WREGSAVE     RESTORE REGS
         MVI   WFRSTERR,X'00'      RESTORE FIRST OPTION ERROR INDIC
         TM    WINDIC,X'01'        RETURN TO INPUT ROUTINE ?
         BO    AGKMVIN             YES, BRANCH
         B     AGKMVOUT            NO
*
*        SYNAD (OPTION 01)
*
AGKTREB  TM    WINDIC,X'01'        INPUT DCB ?
         BO    AGKUSR07            YES, IGNORE SYNAD OPTION
         MVC   DCBSYNA,1(R8)       MOVE SYNAD ADDR INTO DCB
         B     AGKUSR07            GOTO GET NEXT WORD FROM OPTION LIST
*
*        EXLST (OPTION 02)
*
AGKTRECH MVC   DCBEXLSA,1(R8)      UPDATE DCBEXLSA
         B     AGKUSR07            GOTO GET NEXT WORD FROM OPTION LIST
*
*        EROPT (OPTION 03)
*
AGKONECH TM    WINDIC,X'01'        INPUT DCB ?
         BZ    AGKUSR07            NO, IGNORE EROPT OPTION
         MVC   WRDOPT(1),3(R8)
         B     AGKUSR07            GOTO GET NEXT WORD FROM OPTION LIST
*
*        GENERATE ERROR MESSAGE
*
AGKERR   L     R14,PPIAMC+4        MESSAGE MODULE ADDR
         LM    R0,R1,IER044        IER044I - EXIT E
         TM    WINDIC,X'01'        INPUT DCB ?
         BO    AGKERR01            YES, BRANCH
         MVC   IER044B,KTAG+2
         B     AGKERR02            GOTO SSC
*
AGKERR01 MVC   IER044B,KTAG
AGKERR02 L     R15,PPIADSSC
         BAS   R14,12(,R15)        CALL MSG WRITER
         B     AGKUSR07            GO UPDATE USER LIST PTR
*
*        WORK LOCATIONS
*
WNUMIOB  DC    F'0'                NO OF IOBS TO GENERATE
WNUMDCB  DC    F'0'                NO OF INPUT DCBS TO GENERATE
WDCBADR  DC    A(0)                -> DCB AREA
WECBADR  DC    A(0)                -> ECB/IOB (PREFIXED) AREA
WPARLST  DC    A(0)                NEXT USABLE SLOT IN OPEN LIST
WREGSAVE DC    11F'0'              SAVE AREA
WREGSV3  DC    3F'0'               SAVE AREA
WFRSTERR DC    X'00'               INDICATOR - FIRST OPTION ERROR
WINDIC   DC    X'00'               INDICATOR - INPUT OR OUTPUT
*
*        CONSTANTS
*
KTAG     DC    C'3839'             EXIT NUMBERS
KOPTMAX  DC    H'3'                MAX LEGAL OPTION NO
*
DDTABLE  DC    C'0001020304050607080910111213141516170000'
*
*        GENERATE MODEL IOB
*
MODIOB   DC    12F'0'              STANDARD DASD 40 BYTE IOB
*                                  PLUS 8 BYTE S/M PREFIX
MODIOBL  EQU   *-MODIOB            L'MODIOB
         ORG   MODIOB+8            (IOBFLAG1-IERIOB)
         DC    AL1(IOBCMDCH)       SET IOB CMD CHAINING FLAG
         ORG
*
*        GENERATE MODEL DCBS
*
         PRINT NOGEN
*
SORTOUT  DCB   MACRF=(PL),DSORG=PS,DDNAME=SORTOUT
*
SORTOUTL EQU   *-SORTOUT           L'SORTOUT DCB
*
SORTWK   DCB   MACRF=(E),DSORG=PS,DDNAME=SORTWK
*
         DC    F'0'                AREA APPENDED TO EXCP DCB
*                                  REFERENCED AS DCBOPTCD
*
SORTWKL  EQU   *-SORTWK            L'SORTWK DCB
*
         PRINT GEN
*
*        OPEN LIST DSECT
*
OPENLST  DSECT
         DC    4F'0'
IERAP3A  DC    19F'0'
WRDOPT   DC    F'0'                USER SYNAD AND EROPT
*
*        MODULE NAME - IERAMC
*
*        THIS MODULE CONTAINS ALL OF THE MESSAGES THAT ARE
*        REQUIRED FOR PHASE 3 ASSIGNMENT MODULES
*
DIERAMC  DSECT
*
         COPY  AMCMAIN
*
*        DCB DSECT
*
         PRINT NOGEN
*
         DCBD  DSORG=(PS),DEVD=(DA)
*
         PRINT GEN
*
*        IERIOB
*
         IERIOB
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERAGL   0101-20211-20211-1200-00327-00327-00000-RELEASE 00
AGL      TITLE 'IERAGL - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERAGL
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 2 ASSIGNMENT MODULE READ FORWARD
*        THE FUNCTION OF THIS MODULE IS TO CHECK IF USER EXIT
*        E28 IS ACTIVE AND MODIFY IERRGL IN APPROPRIATE PLACES.
*        IT ALSO CHECKS WHETHER FIXED OR VARIABLE LENGTH RECORDS
*        AND OVERLAYS IERRGL
*
*        THIS MODULE ALLOCATES SPACE FOR THE READ FORWARD CCWS
*        AND BLOCK COUNT TABLE IN GENERATED CORE. ENOUGH SPACE IS
*        RESERVED IN GENERATED CORE FOR 2M CCWS EVEN THOUGH
*        THERE MAY NOT BE FULL OVERLAP, AND N+1 (N=TOTAL NUMBER
*        OF WORK UNITS) INPUT BLOCKS (MAXIMUM CASE). THE BLOCK
*        COUNT, READ FORWARD COMMAND CODE, AND SLI BIT (FOR
*        VARIABLE LENGTH RECORDS) IS PUT IN 2M CCWS. M BUFFERS
*        ARE ATTACHED TO M CCWS AND IF THERE ARE ANY INPUT
*        BUFFERS REMAINING, THEY ARE ATTACHED TO AS MANY CCWS AS
*        THERE ARE ALTERNATE (REMAINING) BUFFERS
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - NONE
*
*        MACROS USED BY MODULE -
*        SMPPI
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                       CALLING SEQUENCE -
*                           LOAD EP=IERAGL,DCB=SORTLIB
*                           LR   R15,R0
*                           BALR R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIMRGMX   PPISPGN1   PPITPTBL
*        PPIBDSVA   PPICNTL    PPILAB02
*        PPILAB03   PPISTDCB
*        INFO NEEDED FOR CALCULATIONS TO BUILD SKELETON CCWS,
*        AND TO ATTACH BUFFERS TO THE IOBS
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPILAB03   PPIPSVA   PPIWKARE
*        WORK AREAS NEEDED IN THE CALCULATIONS, ALSO IF NEEDED
*        PPILAB03 (HI BYTE) WILL BE CHANGED TO 2M IF NO OF BFRS
*        EXCEED 2M
*
*        EXTERNAL ROUTINES - NONE
*
*        EXTERNAL PARAMETERS - SEE REGISTERS
*
*        EXITS - NORMAL - EXIT TO IERRC9
*                         CALLING SEQUENCE -
*                             BR   R14        RETURN
*
*        EXITS - ERROR - NONE
*
*        TABLES/WORK AREAS -
*        TABLES AND WORK AREAS ARE IN PPI
*
*        NOTES -
*        THIS MODULE WILL EXECUTE FOR ANY BALANCED TAPE SORT
*        INVOLVING A READ FORWARD EXECUTION TO SAVE A COPY PASS
*
IERAGL   CSECT
*
         USING *,R11               THIS MODULE BASE REGISTER
         USING IERAP22,R1          OPEN LIST BASE REGISTER (DSECT)
         USING IERRCA,R13          PPI BASE REG(DSECT)
         USING DIERRGL,R10         IERRGL BASE REGISTER (DSECT)
         USING IOBSTDRD,R5         IOB BASE REG (DSECT)
         USING IHADCB,R6           DCB BASE REG (DSECT)
*
IERMGB   LR    R11,R15             ESTABLISH MODULE ADDRESSABILITY
         L     R10,PPIRD+4         ADDR OF IERRDL
         SR    R3,R3
         L     R1,PPIOPEN+4        ADDR OF OPEN LIST
*
*        ERROR OPTIONS
*        CHECK TO SEE IF USER READ ERROR SYNAD EXIT E28 IS
*        ACTIVATED. IF ACTIVATED CHECK USER OPTIONS
*        20 = TERMINATE PROGRAM
*        40 = SKIP THE PHYSICAL RECORD
*        80 = ACCEPT THE PHYSICAL RECORD
*        IF NOT ACTIVATED 20 IS ASSUMED. MODIFY IERRDL IN
*        THE APPROPRIATE PLACES
*
         LA    R15,RGBERROR+4      MODIFICATION AREA IN IERRGL
         CLC   WRDOPT+1(3),KCCW+1  E28 SYNAD ACTIVE FOR PHASE 2 ?
         BE    AGBNOADR            NOT ACTIVE, BRANCH
         PPISETON PPIACCPT         SET ACCEPT SKIP SWITCH
         CLI   WRDOPT,X'40'        TEST OPTION BYTE
         BL    AGBTERM             LESS THAN 40 = TERMINATE
         BE    AGBSTRT             EQUAL, BYPASS FURTHER SETTINGS
         MVC   RGBACCPT(2),AGLRAN  GREATER, SET ACCEPT OPTION
AGLRAN   B     AGBSTRT             BRANCH IS ALSO USED AS 47F0
*
AGBNOADR MVI   RGLTERM+1,X'F0'     CONVERT NOP TO AUTOMATIC ABEND
AGBTERM  PPISETOF PPIACCPT         TURN OFF SKIP ACCEPT SWITCH
*
*        CALC AND ALLOCATE SPACE FOR CCW'S AND BLOCK COUNT TABLE
*
AGBSTRT  MVC   KSAVE(2),PPIMRGMX   M=NO OF INPUT FILES
         NI    PPISPGN1+3,X'F8'    ALIGN TO DOUBLE WORD BOUNDARY BY
*                                  DECR START OF GEN CORE TO DWORD
         L     R1,PPISPGN1         START OF GEN CORE ON DWORD BNDRY
         LH    R2,KSAVE            MERGE ORDER
         LR    R0,R2
         SLL   R2,4                X16 EACH CCW IS 8 BYTES THIS CALC
*                                  EQUALS 2MX8
         SR    R1,R2               RESRV 2MX8 BYTES IN GEN CORE
*
*        WRITE DIAGNOSTIC MSG
*
         PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTICS ?
         BZ    AGLTEST             NO, BRANCH
         STM   R14,R4,AGLSTM       SAVE REGS
         LR    R0,R1               ADDR OF FIRST CCW IN GEN CORE
         USING AGLAMB,R4           BASE REG FOR MESSAGE MODULE
         L     R4,PPIAMB+4
         L     R15,PPICONV+4       ADDR OF CONVERT ROUTINE
         BAS   R14,4(,R15)         CALL CONVERT RTN
         MVC   IER927A,2(R1)       MOVE FORMATTED ADDR INTO MSG
         LM    R0,R1,IER927        IER927I INPUT CCW ADDR
         L     R15,PPIADSSC        ADDR OF SSC
         BAS   R14,12(,R15)        CALL PRINT MESSAGE RTN
         LM    R14,R4,AGLSTM       RESTORE REGISTERS
*
*        END OF DIAGNOSTIC ROUTINE
*
AGLTEST  SLL   R0,1                EQUALS 2M
         IC    R3,PPILAB03         NUMBER OF INPUT BUFFERS
         CLR   R3,R0               COMPARE ACTUAL BUFFERS TO FULL
*                                  OVERLAP BUFFER CONDITION
         BNH   *+8                 <= TO 2XM, BRANCH
         STC   R0,PPILAB03         HAVE MORE BUFFERS THAN MAXIMUM
*                                  NEEDED (THAN FULL OVERLAP) THUS
*                                  RESET NO OF BUFFERS TO 2XM
*
*        CALCULATE STORAGE FOR BLOCK COUNT TABLE
*        MODIFY PPISPGN1 TO THE PROPER ADDR
*
         IC    R3,PPIBDSVA         TOTAL NO OF WORK UNITS
         LA    R3,1(,R3)           ADD 1 FOR TABLE ALIGNMENT
         SLL   R3,2                X4 4 BYTES FOR EACH ENTRY
         LR    R4,R1               SAVE STARTG ADDR OF CCW LIST
         SR    R1,R3               RESERVE SPACE FOR BLOCK CTRS
         ST    R1,PPISPGN1         SAVE UPDATED ADDR FOR NEXT RTN
*                                  USING GENERATED CORE
         ST    R1,PPISBLCT         STORE ADDR OF BLOCK COUNT TABLE
*
*        CHECK FOR THE PROPER RECORD FORMAT BEFORE BUILDING THE
*        CCWS
*
         PPITEST  PPIVAR           VARIABLE LENGTH RECORDS ?
         BO    AGBVR020            YES, BRANCH
*
*        BUILD THE CCWS IN GEN STORAGE WITH THE COUNT FIELD, READ
*        FORWARD COMMAND FLAG FIELD
*        (NO SLI BIT FOR FIXED LENGTH RECORDS)
*
AGBGN010 MVC   KCCW+6(2),PPILAB03+2  COUNT FIELD
AGBFLAG  MVI   KCCW+4,X'00'        FLAG=00 FOR FIXED LEN
*
*        GENERATE 2XM CCWS IN GENERATED CORE
*
         LR    R3,R4               STARTG ADDR OF CCWS IN GEN CORE
AGBCCWLP MVC   0(8,R4),KCCW        MOVE A CCW INTO GENERATED CORE
         LA    R4,8(,R4)           UPDATE GEN CORE PTR TO MOVE NEXT CCW
         BCT   R0,AGBCCWLP         DECR 2M CCW CTR LOOP IF MORE CCWS
*
*        ATTACH THE CCWS AND BUFFERS TO THE INPUT IOBS SPECIFIED
*        BY THE TAPE TABLE VIA THE INPUT BIT AND INCREMENT
*
         LR    R0,R3               STARTG ADDR OF THE CCWS IN GEN CORE
         LH    R2,KSAVE            MERGE ORDER (M)
         L     R1,PPISTDCB         PTR TO THE DCB TABLE OF ADDRS
         LA    R4,PPITPTBL         PTR TO THE TAPE TABLE HAVING THE
*                                  INPUT BIT AND FILE INCR
         LA    R7,PPIWKARE         WORK AREA IN PPI
AGBGN030 TM    0(R4),X'80'         SEARCH TAPE TABLE FOR INPUT FILE
         BO    AGBGN040            BRANCH ON AN INPUT FILE
         LA    R4,2(,R4)           NEXT ENTRY IN THE TAPE TABLE
         B     AGBGN030            LOOP
*
*        VARIABLE LENGTH OVERLAYS FOR THE RUNNING PROGRAM IERRGL
*
AGBVR020 MVI   AGBFLAG+1,SLI       SET THE SLI BIT
         MVI   RGBBRVR+1,X'F0'
         MVI   RGBRTRNV+3,X'08'
         MVI   RGBEOSV+3,X'06'
         MVI   RGBPREOS+3,X'06'
         MVI   RGBEREOS+3,X'06'
         MVI   RGBBRVAR+3,X'08'
         MVI   RGBBCCV+1,X'F0'
         MVI   RGBLSTBK+3,X'06'
         MVI   RGBCKEOS+3,X'06'
         B     AGBGN010            MORE CCWS TO BE GENERATED
*
*        THE IOBS ARE ALREADY ATTACHED TO THE DCBS
*        ATTACH A BUFFER NO OF 1 TO THE DCB. SAVE IOB ADDR TO
*        ATTACH AN ALTERNATE BUFFER, TO GAIN FULL OVERLAP, IF
*        THERE ARE BUFFERS REMAINING. ATTACH A CCW TO THE IOB AND
*        ATTACH A BUFFER TO THIS CCW. ATTACH A 2ND CCW IN THE 4
*        BYTES FOLLOWING THE ECB IN PREPARATION FOR PARTIAL OR
*        FULL OVERLAP
*
AGBGN040 SR    R6,R6
         IC    R6,1(,R4)          INCR FROM THE TAPE TABLE
         STC   R6,0(,R7)          STORE IN PPIWKARE
         L     R6,0(R6,R1)        LOAD A DCB ADDR VIA INCR
         MVI   DCBBUFNO,1         SET BUFNO IN DCB TO A 1
         MVC   1(3,R7),DCBIOBAA   SAVE IOB ADDR IN PPIWKARE
         L     R5,DCBIOBAD        ADDR OF THE IOB ATTACHED TO THIS DCB
         ST    R3,IOBSTART        ATTACH STRTG ADDR OF A CCW TO IOB
         L     R6,PPILAB02        ADDR OF BEGINNING OF INPUT BFR ADDR
*                                 TABLE
         L     R8,0(,R6)          STRTG ADDR OF AN INPUT BUFFER
         ST    R8,PPIPSVA+4       SAVE IN A WORK AREA
         MVC   1(3,R3),PPIPSVA+5  MOVE ONLY THE ADDR OF THE INPUT BFR
*                                 INTO CCW ATTACHED TO THE IOB
         LA    R6,4(,R6)          UPDATE INPUT BUFFER ADDR PTR
         ST    R6,PPILAB02        UPDATE THE PTR IN PPI
         LA    R3,8(,R3)          UPDATE CCW PTR TO NEXT AVAILABLE CCW
         LA    R4,2(,R4)          UPDATE TAPE TABLE PTR TO NEXT ENTRY
         LA    R7,4(,R7)          UPDATE PTR TO NEXT FREE AREA IN
*                                 PPIWKARE TABLE, TO INSRT NEXT IOB
         L     R8,IOBECBPT        ADDR OF ECB ATTACHED TO IOB
         ST    R3,4(,R8)          ATTACH THE ALTERNATE CCW TO THE IOB
*                                 (DCB GENERATION SETS ASIDE 4 BYTES
*                                 AFTER THE ECB FOR THIS CCW ADDR)
         LA    R3,8(,R3)          UPDATE CCW PTR TO NEXT AVAILABLE CCW
         BCT   R2,AGBGN030        DECR MERGE ORDER LOOP UNTIL M=0
*
*        EACH INPUT DCB HAS AN IOB
*        EACH IOB HAS A CCW WITH 1 INPUT BUFFER ATTACHED TO IT.
*        THE ADDR OF A 2ND CCW IS LOCATED IN THE 4 BYTES
*        FOLLOWING THE ECB FOR EACH IOB
*
         IC    R2,PPILAB03         TOTAL NO.OF INPUT BUFFERS
         SH    R2,KSAVE            MINUS MERGE ORDER=NO OF ALT BUFFERS
         BZ    AGBLK070            ZERO, NO ALT BUFFERS FOR OVERLAP
*
*        PARTIAL OR FULL OVERLAP ROUTINE
*        ATTACH THE ALTERNATE BUFFERS TO THE IOBS' ALTERNATE
*        CCWS. R2 CONTAINS NO OF ALTERNATE BUFFERS. ALL THE IOB
*        ADDRS WITH THEIR FILE INCR WERE SAVED IN PPIWKARE TABLE
*
         LA    R7,PPIWKARE         ADDR OF THE IOB TABLE OF ADDR
         L     R4,PPILAB02         ALTERNATE BUFFER ADDR PTR
         CH    R2,KSAVE            NO OF ALT BUFFERS TO MERGE ORDER
         BE    AGBAL060            BR IF HAVE FULL OVERLAP CONDITION
         MVI   RGBRFBF+1,X'F0'     PARTIAL OVLAP SET INSTR IN IERRGL
*                                  TO UNCONDITIONAL BRANCH
AGBAL060 L     R5,0(,R7)           IOB ADDR FROM TABLE
         L     R8,IOBECBPT         ADDR OF ECB ATTACHED TO THIS IOB
         L     R6,IOBDCBPT         ADDR OF DCB ATTACHED TO THIS IOB
         L     R8,4(,R8)           IOB'S ALTERNATE CCW ADDR IN GEN CORE
         L     R5,0(,R4)           STRTG ADDR OF NEXT AVAILABLE INPUT
*                                  BUFFER
         ST    R5,PPIPSVA+4        SAVE THIS ADDR IN A WORK AREA
         MVC   1(3,R8),PPIPSVA+5   STORE ALT BFR ADDR IN ACTUAL ALT CCW
         MVI   DCBBUFNO,2          UPDATE IOB'S DCB TO 2 BUFFERS
         LA    R7,4(,R7)           UPDATE IOB ADDR TABLE PTR
         LA    R4,4(,R4)           UPDATE ALTERNATE BUFFER ADDR PTR
         BCT   R2,AGBAL060         DECR ALT BFR CTR LOOP IF MORE BFRS
*
*        RETURN TO IERRC9
*
AGBLK070 BR    R14                 RETURN
*
*        CONSTANTS
*
KCCW     CCW   READFT,0,0,0        MODEL CCW WORK AREA
AGLSTM   DC    7F'0'               SAVE AREA FOR REGS R14-R4
*
*        IERRGL
*
DIERRGL  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRGL SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRGLI
*
*        IERAP22
*
IERAP22  DSECT
         DC    33F'0'
WRDOPT   DC    F'0'
         DC    11F'0'
*
*        AGLAMB
*
AGLAMB   DSECT
*
         COPY  AMBMAIN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
*        IERCCWEQ
*
         IERCCWEQ
*
*        IERIOB
*
         IERIOB
*
         PRINT NOGEN
*
         DCBD  DSORG=PS,DEVD=(DA,TA)
*
         IHAECB DSECT=NO,EXT=NO
*
         IEZDEB LIST=NO
*
         PRINT GEN
*
         SMPPI
*
         END
./ ADD NAME=IERAGM   0101-20211-20211-1200-00465-00465-00000-RELEASE 00
AGM      TITLE 'IERAGM - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERAGM
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 3 ASSIGNMENT MODULE - READ FORWARD
*        THE FUNCTION OF THIS MODULE IS TO CHECK IF USER READ
*        ERROR EXIT E38 SYNAD IS ACTIVATED AND OVERLAYS THE READ
*        FORWARD RUNNING MODULE IERRGM. IT ALSO CHECKS WHETHER
*        FIXED OR VARIABLE LENGTH RECORDS AND OVERLAYS IERRGM
*
*        THIS MODULE ALLOCATES SPACE IN GENERATED CORE AND
*        BUILDS THE READ FORWARD CCWS AND THE TABLE OF INPUT
*        BLOCK COUNTERS. ENOUGH SPACE IS RESERVED FOR 2M CCWS
*        EVEN THOUGH THERE MAY NOT BE FULL OVERLAP, AND
*        N+1 (N=TOTAL NUMBER OF WORK UNITS) INPUT BLOCKS (MAXIMUM
*        CASE)
*
*        AFTER FINDING ALL THE INPUT UNITS FROM THE TAPE TABLE,
*        M INPUT BUFFERS ARE PRIMED AND READS ISSUED ON ANY
*        REMAINING BUFFERS
*
*        TWO TABLES ARE CREATED. THE TABLE OF FILE COUNTERS
*        WHICH HAS EACH INPUT UNIT'S INCREMENT AND THE NUMBER OF
*        BUFFERS ATTACHED TO IT, AND THE PRIMING TABLE WHICH HAS
*        EACH INPUT UNIT'S INCREMENT WITH THE STARTING ADDRESS OF
*        ITS PRIMARY BUFFER
*
*        THIS MODULE ALSO CHECKS FOR READ ERRORS. IF USER EXIT
*        E38 SYNAD IS NOT ACTIVATED IT WILL TERMINATE THROUGH SORT
*        SYSTEM CONTROL. IF IT IS ACTIVE, THE USER MAY TRY TO FIX
*        THE ERROR AFTER IOS HAS TRIED TO DO SO
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - NONE
*
*        MACROS USED BY MODULE -
*        EXCP   SMPPI   DCBD   WAIT
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                       CALLING SEQUENCE -
*                           LOAD EP=IERAGM,DCB=SORTLIB
*                           LR   R15,R0
*                           BALR R14,R15
*
*                     - ENTRY FROM E38 SYNAD
*                       CALLING SEQUENCE -
*                           BR   R14        RETURN
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIBDSVA   PPIMRGMX   PPISRTBL
*        PPIWKARE   PPILAB03   PPIRCDCT
*        PPISTDCB   PPIRCDL2   PPICNTL
*        PPITPTBL
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPILAB01   PPISBLCT   PPICNTL
*        PPILAB02   PPISPGN1   PPILAB03
*        PPISAVEA
*
*        EXTERNAL ROUTINES - NONE
*
*        EXTERNAL PARAMETERS - SEE REGISTERS
*
*        EXITS - NORMAL - EXIT TO IERRC9
*                         CALLING SEQUENCE -
*                             BR   R14        RETURN
*
*                       - EXIT TO IERRPG
*                         CALLING SEQUENCE -
*                             L    R11,PPIWRT+4
*                             BR   R11        0 INPUT W/O E35
*                             B    4(,R11)    0 INPUT W/E35
*
*        EXITS - ERROR - EXIT TO E38 SYNAD
*                        CALLING SEQUENCE -
*                            L    R15,AE38
*                            BALR R14,R15        READ ERROR
*
*                      - EXIT TO SSC VIA
*                        CALLING SEQUENCE -
*                            L R15,PPIADSSC
*                            B 16(,R15)          TERMINATE
*
*        TABLES/WORK AREAS -
*        WORK AREAS ARE IN PPI
*
*        NOTES -
*        THIS MODULE WILL EXECUTE FOR FIXED LENGTH BALANCED OR
*        OSCILLATING SORT REQUIRING PHASE 1 TO PHASE 3 SITUATION
*        TO ELIMINATE A COPY PHASE 2 PASS
*
IERAGM   CSECT
*
         USING *,R11
         USING IERAP33,R1
         USING IERRCA,R13
         USING DIERRGM,R10         DSECT BASE REGISTER
         USING IOBSTDRD,R5
         USING IHADCB,R6
*
IERMGD   LR    R11,R15
         ICM   R10,B'1111',PPIRCDCT  CHECK FOR ZERO
         BZR   R14                 FILE
*
         ST    R14,SAVER14         SAVE RETURN REGISTER
         L     R10,PPIRD+4         READ ROUTINE
         SR    R3,R3
*
*        ERROR OPTION OVERLAYS
*
         L     R1,PPIOPEN+4        SET UP ERROR OPTION AND
         CLC   WRDOPT+1(3),KCCW+1  USER REQ ACTIVE E38 ?
         BE    AGMAUTO             NO, BYPASS SETTINGS
         MVC   AE38+1(3),WRDOPT+1  YES, SET ADCON FOR IERRGM
         PPISETON PPIACCPT         SET ACCEPT SKIP SWITCH
         CLI   WRDOPT,X'40'        TEST OPTION BYTE
         BL    AGMTERMX            < X'40' = TERMINATE
         BE    AGDST001            EQUAL, NO MORE SKIP SETUP
         MVC   RGDACCPT(4),RGDACCBR  MODIFY ACCEPT ADDRS
         MVC   AGDACCPT(4),AGDACCBR  IN R15 & AP
AGMRAN   B     AGDST001              ALSO USED AS CONSTANT 47FO
*
AGMAUTO  MVI   RGMTERM+1,X'F0'     SET TERMINATE IMMEDIATELY IERRGM
         MVI   AGMTERM+1,X'F0'     SET TERMINATE IMMEDIATELY IERAGM
AGMTERMX PPISETOF PPIACCPT         TURN OFF SKIP ACCEPT SWITCH
         DROP  R1
*
*        CALCULATE AND ALLOCATE SPACE FOR CCW'S AND BLOCK COUNT
*        TABLE
*
AGDST001 NI    PPISPGN1+3,X'F8'    ALIGN TO NEXT LOWEST DWORD BOUNDARY
         L     R1,PPISPGN1         START OF GEN CORE
         LH    R2,PPIMRGMX         MERGE ORDER
         LR    R0,R2
         SLL   R2,4                SIZE OF CCW'S
         SR    R1,R2
*
*        WRITE DIAGNOSTIC MSG
*
         PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTICS ?
         BZ    AGMTEST             NO, BRANCH
         STM   R14,R4,AGMSTM       SAVE REGS
         LR    R0,R1               ADDR OF FIRST CCW IN GEN CORE
         USING AGMAMB,R4           BASE REG FOR MESSAGE MODULE
         L     R4,PPIAMB+4         BASE REG FOR MESSAGE MODULE
         L     R15,PPICONV+4       ADDR OF CONVERT ROUTINE
         BAS   R14,4(,R15)         CALL CONVERSION RTN
         MVC   IER945A,2(R1)       MOVE FORMATTED ADDR INTO MSG
         LM    R0,R1,IER945        IER945I INPUT CCW ADDR
         L     R15,PPIADSSC        ADDR OF SSC
         BAS   R14,12(,R15)        CALL PRINT MESSAGE RTN
         LM    R14,R4,AGMSTM       RESTORE REGISTERS
*
*        END OF DIAGNOSTIC ROUTINE
*
AGMTEST  SLL   R0,1                EQUALS 2M
         STC   R0,RGDK2M+1
         IC    R3,PPILAB03         IF NO BUFFERS > (2*M), RESET NO
         CLR   R3,R0               OF BUFFERS TO 2*M
         BNH   AGDST010
         STC   R0,PPILAB03
AGDST010 IC    R3,PPIBDSVA         TOTAL WORK UNITS
         LA    R3,1(,R3)
         SLL   R3,2                BLOCK COUNTERS AREA IN GENERATED
         LR    R4,R1               CORE
         SR    R1,R3
         ST    R1,PPISPGN1         SAVE UPDATED ADDR OF FREE STORAGE
         ST    R1,PPISBLCT         SET ADDR OF BLOCK COUNT TABLE
         PPITEST  PPIVAR           VARIABLE LENGTH RECORDS ?
         BO    AGDVR020            YES, BRANCH
*
*        BUILD 2M CCWS IN GEN STORAGE
*        SET SLI BIT OFF FOR FIXED LENGTH RECORDS
*        SET SLI BIT ON FOR VARIABLE LENGTH RECORDS
*
         SR    R3,R3               ALL FLAG BITS OFF FOR FIX FORMAT
AGDCCWGN MVC   KCCW+6(2),PPILAB03+2    COUNT
         MVC   KBLKCHR+2(2),PPILAB03+2
         STC   R3,KCCW+4           FLAGS
         LR    R3,R4               GENERATE 2*M CCW'S
AGDCCWLP MVC   0(8,R4),KCCW
         LA    R4,8(,R4)           UPDATE GEN AREA POINTER BY L'CCW
         BCT   R0,AGDCCWLP
         LH    R2,PPIMRGMX         MERGE ORDER
         L     R1,PPISTDCB
         LA    R4,PPITPTBL         TAPE TABLE POINTER
         LA    R9,PPIWKARE         SORT WORK AREA
AGDIN030 TM    0(R4),X'80'         SEARCH TAPE TABLE FOR
         BO    AGDIN040            INPUT FILES
         LA    R4,2(,R4)
         B     AGDIN030
*
*        OVERLAYS FOR VARIABLE RECORD FORMAT
*
AGDVR020 LA    R3,SLI              SLI FLAG ON FOR VAR FORMAT
         MVI   AGDBRVR+1,X'F0'     VARIABLE LENGTH RCD OVERLAYS
         MVI   RGDBRVR+1,X'F0'     IN IERAGM AND IERRGM
         MVI   AGDVRDSP+3,X'08'    FOR THE MERGE RCD ADDR BYPASS BCC
         MVI   RGDRTRNV+3,X'08'    AND EOS INDICATOR
         MVI   RGDEOSB1+3,X'06'
         B     AGDCCWGN
*
*        BUILD PPIWKARE TABLE
*        INCR OF INPUT UNIT IN 1ST BYTE
*        IOB ADDR IN NEXT 3 BYTES. DO THIS FOR M INPUT UNITS
*        UPDATE EACH INPUT DCB TO 1 BUFFER
*
AGDIN040 SR    R6,R6
         IC    R6,1(,R4)           INCR
         STC   R6,0(,R9)           SAVE INCR
         L     R6,0(R6,R1)
         MVI   DCBBUFNO,1          BUFNO IN DCB
         MVC   1(3,R9),DCBIOBAD+1  SAVE IOB ADDR IN SORT WORK AREA
         LA    R9,4(,R9)           FOR LATER USE TO ATTACH CCW'S
*                                  AND PRIME THE BUFFERS
         LA    R4,2(,R4)           UPDATE TAPE TABLE POINTER
         BCT   R2,AGDIN030
*
*        ATTACH THE CCW'S AND START PRIMING THE BUFFERS
*
         LA    R4,PPIWKARE         SORT WORK AREA
         L     R6,PPILAB02         INPUT BUFFER TABLE ADDR
         LH    R7,PPIMRGMX
AGDIN050 L     R5,0(,R4)           R5=IOB BASE REG R4=DTR TO PPIWKARE
*                                  TABLE WITH ADDR OF IOB IN IT
         ST    R3,IOBSTART         R3 -> CCWS IN GEN CORE. STORE
*                                  ADDR OF A CCW IN IOB
         L     R1,0(,R6)           STARTG ADDR OF INPUT BFR FROM INPUT
*                                  BUFFER ADDR TABLE
         ST    R1,PPISAVEA         MOVE TO WORK AREA TO REMOVE 1ST BYTE
         MVC   1(3,R3),PPISAVEA+1  STORE STRTG ADDR OF BFR IN A CCW
         MVI   4(R3),SLI           TURN SILI BIT ON IN CASE SHORT BLOCK
*
         IEREXCP  (R5)             READ FORWARD
*
         LA    R3,8(,R3)
         L     R15,IOBECBPT        SAVE ALTERNATE CCW
         ST    R3,4(,R15)          ADDR
         LA    R3,8(,R3)           UPDATE CCW, BUFFER
         LA    R6,4(,R6)           AND IOB POINTERS
         LA    R4,4(,R4)
         BCT   R7,AGDIN050
*
*        M INPUT BUFFERS ARE PRIMED
*        ALTRNATE CCWS HAVE BEEN ASSIGNED THE IOBS
*
         LA    R4,PPIWKARE         IOB IN SORT WORK AREA
         LA    R8,TFCNT            FILE COUNTERS
         IC    R7,PPILAB03         NO OF INPUT BUFFERS MINUS MERGE
         STC   R7,KTOTAL
         SH    R7,PPIMRGMX         ORDER = NO OF ALTERNATE BUFFERS
         BZ    AGDNOVLP            NO OVERLAP
         STH   R7,PPILAB01+12
*
*        PRIME ALTERNATE BUFFERS
*
         LR    R3,R7               LOAD NO OF ALT BFRS CTR
         LH    R0,PPISRTBL         FILE COUNTER
         SLL   R0,1                ENTRY IS 2*SORTBLKING
         ST    R0,PPILAB01+4
AGDOVLP  ST    R6,PPILAB01+8       SAVE BUFFER POINTER PTS TO NEXT
*                                  AVAILABLE BFR ADDR IN THE TABLE
         BAS   R9,AGDLK060         WAIT ADDR IN SORT WORK AREA BLCNT
         L     R2,PPILAB01+8       BUFFER POINTER
         ST    R4,PPILAB01+16
         L     R6,IOBDCBPT         DCB ADDR
         L     R4,IOBSTART         ATTACH THE ALTERNATE BUFFER TO
         L     R14,IOBECBPT
         MVC   IOBSTART,4(R14)     THE FILE
         ST    R4,4(,R14)
         L     R4,IOBSTART         STORE BUFFER ADDR IN
         L     R14,0(,R2)          THE CCW (R3 BACKWARDS)
         ST    R14,PPISAVEA        STORE STRTG BFR ADDR OF ACT BFR
         MVC   1(3,R4),PPISAVEA+1  STORE JUST THE STRTG ADDR IN THE CCW
         MVI   DCBBUFNO,2          UPDATE BUFNO IN DCB TO 2 BUFFERS
*
         IEREXCP  (R5)             READ FORWARD ON ALT BUFFER
*
         L     R4,PPILAB01+16      PREVIOUS ENTRY ADDR OF PPIWKARE TABL
         L     R6,PPILAB01+8       ADDR OF BUFFER (JUST USED AS ALT)
*                                  IN BUFFER ADDR TABLE
         LA    R6,4(,R6)           UP BUFFER PTR TO NEXT FREE BFR ADDR
AGDOVEND LA    R4,4(,R4)           UP PPIWKARE PTR TO NEXT (IOB) ENTRY
         BCT   R3,AGDOVLP          DECR NO OF ALT BFRS CTR BR IF MORE
         ST    R6,PPILAB02         SAVE BUFFER POINTER FOR RP'S USE
         CLC   PPILAB01+12(2),PPIMRGMX
         BE    AGDRTN              FULL OVERLAP ALL WAITS ISSUED
*
*        PARTIAL OVERLAP
*        M INPUT BUFFERS HAVE BEEN PRIMED. READS HAVE BEEN
*        ISSUED ON ALL ALTERNATE BUFFERS. WAITS HAVE BEEN ISSUED
*        ON AS MANY PRIMARY BFRS AS THERE ARE ALTERNATE BFRS SO
*        NOW WAITS MUST BE ISSUED ON THE REST OF THE PRIMARY
*        BUFFERS (THESE BELONG TO THE SINGLE BUFFERED FILES)
*
         LH    R3,PPIMRGMX         NEED TO ISSUE WAITS AND PASS ADDR
         SH    R3,PPILAB01+12      IN SORT WORK AREA ON THE FILES
         B     AGDNOVLP+8          WITH NO ALTERNATE BUFFERS
*
AGDNOVLP LH    R3,PPIMRGMX
         ST    R6,PPILAB02         SAVE BUFFER POINTER FOR IERRGM
         MVC   PPILAB01+6(2),PPISRTBL  FILE COUNTER ENTRY IS SORTBLK
         BAS   R9,AGDLK060         WAIT ON EACH FILE AND PASS INITIAL
         LA    R4,4(,R4)           UPDATE IOB POINTER
         BCT   R3,AGDLP070         ADDR OF RCDS TO MERGE IN
*                                  SORT WORK AREA. SET UP BLCNT
AGDRTN   L     R14,SAVER14         RETURN TO IERRC9
         MVC   KMRGMX(2),PPIMRGMX
         MVC   KMRGMX1(2),PPIMRGMX
         BR    R14
*
*        WAIT ON M BUFFERS AND ERROR CHECK
*
AGDLK060 L     R6,PPISBLCT         R6 -> BLOCK COUNTERS FOR DEBLOCK
AGDLP070 L     R5,0(,R4)           IOB ADDR
         L     R1,IOBECBPT
*
         IERWAIT  1,ECB=(1)        WAIT ON IOB
*
         NI    IOBCSTAT,255-IL     TURN OFF SLI
*
*        EOF - ERROR CHECK RTN
*
AGDEE100 TM    IOBUSTAT,UC+UE      UNIT CHECK OR UNIT EXCEPTION ?
         BNZ   AGSTORRF            SAVE IOB ADDR IN CASE NO SYNAD RTN
*                                  NO NULL FILES OPENED IN IERAGH
         TM    IOBCSTAT,CDC        CHANNEL DATA CHECK ?
         BO    AGSTORRF            SAVE IOB ADDR IN CASE NO SYNAD RTN
AGDEE110 L     R1,KBLKCHR          COUNT OF A FULL BFR FROM LAB03
         SH    R1,IOBCSW+5         SUBTRACT RESIDUAL COUNT IN CSW
         L     R2,IOBSTART         ADDR OF THIS IOB'S CCW
         LR    R15,R2              SAVE ADDR
         L     R2,0(,R2)           STARTING ADDR OF THE INPUT BFR
         SH    R1,KFOUR            ACTUAL NO OF BYTES JUST FOR
*                                  THE NO OF RCDS (4 BYTES=EOS)
AGDBRVR  NOP   AGDLP075            AP WILL MAKE A BR FOR VAR LEN RCDS
*
*        DETERMINE ACTUAL COUNT OF RECORDS IN THIS BUFFER AND LOAD R1
*
         MVI   4(R15),X'00'        TURN OFF SLI (DON'T CARE WHETHER
*                                  SHORT BLOCK AT THIS TIME)
         SR    R14,R14
AGDFIX   SH    R1,PPIRCDL2         SUBTR LEN OF 1 FL RECORD FROM COUNT
         LA    R14,1(,R14)         INCR RECORD COUNTER
         CH    R1,PPIRCDL2         COMPARE REMAINING COUNT
         BNL   AGDFIX              >=, BRANCH MORE RCDS IN BFR
         LR    R1,R14              LOAD NO OF RECORDS IN BFR CTR
*
*        PLACE M STARTING BUFFER ADDRS IN PPIWKARE (R4 PTR TO
*        PPIWKARE) AND M BLOCK COUNTS (R6 PTR TO BLK CNT TABLE)
*        IN BLK COUNT TABLE AS EACH BUFFER IS READ IN. INSERT
*        INCR OF UNIT (HI BYTE) AND FILE CTR ENTRY (2B FOR OVLAP,
*        B FOR NO OVLAP) IN TABLE OF FILE CTRS. R8 POINTS TO THIS
*        TABLE
*
AGDLP075 SR    R15,R15
         IC    R15,0(,R4)          INCR
         MVC   1(3,R8),PPILAB01+5  READ'S FILE COUNTER ENTRY WITH INCR
         STC   R15,0(,R8)          IN HIGH ORDER POSITION
         ST    R1,0(R15,R6)        STORE BLOCK COUNTER IN BLCNT TABLE
         LA    R8,4(,R8)           VIA INCR FOR DEBLOCK
AGDVRDSP LA    R2,4(,R2)           BYPASS EOS ENTRY (THE 4 WILL BE 8 TO
*                                  BYPASS BCC ALSO FOR VAR LEN RECORDS)
         ST    R2,0(,R4)           ADDR OF 1ST RCD IN BFR IN PPIWKARE
*                                  TABLE FOR MERGE NTWK
         STC   R15,0(,R4)          STORE INCR IN HI ORDER BYTE
         BR    R9                  RETURN TO EITHER OVERLAP OR NO
*                                  OVERLAP ROUTINE
*
*        READ ERROR HAS OCCURRED
*
AGDERROR PPISETON PPIREADE         TURN ON ERROR FLAG
AGMTERM  NOP   AGPRTABT            TURNED TO BRANCH IF IMMEDIATE TERM
         L     R1,IOBDCBPT         R1 -> DCB ADDR
         ST    R5,KCCW             SET IOB ADDR WITH
         MVI   KCCW,X'10'          INCREMENT TO CCW ADDR IN
         L     R0,KCCW             THE HIGH ORDER BYTE
*
*        CALL E38 EXIT
*
         L     R15,AE38
         BASR  R14,R15
*
*        PRINT IOS READ ERROR MSG BEFORE TERMINATING
*
AGPRTABT L     R4,KCCW             ADDR OF IOB WITH ERROR ON IT
         L     R15,PPIADSSC
         BAS   R14,16(,R15)        NO RETURN
*
AGDSKIP  OI    IOBFLAG1,IOBCMDCH   ERROR ACCEPTED, RESET ERROR BITS
         NI    IOBCSTAT,255-CDC    IN THE IOB AND DCB
         LR    R15,R6              SAVE REGISTER
         L     R6,IOBDCBPT
         NI    DCBIFLGS,255-DCBIFPEC  DCB EXCEPTION BITS FOR PERM ERROR
         LR    R6,R15
         NI    DCBOFLGS,DCBEX+DCBIFNE1
*
AGDACCPT IEREXCP  (R5)             READ NEXT BLOCK INTO
*
         L     R1,IOBECBPT         SAME BUFFER AREA
*
         IERWAIT 1,ECB=(1)
*
         B     AGDEE100            BRANCH TO ERROR CHECK THE BUFFER
*
AGSTORRF ST    R5,KCCW
         B     AGDERROR
AGDACCBR B     AGDEE110
*
*        CONSTANTS
*
SAVER14  DC    F'0'
KCCW     CCW   READFT,0,0,0
AGMSTM   DC    7F'0'               SAVE AREA FOR R14 - R4
*
*        IERRGM
*
DIERRGM  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRGM SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRGMI
*
*        IERAP33
*
IERAP33  DSECT
         DC    23F'0'
WRDOPT   DC    F'0'
         DC    8F'0'
*
AGMAMB   DSECT
*
         COPY  AMCMAIN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
*        IERCCWEQ
*
         IERCCWEQ
*
*        IERIOB
*
         IERIOB
*
         PRINT NOGEN
*
         DCBD  DSORG=PS,DEVD=(DA,TA)
*
         IHAECB DSECT=NO,EXT=NO
*
         IEZDEB LIST=NO
*
         PRINT GEN
*
         SMPPI
*
         END
./ ADD NAME=IERAGN   0101-20211-20211-1200-00597-00597-00000-RELEASE 00
AGN      TITLE 'IERAGN - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERAGN
*
*        MODULE FUNCTION/OPERATION -
*        THE FUNCTION OF THIS MODULE IS TO GENERATE ALL DCB'S,
*        IOB'S, ECB'S, AND ALTERNATE CCW POINTER SLOTS ASSOCIATED
*        WITH PHASES ONE AND TWO OF AN OSCILLATING SORT. THEY
*        ARE CREATED IN GENERATED STORAGE AS FOLLOWS -
*        ONE QSAM DCB FOR INPUT
*        M+1 EXCP DCBS FOR OUTPUT
*        M+1 IOB'S, ECB'S, AND ALTERNATE CCW POINTERS
*        THE ADDRESS OF EACH DCB GENERATED IS PLACED IN A DCB
*        ADDRESS TABLE AND DCB OPEN LIST. IF THE ACTIVE BITS FOR
*        ANY OR ALL OF USER MODIFICATION EXITS E18, E28, E19, AND
*        E29 ARE FOUND ON, THE PARAMETERS FROM THE USER'S
*        PROGRAMS ARE INCORPORATED INTO THE DCB'S AND THE OPEN
*        LIST
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACROS USED -
*        SMPPI   DCB
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                       CALLING SEQUENCE -
*                            LOAD EP=IERAGN,DCB=
*                            LR R15,R0
*                            BALR R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIAMA     PPILAB03   PPIRCV PPIX18
*        PPIBDSVA   PPILAB06   PPISPGN1   PPIX19
*        PPIDDSRT   PPITPTBL   PPISTDCB   PPIX28
*        PPIDEPHO   PPIMRGMX   PPICNTL    PPIX29
*        PPIEOF     PPIOPEN
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPIDEPHO   PPISPGN1   PPITPTBL
*        ONE QSAM DCB FOR INPUT
*        M+1 EXCP DCB'S FOR OUTPUT
*        M+1 IOB'S, ECB'S, AND ALTERNATE CCW POINTERS
*
*        EXTERNAL ROUTINES - NONE
*
*        EXTERNAL PARAMETERS - NONE
*
*        EXITS - NORMAL -
*        BR R14 - RETURN TO IERRC9
*
*        EXITS - ERROR - NONE
*
*        TABLES/WORK AREAS -
*        WADOPEN  - UPDATED ADDR OF OPEN LIST
*        WDCBADR  - UPDATED ADDR OF DCB AREA IN CORE
*        WDCBTAB  - ADDR OF DCB ADDR TABLE IN GENERATED CORE
*        WECBADR  - ADDR OF ECB/IOB ADDR IN GENERATED CORE
*        WFRSTERR - GENERAL SWITCH
*        WREGS    - REGISTER SAVE AREA DURING PRINT ROUTINE
*        WSAVAREA - GENERAL REGISTER SAVE AREA
*        SORTWK   - MODEL OUTPUT EXCP DCB
*        SORTIN   - MODEL INPUT QSAM DCB
*
*        NOTES -
*        SINCE THE OSCILLATING SORT USES ONLY TAPES, THIS MODULE
*        GENERATES THE NECESSARY PARAMETERS FOR USE WITH TAPE
*        ONLY
*
IERAGN   CSECT
*
         USING *,R11               BASE REGISTER FOR THIS MODULE
         USING IHADCB,R12          BASE REGISTER FOR DCB DSECT
         USING IERRCA,R13          PPI COMMON MODULE BASE REGISTER
         USING DIERAMA,R14         BASE REG FOR MESSAGE MODULE DSECT
         USING OPENLIST,R15        BASE REG FOR OPEN LIST DSECT
*
IERMGN   LR    R11,R15             LOAD BASE REGISTER
         STM   R0,R15,WSAVAREA     SAVE REGISTERS
         L     R14,PPIAMA+4        LOAD BASE REG FOR MESSAGE MOD DSECT
*
         LA    R12,SORTIN          QSAM DCB MODEL
*
*        STORE TOTAL NUMBER OF DCBS TO OPEN AS FIRST ENTRY IN
*        OPEN LIST
*
         LH    R1,PPIMRGMX         NUMBER OF OUTPUT DCBS TO GENERATE
         L     R2,PPIOPEN+4        ADDR OF OPEN LIST
         LA    R1,2(,R1)           MAX MERGE ORDER + 2 = TOTAL NO DCBS
         ST    R1,0(,R2)           STORE IN OPEN LIST
         LA    R2,4(,R2)           UPDATE OPEN LIST POINTER
         ST    R2,WADOPEN          STORE UPDATED POINTER
*
*        ALLOCATE STORAGE FOR IOBS, ECBS, DCBS, AND TABLES
*        SETUP POINTERS
*
         L     R1,PPISPGN1         STARTING ADDR OF GENERATED STORAGE
         LH    R4,PPIMRGMX         LOAD M
         LA    R4,1(,R4)           ADD ONE FOR NUMBER OF OUTPUT DCB'S
         LA    R3,SORTWKL          GET SIZE OF OUTPUT DCB
         MR    R2,R4               MULTIPLY
         LA    R3,SORTINL          L'SORTIN DCB
         SR    R1,R3               UPDATE ADDR OF GEN STORAGE
         ST    R1,WDCBADR          SAVE ADDR OF DCB AREA
         NI    WDCBADR+3,X'F8'     ROUND TO DOUBLE WORD
         L     R1,WDCBADR
         LA    R3,MODIOBL          L'PREFIXED IOB
         MR    R2,R4               MULTIPLY BY M+1
         SR    R1,R3               UPDATE ADDR OF GEN STORAGE
         ST    R1,WECBADR          SAVE ADDR OF IOB AREA
         IC    R2,PPIBDSVA         LOAD TOTAL NUMBER OF WORK UNITS
         LA    R2,1(,R2)           ADD ONE FOR INPUT TAPE UNIT
         SLL   R2,2                MULTIPLY BY FOUR
         SR    R1,R2               UPDATE ADDR OF GEN STORAGE
         ST    R1,WDCBTAB          SAVE ADDR OF DCB TABLE
         ST    R1,PPISPGN1         STORE UPDATED GEN CORE ADDR
         ST    R1,PPISTDCB
*
*        GENERATE OPTIONAL DIAGNOSTIC MESSAGE
*
         PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTICS ?
         BZ    GN00                NO, BRANCH
         LR    R0,R1               LOAD ADDR TO BE CONVERTED
         L     R15,PPICONV+4       LOAD ADDR OF CONVERSION ROUTINE
         BAS   R14,4(,R15)         CALL CONVERSION RTN
         L     R14,PPIAMA+4        ADDR OF MESSAGE MODULE
         MVC   IER906A,2(R1)       MOVE FORMATTED ADDR INTO MSG
         LM    R0,R1,IER906        IER906I DCB TABLE ADDR
         L     R15,PPIADSSC        ADDR OF PRINT ROUTINE
         BAS   R14,12(,R15)        CALL PRINT ROUTINE
*
*        SET INDICATOR BIT IN FIRST BYTE OF ALL DCB ADR TABLE SLOTS
*
GN00     L     R1,PPISTDCB         ADDR OF DCB TABLE
         L     R3,KSIGNBIT         SET SIGN BIT ON
         SRL   R2,2                GET TOTAL NUMBER OF TAPE UNITS
GN01     ST    R3,0(,R1)           SET SIGN BIT IN DCB TABLE ENTRY
         LA    R1,4(,R1)           UPDATE POINTER
         BCT   R2,GN01             IF MORE ENTRIES, BRANCH
*
*        CONVERT WORK UNIT NUMBERS IN THE TAPE TABLE TO AN
*        OFFSET USED TO REFERENCE THE DCB ADDR IN THE DCB
*        ADDR TABLE
*
GN03     LA    R1,PPITPTBL         LOAD ADDR OF TAPE TABLE
         IC    R2,PPIBDSVA         LOAD TOTAL NUMBER OF WORK UNITS
GN04     IC    R3,1(,R1)           GET WORK UNIT NUMBER FROM TABLE
         SLL   R3,2                CONVERT TO OFFSET
         STC   R3,1(,R1)           STORE
         LA    R1,2(,R1)           UPDATE POINTER
         BCT   R2,GN04             LOOP TO PROCESS TAPE TABLE
*
*        CONVERT DEPHO+3 TO OFFSET
*
GN06     IC    R3,PPIDEPHO+3       LOAD NO OF FIRST OUTPUT UNIT
         SLL   R3,2                CONVERT TO OFFSET
         STC   R3,PPIDEPHO+3       STORE
*
*        GENERATE INPUT DCB
*
GN07     LA    R12,SORTIN          SET UP DCB ADDRESSABILITY
         MVC   DCBDDNAM(L'PPIDDSRT),PPIDDSRT  MOVE IN DDNAME PREFIX
         MVC   DCBBUFNO,PPILAB03       MOVE IN NUMBER OF OUTPUT BUFFERS
         MVC   DCBBUFCA,PPILAB06+1     MOVE IN ADDR OF BUFFER POOL
         MVC   DCBBUFL,PPILAB03+2      MOVE IN SIZE OF INPUT BUFFER
         MVC   DCBEODA,PPIEOF+5        MOVE IN EOD ADDR
         MVI   DCBEROPT,DCBERABE   ERROR OPTION = TERMINATE PROGRAM
         L     R1,PPIADSSC
         MVC   DCBSYNAD,24(R1)     MOVE IN ADDR OF ERROR ROUTINE
         MVI   DCBBFTEK,DCBBFTS    USE SIMPLE BUFFERING
         PPITEST  PPIMVSI          VBS INPUT ?
         BO    AGNVRE              YES, GOTO SET MOVE MODE
         OI    DCBMACR,DCBMRGET+DCBMRLCG  USE GET LOCATE MODE
         B     GN09                GOTO SET IOS ERROR ROUTINE
*
AGNVRE   OI    DCBMACR,DCBMRGET+DCBMRMVG  GET MOVE MODE
         NI    DCBMACR,255-DCBMRLCG       TURN OFF LOCATE MODE
*
GN09     MVI   DCBIFLG,DCBIFER     USE IOS ERROR ROUTINES
         PPITEST  PPISWA           FULL WORD BUFFER ALIGNMENT ?
         BO    GN10                YES, BRANCH
         OI    DCBBFTEK,DCBBFAD    DOUBLE WORD BUFFER ALIGNMENT
         B     GN11                GOTO TEST USER MOD TAB E18
*
GN10     OI    DCBBFTEK,DCBBFAF1   FULL WORD BUFFER ALIGNMENT
GN11     PPITEST  PPIME18          USER MODIFICATION E18 ACTIVE ?
         BZ    GN22                NO, BRANCH
*
*        CALL USER MODIFICATION EXIT E18
*
*        THE EXIT RETURNS WITH THE ADDR OF THE USER OPTION LIST IN R1
*        THE MODEL DCB WILL BE MODIFIED ACCORDING TO THE OPTIONS
*        SPECIFIED ON THE LIST
*
*        R1 -> USER OPTION LIST
*
*          BYTE 1      BYTE 2      BYTE 3      BYTE 4
*         _______________________________________________
*        |           |                                   |
*        | X'01'     | ADDR OF USER PROVIDED SYNAD I/O   |
*        |           | ERROR ROUTINE                     |
*        |___________|___________________________________|
*        |           |                                   |
*        | X'02'     | ADDR OF USER PROVIDED DCB DCBEXLSA|
*        |           | LIST                              |
*        |___________|___________________________________|
*        |           |           |           |           |
*        | X'03'     | 0         | 0         | DCBERROPT |
*        |           |           |           | FLAG BYTE |
*        |___________|___________|___________|___________|
*        |           |                                   |
*        | X'04'     | DCB EODAD ROUTINE                 |
*        |           |                                   |
*        |___________|___________________________________|
*        |           |                                   |
*        | X'00'     | TERMINATING ENTRY IN LIST         |
*        |           |                                   |
*        |___________|___________________________________|
*
*
         L     R15,PPIX18+4        LOAD ADDR OF USER EXIT E18
         BASR  R14,R15             CALL E18
GN15     SR    R4,R4
         ICM   R4,B'0001',0(R1)    GET USER OPTION NUMBER
         BZ    GN22                TERMINATING ENTRY ? BRANCH
         CH    R4,WOPTMAX          USER OPTION NO > LEGAL VALUE ?
         BH    GN20                INVALID OPTION, BRANCH
         SLL   R4,2                CONVERT OPTION NUMBER INTO OFFSET
         B     *(R4)               BRANCH TABLE
         B     GN17                +04 SYNAD (OPTION 01)
         B     GN14                +08 EXLST (OPTION 02)
         B     GN19                +12 EROPT (OPTION 03)
         B     GN16                +16 EODAD (OPTION 04 - INPUT ONLY)
*
GN18     LA    R1,4(,R1)           UPDATE USER PARAMETER LIST POINTER
         B     GN15                TO PROCESS NEXT ENTRY ON LIST
*
*        SYNAD OPTION
*
GN17     MVC   DCBSYNA,1(R1)       MOVE SYNAD ADDR INTO DCB
         B     GN18                GOTO PROCESS NEXT OPTION
*
*        EXLST OPTION
*
GN14     MVC   DCBEXLSA,1(R1)      UPDATE DCBEXLSA ADDR IN DCB
         B     GN18                GOTO PROCESS NEXT OPTION
*
*        EROPT OPTION
*
GN19     MVC   DCBEROPT,3(R1)      MOVE ERROR OPTION INTO DCB
         B     GN18                GOTO PROCESS NEXT OPTION
*
*        EODAD OPTION
*
GN16     L     R6,PPIEOF+4
         LA    R6,9(,R6)           UPDATE ADDR TO PROPER LOCATION
         MVC   0(3,R6),1(R1)       MOVE ADDR INTO PROPER LOCATION
         B     GN18                GOTO PROCESS NEXT OPTION
*
*        SET UP ERROR PRINTOUT FOR PRINT MODULE IF FIRST ERROR
*
GN20     TM    WFRSTERR,X'01'      FIRST ERROR OPTION ?
         BO    GN18                NO, BRANCH
         MVI   WFRSTERR,X'11'      YES, SET INDICATOR
         L     R14,PPIAMA+4        LOAD BASE REG FOR MESSAGE MOD DSECT
         MVC   IER044A,KTAG        MOVE '18' INTO ERROR MESSAGE
GN21     STM   R15,R6,WREGS        SAVE REGISTERS
         LM    R0,R1,IER044        IER044I EXIT EXX
         L     R15,PPIADSSC        LOAD ADDR OF PRINT ROUTINE
         BAS   R14,12(,R15)        CALL PRINT ROUTINE
         LM    R15,R6,WREGS        RESTORE REGISTERS
         TM    WFRSTERR,X'80'      ERROR IN EXIT E29 ?
         BO    GN39                YES, RETURN
         TM    WFRSTERR,X'40'      ERROR IN EXIT E19 ?
         BO    GN34                YES, RETURN
         TM    WFRSTERR,X'20'      ERROR IN EXIT E28 ?
         BO    GN24                YES, RETURN
         B     GN18                RETURN TO WORK ON EXIT E18 PARAMS
*
*        MODIFICATION COMPLETE, RETURN TO MAIN PROGRAM
*
GN22     MVI   WFRSTERR,X'00'      RESTORE FIRST OPTION ERROR INDIC
         PPITEST  PPIME28          USER MODIFICATION EXIT 28 ?
         BZ    GN27                NO, BRANCH
*
*        CALL USER EXIT E28
*
*        THE EXIT RETURNS WITH THE ADDR OF THE USER OPTION LIST IN R1
*        THE MODEL DCB WILL BE MODIFIED ACCORDING TO THE OPTIONS
*        SPECIFIED ON THE LIST
*
*        R1 -> USER OPTION LIST
*
*          BYTE 1      BYTE 2      BYTE 3      BYTE 4
*         _______________________________________________
*        |           |                                   |
*        | X'01'     | ADDR OF USER PROVIDED SYNAD I/O   |
*        |           | ERROR ROUTINE                     |
*        |___________|___________________________________|
*        |           |                                   |
*        | X'02'     | ADDR OF USER PROVIDED DCB DCBEXLSA|
*        |           | LIST                              |
*        |___________|___________________________________|
*        |           |           |           |           |
*        | X'03'     | 0         | 0         | DCBERROPT |
*        |           |           |           | FLAG BYTE |
*        |___________|___________|___________|___________|
*        |           |                                   |
*        | X'04'     | DCB EODAD ROUTINE                 |
*        |           |                                   |
*        |___________|___________________________________|
*        |           |                                   |
*        | X'00'     | TERMINATING ENTRY IN LIST         |
*        |           |                                   |
*        |___________|___________________________________|
*
*
         L     R15,PPIX28+4        LOAD ADDR OF USER EXIT E28
         BASR  R14,R15             CALL EXIT E28
         L     R15,PPIOPEN+4       LOAD BASE REG FOR OPEN LIST DSECT
GN23     CLI   0(R1),X'00'         THERE MORE OPTIONS ?
         BE    GN27                NO, BRANCH
         CLI   0(R1),X'01'         USER SYNAD OPTION ?
         BE    GN25                YES, BRANCH
         CLI   0(R1),X'03'         USER EROPT OPTION ?
         BE    GN26                YES, BRANCH
         BNH   GN24                VALID OP CODE, BRANCH
*
*        IF FIRST ERROR, SET UP ERROR PRINTOUT FOR PRINT MODULE
*
         TM    WFRSTERR,X'01'      FIRST ERROR OPTION ?
         BO    GN24                NO, BRANCH
         MVI   WFRSTERR,X'21'      ON YES, SET INDICATOR
         L     R14,PPIAMA+4        LOAD BASE REG FOR MESSAGE MOD DSECT
         MVC   IER044A,KTAG+2      MOVE '28' INTO ERROR MESSAGE
         B     GN21                BRANCH TO BRANCH TO PRINT ROUTINE
*
GN24     LA    R1,4(,R1)           UPDATE POINTER TO USER PARAMS
         B     GN23                GO THRU LOOP AGAIN
*
*        SYNAD OPTION
*
GN25     MVC   AP1RD2+1(3),1(R1)   MOVE USER SYNAD INTO OPEN LIST
         B     GN24                GO THRU THE LOOP AGAIN ?
*
*        EROPT OPTION
*
GN26     MVC   AP1RD2(1),3(R1)     MOVE USER EROPT INTO OPEN LIST
         B     GN24                GO THRU THE LOOP AGAIN ?
*
*        ENTRIES MADE, RETURN TO MAIN PROGRAM
*
GN27     MVI   WFRSTERR,X'00'      RESTORE FIRST ERROR OPTION INDIC
         L     R1,WDCBADR          LOAD ADDR OF DCB AREA IN GEN COR
         L     R2,WDCBTAB          LOAD ADDR OF DCB TABLE IN GEN CORE
         ST    R1,0(,R2)           STORE ADDR OF INP DCB IN DCB TABLE
         L     R3,WADOPEN          LOAD UPDATED ADDR OF OPEN LIST
         ST    R1,0(,R3)           STORE ADDR OF INP DCB IN OPEN LIST
         LA    R3,4(,R3)           UPDATE ADDR OF OPEN LIST
         ST    R3,WADOPEN          STORE
*
*        MOVE DCB INTO ALLOCATED STORAGE
*
         L     R3,WDCBADR          NEXT USABLE ACTUAL DCB ADDR
         MVC   0(SORTINL,R3),SORTIN  MOVE DCB INTO ALLOCATED CORE
         LA    R3,SORTINL(,R3)       UPDATE ACTUAL DCB ADDR
         ST    R3,WDCBADR            STORE UPDATED DCB CORE ADDR
*
*        GENERATE OUTPUT EXCP DCB'S
*
GN28     LA    R12,SORTWK          SET UP DCB ADDRESSABILITY
         MVC   DCBDDNAM(L'PPIDDSRT),PPIDDSRT  MOVE IN DDNAME PREFIX
         MVI   DCBBFTEK,DCBBFTS    USE SIMPLE BUFFERING
         PPITEST  PPISWA           FULL WORD BUFFER ALIGNMENT ?
         BO    GN31                YES, BRANCH
         OI    DCBBFTEK,DCBBFAD    USE DOUBLE WORD BUFFER ALIGNMENT
         B     GN32                GOTO SET IOS ERROR ROUTINE
*
GN31     OI    DCBBFTEK,DCBBFAF1   USE FULL WORD BUFFER ALIGNMENT
GN32     MVI   DCBIFLG,DCBIFER     USE IOS ERROR ROUTINES
         PPITEST  PPIME19          USER EXIT E19 ACTIVE ?
         BZ    GN37                NO, BRANCH
*
*        CALL USER MODIFICATION EXIT E19
*
         L     R15,PPIX19+4        LOAD ADDR OF USER EXIT E19
         BASR  R14,R15             CALL USER MOD EXIT E19
GN33     CLI   0(R1),X'00'         MORE OPTIONS ?
         BE    GN37                NO, BRANCH
         CLI   0(R1),X'01'         USER SYNAD OPTION ?
         BE    GN35                YES, BRANCH
         CLI   0(R1),X'02'         USER EXLST OPTION ?
         BE    GN36                YES, BRANCH
*
*        IF FIRST ERROR, SET UP ERROR PRINTOUT FOR PRINT MODULE
*
         TM    WFRSTERR,X'01'      FIRST ERROR OPTION ?
         BO    GN34                NO, BRANCH
         OI    WFRSTERR,X'41'      YES, SET INDICATOR
         L     R14,PPIAMA+4        LOAD BASE REG FOR MESSAGE MOD DSECT
         MVC   IER044A,KTAG+4      MOVE '19' INTO ERROR MESSAGE
         B     GN21                BRANCH TO PRINT ROUTINE
*
*        MORE OPTIONS ?
*
GN34     TM    WFRSTERR,X'02'      THE SECOND TIME THRU LOOP ?
         BO    GN37                YES, BRANCH
         OI    WFRSTERR,X'02'      SET ONCE THRU LOOP INDICATOR
         LA    R1,4(,R1)           UPDATE POINTER TO USER PARAMS
         B     GN33                GO THRU LOOP AGAIN
*
*        SYNAD OPTION
*
GN35     L     R15,PPIOPEN+4       LOAD BASE REG FOR OPEN LIST DSECT
         MVC   AP1WRT1+1(3),1(R1)  MOVE USER SYNAD INTO OPEN LIST
         B     GN34                GO THRU LOOP AGAIN ?
*
*        EXLST OPTION
*
GN36     MVI   WFRSTERR+1,X'FF'    SET USER EXIT E19 EXLST SWITCH
         MVC   DCBEXLSA,1(R1)      STORE EXLST ADDR IN MODEL DCB
         B     GN34                GO THRU LOOP AGAIN ?
*
*        ENTRIES MADE, RETURN TO MAIN PROGRAM
*
GN37     MVI   WFRSTERR,X'00'      RESTORE FIRST ERROR OPTION INDIC
         PPITEST  PPIME29          USER EXIT E29 ACTIVE ?
         BZ    GN42                NO, BRANCH
*
*        CALL USER EXIT E29
*
         L     R15,PPIX29+4        LOAD ADDR OF USER EXIT E29
         BASR  R14,R15             CALL USER EXIT E29
GN38     CLI   0(R1),X'00'         MORE OPTIONS ?
         BE    GN42                NO, BRANCH
         CLI   0(R1),X'01'         USER SYNAD OPTION ?
         BE    GN40                YES, BRANCH
         CLI   0(R1),X'02'         USER EXLST OPTION ?
         BE    GN41                YES, BRANCH
*
*        IF FIRST ERROR, SET UP ERROR MESSAGE FOR PRINT MODULE
*
         TM    WFRSTERR,X'01'      FIRST ERROR OPTION ?
         BO    GN39                NO, BRANCH
         OI    WFRSTERR,X'81'      YES, SET INDICATOR
         L     R14,PPIAMA+4        MESSAGE ADDR
         MVC   IER044A,KTAG+6      MOVE '29' INTO ERROR MESSAGE
         B     GN21                BRANCH TO PRINT ROUTINE
*
*        MORE OPTIONS ?
*
GN39     TM    WFRSTERR,X'02'      SECOND TIME THRU LOOP ?
         BO    GN42                YES, GO SET UP PARAM FOR LOOP
         OI    WFRSTERR,X'02'      SET ONCE THRU LOOP INDICATOR
         LA    R1,4(,R1)           UPDATE POINTER TO USER PARAMS
         B     GN38                GO THRU LOOP AGAIN
*
*        SYNAD OPTION
*
GN40     L     R15,PPIOPEN+4       LOAD BASE REG FOR OPEN LIST DSECT
         MVC   AP1WRT2+1(3),1(R1)  MOVE USER SYNAD INTO OPEN LIST
         B     GN39                GO THRU LOOP AGAIN ?
*
*        EXLST OPTION
*
GN41     TM    WFRSTERR+1,X'FF'    USER EXIT E19 EXLST SWITCH SET ?
         BO    GN39                ON, IGNORE. GO THRU LOOP AGAIN
         MVC   DCBEXLSA,1(R1)      ELSE, STORE EXLST ADDR IN DCB
         B     GN39                GO THRU LOOP AGAIN ?
*
*        ENTRIES MADE, RETURN TO MAIN AND SET UP PARAMS FOR LOOP
*
GN42     LA    R0,1                INITIALIZE COUNTER FOR LOOP
         AH    R0,PPIMRGMX         EQUALS NO OUTPUT DCB'S
         L     R3,WDCBADR          LOAD ADDR OF DCB AREA IN CORE
         L     R2,WECBADR          LOAD ADDR OF ECB/IOB AREA IN CORE
         L     R5,WADOPEN          LOAD ADDR OF UPDATED OPEN LIST PTR
         L     R6,WDCBTAB          LOAD ADDR OF DCB ADDR TABLE
         LR    R7,R3
         LR    R8,R2
         LA    R8,8(,R8)           LOAD ADDR OF FIRST IOB PAST PREFIX
         LA    R9,PPITPTBL         LOAD ADDR OF THE TAPE TABLE
*
*        LOOP
*
GN43     ST    R2,MODIOB+IOBECBPT-IERIOB  STORE ECB ADDR IN MODEL IOB
         ST    R7,MODIOB+IOBDCBPT-IERIOB  STORE DCB ADDR IN MODEL IOB
         ST    R8,DCBIOBAD         STORE IOB ADDR IN MODEL EXCP DCB
         SR    R10,R10
         IC    R10,1(,R9)          GET OFFSET FROM TAPE TABLE
         ST    R7,0(R10,R6)        STORE DCB ADDR IN DCB ADDR TABLE
         SRL   R10,1               CONVERT TO DDTABLE OFFSET
         LH    R10,DDTABLE(R10)    ADD TO IT ADDR OF DCB ID TABLE
         STH   R10,DCBDDNAM+6      STORE DCB SORTWK SUFFIX IN DCBDDNAM
         ST    R7,0(,R5)             STORE DCB ADDR IN OPEN LIST
         MVC   0(SORTWKL,R3),SORTWK  MOVE MODEL DCB INTO ALLOCATED CORE
         MVC   0(MODIOBL,R2),MODIOB  MOVE MODEL ECB/IOB INTO CORE
         BCT   R0,GN44               GO THRU LOOP AGAIN  ?
         MVC   IOBINCAM-IERIOB(2,R2),K1  MOVE PLUS ONE INTO THE IOB
*                                  TAPE BLOCK COUNT INCREMENT
*
*        RETURN TO CALLING ROUTINE
*
         LM    R0,R15,WSAVAREA     RESTORE REGISTERS
         BR    R14                 RETURN TO LOAD ROUTINE, IERRC9
*
*        UPDATE POINTERS TO GO THRU LOOP AGAIN
*
GN44     LA    R2,MODIOBL(,R2)     UPDATE ECB/IOB AREA PTR IN CORE
         LA    R3,SORTWKL(,R3)     UPDATE DCB AREA PTR IN CORE
         LA    R5,4(,R5)           UPDATE OPEN LIST POINTER
         LA    R7,SORTWKL(,R7)     UPDATE ADJ DCB ADDR IN CORE
         LA    R8,MODIOBL(,R8)     UPDATE IOB PTR IN CORE
         LA    R9,2(,R9)           UPDATE POINTER IN PPITPTBL
         B     GN43                GO THRU LOOP AGAIN
*
*        CONSTANT
*
K1       DC    H'1'                OUTPUT IOB BLK COUNT INC
WOPTMAX  DC    H'4'                MAX VALID USER OPTION CODE
KSIGNBIT DC    X'80000000'
*
DDTABLE  DC    C'000102030405060708091011121314151617'
*
KTAG     DC    C'18281929'         USER EXIT NUMBER FOR ERROR MSG
*
*        WORK AREAS
*
WADOPEN  DC    F'0'                UPDATED ADDR IN OPEN LIST
WDCBADR  DC    F'0'                UPDATED ADDR OF DCB AREA IN CORE
WDCBTAB  DC    F'0'                ADDR OF DCB AD TABLE IN GEN CORE
WECBADR  DC    F'0'                ADDR OF ECB/IOB AREA IN GEN CORE
WFRSTERR DC    F'0'                GENERAL SWITCH
WREGS    DC    8F'0'               SAVE AREA DURING PRINT ROUTINE
WSAVAREA DC    16F'0'              GENERAL REGISTER SAVE AREA
*
*        MODEL TAPE IOB
*        WITH S/M IOB 8 BYTE PREFIX
*
MODIOB   DC    10F'0'
*
MODIOBL  EQU   *-MODIOB            L'PREFIXED IOB
         ORG   MODIOB+36           (IOBINCAM-IERIOB)
         DC    H'-1'               SET THE TAPE BLOCK INCREMENT
         ORG
*
*        MODEL DCBS USED BY PROGRAM
*
SORTWK   DCB   MACRF=(E),DSORG=PS,DDNAME=SORTWKXX,REPOS=Y
*
         DC    F'0'                AREA APPENDED TO EXCP DCB
*                                  REFERENCED AS DCBOPTCD
*
SORTWKL  EQU   *-SORTWK            L'SORTWK DCB
*
SORTIN   DCB   MACRF=(GL),DSORG=PS,DDNAME=SORTIN
*
SORTINL  EQU   *-SORTIN            L'SORTIN DCB
*
*        OPEN LIST DSECT
*
OPENLIST DSECT
*
         DC    19F'0'              OPEN LIST DSECT
AP1RD2   DC    X'20000000'         USER SYNAD AND EROPT, READ - PH2
AP1WRT1  DC    F'0'                USER SYNAD, WRITE - PH1
AP1WRT2  DC    F'0'                USER SYNAD, WRITE - PH2
*
*        IERAMA
*
*        THIS MODULE CONTAINS ALL OF THE MESSAGES THAT ARE
*        REQUIRED FOR PHASE 1 ASSIGNMENT MODULES
*
DIERAMA  DSECT
*
         COPY  AMAMAIN
*
*        DCB DSECT
*
         PRINT NOGEN
*
         DCBD  DSORG=PS,DEVD=(DA,TA)
*
         PRINT GEN
*
*        IERIOB
*
         IERIOB
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERAGO   0101-20211-20211-1200-00251-00251-00000-RELEASE 00
AGO      TITLE 'IERAGO - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERAGO - NOT SUPPORTED
*
*        MODULE FUNCTION/OPERATION -
*        THIS MODULE READS ASSIGNMENT PHASE 2, CREATES CCWS AND
*        ATTACHES BUFFERS TO THE IOBS FOR THE READ DRUM ROUTINE
*        IN THE INTERMEDIATE MERGE PHASE. IF THE RECORD FORMAT IS
*        VARIABLE THE ROUTINE TURNS THE SLI BIT ON IN THE READ
*        CCW AND DOES SEVERAL OVERLAYS IN IERRGO. THE MODULE ALSO
*        ALLOCATES THE SPACE NEEDED FOR THE TABLE OF BLOCK
*        COUNTERS AND STORES THE TABLE@S STARTING ADDRESS IN
*        PPIBLCT. THIS MODULE SETS UP THE READ ERROR OPTION AS
*        INDICATED TO THE SORT BY EXIT E28
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - N/A
*
*        INPUT - PPI FIELDS REFERENCED
*
*        OUTPUT - N/A
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL - N/A
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS - N/A
*
*        NOTES - N/A
*
IERAGO   CSECT
*
         USING *,R11
         USING IERAP22,R1          OPEN LIST DSECT
         USING IOBSTDRD,R5         IOB DSECT
         USING IERRGO,R10          IERRGO
         USING IERRCA,R13          PPIA DSECT
IERMGB   LR    R11,R15
         ST    R14,AGOSAVE         SAVE R14
         L     R1,PPIOPEN+4
         L     R10,PPIRD+4
*
*        ERROR OPTION
*
         CLC   WRDOPT+1(3),AE28+1
         BZ    AGONOADR            LINK TO USER IF E28 ACTIVATED
         MVC   AE28+1(3),WRDOPT+1
         PPISETON PPIACCPT         SET ACCEPT SKIP SWITCH
         CLI   WRDOPT,X'40'
         BL    AGOTERM
         BE    AGOST001
         MVC   RGOACCV(4),RGOBR
         B     AGOST001
*
AGONOADR MVI   RGOTERM+1,X'F0'
AGOTERM  PPISETOF PPIACCPT         TURN OFF SKIP ACCEPT SWITCH
         DROP  R1
*
*        DIRECTORY READ OVERLAYS
*
AGOST001 MVC   RGOTRKNO+1(1),PPIBPTRK+1  NO OF BLOCKS PER TRACK FOR
*                                        UPDATING DRUM ADDR IN IERRGO
         LA    R1,PPILAB01         PLACE DIRECTORY BUFFER AREA ADDR
         ST    R1,KRDDIR+16        IN THE DIRECTORY'S READ CCW
         MVI   KRDDIR+16,X'06'
*
*        CALCULATE AND ALLOCATE SPACE FOR CCW'S AND BLOCK COUNT
*        TABLE
*
         L     R1,PPISPGN1         GENERATE CORE ADDR
         LA    R1,7(,R1)           MAKE SURE CCWS
         N     R1,KMASK
         SH    R1,KEIGHT           START ON DOUBLE WORD BOUNDARY
         LH    R2,PPIMRGOP         MERGE ORDER
         LR    R0,R2
         SLL   R2,4                SPACE FOR CCWS
         LR    R3,R2               =3(16*M)  -EACH CCW IS 8 BYTES
         AR    R2,R3               AND NEED 6*M OF THEM
         AR    R2,R3
         SR    R14,R14
         IC    R14,PPILAB03        IF NO BUFFERS > (2*M), RESET NO
         LR    R15,R0
         SLL   R15,1
         CLR   R15,R14
         BNL   *+8
         STC   R15,PPILAB03        OF BUFFERS TO 2*M
         SR    R1,R2
         SR    R3,R3
         IC    R3,PPIBDSVA         TOTAL NO OF WORK UNITS
         LA    R3,1(,R3)
         SLL   R3,2                BLOCK COUNTER TABLE IN
         LR    R4,R1               GENERATED CORE =(NO UNITS+1)*4
         SR    R1,R3
         ST    R1,PPISPGN1         SAVE UPDATED
         ST    R1,PPISBLCT         STORE ADDR OF BLOCK COUNT TABLE
         LA    R3,SLI              SLI BIT ON FOR ALL DRUM SORTS
*
*        WRITE DIAGNOSTIC MESSAGES
*
         PPITEST  PPIDIAG          DIAGOSTICS REQUESTED ?
         BZ    AGOTEST             NO, BRANCH
         STM   R14,R4,AGOSTM
         LR    R0,R4               PUT ADDR OF CCW IN R0
         USING AGOAMB,R4
         L     R4,PPIAMB+4
         L     R15,PPICONV+4       ADDR OF CONVERT ROUTINE
         BAS   R14,4(,R15)
         MVC   IER927A,2(R1)       MOVE CONVERTED DATA TO MSG AREA
         LM    R0,R1,IER927        IER927I INPUT CCW ADDR
         L     R15,PPIADSSC        LOAD ADDR OF PRINT MSG RTN
         BAS   R14,12(,R15)
         LM    R14,R4,AGOSTM
*
*        MANY IOBS ARE ATTACHED TO ONE DCB AND CANNOT CONTROL
*        OCCURRENCE OF SHORT BLOCKS
*        DON'T WANT ERROR POSTED FOR THEM IN DCB
*
AGOTEST  PPITEST  PPIVAR           VARIABLE LENGTH RECORDS ?
         BO    AGOVR100
*
*        ATTACH BUFFERS AND CCW'S TO THE IOB'S
*
AGOGN010 MVC   KCCWLST+22(2),PPILAB03+2  COUNT
         STC   R3,KCCWLST+20             FLAGS
         L     R6,PPISTIOB         TABLE OF IOB ADDR
         L     R3,PPILAB02         TABLE OF INPUT BUFFER ADDR
         LA    R6,4(,R6)           BYPASS THE OUTPUT IOB
AGECCWGN L     R5,0(,R6)           IOB ADDR
         LA    R15,IOBCC           SET UP THE CCW LIST, MOVE TO
         ST    R15,KCCWLST         GENERATED CORE AREA, ATTACH TWO
         MVI   KCCWLST,SEARIDEQ    LISTS TO EACH IOB
         ST    R4,KCCWLST+8        SET UP 1ST LIST
         MVI   KCCWLST+8,TIC
         ST    R4,IOBSTART         ATTACH FIRST LIST TO IOB
         MVC   0(24,R4),KCCWLST
         MVC   17(3,R4),1(R3)      STORE BUFFER ADDR IN CCW LIST
         LA    R4,24(,R4)
         ST    R4,KCCWLST+8        SET UP 2ND LIST
         MVI   KCCWLST+8,TIC
         MVC   0(24,R4),KCCWLST
         L     R14,IOBECBPT        SAVE ALTERNATE LIST ADDR AT ECB+4
         ST    R4,4(,R14)
         MVI   4(R14),1            NO OF BUFFERS ATTACHED
         LA    R4,24(,R4)          UPDATE GEN AREA FOR CCW'S
         LA    R6,4(,R6)                  IOB TABLE
         LA    R3,4(,R3)                  BUFFER TABLE
         BCT   R0,AGECCWGN         HAVE M BUFFERS BEEN ATTACHED ?
         IC    R0,PPILAB03         TOTAL NO OF INPUT BUFFERS
         SH    R0,PPIMRGOP         MINUS MERGE ORDER = NO OF ALT BUFS
         BZ    AGOLK030
*
*        PARTIAL OR FULL OVERLAP
*        NO OVERLAP
*        ATTACH THE ALTERNATE BUFFERS TO THE IOBS ALTERNATE CCW
*        LISTS
*
         L     R6,PPISTIOB         IOB TABLE ADDR
         LA    R6,4(,R6)           BYPASS OUTPUT IOB
AGOAL020 L     R5,0(,R6)           IOB ADDR
         L     R1,IOBECBPT
         L     R4,4(,R1)           ALTERNATE CCW LIST ADDR
         MVC   17(3,R4),1(R3)      STORE BUFFER ADDR IN READ CCW
         MVI   4(R1),2             SET NO OF BUFFERS ATTACHED TO IOB=2
         LA    R3,4(,R3)           UPDATE BUFFER TABLE
         LA    R6,4(,R6)                  IOB TABLE
         BCT   R0,AGOAL020         ALL OF THE ALTERNATE BUFFERS
*                                  BEEN ATTACHED ?
AGOLK030 L     R14,AGOSAVE         SET RETURN REGISTER
         BR    R14
*
*        OVERLAYS FOR VARIABLE RECORD FORMAT
*
AGOVR100 MVI   IERDGB2D+11,X'05'   VARIABLE RECORD FORMAT OVERLAYS
         MVI   IERDGB2D+11,X'05'   VARIABLE RECORD FORMAT OVERLAYS
         MVI   RGORTRN+7,X'08'
         MVI   RGOEOSV+3,X'05'     IN IERRGO TO INCLUDE THE 4 BYTE
         MVI   RGOFBV+3,X'05'
         MVI   RGOBRVR+1,X'F0'     BCC WHEN CONSIDERING THE
         MVI   RGOACCV+3,X'05'
         MVI   RGOBRVAR+3,X'08'    DISPLACEMENT FROM THE START OF
         MVI   RGOPR250+3,X'05'
         B     AGOGN010            A BUFFER
*
AGOSAVE  DC    F'0'
AGOSTM   DC    7F'0'
KMASK    DC    X'FFFFFFF8'
KEIGHT   DC    H'8'
*
KCCWLST  CCW   SEARIDEQ,0,CC+SLI,5
         CCW   TIC,0,CC+SLI,0
         CCW   READDATA,0,0,0
*
*        IERRGO
*
IERRGO   DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRGO SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRGOI
*
*        AMBMAIN
*
AGOAMB   DSECT
*
         COPY  AMBMAIN
*
*        IERAP22
*
IERAP22  DSECT
         DC    33F'0'
WRDOPT   DC    F'0'
         DC    11F'0'
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
*        IERCCWEQ
*
         IERCCWEQ
*
*        IERIOB
*
         IERIOB
*
         PRINT NOGEN
*
         DCBD  DSORG=PS,DEVD=(DA)
*
         IHAECB DSECT=NO,EXT=NO
*
         IEZDEB LIST=NO
*
         PRINT GEN
*
         SMPPI
*
         END
./ ADD NAME=IERAGP   0101-20211-20211-1200-00559-00559-00000-RELEASE 00
AGP      TITLE 'IERAGP - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERAGP - NOT SUPPORTED
*
*        MODULE FUNCTION/OPERATION -
*        THIS MODULE READS ASSINGMENT PHASE 3
*        THE MODULE CREATES CCWS AND PRIMES THE BUFFERS FOR THE
*        READ DRUM ROUTINE. IF THE RECORD FORMAT IS VARIABLE, THE
*        ROUTINE ADJUSTS THE INSTRUCTION LABELED RGPVBCC ETC IN
*        IERRGP. THE MODULE ALSO SETS UP THE TABLE OF BLOCK
*        COUNTERS FOR THE DEBLOCK ROUTINE AND IT STORES THE TABLE
*        ADDRESS IN PPISBLCT. THE ROUTINE USES AN ERROR CHECK
*        SUBROUTINE LIKE IERRGP
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACROS USED - SMPPI
*
*        ENTRY POINT -
*        IERMGD - ONLY ENTRY POINT TO IERAGP
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL - N/A
*
*        EXIT POINT -
*        IERMD34 - NORMAL INTERFACE
*        IERDB34 - ZERO INPUT FILE AND EXIT E35 ACTIVATED
*        IERRPG  - ZERO INPUT FILE AND NO EXIT E35
*
*        INPUT - PPI FIELDS REFERENCED -
*
*        OUTPUT - N/A
*
*        EXTERNAL ROUTINES - N/A
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS - N/A
*
*        NOTES - N/A
*
IERAGP   CSECT
*
         USING *,R11
         USING IERAP33,R1          OPEN DSECT
         USING IERRCA,R13          PPI DSECT
         USING IERRGP,R10          RUNNING PGM DSECT
         USING IOBSTDRD,R5         IOB DSECT
*
IERMGD   LR    R11,R15
         ST    R14,AGPSAVE         SAVE REG R14
         L     R10,PPIRD+4
         L     R1,PPIOPEN+4
*
*        ERROR OPTION OVERLAYS
*
         CLC   WRDOPT+1(3),AE38+1  LINK TO USER IF E38 ACTIVATED
         BE    AGPNOADR            FOR READ ERROR HANDLING
         MVC   AE38+1(3),WRDOPT+1  ADDR OF USER ROUTINE
         PPISETON PPIACCPT         SET ACCEPT SKIP SWITCH
         CLI   WRDOPT,X'40'
         BL    AGPTERMX
         BE    AGPST001
         MVC   RGPACCPT(4),RGPBR
         MVC   AGPACCPT(4),AGPBR
         B     AGPST001
*
AGPNOADR MVI   RGPTERM+1,X'F0'
         MVI   AGPTERM+1,X'F0'
AGPTERMX PPISETOF PPIACCPT         TURN OFF SKIP ACCEPT SWITCH
*
*        ALGORITHM FUNCTION - READ DIRECTORY
*
AGPST001 LA    R7,PPIWKARE         HOUSEKEEPING
         LA    R8,PPILAB01         FOR READING THE DIRECTORY-
         STCM  R8,B'0111',KCCWLST+17   BUFFER AREA
         LH    R6,PPINDSKA
         LA    R9,PPISEQCT         THE ALGORITHM FUNCTIONS OF PHASE
         SR    R2,R2               TWO ARE BUILT IN TO THIS ASSG
         LA    R3,PPIENDAR         ROUTINE
*
AGPAREA  SR    R1,R1               INCR FOR DCB
         IC    R1,0(,R3)
         L     R5,PPISTDCB
         L     R15,0(R1,R5)        R15 -> DCB
         USING IHADCB,R15
         L     R5,DCBIOBAD
*
*        SETUP FOR EXCP
*        CONVERT TTR -> MBBCCHHR
*
         STM   R14,12,12(R13)      SAVE REGS ACROSS RTN
         LR    R3,R13              SAVE R13
         SR    R0,R0
         ICM   R0,B'1110',5(R3)    R0 = TTR0 FROM PPIENDAR ENTRY
         L     R1,DCBDEBAD         R1 -> DEB
         LA    R2,DCBFDAD          R2 -> MBBCCHHR RESULT
         L     R15,PPIPCNVT        R15 -> CONVERSION RTN
         BASR  R14,R15             CONVERT TTR -> MBBCCHHR
         LR    R13,R3
         LTR   R15,R15          *  SET CC
         LM    R14,R12,12(R13)  |  RESTORE REGS
         BNZ   AGPSSCBR         V  CONVERSION FAILED, TERMINATE SORT
         MVC   IOBSEEK,DCBFDAD     MOVE SEARCH ADDR TO IOB
         DROP  R15
         LA    R15,IOBCC           FOR
         STCM  R15,B'0111',KCCWLST+1  SEARCH ID EQ
         LH    R4,0(,R9)           LOAD SEQ CNT FOR THE AREA
         LTR   R4,R4               SEQ CNT = 0 ?
         BZ    AGPUPDTE            YES, BRANCH
         AR    R2,R4
         LA    R15,KCCWLST         TO BE READ
         ST    R15,IOBSTART        STORE CCW LIST ADDR IN THE IOB
*
AGPRDDIR IEREXCP  (R5)             READ DIRECTORY INTO PPILAB01
*
         L     R1,IOBECBPT
*
         IERWAIT  1,ECB=(1)        WAIT ON ABOVE READ
*
         L     R1,IOBECBPT
         CLI   0(R1),ECBNORM       CHANNEL PROGRAM COMPLETE NO ERROR ?
         BNE   AGPSSCBR            NO, TERMINATE JOB
*
AGPNOERR LA    R14,8               BLOCKING FACTOR FOR THE DIRECTORY
         MVC   0(8,R7),0(R8)       MOVE DIR ENTRY TO WORK AREA
         BCT   R4,AGPNOERA         SEQ CNT ZERO ?
         LA    R7,8(,R7)
         B     AGPUPDTE            FINISHED WITH THIS AREA GOTO NEXT
*
AGPNOERA LA    R7,8(,R7)           UPDATE WORK AND
         LA    R8,8(,R8)           READ AREA POINTERS
         BCT   R14,AGPNOERR+4      BLOCK PROCESSED ?
         LA    R8,PPILAB01         REINITIALIZE READ AREA POINTER
         MVI   IOBR,2              UPDATE DIR ADDR TO READ SEC BLOCK
         B     AGPRDDIR
*
AGPUPDTE LA    R9,2(,R9)           UPDATE SEQ CNT
         LA    R3,8(,R3)           AND DIR ADDR POINTERS
         LA    R8,PPILAB01         REINITIALIZE READ AREA POINTER
         BCT   R6,AGPAREA          ALL AREAS PROCESSED ?
         STH   R2,PPIMRGMX         SUM OF SEQ CNTS IS THE MERGP ORDER
*
*        END OF ALGORITHM FUNCTION AND READING OF THE DIRECTORY
*
         LTR   R2,R2               ZERO ?
         BNZ   AGPST010            NO, BRANCH
AGPZERO  L     R14,AGPSAVE         RETURN TO IERRC9
         BR    R14
*
*        CALC AND ALLOCATE SPACE FOR CCW'S AND BLOCK COUNT TABLE
*
AGPST010 L     R1,PPISPGN1         GENERATED CORE ADDR
         LA    R1,7(0,R1)          MAKE SURE CCW'S
         N     R1,KMASK
         SH    R1,KEIGHT           START ON DOUBLE WORD BOUNDARY
         LR    R0,R2               MERGP ORDER
         SLL   R2,4                SPACE FOR CCW'S
         LR    R3,R2               =3(16*M)
         AR    R2,R3
         AR    R2,R3
         SR    R1,R2
         SLL   R0,1
         STC   R0,RGPK2M+1         2*M FOR OVERLAP TEST IN IERRGP
         SR    R3,R3
         IC    R3,PPILAB03         IF NO OF BUFFERS > (2*M) RESET NO
         CLR   R0,R3               TO (2*M)
         BNL   *+8
         STC   R0,PPILAB03
         IC    R3,PPIBDSVA         TOTAL WORK UNITS
         LA    R3,1(,R3)
         SLL   R3,2                ALLOCATE SPACE IN GENERATED CORE
         LR    R4,R1               FOR THE TABLE OF BLOCK COUNTERS
         LH    R9,PPIMRGMX
         SR    R1,R3
         ST    R1,PPISPGN1         SAVE UPDATED FREE STORAGE ADDR
         ST    R1,PPISBLCT         SET ADDR OF BLOCK COUNT TABLE
         LA    R3,32               SLI BIT ON FOR ALL DRUM SORTS
*                                  HAVE ATTACHED MANY IOBS TO ONE
*                                  DCB AND CANNOT CONTROL OCCURRENCE
*                                  OF SHORT BLOCKS - DON'T WANT
*                                  ERROR POSTED FOR THEM IN DCB
         PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTIC ?
         BZ    AGPTEST             NO, BRANCH
         STM   R14,R4,AGPCCWSV
         USING AGPAMC,R3
         L     R3,PPIAMC+4
*
*        CCW ADDRESS
*
         LR    R0,R4               LOAD ADDR OF CCW LIST
         L     R15,PPICONV+4       PRIME REG R15 FOR CONVERT ROUTINE
         BAS   R14,4(,R15)         CALL CONVERT ROUTINE
         MVC   IER945A,2(R1)       MOVE FORMATTED ADDR TO MSG
         LM    R0,R1,IER945        IER945I INPUT CCW ADDR
         L     R15,PPIADSSC
         BAS   R14,12(,R15)        CALL PRINT ROUTINE
         LM    R14,R4,AGPCCWSV
AGPTEST  PPITEST  PPIVAR           VARIABLE LENGTH RECORDS ?
         BO    AGPVR050            YES, BRANCH
AGPCCW   L     R6,PPISTIOB         TABLE OF INPUT IOBS
         MVC   KCCWLST+22(2),PPILAB03+2
         L     R7,PPILAB02         TABLE OF INPUT BUFFER ADDR
         LA    R8,PPIWKARE         DRUM ADDR FROM READING DIR
AGPCCWGN L     R5,0(,R6)           IOB ADDR
         LA    R15,IOBCC           SET UP THE CCW LISTS MOVE TO
         STCM  R15,B'0111',KCCWLST+1       GENERATED CORE AREA
         STCM  R4,B'0111',KCCWLST+9        SET UP 1ST LIST
         STC   R3,KCCWLST+20
         ST    R4,IOBSTART         ATTACH FIRST LIST TO IOB
         MVC   0(24,R4),KCCWLST
         MVC   17(3,R4),1(R7)      STORE BUFFER ADDR IN CCW LIST
         LA    R4,24(,R4)
         STCM  R4,B'0111',KCCWLST+9        SET UP 2ND LIST
         MVC   0(24,R4),KCCWLST
         L     R14,IOBECBPT        SAVE ALTERNATE LIST ADDR AT ECB+4
         ST    R4,4(,R14)
         MVI   4(R14),1            NO OF BUFFERS ATTACHED
         LA    R4,24(,R4)          UPDATE - GEN AREA FOR CCW'S
         LA    R6,4(,R6)                    IOB TABLE
         LA    R7,4(,R7)                    BUFFER TABLE
*
*        LOCATE DCB
*
         L     R15,IOBDCBPT        R15 -> DCB FROM IOB
         USING IHADCB,R15
*
*        SETUP FOR EXCP
*        CONVERT TTR -> MBBCCHHR
*
         STM   R14,12,12(R13)      SAVE REGS ACROSS RTN
         LR    R3,R13              SAVE R13
         SR    R0,R0
         ICM   R0,B'1110',5(R8)    R0 = TTR0 FROM PPIENDAR ENTRY
         L     R1,DCBDEBAD         R1 -> DEB
         LA    R2,DCBFDAD          R2 -> MBBCCHHR RESULT
         L     R15,PPIPCNVT        R15 -> CONVERSION RTN
         BASR  R14,R15             CONVERT TTR -> MBBCCHHR
         LR    R13,R3
         LTR   R15,R15          *  SET CC
         LM    R14,R12,12(R13)  |  RESTORE REGS
         BNZ   AGPSSCBR         V  CONVERSION FAILED, TERMINATE SORT
         MVC   IOBSEEK,DCBFDAD     MOVE SEARCH ADDR TO IOB
         DROP  R15
*
         IEREXCP  (R5)             PRIME THE BUFFER
*
         LA    R8,8(,R8)           DRUM ADDR IN WORK AREA
         BCT   R9,AGPCCWGN         ALL M FILES BEEN PRIMED ?
*
*        TEST FOR NO OF ALTERNATE BUFFERS AVAILABLE
*        WAIT ON M BUFFERS
*        CHECK FOR ERRORS
*        PASS RCD ADDR TO MERGP
*        PLACE BLOCK COUNT IN TABLE VIA INCR (RANGES FROM 0 TO 4M-4)
*        PRIME ALTERNATES
*
         SR    R2,R2               INCR FOR ACCESSING IOB'S AND BLCNT
*                                  (RANGES FROM 0 TO 4M-4)
         L     R6,PPISTIOB         TABLE OF INPUT IOBS
         LA    R3,PPIWKARE         POINTER TO PPI WHERE STORE RCD ADDR
         LA    R4,TFCNT            TABLE OF FILE COUNTERS
         IC    R9,PPILAB03
         STC   R9,KTOTAL
         SH    R9,PPIMRGMX
         STH   R9,PPILAB01         NO OF ALTERNATES
         BZ    AGPNOVLP            NO OVERLAP
*
*        PRIME ALTERNATE BUFFERS
*
         LH    R0,PPISRTBL         FILE COUNTER
         SLL   R0,1                ENTRY IS 2*SRT BLKING
         ST    R0,PPILAB01+4
AGPAL020 BAS   R8,AGPWT030         WAIT RCD ADDR IN PPI-BLCNT
         L     R15,IOBSTART
         L     R14,16(,R15)
AGPEOS   TM    1(R14),X'07'        IF EOS, DON'T ISSUE ANOTHER READ
         BO    AGPNEXTO
         L     R14,IOBECBPT        ATTACH THE ALTERNATE BUFFER
         MVC   IOBSTRTB,5(R14)     TO THE FILE VIA THE ALTERNATE
         ST    R15,4(,R14)         CCW LIST
         MVI   4(R14),2            UPDATE NO OF BUFFERS ATTACHED
         L     R15,IOBSTART
         MVC   17(3,R15),1(R7)     STORE BUFFER ADDR IN CCW LIST
*
         IEREXCP  (R5)             READ
*
         LA    R7,4(,R7)           BUFFER POINTER
AGPNEXTO LA    R6,4(,R6)           UPDATE IOB POINTER
         BCT   R9,AGPAL020
*
         ST    R7,PPILAB02         SAVE BUFFER POINTER FOR IERRGP USE
         CLC   PPILAB01(2),PPIMRGMX  IF FULL OVERLAP
         BE    AGPRTN                ALL WAITS HAVE BEEN ISSUED
*
*        PARTIAL OVERLAP ONLY
*
         LH    R9,PPIMRGMX         NEED TO ISSUE WAITS AND PASS ADDR
         SH    R9,PPILAB01         IN PPI ON THOSE FILES WITH NO
         B     AGPNOVLP+8          ALTERNATE BUFFERS
*
AGPNOVLP LH    R9,PPIMRGMX
         ST    R7,PPILAB02         SAVE BUFFER POINTER FOR IERRGP USE
         MVC   PPILAB01+6(2),PPISRTBL  FILE COUNTER ENTRY IS SRTBLK
         BAS   R8,AGPWT030         WAIT RCD ADDR IN PPI-BLCNT
AGPNEXT  LA    R6,4(,R6)           UPDATE IOB ADDR
         BCT   R9,AGPWT030
AGPRTN   L     R14,AGPSAVE         SET RETURN REGISTER
         MVC   KMRGMX,PPIMRGMX
         BR    R14
*
AGPWT030 L     R5,0(,R6)           IOB ADDR
         L     R1,IOBECBPT
*
         IERWAIT  1,ECB=(1)        WAIT ON IOB
*
*        ERROR CHECK
*
         L     R1,IOBECBPT
         CLI   0(R1),ECBNORM       CHANNEL PROGRAM COMPLETE NO ERROR ?
         BNE   AGPRESET            NO, BRANCH
AGPWT035 MVC   1(3,R4),PPILAB01+5  READ'S FILE COUNTER ENTRY WITH
         STC   R2,0(,R4)           INCR IN HIGH ORDER POSITION
         LH    R1,PPILAB03+2       OBTAIN
         SH    R1,IOBCSW+5         SUBTRACT CSW RESIDUAL COUNT
         SH    R1,KFOUR            (EOS'S 4 BYTES)
AGPVR    NOP   AGPLP040            UNCOND BRANCH IF VAR RCD FORMAT
         SR    R14,R14
AGPFIX   SH    R1,PPIRCDL2         NEED BLOCK CNT IF FIX RCD FORMAT
         LA    R14,1(,R14)
         CH    R1,PPIRCDL2
         BNL   AGPFIX
         LR    R1,R14
AGPLP040 L     R15,PPISBLCT
         ST    R1,0(R2,R15)        STORE BLOCK COUNTER IN BLCNT TABLE
         L     R15,IOBSTART
         L     R15,16(,R15)        OBTAIN BUFFER ADDR
AGPVRDSP LA    R15,4(,R15)         BYPASS EOS (AND BCC IF VAR),
         ST    R15,0(,R3)          STORE ADDR IN PPI FOR MERGP
         STC   R2,0(,R3)           STORE INCR IN HIGH ORDER BYTE OF
         LA    R2,4(,R2)           RCD ADDR
         LA    R3,4(,R3)           UPDATE INCR, PPIWKARE, AND
         LA    R4,4(,R4)           TFCNT POINTER
*
*        DRUM ADDR - MBBCCHHR
*
*        UPDATE THE RECORD COUNT
*
AGPTRKNO CLC   IOBR,PPIBPTRK+1     TRACK FULL ?
         BE    AGPUPH              YES, BRANCH TO UPDATE TRACK
         IC    R15,IOBR            INCR RECORD NUMBER
         LA    R15,1(,R15)
         STC   R15,IOBR
         BR    R8
*
AGPUPH   MVI   IOBR,X'01'           RESET RECORD TO 1 ON NEW TRACK
*
*        LOCATE THE DCB
*
         L     R15,IOBDCBPT        R15 -> DCB
         USING IHADCB,R15
*
*        SETUP FOR EXCP
*        CONVERT MBBCCHHR -> TTR
*
         STM   R14,12,12(R13)      SAVE REGS ACROSS RTN
         LR    R3,R13              SAVE R13
         L     R1,DCBDEBAD         R1 -> DEB
         LA    R2,IOBSEEK          R2 -> MBBCCHHR
         L     R15,PPIPRLTV        R15 -> CONVERSION RTN
         BASR  R14,R15             CONVERT MBBCCHHR -> TTR
         LR    R13,R3              RESTORE R13
         LTR   R15,R15          *  SET CC
         LM    R14,R15,12(R13)  |  RESTORE REGS, DO NOT RESTORE R0
         LM    R1,R12,24(R13)   |
         BNZ   AGPSSCBR         V  CONVERSION FAILED, TERMINATE SORT
*
*        INCR TT
*
         AL    R0,ADDTRKA          INCR TT ONLY IN TTRN
*
*        SETUP FOR EXCP
*        CONVERT TTR -> MBBCCHHR
*
         STM   R14,12,12(R13)      SAVE REGS ACROSS RTN
         LR    R3,R13              SAVE R13
         L     R1,DCBDEBAD         R1 -> DEB
         LA    R2,DCBFDAD          R2 -> MBBCCHHR RESULT
         L     R15,PPIPCNVT        R15 -> CONVERSION RTN
         BASR  R14,R15             CONVERT TTR -> MBBCCHHR
         LR    R13,R3
         LTR   R15,R15          *  SET CC
         LM    R14,R12,12(R13)  |  RESTORE REGS
         BNZ   AGPSSCBR         V  CONVERSION FAILED, TERMINATE SORT
         MVC   IOBSEEK,DCBFDAD     MOVE UPDATED SEARCH ADDR TO IOB
         BR    R8                  RETURN TO MAINLINE
*
         DROP  R15
*
*        OVERLAYS FOR VARIABLE RECORD FORMAT
*
AGPVR050 MVI   AGPVR+1,X'F0'       VARIABLE LENGTH RCD  OVERLAYS
         MVI   AGPEOS+3,X'05'
         MVI   AGPVRDSP+3,X'08'    IN THE ASSG AND IERRGP
         MVI   RGPEOSCK+3,X'05'    TO INCLUDE THE 4 BYTE BCC
         MVI   RGPFBV+3,X'05'      WHEN CONSIDERING THE DISPLACEMENT
         MVI   RGPRTRNV+3,X'08'    FROM THE START OF A BUFFER
         MVC   RGPVBCC+2(2),RGPINST1+2
         MVI   RGPACCV+3,X'05'
         MVI   AGPACCV+3,X'05'
         MVI   RGPVBCC+9,X'F0'
         MVI   RGPBF010+3,X'05'
         MVI   RGPAL025+11,X'05'
         B     AGPCCW
*
AGPRESET CLI   0(R1),ECBREPRG      REQUEST ELEMENT AVAIL AFTER PURGE ?
         BNE   AGPERROR            NO, ERROR CONDITION
*
*        REQUEST PURGED DUE TO I/O ERROR ON OTHER READ
*        RESTORE REQUEST QUEUE
*
         L     R15,IOBDCBPT
         USING IHADCB,R15
         NI    DCBIFLGS,255-DCBIFPEC  RESET I/O
         OI    IOBFLAG1,IOBCMDCH   SET COMMAND CHAINING ON
         L     R1,DCBDEBAD         R1 -> DEB
         USING DEBBASIC,R1
         LA    R1,DEBUSRPG         POINT TO FIRST PURGED IOB ADDR
         DROP  R1
         IERESTOR (1)              RESTORE SVC
         B     AGPWT030+4
*
AGPERROR PPISETON PPIREADE         TURN ON ERROR BIT IN PPI
AGPTERM  NOP   AGPSSCBR
         L     R1,IOBDCBPT         DCB ADDR
         ST    R5,KCCWLST          SET IOB ADDR WITH
         MVI   KCCWLST,X'10'       INCREMENT TO CCW ADDR IN
         L     R0,KCCWLST          THE HIGH ORDER BYTE
*
*        CALL E38
*        LINK TO USER IS OVERLAYED IF NOT ACTIVATED
*
         L     R15,AE38            R15 -> E38 EXIT
         BASR  R14,R15             CALL E38
*
AGPSSCBR ST    R4,AGPSVEME
         L     R15,PPIADSSC        TERMINATE OPTION ON OVERLAY FOR
         BAS   R14,16(,R15)
*
AGPSKIP  NI    IOBUSTAT,255-UC-UE  IF ERROR ACCEPTED
         NI    IOBCSTAT,255-IL-CDC
         L     R15,IOBDCBPT        RESET ALL ERROR BITS SET BY IOS
         USING IHADCB,R15
         NI    DCBIFLGS,255-DCBIFPEC  RESET I/O
         L     R1,DCBDEBAD         R1 -> DEB
         USING DEBBASIC,R1
         LA    R1,DEBUSRPG         POINT TO FIRST PURGED IOB ADDR
         DROP  R1
         IERESTOR (1)              RESTORE SVC
         DROP  R15
         OI    IOBFLAG1,IOBCMDCH   SET COMMAND CHAINING ON
AGPACCPT L     R1,IOBSTART
         L     R1,16(,R1)          WAS THE BLOCK TO BE
AGPACCV  CLI   1(R1),C'$'
         BE    AGPEOSER
*
         IEREXCP  (R5)             READ NEXT BLOCK INTO
*
         B     AGPWT030+4
AGPBR    B     AGPWT035
*
AGPEOSER LH    R15,PPIMRGMX        CHECK FOR ZERO
         BCT   R15,*+4             MERGP
         B     AGPZERO
*
         STH   R15,PPIMRGMX        ALLOW UNUSED BUFFER TO BE
         LH    R15,KCOUNT          PUT ON LIST TO BE USED BY IERRGP
         LA    R15,1(,R15)         TO ATTACH TO FILE'S WITH NO ALT
         STH   R15,KCOUNT          UPDATE LIST'S COUNT
         SH    R7,KFOUR            AND POINTER
         ST    R7,PPILAB02
         L     R15,IOBSTART        OBTAIN BUFFER ADDR FROM CCW LIST
         L     R15,16(,R15)
         ST    R15,0(,R7)          PLACE BUFFER ADDR ON LIST
         LH    R15,PPILAB01
         BCTR  R15,0
         STH   R15,PPILAB01
         CLC   PPILAB01+6(2),PPISRTBL
         BNE   AGPNEXTO
         B     AGPNEXT             UPDATE IOB ADDR AND LINK TO WAIT
*                                  ON THE NEXT FILE R8 STILL CONTAINS
*                                  ITS RETURN ADDR
AGPSAVE  DC    F'0'
*
KCCWLST  CCW   SEARIDEQ,0,CC+SLI,5
         CCW   TIC,KCCWLST,CC+SLI,0
         CCW   READDATA,0,SLI,64
*
         DC    0F'0'
KMASK    DC    X'FFFFFFF8'
ADDTRKA  DC    X'00010000'         ADD 1 TO TTRN
AGPCCWSV DC    7F'0'
AGPSVEME DC    F'0'
KEIGHT   DC    H'8'
*
         DROP  R10,R11
*
*        IERRGP
*
IERRGP   DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRGP SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRGPI
*
*        IERAP33
*
IERAP33  DSECT
         DC    23F'0'
WRDOPT   DC    9F'0'
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
*        IERCCWEQ
*
         IERCCWEQ
*
*        IERIOB
*
         IERIOB
*
         PRINT NOGEN
*
         DCBD  DSORG=PS,DEVD=(DA)
*
         IHAECB DSECT=NO,EXT=NO
*
         IEZDEB LIST=NO
*
         PRINT GEN
*
*        AGPAMC
*
AGPAMC   DSECT
*
         COPY  AMCMAIN
*
         SMPPI
*
         END
./ ADD NAME=IERAMA   0101-20211-20211-1200-00039-00039-00000-RELEASE 00
AMA      TITLE 'IERAMA - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERAMA
*
*        MODULE FUNCTION/OPERATION -
*        THIS MODULE CONTAINS ALL OF THE MESSAGES THAT ARE
*        REQUIRED FOR PHASE 1 ASSIGNMENT MODULES
*
*        THIS MODULE IS A DSECT IN -
*        IERABF,-ABS
*        -AGA,-AGI,-AGN,-9GN
*        -AOA,-AOB,-AOC,-AOD
*        -AOE,-AOF,-AOG,-AOH
*        -APA,-APB,-9PA,-APN
*        -APC,-APG,-APL
*
*        MACROS USED - NONE
*
*        ENTRY POINTS - N/A
*
*        INPUT - N/A
*
*        OUTPUT - N/A
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL - N/A
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS - N/A
*
IERAMA   CSECT
*
         COPY  AMAMAIN
*
         END
./ ADD NAME=IERAMB   0101-20211-20211-1200-00039-00039-00000-RELEASE 00
AMB      TITLE 'IERAMB - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERAMB
*
*        MODULE FUNCTION/OPERATION -
*        THIS MODULE CONTAINS ALL OF THE MESSAGES THAT ARE
*        REQUIRED FOR PHASE 2 ASSIGNMENT MODULES
*
*        THIS MODULE IS A DSECT IN -
*        IERABR
*        -AGB,-AGC,-AGL,-AGO
*        -9GB -AGG,-AGJ -APD
*        -APE,-APO -APH,-APJ
*        -APL
*        ALL USE A COPY STATEMENT FOR AMB
*
*        MACROS USED - N/A
*
*        ENTRY POINTS - N/A
*
*        INPUT - N/A
*
*        OUTPUT - N/A
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL - N/A
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS - N/A
*
IERAMB   CSECT
*
         COPY  AMBMAIN
*
         END
./ ADD NAME=IERAMC   0101-20211-20211-1200-00044-00044-00000-RELEASE 00
AMC      TITLE ' IERAMC - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERAMC
*
*        MODULE FUNCTION/OPERATION -
*        THIS MODULE CONTAINS ALL OF THE MESSAGES THAT ARE
*        REQUIRED FOR PHASE 3 ASSIGNMENT MODULES
*
*        MODULE IS A DSECT IN -
*        IERABL
*        -ABM,-ABN,-ABO,-ABP
*        -ABQ -AGD,-AGE,-AGM
*        -9GC,-AGP,-AGF,-AGH
*        -AGK,-APF,-API,-APK
*
*        MACROS USED - NONE
*
*        ENTRY POINTS - N/A
*
*        INPUT - N/A
*
*        OUTPUT - N/A
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL N/A
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS - N/A
*
IERAMC   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE AMCHAIN SOURCE
*
*----------------------------------------------------------------------
*
         COPY  AMCMAIN
*
         END
./ ADD NAME=IERAM1I  0101-20211-20211-1200-00069-00069-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERAM1 SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERAM1I
*
*        VERSION IDENTIFICATION
*
AM1VER   DC    CL4'????'           < --- SET FOR MESSAGES
*
AM1FLAGS DC    XL4'00000000'       OPTION FLAGS
*                               +0
*  STOPF EQU   BIT0                1. ALLOCATED TO STOPAFT
AM1DYNA  EQU   BIT1                2. DYNAUTO = YES
AM1DYNI  EQU   BIT2                3. DYNAUTO = IGNWKDD
AM1EQU   EQU   BIT3                4. EQUALS = YES
AM1ERET  EQU   BIT4                5. ERET = ABEND
AM1ESTA  EQU   BIT5                6. ESTAE = YES
AM1ECHK  EQU   BIT6                7. EXITCK = STRONG
AM1FSEX  EQU   BIT7                8. FSZEST = YES EXACT
*                               +1
AM1LIST  EQU   BIT0                9. LIST = YES
AM1RSET  EQU   BIT1               10. RESET = YES
AM1SMFR  EQU   BIT2               11. SMF = YES
AM1SMFL  EQU   BIT3               12. SMF = FULL
AM1LIBS  EQU   BIT4               13. SORTLIB = SYSTEM
AM1MAXS  EQU   BIT5               14. SIZE/MAINSIZE/CORE=MAX
AM1ABMSG EQU   BIT6               15. USE MSG NO FOR ABEND
*        EQU   BIT7               16.       RESERVED
*                               +2
AM1CALL  EQU   BIT0               17. ALL MESSAGES TO THE CONSOLE
AM1CCRT  EQU   BIT1               18. CRITICAL MESSAGES TO THE CONSOLE
AM1PALL  EQU   BIT2               19. ALL MESSAGES TO THE PRINTER
AM1PCRT  EQU   BIT3               20. CRITICAL MESSAGES TO THE PRINTER
*  OSTMT EQU   BIT4               21. ALLOCATED TO OPTION STMT
*  DSTMT EQU   BIT5               22. ALLOCATED TO DEBUG STMT
AM1VSEQ  EQU   BIT6               23. VERIFY=YES FOR SEQUENCE CHECK
AM1CHCK  EQU   BIT7               24. CHECK=YES FOR RECORD COUNT
*                               +3
AM1DIAG  EQU   BIT0               25. DIAGNOSTICS = YES
AM1DSIM  EQU   BIT1               26. DIAGSIM = YES
AM1TEXCP EQU   BIT2               27. TRACE EXCP
AM1TWAIT EQU   BIT3               28. TRACE COMPLETION OF EXCP
AM1TMODF EQU   BIT4               29. TRACE MODULE FLOW
AM1TSCPI EQU   BIT5               30. SNAP THE CPI
AM1TSPPI EQU   BIT6               31. SNAP THE PPI
AM1TBRKP EQU   BIT7               32. EXECUTE BREAKPOINTS
*
AM1ABC   DC    AL2(16)             ABEND CODE IF NOT MESSAGE NO OPTION
AM1DYND  DC    CL8'3390'           DEVICE TYPE FOR DYNAMIC ALLOCATION
AM1DYNN  DC    AL2(6)              NUMBER OF DYN ALLOC WORK DATA SETS
AM1DYNS  DC    AL4(5)              MEGABYTES OF DASD TO ALLOCATE
AM1DYNP  DC    AL2(50)             % INCR FACTOR IN SPACE CALC OVERHEAD
AM1MAXL  DC    AL4(2048*1024)      MAXIMUM STORAGE LIMIT FOR SORT/MERGE
AM1MINL  DC    AL4(80*1024)        MINIMUM STORAGE LIMIT FOR SORT/MERGE
AM1RMAX  DC    AL4(64*1024)        RESVD STORAGE - SIZE = MAX, EXEC
AM1RMAXI DC    AL4(96*1024)        RESVD STORAGE - SIZE = MAX, INVOKED
AM1STOR  DC    AL4(256*1024)       SORT STORAGE SIZE
AM1MDDN  DC    CL8'SYSOUT'         DDNAME FOR MESSAGE DATA SET
AM1PDDN  DC    CL8'IERPARM'        DDAME FOR PARAMETER DDN
AM1SDDN  DC    CL4'SORT'           DEFAULT DDN PREFIX
AM1SVC   DC    H'0'                0 = NO SVC, 109, OR 200 - 255
AM1SVCE  DC    H'0'                SVC ESR NUMBER
AM1WTOR  DC    XL2'0000'           WTO ROUTING CODES
AM1WTOD  DC    XL2'0000'           WTO DESCRIPTOR CODES
*
./ ADD NAME=IERAOA   0101-20211-20211-1200-00239-00239-00000-RELEASE 00
AOA      TITLE 'IERAOA - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERAOA
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 1 ASSIGNMENT FOR FIXED LENGTH REPLACEMENT WITH
*        MULTIPLE CONTROL FIELDS
*
*        THE FUNCTION OF THIS MODULE IS TO GENERATE THE
*        REPLACEMENT TREE IN GENERATED STORAGE, CHANGE THE
*        CONDITIONS FOR BRANCHING IN THE RUNNING PROGRAM IF THE
*        RECORDS ARE TO BE COLLATED IN DESCENDING ORDER IN THE
*        FIRST SEQUENCE, AND OTHERWISE INITIALIZE THE COMPARE
*        INSTRUCTIONS IN THE RUNNING PROGRAM
*
*        USED AS A DSECT IN - N/A
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM LOAD MODULE IERRC9
*                       CALLING SEQUENCE -
*                           LOAD   EP=IERAOA,DCB=
*                           LR     R15,R0
*                           BALR   R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPISRTG    PPISPGN1
*        PPICNTL    PPINET
*        PPIAXERT   PPIDDO1
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPISPGN1
*        REPLACEMENT TREE IS CREATED IN GENERATED CORE
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL -
*        BR R14 - RETURN TO LOAD ROUTINE IERRC9
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS -
*        WOADISP - A FULL WORD, IS USED TO HOLD DISPLACEMENT
*                  FIELD FOR ORING THE DISPLACEMENT
*                  FIELDS IN THE COMPARE INSTRUCTIONS IN THE
*                  RUNNING PROGRAM IN ORDER TO INITIALIZE THEM
*                  AS MECESSARY
*        WRSAVC9 - A FULL WORD, IS USED TO HOLD THE ADDRESS OF
*                  THE CALLING ROUTINE, THE LOAD MODULE IERRC9
*
*        NOTES -
*        THIS MODULE IS USED WITH FIXED LENGTH RECORDS WITH
*        MULTIPLE CONTROL FIELDS
*
IERAOA   CSECT
*
         USING *,R11
         USING IERRCA,R13
         USING DIERROA,R14
*
         IERENTRY 'IERAOA &SYSDATE &SYSTIME'
*
         LR    R11,R15             SET PROGRAM BASE REGISTER
         ST    R14,WRSAVC9
         L     R14,PPINET+4        SET DSECT REGISTER OF RUNNING MOD
*
*        DETERMINE SIZE OF AREA FOR GENERATING THE TREE, RESET
*        THE ADDRESS OF THE GENERATED AREA BY THIS AMOUNT, AND
*        SAVE THIS ADDRESS FOR THE NETWORK AS THE TREE ADDRESS
*        AND FOR THE NEXT ROUTINE AS THE ADDRESS OF THE GENERATED
*        AREA
*
         L     R8,PPISRTG          G OR NUMBER OF RECORDS FOR TREE
         LA    R3,3                NUMBER OF RECORDS ADDED PER NODE
         LA    R2,20               BYTES PER NODE
         LA    R10,1               RECORD COUNTER RECORDS TREE CAN HOLD
         LR    R5,R8               G OR NUMBER OF RECORDS FOR TREE
         SR    R5,R10              FORM G-1
         SR    R4,R4               ZERO REGISTER
         DR    R4,R3               FORM (G-1)/3
         LTR   R4,R4               TEST FOR REMAINDER
         BE    OASKIP              ROUND TO FULL NO OF NODES IF NOT 0
         AR    R5,R10              ROUND TO FULL NUMBER OF NODES
OASKIP   MR    R4,R2               CALCULATE NUMBER OF BYTES IN TREE
OAOKSIZE PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTICS ?
         BZ    AOANOMES            NO, BRANCH
         USING DIERAMA,R9          SET UP BASE REG FOR MESSAGE MOD
         ST    R9,OASAVEJ          SAVE R9
         STM   R14,R1,AOASAVO      SAVE REGISTERS
         L     R9,PPIAMA+4         SET MSG BASE REG
         L     R0,PPISPGN1         LOAD NUMBER TO BE CONVERTED
         L     R15,PPICONV+4       R15 -> CONVERSION ROUTINE
         BAS   R14,4(,R15)
         MVC   IER904B,2(R1)       MOVE TREE ADDR INTO MESSAGE
         L     R9,OASAVEJ          RESTORE R9
         LM    R14,R1,AOASAVO      RESTORE REGISTERS
         DROP  R9
AOANOMES L     R6,PPISPGN1         ADDR OF GENERATED CODE
         SR    R6,R5               DECREMENT ADDR OF GENERATED CODE
         SRL   R6,2                ROUND DOWN TO
         SLL   R6,2                FULL WORDS
         ST    R6,PPISPGN1         RESET NEW ADDR OF GENERATED CODE
         ST    R6,WATREEAD         STORE THIS TREE ADDR IN NETWORK
         PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTICS ?
         BZ    OANOMESS            NO, BRANCH
         USING DIERAMA,R9          SET UP BASE REG FOR MESSAGE MOD
         ST    R9,OASAVEJ          SAVE R9
         STM   R14,R1,AOASAVO      SAVE REGISTERS
         L     R9,PPIAMA+4         SET MSG BASE REG
         L     R0,PPISPGN1         LOAD NUMBER TO BE CONVERTED
         L     R15,PPICONV+4       LOAD ADDR OF CONVERSION ROUTINE
         BAS   R14,4(,R15)
         MVC   IER904A,2(R1)       MOVE TREE ADDR INTO MESSAGE
         LM    R0,R1,IER904        IER904I TREE ADDR FROM
         L     R15,PPIADSSC        R15 -> PRINT ROUTINE
         BAS   R14,12(,R15)        CALL PRINT MESSAGE
         L     R9,OASAVEJ          RESTORE R9
         LM    R14,R1,AOASAVO      RESTORE REGISTERS
         DROP  R9
*
*        SET BASE REGISTER FOR EQUALS ROUTINE
*
OANOMESS L     R12,PPIAXERT        SET BASE REGISTER OF EQUALS ROUTINE
*
*        SET UP ANY ADDITIONAL CONSTANTS REQUIRED TO GENERATE TREE
*
         LR    R9,R6               NEXT LEVEL ADDR FOR PREVIOUS LEVEL
         LA    R7,4                WAY OR NODE COUNTER
         LA    R4,WALTNODE         ADDR OF LAST TEST NODE
         SR    R5,R5               SET FORMAT OF THIS NODE TO ZERO
*
*        GENERATE THE REQUIRED TREE
*
OASTTREE STM   R4,R5,0(R6)         STORE NLA AND FORMAT OF NODE
         AR    R10,R3              INC RECORD COUNTER BY 3 EACH NODE
         CR    R10,R8              RECORDS TREE HOLDS NOW TO REQD NO
         BNL   OAENOUGH            NO MORE NODES REQUIRED
         AR    R6,R2               INCREMENT TO LOCATION OF NEXT NODE
         LR    R4,R9               SET NEXT LEVEL ADDRESS
         BCT   R7,OASTTREE         BRANCH IF NODE COUNTER NOT ZERO
         LA    R7,4                RESET NODE OR WAY COUNTER
         AR    R9,R2               INCREMENT NEXT LEVEL ADDRESS
         B     OASTTREE
*
*        SAVE TREE INFORMATION FOR THE NETWORK
*
OAENOUGH STM   R7,R9,WASAVE        SAVE FILLING REGISTERS
*
*        IF COLLATING ORDER OF FIRST SEQUENCE IS TO BE
*        DECENDING, REVERSE THE NECESSARY CONDITIONAL BRANCHES IN
*        THE RUNNING ROUTINE
*
         PPITEST  PPIPH1CO         TEST COLLATING ORDER
         BZ    OAASCEND            ORDER IS ASCEND, BRANCH
         XI    OAC44A+1,X'60'      REVERSE CONDITIONAL BRANCH IN NETWOR
         XI    OAC44B+1,X'60'      SAME
         XI    OAC38B+1,X'60'      SAME
         XI    OAC34A+1,X'60'      SAME
         XI    OAC28A+1,X'60'      SAME
         XI    OAC27A+1,X'60'      SAME
         XI    OAC27C+1,X'60'      SAME
         XI    OAC22A+1,X'60'      SAME
         XI    OAC16A+1,X'60'      SAME
         XI    OAC15A+1,X'60'      SAME
         XI    OASCHECK+1,X'60'    REVERSE CONDITIONAL BRANCH IN SEQCK
*
*        INITIALIZE THE DISPLACEMENT FIELDS IN THE COMPARE
*        INSTRUCTIONS IN THE RUNNING ROUTINE AS NECESSARY
*
OAASCEND LH    R4,PPIDD0L1         DISPLACEMENT OF FIRST CONTROL FIELD
         LA    R4,4(,R4)           INCREMENT DISPLACEMENT FOR TREE ADDR
         STH   R4,WOADISP          SET UP DISPLACEMENT
         STH   R4,WOADISP+2        FIELDS FOR ORING
         OC    OACASE44+6(4),WOADISP    INIT DISP IN CLC IN NETWK
         OC    OAC44A+6(4),WOADISP      SAME
         OC    OAC38A+2(4),WOADISP      SAME
         OC    OACASE34+14(4),WOADISP   SAME
         OC    OACASE28+2(4),WOADISP    SAME
         OC    OACASE27+14(4),WOADISP   SAME
         OC    OAC27B+2(4),WOADISP      SAME
         OC    OACASE22+14(4),WOADISP   SAME
         OC    OACASE16+2(4),WOADISP    SAME
         OC    OACASE15+14(4),WOADISP   SAME
         OC    OARETRUN+18(4),WOADISP   INITIALIZE DISP IN CLC IN SEQCK
*
*        INITIALIZE THE LENGTH FIELDS IN THE COMPARE
*        INSTRUCTIONS IN THE RUNNING ROUTINE AS NECESSARY
*
         IC    R4,PPIDD0L1+3       LENGTH OF 1ST CONTROL FIELD FOR CLC
         STC   R4,OACASE44+5       SET LENGTH FIELD IN CLC IN NETWORK
         STC   R4,OAC44A+5          SAME
         STC   R4,OAC38A+1          SAME
         STC   R4,OACASE34+13       SAME
         STC   R4,OACASE28+1        SAME
         STC   R4,OACASE27+13       SAME
         STC   R4,OAC27B+1          SAME
         STC   R4,OACASE22+13       SAME
         STC   R4,OACASE16+1        SAME
         STC   R4,OACASE15+13       SAME
         STC   R4,OARETRUN+17      SET LENGTH FIELD IN CLC IN SEQCK
*
*        EXIT TO NEXT ASSIGNMENT ROUTINE
*
         L     R14,WRSAVC9          RESTORE RETURN ADDR
         BR    R14                  RETURN TO LOAD ROUTINE
*
*        WORK AREAS
*
WOADISP  DC    F'0'                 HOLD DISP FIELD FOR ORING
WRSAVC9  DC    F'0'                 SAVE R14
OASAVEJ  DC    F'0'
AOASAVO  DC    4F'0'
*
DIERROA  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERROA SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERROAI
*
*
DIERAMA  DSECT
*
         COPY  AMAMAIN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERAOB   0101-20211-20211-1200-00265-00265-00000-RELEASE 00
AOB      TITLE 'IERAOB - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERAOB
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 1 ASSIGNMENT FOR FIXED LENGTH REPLACEMENT WITH
*        SINGLE CONTROL FIELD. THE FUNCTION OF THIS MODULE IS TO
*        SET UP THE APPROPRIATE LENGTH FIELDS, DISPLACEMENT
*        FIELDS, AND CONSTANTS, DEPENDING ON WHETHER THE EXTRACT
*        ROUTINE WILL BE USED OR NOT, GENERATE THE REPLACEMENT
*        TREE IN GENERATED STORAGE, CHANGE THE CONDITIONS FOR
*        BRANCHING IN THE RUNNING PROGRAM IF THE RECORDS ARE TO
*        BE COLLATED IN DESCENDING ORDER IN THE FIRST SEQUENCE,
*        AND OTHERWISE INITIALIZE THE COMPARE INSTRUCTIONS IN THE
*        RUNNING PROGRAM
*
*        USED AS A DSECT IN - N/A
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                       CALLING SEQUENCE -
*                           LOAD  EP=IERAOB,DCB=
*                           LR    R15,R0
*                           BALR  R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPISRTG    PPILEXFF
*        PPIAXERT   PPIX61+4
*        PPISPGN1   PPINET+4
*        PPIDDOL1   PPICNTL - PPIEXTRT+PPIPEOF, PPIME31
*        PPILEXFD
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPISPGN1
*        REPLACEMENT TREE IS CREATED IN GENERATED STORAGE
*
*        EXTERNAL ROUTINE - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL - BR R14 - RETURN TO IERRC9
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS -
*        WOADISP - FULL WORD USED TO HOLD DISPLACEMENT FIELD FOR
*                  ORING THE DISPLACEMENT FIELDS IN THE COMPARE
*                  INSTRUCTIONS IN THE RUNNING PROGRAM IN ORDER TO
*                  INITIALIZE THEM AS NECESSARY
*        WOALGTH - FULL WORD IS USED TO HOLD LENGTH FIELD FOR
*                  COMPARE INSTRUCTIONS
*        WRSAVC9 - FULL WORD IS USED TO HOLD THE ADDR OF THE
*                  CALLING ROUTINE IERRC9
*
*        NOTES - THIS NODULE IS USED WITH FIXED LENGTH RECORDS
*        WITH A SINGLE CONTROL FIELD
*
IERAOB   CSECT
*
         USING *,R11
         USING IERRCA,R13
         USING DIERROB,R12
*
         IERENTRY 'IERAOB &SYSDATE &SYSTIME'
*
         LR    R11,R15             SET PROGRAM BASE REGISTER
         ST    R14,SAVERET         SAVE RETURN ADDR IN IERRC9
         L     R12,PPINET+4        R12 -> IERROB
*
*        DETERMINE IF EXTRACTING AND SET SWITCH IN NETWORK
*        ACCORDINGLY
*
         PPITEST  PPIEXTRT         EXTRACT ON ?
         BZ    OANOEXT             NO, BRANCH
         LA    R6,255              CONSTANT X'FF'
         STH   R6,KASWITCH+2       SET EXT SWITCH ON IN RUNNING MODULE
*
*        DETERMINE IF MODIFICATION EXIT E61 IS ACTIVE AND STORE
*        ITS ADDR IN EXTRACT ROUTINE IF NECESSARY
*
         PPITEST  PPIME61          USER EXIT E61 ACTIVE ?
         BZ    OANOUSER            NO, BRANCH
         L     R15,PPIAXERT        R15 -> EXTRACT ROUTINE
         L     R6,PPIX61+4         ADDR OF USER MODIFICATION
         ST    R6,0(,R15)          ADDR OF USER MODIFICATION IN EXTRACT
*
*        SET UP LENGTH FIELDS, DISPLACEMENT FIELDS AND CONSTANTS
*        AS REQUIRED IF EXTRACTING
*
OANOUSER LH    R6,PPILEXFF         L'EXTRACTED FIELD ROUNDED FULL
         LA    R6,4(,R6)           INCREMENT BY 4 FOR TREE ADDR
         ST    R6,KAINCDEC         STORE IN NETWORK AS INC OR DEC
         LA    R6,4                CONSTANT OF 4 FOR DISPLACEMENT
         STH   R6,WOADISP          SET UP DISPLACEMENT
         STH   R6,WOADISP+2        FIELDS FOR ORING
         LH    R6,PPILEXFD         LGTH OF EXTRACTED FIELD FOR COMPARES
         ST    R6,WOALGTH          LENGTH FIELD FOR COMPARE INSTS
         B     OAGOGO
*
*        SET UP LENGTH FIELDS, DISPLACEMENT FIELDS AND CONSTANTS
*        AS REQUIRED IF NOT EXTRACTING
*
OANOEXT  LH    R4,PPIDD0L1         DISPLACEMENT OF FIRST CONTROL FIELD
         LA    R4,4(,R4)           INCREMENT DISPLACEMENT FOR TREE ADDR
         STH   R4,WOADISP          SET UP DISPLACEMENT
         STH   R4,WOADISP+2        FIELDS FOR ORING
         LA    R4,4                CONSTANT OF 4
         ST    R4,KAINCDEC         STORE IN NETWORK AS INC OR DEC
         SR    R4,R4               ZERO REGISTER
         IC    R4,PPIDD0L1+3       LENGTH OF 1ST CONTROL FIELD FOR CLC
         ST    R4,WOALGTH          LENGTH FIELD FOR COMPARE INSTS
*
*        DETERMINE SIZE OF AREA FOR GENERATING THE TREE
*        RESET THE ADDR OF THE GENERATED AREA BY THIS AMOUNT AND
*        SAVE THIS ADDR FOR THE NETWORK AS THE TREE ADDR AND FOR
*        THE NEXT ROUTINE AS THE ADDR OF THE GENERATED AREA
*
OAGOGO   L     R8,PPISRTG          G OR NUMBER OF RECORDS FOR TREE
         LR    R5,R8               G OR NUMBER OF RECORDS FOR TREE
         LA    R3,3                NUMBER OF RECORDS ADDED PER NODE
         LA    R2,20               BYTES PER NODE
         LA    R10,1               RECORD COUNTER RECORDS TREE CAN HOLD
         SR    R5,R10              FORM G-1
         SR    R4,R4               ZERO REGISTER
         DR    R4,R3               FORM (G-1)/3
         LTR   R4,R4               REMAINDER ?
         BZ    OASKIP              ROUND TO FULL NO OF NODES IF NOT 0
         AR    R5,R10              ROUND TO FULL NUMBER OF NODES
OASKIP   MR    R4,R2               CALCULATE NUMBER OF BYTES IN TREE
         PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTICS ?
         BZ    OAOKSZE             NO, BRANCH
         USING DIERAMA,R9          SET UP BASE REG FOR MESSAGE MOD
         L     R9,PPIAMA+4         SET MSG BASE REG
         L     R0,PPISPGN1         LOAD NUMBER TO BE CONVERTED
         L     R15,PPICONV+4       LOAD ADDR OF CONVERSION ROUTINE
         BAS   R14,4(,R15)
         MVC   IER904B,2(R1)       MOVE FORMATTED ADDR INTO MSG
OAOKSZE  L     R6,PPISPGN1         ADDR OF GENERATED STORAGE
         SR    R6,R5               DECREMENT ADDR OF GENERATED CODE
         SRL   R6,2                ROUND DOWN TO
         SLL   R6,2                FULL WORDS
         ST    R6,PPISPGN1         RESET NEW ADDR OF GENERATED CODE
         ST    R6,WATREEAD         STORE THIS TREE ADDR IN NETWORK
         PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTICS ?
         BZ    OANOMESS            NO, BRANCH
         L     R0,PPISPGN1         LOAD ADDR TO BE CONVERTED
         L     R15,PPICONV+4       LOAD ADDR OF CONVERSION ROUTINE
         BAS   R14,4(,R15)
         MVC   IER904A,2(R1)       MOVE FORMATTED ADDR INTO MSG
         LM    R0,R1,IER904        IER904I TREE ADDR FROM
         L     R15,PPIADSSC        LOAD ADDR OF PRINT ROUTINE
         BAS   R14,12(,R15)        CALL MSG WRITER
         DROP  R9
*
*        SET UP ANY ADDITIONAL CONSTANTS REQUIRED TO GENERATE TREE
*
OANOMESS LR    R9,R6               NEXT LEVEL ADDR FOR PREVIOUS LEVEL
         LA    R7,4                WAY OR NODE COUNTER
         LA    R4,WALTNODE         ADDR OF LAST TEST NODE
         SR    R5,R5               SET FORMAT OF THIS NODE TO ZERO
*
*        GENERATE THE REQUIRED TREE
*
OASTTREE STM   R4,R5,0(R6)         STORE NLA AND FORMAT OF NODE
         AR    R10,R3              INC RECORD COUNTER BY 3 EACH NODE
         CR    R10,R8              RECORDS TREE HOLDS NOW TO REQD NO ?
         BNL   OAENOUGH            NO MORE NODES REQUIRED
         AR    R6,R2               INCREMENT TO LOCATION OF NEXT NODE
         LR    R4,R9               SET NEXT LEVEL ADDR
         BCT   R7,OASTTREE         BRANCH IF NODE COUNTER NOT ZERO
         LA    R7,4                RESET NODE OR WAY COUNTER
         AR    R9,R2               INCREMENT NEXT LEVEL ADDR
         B     OASTTREE
*
*        SAVE TREE INFORMATION FOR THE NETWORK
*
OAENOUGH STM   R7,R9,WASAVE        SAVE FILLING REGISTERS
*
*        IF COLLATING ORDER OF FIRST SEQUENCE IS TO BE DECENDING
*        REVERSE THE NECESSARY CONDITIONAL BRANCHES IN THE
*        RUNNING ROUTINE
*
         PPITEST  PPIPH1CO         COLLATING ORDER DESCENDING ?
         BZ    OAASCEND            NO, BRANCH ORDER IS ASCENDING
         XI    OACASE44+11,X'60'   REVERSE CONDITIONAL BRANCH IN NTWK
         XI    OACASE44+21,X'60'    SAME
         XI    OAC38A+7,X'60'       SAME
         XI    OACASE34+19,X'60'    SAME
         XI    OACASE28+7,X'60'     SAME
         XI    OACASE27+19,X'60'    SAME
         XI    OAC27A+7,X'60'       SAME
         XI    OACASE22+19,X'60'    SAME
         XI    OACASE16+7,X'60'     SAME
         XI    OACASE15+19,X'60'    SAME
         XI    OANOTON2+19,X'60'    REVERSE CONDITIONAL BRANCH IN SEQCK
*
*        INITIALIZE THE DISPLACEMENT FIELDS IN THE COMPARE
*        INSTRUCTIONS IN THE RUNNING ROUTINE AS NECESSARY
*
OAASCEND OC    OACASE44+6(4),WOADISP  INIT DISP IN CLC IN NETWK
         OC    OACASE44+16(4),WOADISP   SAME
         OC    OAC38A+2(4),WOADISP      SAME
         OC    OACASE34+14(4),WOADISP   SAME
         OC    OACASE28+2(4),WOADISP    SAME
         OC    OACASE27+14(4),WOADISP   SAME
         OC    OAC27A+2(4),WOADISP      SAME
         OC    OACASE22+14(4),WOADISP   SAME
         OC    OACASE16+2(4),WOADISP    SAME
         OC    OACASE15+14(4),WOADISP   SAME
         OC    OANOTON2+14(4),WOADISP   INITIALIZE DISP IN CLC IN SEQCK
*
*        INITIALIZE THE LENGTH FIELDS IN THE COMPARE
*        INSTRUCTIONS IN THE RUNNING ROUTINE AS NECESSARY
*
         L     R4,WOALGTH          LENGTH OF CONTROL FIELD FOR COMPARES
         STC   R4,OACASE44+5       SET LENGTH FIELD IN CLC IN NETWORK
         STC   R4,OACASE44+15       SAME
         STC   R4,OAC38A+1          SAME
         STC   R4,OACASE34+13       SAME
         STC   R4,OACASE28+1        SAME
         STC   R4,OACASE27+13       SAME
         STC   R4,OAC27A+1          SAME
         STC   R4,OACASE22+13       SAME
         STC   R4,OACASE16+1        SAME
         STC   R4,OACASE15+13       SAME
         STC   R4,OANOTON2+13       SET LENGTH FIELD IN CLC IN SEQCK
*
*        EXIT TO RETURN TO IERRC9 FOR NEXT ASSIGNMENT ROUTINE
*
         L     R14,SAVERET          RESTORE RETURN ADDR
         BR    R14                  RETURN TO LOAD ROUTINE
*
*        WORK AREAS
*
*
WOADISP  DC    F'0'                 HOLD DISP FIELD FOR ORING
WOALGTH  DC    F'0'                 HOLD LENGTH FIELD FOR INIT
SAVERET  DC    F'0'                 SAVE R14
*
*        IERROB
*
DIERROB  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERROB SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERROBI
*
DIERAMA  DSECT
*
         COPY  AMAMAIN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERAOC   0101-20211-20211-1200-00209-00209-00000-RELEASE 00
AOC      TITLE 'IERAOC - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME IERAOC
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 1 ASSIGNMENT FOR VARIABLE LENGTH REPLACEMENT WITH
*        MULTIPLE CONTROL FIELDS. THE FUNCTION OF THIS MODULE IS
*        TO GENERATE THE REPLACEMENT TREE IN GENERATED CORE,
*        CHANGE THE CONDITIONS FOR BRANCHING IN THE RUNNING
*        PROGRAM IF THE RECORDS ARE TO BE COLLATED IN DESCENDING
*        ORDER IN THE FIRST SEQUENCE, AND OTHERWISE INITIALIZE
*        THE COMPARE INSTRUCTIONS IN THE RUNNING PROGRAM
*
*        USED AS A DSECT IN - N/A
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                       CALLING SEQUENCE -
*                           LOAD   EP=IERAOC,DCB=
*                           LR     R15,R0
*                           BALR   R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPICNTL   PPIDDOL1   PPISRTG   PPISPGN1
*        PPIAXERT  PPINET+4   PPIDDOL1
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPISPGN1
*        REPLACEMENT TREE IS CREATED IN GENERATED CORE
*
*        EXTERNAL ROUTINES -
*        N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL -
*                BR R14 - RETURN TO IERRC9
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS -
*        WOCDISP - FULL WORD USED TO HOLD DISPLACEMENT FIELD FOR
*        ORING THE DISPLACEMENT FIELDS IN THE COMPARE
*        INSTRUCTIONS IN THE RUNNING RPOGRAM IN ORDER TO
*        INITIALIZE THEM AS NECESSARY
*        WRSAVC9 - A FULL WORD IS USED TO HOLD THE ADDR OF THE
*        CALLING ROUTINE IERRC9
*
*        NOTES -
*        THIS MODULE IS USED WITH VARIABLE LENGTH RECORDS WITH
*        MULTIPLE CONTROL FIELDS
*
IERAOC   CSECT
*
         USING *,R11
         USING IERRCA,R13
         USING DIERROC,R14
*
         IERENTRY 'IERAOC &SYSDATE &SYSTIME'
*
         LR    R11,R15             SET PROGRAM BASE REGISTER
         ST    R14,WRSAVC9
         L     R14,PPINET+4        SET DSECT REGISTER OF RUNNING MOD
*
*        DETERMINE SIZE OF AREA FOR GENERATING THE TREE, RESET
*        THE ADDR OF THE GENERATED AREA BY THIS AMOUNT,AND SAVE
*        THIS ADDRESS FOR THE NETWORK AS THE TREE ADDR AND FOR
*        THE NEXT ROUTINE AS THE ADDR OF THE GENERATED AREA
*
         L     R8,PPISRTG          G OR NUMBER OF RECORDS FOR TREE
         LA    R10,1               RECORD COUNTER RECORDS TREE CAN HOLD
         LA    R2,12               BYTES PER NODE
         LR    R5,R8               G OR NUMBER OF RECORDS FOR TREE
         SR    R5,R10              FORM G-1
         SR    R4,R4               ZERO R4
         MR    R4,R2               CALCULATE NUMBER OF BYTES IN TREE
         LA    R9,36               SIZE OF MINIMUM TREE
         CR    R5,R9               CALCULATED SIZE >= G MINIMUM
         BNL   OCOKSIZE            YES, BRANCH
         LR    R5,R9               SET TREE SIZE TO MINIMUM
OCOKSIZE PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTICS ?
         BZ    AOCNOMES            NO, BRANCH
         USING DIERAMA,R9          SET UP BASE REG FOR MESSAGE MOD
         ST    R9,OASAVEJ          SAVE R9
         STM   R14,R1,AOCSAVO      SAVE REGISTERS
         L     R9,PPIAMA+4         SET MSG BASE REG
         L     R0,PPISPGN1         LOAD NUMBER TO BE CONVERTED
         L     R15,PPICONV+4       LOAD ADDR OF CONVERSION ROUTINE
         BAS   R14,4(,R15)
         MVC   IER904B,2(R1)       MOVE FORMATTED ADDR INTO MSG
         L     R9,OASAVEJ          RESTORE R9
         LM    R14,R1,AOCSAVO      RESTORE REGISTERS
         DROP  R9
AOCNOMES L     R6,PPISPGN1         ADDR OF GENERATED CODE
         SR    R6,R5               DECREMENT ADDR OF GENERATED CODE
         SRL   R6,2                ROUND DOWN TO
         SLL   R6,2                FULL WORDS
         ST    R6,PPISPGN1         RESET NEW ADDR OF GENERATED CODE
         ST    R6,WCTREE           STORE THIS TREE ADDR IN NETWORK
         PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTICS ?
         BZ    OANOMESS            NO, BRANCH
         USING DIERAMA,R9          SET UP BASE REG FOR MESSAGE MOD
         ST    R9,OASAVEJ          SAVE R9
         STM   R14,R1,AOCSAVO      SAVE REGISTERS
         L     R9,PPIAMA+4         SET MSG BASE REG
         L     R0,PPISPGN1         LOAD NUMBER TO BE CONVERTED
         L     R15,PPICONV+4       LOAD ADDR OF CONVERSION ROUTINE
         BAS   R14,4(,R15)
         MVC   IER904A,2(R1)       MOVE FORMATTED ADD
         LM    R0,R1,IER904        IER904I TREE ADDR FROM
         L     R15,PPIADSSC        LOAD ADDR OF PRINT ROUTINE
         BAS   R14,12(0,R15)       CALL PRINT MESSAGE RTN
         L     R9,OASAVEJ          RESTORE R9
         LM    R14,R1,AOCSAVO      RESTORE REGS
         DROP  R9
*
*        SET BASE REGISTER FOR EQUALS ROUTINE
*
OANOMESS L     R12,PPIAXERT        SET BASE REG OF EQUALS ROUTINE
*
*        SET UP ANY ADDITIONAL CONSTANTS REQUIRED TO GENERATE
*        TREE
*
         LR    R9,R6               NEXT LEVEL ADDR FOR PREVIOUS LEVEL
         LA    R7,2                WAY OR NODE COUNTER
         LA    R4,WCLTNODE         ADDR OF LAST TEST NODE
         SR    R5,R5               SET FORMAT OF THIS NODE TO ZERO
*
*        GENERATE THE REQUIRED TREE
*
OCSTTREE STM   R4,R5,0(R6)         STORE NLA AND FORMAT OF NODE
         LA    R10,1(,R10)         INC RECORD COUNTER BY 1 EACH NODE
         CR    R10,R8              RECORDS TREE HOLDS NOW TO REQD NO
         BNL   OCENOUGH            NO MORE NODES REQUIRED
         LA    R6,12(,R6)          INCREMENT TO LOCATION OF NEXT NODE
         LR    R4,R9               SET NEXT LEVEL ADDR
         BCT   R7,OCSTTREE         BRANCH IF NODE COUNTER NOT ZERO
         LA    R7,2                RESET NODE OR WAY COUNTER
         LA    R9,12(,R9)          INCREMENT NEXT LEVEL ADDR
         B     OCSTTREE
*
*        SAVE TREE INFORMATION FOR THE NETWORK
*
OCENOUGH STM   R7,R9,WCSAVE        SAVE FILLING REGISTERS
*
*        IF COLLATING ORDER OF FIRST SEQUENCE IS TO BE DECENDING,
*        REVERSE THE NECESSARY CONDITIONAL BRANCHES IN THE
*        RUNNING ROUTINE
*
         PPITEST  PPIPH1CO         COLLATING ORDER DESCENDING ?
         BZ    OCASCEND            NO, BRANCH ACENDING
         XI    OCC24A+1,X'60'      REVERSE CONDITIONAL BRANCH IN NETWOR
         XI    OCSCHECK+1,X'60'    REVERSE CONDITIONAL BRANCH IN SEQCK
*
*        INITIALIZE THE DISPLACEMENT FIELDS IN THE COMPARE
*        INSTRUCTIONS IN THE RUNNING ROUTINE AS NECESSARY
*
OCASCEND LH    R4,PPIDD0L1         DISPLACEMENT OF FIRST CONTROL FIELD
         LA    R4,4(,R4)           INCREMENT DISPLACEMENT FOR TREE ADDR
         STH   R4,WOCDISP          SET UP DISPLACEMENT
         STH   R4,WOCDISP+2        FIELDS FOR ORING
         OC    OCCASE24+2(4),WOCDISP   INIT DISP IN CLC IN NETWORK
         OC    OCGOTRUN+26(4),WOCDISP  INIT DISP IN CLC IN SEQCK
*
*        INITIALIZE THE LENGTH FIELDS IN THE COMPARE INSTRUCTIONS
*        IN THE RUNNING ROUTINE AS NECESSARY
*
         IC    R4,PPIDD0L1+3       LENGTH OF 1ST CONTROL FIELD FOR CLC
         STC   R4,OCCASE24+1       SET LENGTH FIELD IN CLC IN NETWORK
         STC   R4,OCGOTRUN+25      SET LENGTH FIELD IN CLC IN SEQCK
*
*        EXIT TO NEXT ASSIGNMENT ROUTINE
*
         L     R14,WRSAVC9         RESTORE RETURN ADDR
         BR    R14                 RETURN TO LOAD ROUTINE
*
*        WORK AREAS
*
WOCDISP  DC    F'0'                HOLD DISP FIELDS FOR ORING
WRSAVC9  DC    F'0'                SAVE R14
OASAVEJ  DC    F'0'
AOCSAVO  DC    4F'0'
*
*        IERROC
*
DIERROC  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERROC SOURCE
*
*----------------------------------------------------------------------
*
         COPY IERROCI
*
DIERAMA  DSECT
*
         COPY  AMAMAIN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERAOD   0101-20211-20211-1200-00251-00251-00000-RELEASE 00
AOD      TITLE 'IERAOD - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERAOD
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 1 ASSIGNMENT FOR VARIABLE LENGTH REPLACEMENT WITH
*        SINGLE CONTROL FIELD. THE FUNCTION OF THIS MODULE IS TO
*        SET UP THE APPROPRIATE LENGTH FIELDS, DISPLACEMENT
*        FIELDS, AND CONSTANTS, DEPENDING ON WHETHER THE EXTRACT
*        ROUTINE WILL BE USED OR NOT, GENERATE THE REPLACEMENT
*        TREE IN GENERATED CORE, CHANGE THE CONDITIONS FOR
*        BRANCHING IN THE RUNNING PROGRAM IF THE RECORDS ARE TO
*        BE COLLATED IN DESCENDING ORDER IN THE FIRST SEQUENCE,
*        AND OTHERWISE INITIALIZE THE COMPARE INSTRUCTIONS IN THE
*        RUNNING PROGRAM
*
*        USED AS A DSECT IN - N/A
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                           LOAD  EP=IERAOD,DCB=
*                           LR    R15,R0
*                           BALR  R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPISRTG    PPILEXFF
*        PPIAXERT   PPIX61+4
*        PPIDDOL1   PPICNTL
*        PPISPGN1   PPINET+4
*        PPILEXFD
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPISPGN1
*        REPLACEMENT TREE IS CREATED IN GENERATED CORE
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL -
*        BR R14 - RETURN TO IERRC9
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS -
*        WOCDISP - FULL WORD HOLD DISPLACEMENT FIELD FOR ORING
*                  THE DISPLACEMENT FIELDS IN THE COMPARE
*                  INSTRUCTIONS IN ORDER TO INITIALIZE
*                  THEM AS NECESSARY
*        WOCLGTH - FULL WORD HOLD LENGTH FIELD FOR COMPARE
*                  INSTRUCTIONS
*        WRSAVC9 - FULL WORD HOLD THE ADDRESS OF THE CALLING
*                  ROUTINE IERRC9
*
*        NOTES -
*        THIS MODULE IS USED WITH VARIABLE LENGTH RECORDS WITH A
*        SINGLE CONTROL FIELD
*
IERAOD   CSECT
*
         USING *,R11
         USING IERRCA,R13
         USING DIERROD,R14
*
IERMOA   LR    R11,R15             SET PROGRAM BASE REGISTER
         ST    R14,WRSAVC9
         L     R14,PPINET+4        SET DSECT REGISTER OF IERROD
*
*        DETERMINE IF EXTRACTING AND SET SWITCH IN NETWORK
*        ACCORDINGLY
*
         PPITEST  PPIEXTRT         EXTRACTING ?
         BZ    OCNOEXT             NO, BRANCH
         LA    R6,255              CONSTANT X'FF'
         STH   R6,KCSWITCH+2       SET EXT SWITCH ON IN IERROD
         L     R12,PPIAXERT        SET BASE REGISTER OF EXTRACT ROUTINE
*
*        DETERMINE IF MODIFICATION EXIT 61 IS ACTIVE AND STORE
*        ITS ADDR IN EXTRACT ROUTINE IF NECESSARY
*
         PPITEST  PPIME61          E61 EXIT REQUESTED ?
         BZ    OCNOUSER            BRANCH
         L     R6,PPIX61+4         ADDR OF USER MODIFICATION
         ST    R6,0(,R12)          ADDR OF USER MODIFICATION IN EXTRACT
*
*        SET UP LENGTH FIELDS, DISPLACEMENT FIELD, AND CONSTANTS
*        AS REQUIRED IF EXTRACTING
*
OCNOUSER LH    R6,PPILEXFF         LEN OF EXTRACTED FIELD ROUNDED FULL
         LA    R6,4(,R6)           INCREMENT BY 4 FOR TREE ADDR
         ST    R6,KCINCDEC         STORE IN NETWORK AS INC OR DEC
         LA    R6,4                CONSTANT OF 4 FOR DISPLACEMENT
         STH   R6,WOCDISP          SET UP DISPLACEMENT
         STH   R6,WOCDISP+2        FIELDS FOR ORING
         LH    R6,PPILEXFD         LEN OF EXTRACTED FIELD FOR COMPARES
         ST    R6,WOCLGTH          LENGTH FIELD FOR COMPARE INSTS
         B     OCGOGO
*
*        SET UP LENGTH FIELDS, DISPLACEMENT FIELDS, AND CONSTANTS
*        AS REQUIRED IF NOT EXTRACTING
*
OCNOEXT  LH    R4,PPIDD0L1         DISPLACEMENT OF FIRST CONTROL FIELD
         LA    R4,4(,R4)           INCREMENT DISPLACEMENT FOR TREE ADDR
         STH   R4,WOCDISP          SET UP DISPLACEMENT
         STH   R4,WOCDISP+2        FIELDS FOR ORING
         LA    R4,4                CONSTANT OF 4
         ST    R4,KCINCDEC         STORE LEN NETWORK AS INC OR DEC
         SR    R4,R4               ZERO REG
         IC    R4,PPIDD0L1+3       LENGTH OF 1ST CONTROL FIELD FOR CLC
         ST    R4,WOCLGTH          LENGTH FIELD FOR COMPARE INSTS
*
*        DETERMINE SIZE OF AREA FOR GENERATING THE TREE, RESET
*        THE ADDR OF THE GENERATED AREA BY THIS AMOUNT,AND SAVE
*        THIS ADDR FOR THE NETWORK AS THE TREE ADDR AND FOR THE
*        NEXT ROUTINE AS THE ADDR OF THE GENERATED AREA
*
OCGOGO   L     R8,PPISRTG          G OR NUMBER OF RECORDS FOR TREE
         LA    R10,1               RECORD COUNTER RECORDS TREE CAN HOLD
         LA    R2,12               BYTES PER NODE
         LR    R5,R8               G OR NUMBER OF RECORDS FOR TREE
         SR    R5,R10              FORM G-1
         SR    R4,R4               ZERO REG
         MR    R4,R2               CALCULATE NUMBER OF BYTES IN TREE
         LA    R9,36               SIZE OF MINIMUM TREE
         CR    R5,R9               CALCULATED SIZE >= G MINIMUM
         BNL   OCOKSIZE            YES, BRANCH
         LR    R5,R9               SET TREE SIZE TO MINIMUM
OCOKSIZE PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTICS ?
         BZ    AODNOMES            NO, BRANCH
         USING DIERAMA,R9          SET UP BASE REG FOR MESSAGE MOD
         ST    R9,OASAVEJ          SAVE R9
         STM   R14,R1,AODSAVO      SAVE REGISTER
         L     R9,PPIAMA+4         SET MSG BASE REG
         L     R0,PPISPGN1         LOAD ADDR TO BE CONVERTED
         L     R15,PPICONV+4       LOAD ADDR OF CONVERSION ROUTINE
         BAS   R14,4(,R15)         CALL CONVERSION RTN
         MVC   IER904B,2(R1)       MOVE FORMATTED ADDR INTO MSG
         L     R9,OASAVEJ          RESTORE R9
         LM    R14,R1,AODSAVO      RESTORE REGISTERS
         DROP  R9
AODNOMES L     R6,PPISPGN1         ADDR OF GENERATED CODE
         SR    R6,R5               DECREMENT ADDR OF GENERATED CODE
         SRL   R6,2                ROUND DOWN TO
         SLL   R6,2                FULL WORDS
         ST    R6,PPISPGN1         RESET NEW ADDR OF GENERATED CODE
         ST    R6,WCTREE           STORE THIS TREE ADDR IN NETWORK
         PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTICS ?
         BZ    OANOMESS            NO, BRANCH
         USING DIERAMA,R9          SET UP BASE REG FOR MESSAGE MOD
         ST    R9,OASAVEJ          SAVE R9
         STM   R14,R1,AODSAVO      SAVE REGISTERS
         L     R9,PPIAMA+4         SET MSG BASE REG
         L     R0,PPISPGN1         LOAD ADDR TO BE CONVERTED
         L     R15,PPICONV+4       LOAD ADDR OF CONVERSION ROUTINE
         BAS   R14,4(,R15)         CALL CONVERSION RTN
         MVC   IER904A,2(R1)       MOVE FORMATTED ADDR INTO MSG
         LM    R0,R1,IER904        IER904I TREE ADDR FROM
         L     R15,PPIADSSC        LOAD ADDR OF PRINT ROUTINE
         BAS   R14,12(,R15)        CALL PRINT MESSAGE RTN
         L     R9,OASAVEJ          RESTORE R9
         LM    R14,R1,AODSAVO      RESTORE REGISTERS
         DROP  R9
*
*        SET UP ANY ADDITIONAL CONSTANTS REQUIRED TO GENERATE
*        TREE
*
OANOMESS LR    R9,R6               NEXT LEVEL ADDR FOR PREVIOUS LEVEL
         LA    R7,2                WAY OR NODE COUNTER
         LA    R4,WCLTNODE         ADDR OF LAST TEST NODE
         SR    R5,R5               SET FORMAT OF THIS NODE TO ZERO
*
*        GENERATE THE REQUIRED TREE
*
OCSTTREE STM   R4,R5,0(R6)         STORE NLA AND FORMAT OF NODE
         LA    R10,1(,R10)         INC RECORD COUNTER BY 1 EACH NODE
         CR    R10,R8              RECORDS TREE HOLDS NOW TO REQD NO
         BNL   OCENOUGH            NO MORE NODES REQUIRED
         LA    R6,12(,R6)          INCREMENT TO LOCATION OF NEXT NODE
         LR    R4,R9               SET NEXT LEVEL ADDR
         BCT   R7,OCSTTREE         BRANCH IF NODE COUNTER ¬ 0
         LA    R7,2                RESET NODE OR WAY COUNTER
         LA    R9,12(,R9)          INCREMENT NEXT LEVEL ADDR
         B     OCSTTREE
*
*        SAVE TREE INFORMATION FOR THE NETWORK
*
OCENOUGH STM   R7,R9,WCSAVE        SAVE FILLING REGISTERS
*
*        IF COLLATING ORDER OF FIRST SEQUENCE IS TO BE DECENDING
*        REVERSE THE NECESSARY CONDITIONAL BRANCHES IN THE
*        RUNNING ROUTINE
*
         PPITEST  PPIPH1CO         COLLATING ORDER DESCENDING ?
         BZ    OCASCEND            NO, BRANCH
         XI    OCCASE24+7,X'60'    REVERSE CONDITIONAL BRANCH IN NETWOR
         XI    OCNOTON2+27,X'60'   REVERSE CONDITIONAL BRANCH IN SEQCK
*
*        INITIALIZE THE DISPLACEMENT FIELDS IN THE COMPARE
*        INSTRUCTIONS IN THE RUNNING ROUTINE AS NECESSARY
*
OCASCEND OC    OCCASE24+2(4),WOCDISP  INITIALIZE DISP IN CLC IN NETWORK
         OC    OCNOTON2+22(4),WOCDISP INITIALIZE DISP IN CLC IN SEQCK
*
*        INITIALIZE THE LENGTH FIELDS IN THE COMPARE INSTRUCTIONS
*        IN THE RUNNING ROUTINE AS NECESSARY
*
         L     R4,WOCLGTH          LENGTH OF 1ST CONTROL FIELD FOR CLC
         STC   R4,OCCASE24+1       SET LENGTH FIELD IN CLC IN NETWORK
         STC   R4,OCNOTON2+21      SET LENGTH FIELD IN CLC IN SEQCK
*
*        EXIT TO NEXT ASSIGNMENT ROUTINE
*
         L     R14,WRSAVC9         RESTORE RETURN ADDR
         BR    R14                 RETURN TO LOAD ROUTINE
*
*        WORK AREAS
*
WOCDISP  DC    F'0'                HOLD DISP FIELDS FOR ORING
WOCLGTH  DC    F'0'                HOLD LENGTH FIELD FOR INIT
WRSAVC9  DC    F'0'                SAVE R14
OASAVEJ  DC    F'0'
AODSAVO  DC    4F'0'
*
*        IERROD
*
DIERROD  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERROD SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRODI
*
*        IERAMA
*
DIERAMA  DSECT
*
         COPY  AMAMAIN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERAOE   0101-20211-20211-1200-00249-00249-00000-RELEASE 00
AOE      TITLE 'IERAOE - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERAOE
*
*        MODULE FUNCTION -
*        PHASE ONE ASSIGNMENT FOR FIXED LENGTH POLYPHASE
*        REPLACEMENT WITH MULTIPLE CONTROL FIELDS
*        THE FUNCTION FO THIS MODULE IS TO GENERATE THE
*        REPLACEMENT TREE IN GENERATED CORE, CHANGE THE
*        CONDITIONS FOR BRANCHING IN THE RUNNING PROGRAM IF THE
*        RECORDS ARE TO BE COLLATED IN DESCENDING ORDER IN THE
*        FIRST SEQUENCE AND OTHERWISE INITIALIZE THE COMPARE
*        INSTRUCTIONS IN THE RUNNING PROGRAM
*
*        USED AS A DSECT IN - N/A
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                       CALLING SEQUENCE -
*                           LOAD  EP=IERAOE,DCB=
*                           LR    R15,R0
*                           BALR  R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIDDOL1   PPICNTL
*        PPIAXERT   PPISPGN1
*        PPISRTG    PPINET+4
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPISPGN1
*        REPLACEMENT TREE IS CREATED IN GENERATED CORE
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL -
*        BR R14 - RETURN TO IERRC9
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS -
*        WOADISP - FULL WORD TO HOLD DISPLACEMENT FIELD FOR
*                  ORING THE DISPLACEMENT FIELDS IN THE COMPARE
*                  INSTRUCTIONS IN IERROE IN ORDER INITIALIZE
*                  THEM AS NECESSARY
*        WRSAVC9 - FULL WORD TO HOLD THE ADDR OF THE CALLING
*                  ROUTINE IERRC9
*
*        NOTES -
*        THIS MODULE USED WITH FIXED LENGTH RECORDS WITH
*        MULTIPLE CONTROL FIELDS IN THE POLYPHASE SORT
*
IERAOE   CSECT
*
         USING *,R11
         USING IERRCA,R13
         USING DIERROE,R14
*
IERMOA   LR    R11,R15             SET PROGRAM BASE REGISTER
         ST    R14,WRSAVC9
         L     R14,PPINET+4        SET DSECT REGISTER OF IERROE
*
*        DETERMINE SIZE OF AREA FOR GENERATING THE TREE
*        RESET THE ADDR OF THE GENERATED AREA BY THIS AMOUNT
*        SAVE THIS ADDR FOR THE NETWORK AS THE TREE ADDR AND FOR
*        THE NEXT ROUTINE AS THE ADDR OF THE GENERATED AREA
*
         L     R8,PPISRTG          G OR NUMBER OF RECORDS FOR TREE
         LA    R3,3                NUMBER OF RECORDS ADDED PER NODE
         LA    R2,20               BYTES PER NODE
         LA    R10,1               RECORD COUNTER-RECORDS TREE CAN HOLD
         LR    R5,R8               G OR NUMBER OF RECORDS FOR TREE
         SR    R5,R10              FORM G-1
         SR    R4,R4               ZERO REG
         DR    R4,R3               FORM (G-1)/3
         LTR   R4,R4               REMAINDER ?
         BE    OASKIP              ROUND TO FULL NO OF NODES IF ¬ 0
         AR    R5,R10              ROUND TO FULL NUMBER OF NODES
OASKIP   MR    R4,R2               CALCULATE NUMBER OF BYTES IN TREE
OAOKSIZE PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTICS ?
         BZ    AOENOMES            NO, BRANCH
         USING DIERAMA,R9          SET UP BASE REG FOR MESSAGE MOD
         STM   R14,R1,AOESAVO      SAVE REGISTERS
         ST    R9,OASAVEJ          SAVE R9
         L     R9,PPIAMA+4         SET MSG BASE REG
         L     R0,PPISPGN1         LOAD NUMBER TO BE CONVERTED
         L     R15,PPICONV+4       LOAD ADDR OF CONVERSION ROUTINE
         BAS   R14,4(,R15)
         MVC   IER904B,2(R1)       MOVE FORMATTED ADDR INTO MSG
         L     R9,OASAVEJ          RESTORE R9
         LM    R14,R1,AOESAVO      RESTORE REGISTERS
         DROP  R9
AOENOMES L     R6,PPISPGN1         ADDR OF GENERATED CODE
         SR    R6,R5               DECREMENT ADDR OF GENERATED CODE
         SRL   R6,2                ROUND DOWN TO
         SLL   R6,2                FULL WORDS
         ST    R6,PPISPGN1         RESET NEW ADDR OF GENERATED CODE
         ST    R6,WATREEAD         STORE THIS TREE ADDR IN NETWORK
         PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTICS ?
         BZ    OANOMESS            NO, BRANCH
         USING DIERAMA,R9          SET UP BASE REG FOR MESSAGE MOD
         ST    R9,OASAVEJ          SAVE R9
         STM   R14,R1,AOESAVO      SAVE REGISTERS
         L     R9,PPIAMA+4         SET MSG BASE REG
         L     R0,PPISPGN1         LOAD NUMBER TO BE CONVERTED
         L     R15,PPICONV+4       LOAD ADDR OF CONVERSION ROUTINE
         BAS   R14,4(,R15)         CALL CONVERSION RTN
         MVC   IER904A,2(R1)       MOVE FORMATTED ADDR INTO MSG
         LM    R0,R1,IER904        IER904I TREE ADDR FROM
         L     R15,PPIADSSC        LOAD ADDR OF PRINT ROUTINE
         BAS   R14,12(,R15)        CALL PRINT MESSAGE RTN
         L     R9,OASAVEJ          RESTORE R9
         LM    R14,R1,AOESAVO      RESTORE REGISTERS
         DROP  R9
*
*        SET BASE REGISTER FOR EQUALS ROUTINE
*
OANOMESS L     R12,PPIAXERT        SET BASE REGISTER OF EQUALS ROUTINE
*
*        SET UP ANY ADDITIONAL CONSTANTS REQUIRED TO GENERATE TREE
*
         LR    R9,R6               NEXT LEVEL ADDR FOR PREVIOUS LEVEL
         LA    R7,4                WAY OR NODE COUNTER
         LA    R4,WALTNODE         ADDR OF LAST TEST NODE
         SR    R5,R5               SET FORMAT OF THIS NODE TO ZERO
*
*        GENERATE THE REQUIRED TREE
*
OASTTREE STM   R4,R5,0(R6)         STORE NLA AND FORMAT OF NODE
         AR    R10,R3              INC RECORD COUNTER BY 3 EACH NODE
         CR    R10,R8              RECORDS TREE HOLDS NOW TO REQD NO
         BNL   OAENOUGH            NO MORE NODES REQUIRED
         AR    R6,R2               INCREMENT TO LOCATION OF NEXT NODE
         LR    R4,R9               SET NEXT LEVEL ADDR
         BCT   R7,OASTTREE         BRANCH IF NODE COUNTER ¬ 0
         LA    R7,4                RESET NODE OR WAY COUNTER
         AR    R9,R2               INCREMENT NEXT LEVEL ADDR
         B     OASTTREE
*
*        SAVE TREE INFORMATION FOR THE NETWORK
*
OAENOUGH STM   R7,R9,WASAVE        SAVE FILLING REGISTERS
*
*        IF COLLATING ORDER OF FIRST SEQUENCE IS TO BE DECENDING
*        REVERSE THE NECESSARY CONDITIONAL BRANCHES IN THE
*        RUNNING ROUTINE
*
         PPITEST  PPIPH1CO         COLLATING ORDER DESCENDING ?
         BZ    OAASCEND            NO, BRANCH
         XI    OAC44A+1,X'60'      REVERSE CONDITIONAL BRANCH IN NETWOR
         XI    OAC44B+1,X'60'       SAME
         XI    OAC38B+1,X'60'       SAME
         XI    OAC34A+1,X'60'       SAME
         XI    OAC30A+1,X'60'       SAME
         XI    OAC30B+1,X'60'       SAME
         XI    OAC28A+1,X'60'       SAME
         XI    OAC27A+1,X'60'       SAME
         XI    OAC27C+1,X'60'       SAME
         XI    OAC22A+1,X'60'       SAME
         XI    OAC18A+1,X'60'       SAME
         XI    OAC16A+1,X'60'       SAME
         XI    OAC15A+1,X'60'       SAME
         XI    OAC10A+1,X'60'       SAME
         XI    OASCHECK+1,X'60'     REVERSE CONDITIONAL BRANCH IN SEQCK
*
*        INITIALIZE THE DISPLACEMENT FIELDS IN THE COMPARE
*        INSTRUCTIONS IN THE RUNNING ROUTINE AS NECESSARY
*
OAASCEND LH    R4,PPIDD0L1         DISPLACEMENT OF FIRST CONTROL FIELD
         LA    R4,4(,R4)           INCREMENT DISPLACEMENT FOR TREE ADDR
         STH   R4,WOADISP          SET UP DISPLACEMENT
         STH   R4,WOADISP+2        FIELDS FOR ORING
         OC    OACASE44+6(4),WOADISP    INIT DISP IN CLC IN NETWK
         OC    OAC44A+6(4),WOADISP      SAME
         OC    OAC38A+2(4),WOADISP      SAME
         OC    OACASE34+14(4),WOADISP   SAME
         OC    OACASE30+10(4),WOADISP   SAME
         OC    OAC30A+6(4),WOADISP      SAME
         OC    OACASE28+2(4),WOADISP    SAME
         OC    OACASE27+14(4),WOADISP   SAME
         OC    OAC27B+2(4),WOADISP      SAME
         OC    OACASE22+14(4),WOADISP   SAME
         OC    OACASE18+10(4),WOADISP   SAME
         OC    OACASE16+2(4),WOADISP    SAME
         OC    OACASE15+14(4),WOADISP   SAME
         OC    OAC10SS+2(4),WOADISP     SAME
         OC    OARETRUN+18(4),WOADISP   INITIALIZE DISP IN CLC IN SEQCK
*
*        INITIALIZE THE LENGTH FIELDS IN THE COMPARE INSTRUCTIONS
*        IN THE RUNNING ROUTINE AS NECESSARY
*
         IC    R4,PPIDD0L1+3       LENGTH OF 1ST CONTROL FIELD FOR CLC
         STC   R4,OACASE44+5       SET LENGTH FIELD IN CLC IN NETWORK
         STC   R4,OAC44A+5          SAME
         STC   R4,OAC38A+1          SAME
         STC   R4,OACASE34+13       SAME
         STC   R4,OACASE30+9        SAME
         STC   R4,OAC30A+5          SAME
         STC   R4,OACASE28+1        SAME
         STC   R4,OACASE27+13       SAME
         STC   R4,OAC27B+1          SAME
         STC   R4,OACASE22+13       SAME
         STC   R4,OACASE18+9        SAME
         STC   R4,OACASE16+1        SAME
         STC   R4,OACASE15+13       SAME
         STC   R4,OAC10SS+1         SAME
         STC   R4,OARETRUN+17      SET LENGTH FIELD IN CLC IN SEQCK
*
*        EXIT TO NEXT ASSIGNMENT ROUTINE
*
         L     R14,WRSAVC9         RESTORE RETURN ADDR
         BR    R14                 RETURN TO LOAD ROUTINE
*
*        WORK AREAS
*
WOADISP  DC    F'0'                HOLD DISP FIELD FOR ORING
WRSAVC9  DC    F'0'                SAVE REGISTER R14
OASAVEJ  DC    F'0'
AOESAVO  DC    4F'0'
*
*        IERROE
*
DIERROE  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERROE SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERROEI
*
*        IERAMA
*
DIERAMA  DSECT
*
         COPY  AMAMAIN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERAOF   0101-20211-20211-1200-00295-00295-00000-RELEASE 00
AOF      TITLE 'IERAOF - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERAOF
*
*        MODULE FUNCTION -
*        PHASE ONE ASSIGNMENT FOR FIXED LENGTH POLYPHASE
*        REPLACEMENT WITH SINGLE CONTROL FIELD THE FUNCTION OF
*        THIS MODULE IS TO SET UP THE APPROPRIATE LENGTH FIELDS,
*        DISPLACEMENT FIELDS, AND CONSTANTS, DEPENDING ON WHETHER
*        THE EXTRACT ROUTINE WILL BE USED OR NOT, GENERATE THE
*        REPLACEMENT TREE IN GENERATED CORE, CHANGE THE
*        CONDITIONS FOR BRANCHING IN THE RUNNING PROGRAM IF THE
*        RECORDS ARE TO BE COLLATED IN DESCENDING ORDER IN THE
*        FIRST SEQUENCE ELSE INITIALIZE THE COMPARE INSTRUCTIONS
*        IN THE IERROF PROGRAM
*
*        USED AS A DSECT IN - N/A
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                       CALLING SEQUENCE -
*                           LOAD  EP=IERAOF,DCB=
*                           LR    R15,R0
*                           BALR  R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPISRTG    PPILEXFF
*        PPIAXERT   PPIX61+4
*        PPIDDOL1   PPICNTL
*        PPISPGN1   PPINET+4
*        PPILEXFD
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPISPGN1
*        REPLACEMENT TREE IS CREATED IN GENERATED CORE
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL -
*        BR R14 - RETURN TO LOAD ROUTINE IERRC9
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS -
*        WOADISP - FULL WORD USED TO HOLD DISPLACEMENT FIELD FOR
*                  ORING THE DISPLACEMENT FIELDS IN THE COMPARE
*                  INSTRUCTIONS IN IERROF IN ORDER TO INITIALIZE
*                  THEN AS NECESSARY
*        WOALGTH - FULL WORD S USED TO HOLD LENGTH FIELD FOR
*                  COMPARE INSTRUCTIONS
*        WRSAVC9 - FULL WORD USED TO HOLD THE ADDRESS OF THE
*                  CALLING ROUTINE IERRC9
*
*        NOTES -
*        THIS MODULE IS USED WITH FIXED LENGTH RECORDS WITH
*        SINGLE CONTROL FIELD FOR A POLYPHASE SORT
*
IERAOF   CSECT
*
         USING *,R11
         USING IERRCA,R13
         USING DIERROF,R14
*
IERMOA   LR    R11,R15             SET PROGRAM BASE REGISTER
         ST    R14,WRSAVC9
         L     R14,PPINET+4        SET DSECT REGISTER OF RUNNING PROG
*
*        DETERMINE IF EXTRACTING AND SET SWITCH IN NETWORK
*        ACCORDINGLY
*
         PPITEST  PPIEXTRT         EXTRACTING ?
         BZ    OANOEXT             NO, BRANCH
         LA    R6,255              CONSTANT X'FF'
         STH   R6,KASWITCH+2       SET EXT SWITCH ON IN RUNNING MODULE
*
*        SET BASE REGISTER FOR EXTRACT ROUTINE
*
         L     R12,PPIAXERT        SET BASE REGISTER OF EXTRACT ROUTINE
*
*        DETERMINE IF MODIFICATION EXIT E61 IS ACTIVE AND STORE
*        ITS ADDRESS IN EXTRACT ROUTINE IF NECESSARY.
*
         PPITEST  PPIME61          MODIFICATION E61 REQUESTED ?
         BZ    OANOUSER            NO, BRANCH
         L     R6,PPIX61+4         ADDR OF USER MODIFICATION
         ST    R6,0(,R12)          ADDR OF USER MODIFICATION IN EXTRACT
*
*        SET UP LENGTH FIELDS, DISPLACEMENT FIELDS, AND CONSTANTS
*        AS REQUIRED IF EXTRACTING
*
OANOUSER LH    R6,PPILEXFF         LEN OF EXTRACTED FIELD ROUNDED FULL
         LA    R6,4(,R6)           INCREMENT BY 4 FOR TREE ADDR
         ST    R6,KAINCDEC         STORE IN NETWORK AS INC OR DEC
         LA    R6,4                CONSTANT OF 4 FOR DISPLACEMENT
         STH   R6,WOADISP          SET UP DISPLACEMENT
         STH   R6,WOADISP+2        FIELDS FOR ORING
         LH    R6,PPILEXFD         LEN OF EXTRACTED FIELD FOR COMPARES
         ST    R6,WOALGTH          LENGTH FIELD FOR COMPARE INSTS
         B     OAGOGO
*
*        SET UP LENGTH FIELDS, DISPLACEMENT FIELDS, AND CONSTANTS
*        AS REQUIRED IF NOT EXTRACTING
*
OANOEXT  LH    R4,PPIDD0L1         DISPLACEMENT OF FIRST CONTROL FIELD
         LA    R4,4(,R4)           INCREMENT DISPLACEMENT FOR TREE ADDR
         STH   R4,WOADISP          SET UP DISPLACEMENT
         STH   R4,WOADISP+2        FIELDS FOR ORING
         LA    R4,4                CONSTANT OF 4
         ST    R4,KAINCDEC         STORE IN NETWORK AS INC OR DEC
         SR    R4,R4               ZERO REG
         IC    R4,PPIDD0L1+3       LENGTH OF 1ST CONTROL FIELD FOR CLC
         ST    R4,WOALGTH          LENGTH FIELD FOR COMPARE INSTS
*
*        DETERMINE SIZE OF AREA FOR GENERATING THE TREE, RESET
*        THE ADDR OF THE GENERATED AREA BY THIS AMOUNT, AND SAVE
*        THIS ADDR FOR THE NETWORK AS THE TREE ADDR AND FOR THE
*        NEXT ROUTINE AS THE ADDR OF THE GENERATED AREA
*
OAGOGO   L     R8,PPISRTG          G OR NUMBER OF RECORDS FOR TREE
         LA    R3,3                NUMBER OF RECORDS ADDED PER NODE
         LA    R2,20               BYTES PER NODE
         LA    R10,1               RECORD COUNTER-RECORDS TREE CAN HOLD
         LR    R5,R8               G OR NUMBER OF RECORDS FOR TREE
         SR    R5,R10              FORM G-1
         SR    R4,R4               ZERO REG
         DR    R4,R3               FORM (G-1)/3
         LTR   R4,R4               REMAINDER ?
         BZ    OASKIP              ROUND TO FULL NO OF NODES IF ¬ 0
         AR    R5,R10              ROUND TO FULL NUMBER OF NODES
OASKIP   MR    R4,R2               CALCULATE NUMBER OF BYTES IN TREE
OAOKSIZE PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTICS ?
         BZ    AOFNOMES            NO, BRANCH
         USING DIERAMA,R9          SET UP BASE REG FOR MESSAGE MOD
         STM   R14,R1,WRSAVC10
         L     R14,WRSAVC9
         ST    R9,OASAVEJ          SAVE R9
         L     R9,PPIAMA+4         SET MSG BASE REG
         L     R0,PPISPGN1         LOAD NUMBER TO BE CONVERTED
         L     R15,PPICONV+4       LOAD ADDR OF CONVERSION ROUTINE
         BAS   R14,4(,R15)         CALL CONVERSION RTN
         MVC   IER904B,2(R1)       MOVE FORMATTED ADDR INTO MSG
         LM    R14,R1,WRSAVC10     RESTORE REGISTERS
         L     R9,OASAVEJ          RESTORE R9
         DROP  R9
AOFNOMES L     R6,PPISPGN1         ADDR OF GENERATED CORE
         SR    R6,R5               DECREMENT ADDR OF GENERATED CODE
         SRL   R6,2                ROUND DOWN TO
         SLL   R6,2                FULL WORDS
         ST    R6,PPISPGN1         RESET NEW ADDR OF GENERATED CODE
         ST    R6,WATREEAD         STORE THIS TREE ADDR IN NETWORK
         PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTICS ?
         BZ    OANOMESS            NO, BRANCH
         USING DIERAMA,R9          SET UP BASE REG FOR MESSAGE MOD
         ST    R9,OASAVEJ          SAVE R9
         STM   R14,R1,WRSAVC10     SAVE REGISTERS
         L     R9,PPIAMA+4         SET MSG BASE REG
         L     R0,PPISPGN1         LOAD NUMBER TO BE CONVERTED
         L     R15,PPICONV+4       LOAD ADDR OF CONVERSION ROUTINE
         BAS   R14,4(R15)          CALL CONVERSION RTN
         MVC   IER904A(8),2(R1)    MOVE FORMATTED ADDR INTO MSG
         LM    R0,R1,IER904        IER904I TREE ADDR FROM
         L     R15,PPIADSSC        LOAD ADDR OF MSG WRITER
         BAS   R14,12(,R15)        CALL MSG WRITER
         L     R9,OASAVEJ          RESTORE R9
         LM    R14,R1,WRSAVC10
         DROP  R9
*
*        SET UP ANY ADDITIONAL CONSTANTS REQUIRED TO GENERATE TREE
*
OANOMESS LR    R9,R6               NEXT LEVEL ADDR FOR PREVIOUS LEVEL
         LA    R7,4                WAY OR NODE COUNTER
         LA    R4,WALTNODE         ADDR OF LAST TEST NODE
         SR    R5,R5               SET FORMAT OF THIS NODE TO ZERO
*
*        GENERATE THE REQUIRED TREE
*
OASTTREE STM   R4,R5,0(R6)         STORE NLA AND FORMAT OF NODE
         AR    R10,R3              INC RECORD COUNTER BY 3 EACH NODE
         CR    R10,R8              RECORDS TREE HOLDS NOW TO REQD NO
         BNL   OAENOUGH            NO MORE NODES REQUIRED
         AR    R6,R2               INCREMENT TO LOCATION OF NEXT NODE
         LR    R4,R9               SET NEXT LEVEL ADDRESS
         BCT   R7,OASTTREE         BRANCH IF NODE COUNTER NOT ZERO
         LA    R7,4                RESET NODE OR WAY COUNTER
         AR    R9,R2               INCREMENT NEXT LEVEL ADDR
         B     OASTTREE
*
*        SAVE TREE INFORMATION FOR THE NETWORK
*
OAENOUGH STM   R7,R9,WASAVE        SAVE FILLING REGISTERS
*
*        IF COLLATING ORDER OF FIRST SEQUENCE IS TO BE DECENDING,
*        REVERSE THE NECESSARY CONDITIONAL BRANCHES IN THE
*        RUNNING ROUTINE
*
         PPITEST  PPIPH1CO         COLLATING ORDER DESCENDING ?
         BZ    OAASCEND            NO, BRANCH ITS ASCENDING
         XI    OACASE44+11,X'60'   REVERSE CONDITIONAL BRANCH IN NTWK
         XI    OACASE44+21,X'60'   SAME
         XI    OAC38A+7,X'60'      SAME
         XI    OACASE34+19,X'60'   SAME
         XI    OAC30A+1,X'60'      SAME
         XI    OAC30B+1,X'60'      SAME
         XI    OACASE28+7,X'60'    SAME
         XI    OACASE27+19,X'60'   SAME
         XI    OAC27A+7,X'60'      SAME
         XI    OACASE22+19,X'60'   SAME
         XI    OAC18A+1,X'60'      SAME
         XI    OACASE16+7,X'60'    SAME
         XI    OACASE15+19,X'60'   SAME
         XI    OAC10A+1,X'60'      SAME
         XI    OANOTON2+19,X'60'   REVERSE CONDITIONAL BRANCH IN SEQCK
*
*        INITIALIZE THE DISPLACEMENT FIELDS IN THE COMPARE
*        INSTRUCTIONS IN THE RUNNING ROUTINE AS NECESSARY
*
OAASCEND OC    OACASE44+6(4),WOADISP  INIT DISP IN CLC IN NETWK
         OC    OACASE44+16(4),WOADISP  SAME
         OC    OAC38A+2(4),WOADISP     SAME
         OC    OACASE34+14(4),WOADISP  SAME
         OC    OACASE30+10(4),WOADISP  SAME
         OC    OAC30A+6(4),WOADISP     SAME
         OC    OACASE28+2(4),WOADISP   SAME
         OC    OACASE27+14(4),WOADISP  SAME
         OC    OAC27A+2(4),WOADISP     SAME
         OC    OACASE22+14(4),WOADISP  SAME
         OC    OACASE18+10(4),WOADISP  SAME
         OC    OACASE16+2(4),WOADISP   SAME
         OC    OACASE15+14(4),WOADISP  SAME
         OC    OAC10SS+2(4),WOADISP    SAME
         OC    OANOTON2+14(4),WOADISP  INITIALIZE DISP IN CLC IN SEQCK
*
*        INITIALIZE THE LENGTH FIELDS IN THE COMPARE INSTRUCTIONS
*        IN THE RUNNING ROUTINE AS NECESSARY
*
         L     R4,WOALGTH          LENGTH OF CONTROL FIELD FOR COMPARES
         STC   R4,OACASE44+5       SET LENGTH FIELD IN CLC IN NETWORK
         STC   R4,OACASE44+15      SAME
         STC   R4,OAC38A+1         SAME
         STC   R4,OACASE34+13      SAME
         STC   R4,OACASE30+9       SAME
         STC   R4,OAC30A+5         SAME
         STC   R4,OACASE28+1       SAME
         STC   R4,OACASE27+13      SAME
         STC   R4,OAC27A+1         SAME
         STC   R4,OACASE22+13      SAME
         STC   R4,OACASE18+9       SAME
         STC   R4,OACASE16+1       SAME
         STC   R4,OACASE15+13      SAME
         STC   R4,OAC10SS+1        SAME
         STC   R4,OANOTON2+13      SET LENGTH FIELD IN CLC IN SEQCK
*
*        EXIT TO NEXT ASSIGNMENT ROUTINE
*
         L     R14,WRSAVC9         RESTORE RETURN ADDR
         BR    R14                 RETURN TO LOAD ROUTINE
*
*        WORK AREAS
*
WOADISP  DC    F'0'                HOLD DISP FIELD FOR ORING
WOALGTH  DC    F'0'                HOLD LENGTH FIELD FOR INIT
WRSAVC9  DC    F'0'                SAVE R14
OASAVEJ  DC    F'0'
WRSAVC10 DC    7F'0'
*
*        IERROF
*
DIERROF  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERROF SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERROFI
*
*        IERAMA
*
DIERAMA  DSECT
*
         COPY  AMAMAIN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERAOG   0101-20211-20211-1200-00215-00215-00000-RELEASE 00
AOG      TITLE 'IERAOG - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERAOG
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 1 ASSIGNMENT FOR VARIABLE LENGTH POLYPHASE
*        REPLACEMENT WITH MULTIPLE CONTROL FIELDS
*        THE FUNCTION OF THIS MODULE IS TO -
*        1. GENERATE THE REPLACEMENT TREE IN GENERATED CORE
*        2. CHANGE THE CONDITIONS FOR BRANCHING IN THE RUNNING
*           PROGRAM IF THE RECORDS ARE TO BE COLLATED IN DESCENDING
*           ORDER IN THE FIRST SEQUENCE
*        3. INITIALIZE THE COMPARE INSTRUCTIONS IN THE RUNNING
*           PROGRAM
*
*        USED AS A DSECT IN - N/A
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                       CALLING SEQUENCE -
*                           LOAD   EP=IERAOG,DCB=
*                           LR     R15,R0
*                           BALR   R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPISRTG    PPISPGN1
*        PPIAXERT   PPINET+4
*        PPICNTL    PPIDDOL1
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPISPGN1
*        REPLACEMENT TREE IS CREATED IN GENERATED CORE
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL -
*        BR R14 - RETURN TO LOAD ROUTINE IERRC9
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS -
*        WOCDISP - FULL WORD USED TO HOLD DISPLACEMENT FIELD FOR
*                  ORING THE DISPLACEMENT FIELDS IN THE COMPARE
*                  INSTRUCTIONS IN THE RUNNING PROGRAM IN ORDER
*                  TO INITIALIZE THEM AS MECESSARY
*        WRSAVC9 - FULL WORD USED TO HOLD THE ADDRESS OF THE
*                  CALLING ROUTINE IERRC9
*
*        NOTES -
*        THIS MODULE IS USED WITH VARIABLE LENGTH RECORDS WITH
*        MULTIPLE CONTROL FIELDS FOR A POLYPHASE SORT
*
IERAOG   CSECT
*
         USING *,R11
         USING IERRCA,R13
         USING DIERROG,R14
*
IERMOA   LR    R11,R15             SET PROGRAM BASE REGISTER
         ST    R14,WRSAVC9
         L     R14,PPINET+4        SET DSECT REGISTER OF IERROG
*
*        DETERMINE SIZE OF AREA FOR GENERATING THE TREE
*        RESET THE ADDR OF THE GENERATED AREA BY THIS AMOUNT
*        SAVE THIS ADDR FOR THE NETWORK AS THE TREE ADDR
*        AND FOR THE NEXT ROUTINE AS THE ADDR OF THE GENERATED
*        AREA
*
         L     R8,PPISRTG          G OR NUMBER OF RECORDS FOR TREE
         LA    R10,1               RECORD COUNTER-RECORDS TREE CAN HOLD
         LA    R2,12               BYTES PER NODE
         LR    R5,R8               G OR NUMBER OF RECORDS FOR TREE
         SR    R5,R10              FORM G-1
         SR    R4,R4               ZERO REG
         MR    R4,R2               CALCULATE NUMBER OF BYTES IN TREE
         LA    R9,36               SIZE OF MINIMUM TREE
         CR    R5,R9               CALCULATED SIZE >= G MINIMUM
         BNL   OCOKSIZE            YES, BRANCH
         LR    R5,R9               SET TREE SIZE TO MINIMUM
OCOKSIZE PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTICS ?
         BZ    AOGNOMES            NO, BRANCH
         USING DIERAMA,R9          SET UP BASE REG FOR MESSAGE MOD
         ST    R9,OASAVEJ          SAVE R9
         STM   R14,R1,AOGSAVO      SAVE REGISTERS
         L     R9,PPIAMA+4         SET MSG BASE REG
         L     R0,PPISPGN1         LOAD NUMBER TO BE CONVERTED
         L     R15,PPICONV+4       LOAD ADDR OF CONVERSION ROUTINE
         BAS   R14,4(,R15)         CALL CONVERSION RTN
         MVC   IER904B,2(R1)       MOVE FORMATTED ADDR INTO MESSAGE
         L     R9,OASAVEJ          RESTORE R9
         LM    R14,R1,AOGSAVO      RESTORE REGISTERS
         DROP  R9
AOGNOMES L     R6,PPISPGN1         ADDR OF GENERATED CODE
         SR    R6,R5               DECREMENT ADDR OF GENERATED CODE
         SRL   R6,2                ROUND DOWN TO
         SLL   R6,2                FULL WORDS
         ST    R6,PPISPGN1         RESET NEW ADDR OF GENERATED CODE
         ST    R6,WCTREE           STORE THIS TREE ADDR IN NETWORK
         PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTICS ?
         BZ    OANOMESS            NO, BRANCH
         USING DIERAMA,R9          SET UP BASE REG FOR MESSAGE MOD
         ST    R9,OASAVEJ          SAVE R9
         STM   R14,R1,AOGSAVO      SAVE REGISTERS
         L     R9,PPIAMA+4         SET MSG BASE REG
         L     R0,PPISPGN1         LOAD NUMBER TO BE CONVERTED
         L     R15,PPICONV+4       LOAD ADDR OF CONVERSION ROUTINE
         BAS   R14,4(,R15)         CALL CONVERSION RTN
         MVC   IER904A,2(R1)       MOVE FORMATTED ADDR INTO MSG
         LM    R0,R1,IER904        IER904I TREE ADDR FROM
         L     R15,PPIADSSC        LOAD ADDR OF PRINT ROUTINE
         BAS   R14,12(0,R15)       CALL PRINT MESSAGE RTN
         L     R9,OASAVEJ          RESTORE R9
         LM    R14,R1,AOGSAVO      RESTORE REGISTERS
         DROP  R9
*
*        SET BASE REGISTER FOR EQUALS ROUTINE
*
OANOMESS L     R12,PPIAXERT       SET BASE REGISTER OF EQUALS ROUTINE
*
*        SET UP ANY ADDITIONAL CONSTANTS REQUIRED TO GENERATE
*        TREE
*
         LR    R9,R6               NEXT LEVEL ADDR FOR PREVIOUS LEVEL
         LA    R7,2                WAY OR NODE COUNTER
         LA    R4,WCLTNODE         ADDR OF LAST TEST NODE
         SR    R5,R5               SET FORMAT OF THIS NODE TO ZERO
*
*        GENERATE THE REQUIRED TREE
*
OCSTTREE STM   R4,R5,0(R6)         STORE NLA AND FORMAT OF NODE
         LA    R10,1(,R10)         INC RECORD COUNTER BY 1 EACH NODE
         CR    R10,R8              RECORDS TREE HOLDS NOW TO REQD NO
         BNL   OCENOUGH            NO MORE NODES REQUIRED
         LA    R6,12(,R6)          INCREMENT TO LOCATION OF NEXT NODE
         LR    R4,R9               SET NEXT LEVEL ADDR
         BCT   R7,OCSTTREE         BRANCH IF NODE COUNTER ¬ 0
         LA    R7,2                RESET NODE OR WAY COUNTER
         LA    R9,12(,R9)          INCREMENT NEXT LEVEL ADDR
         B     OCSTTREE
*
*        SAVE TREE INFORMATION FOR THE NETWORK
*
OCENOUGH STM   R7,R9,WCSAVE        SAVE FILLING REGISTERS
*
*        IF COLLATING ORDER OF FIRST SEQUENCE IS TO BE DECENDING
*        REVERSE THE NECESSARY CONDITIONAL BRANCHES IN THE
*        RUNNING ROUTINE
*
         PPITEST  PPIPH1CO         COLLATING ORDER DESCENDING ?
         BZ    OCASCEND            NO, BRANCH
         XI    OCC24A+1,X'60'      REVERSE CONDITIONAL BRANCH IN NETWOR
         XI    OCC14A+1,X'60'      REVERSE CONDITIONAL BRANCH IN NETWOR
         XI    OCSCHECK+1,X'60'    REVERSE CONDITIONAL BRANCH IN SEQCK
*
*        INITIALIZE THE DISPLACEMENT FIELDS IN THE COMPARE
*        INSTRUCTIONS IN THE RUNNING ROUTINE AS NECESSARY
*
OCASCEND LH    R4,PPIDD0L1         DISPLACEMENT OF FIRST CONTROL FIELD
         LA    R4,4(,R4)           INCREMENT DISPLACEMENT FOR TREE ADDR
         STH   R4,WOCDISP          SET UP DISPLACEMENT
         STH   R4,WOCDISP+2        FIELDS FOR ORING
         OC    OCCASE24+2(4),WOCDISP   INITIAL DISP IN CLC IN NETWORK
         OC    OCCASE14+10(4),WOCDISP  INITIAL DISP IN CLC IN NETWORK
         OC    OCGOTRUN+26(4),WOCDISP  INITIAL DISP IN CLC IN SEQCK
*
*        INITIALIZE THE LENGTH FIELDS IN THE COMPARE INSTRUCTIONS
*        IN THE RUNNING ROUTINE AS NECESSARY
*
         IC    R4,PPIDD0L1+3       LENGTH OF 1ST CONTROL FIELD FOR CLC
         STC   R4,OCCASE24+1       SET LENGTH FIELD IN CLC IN NETWORK
         STC   R4,OCCASE14+9       SET LENGTH FIELD IN CLC IN NETWORK
         STC   R4,OCGOTRUN+25      SET LENGTH FIELD IN CLC IN SEQCK
*
*        EXIT TO NEXT ASSIGNMENT ROUTINE
*
         L     R14,WRSAVC9         RESTORE RETURN ADDR
         BR    R14                 RETURN TO LOAD ROUTINE
*
*        WORK AREAS
*
WOCDISP  DC    F'0'                HOLD DISP FIELDS FOR ORING
WRSAVC9  DC    F'0'                SAVE REGISTER R14
OASAVEJ  DC    F'0'
AOGSAVO  DC    4F'0'
*
*        IERROG
*
DIERROG  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERROG SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERROGI
*
*        IERAMA
*
DIERAMA  DSECT
*
         COPY  AMAMAIN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERAOH   0101-20211-20211-1200-00258-00258-00000-RELEASE 00
AOH      TITLE 'IERAOH - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERAOH
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 1 ASSIGNMENT FOR VARIABLE LENGTH POLYPHASE
*        REPLACEMENT WITH SINGLE CONTROL FIELD
*        THE FUNCTION OF THIS MODULE IS TO SET UP APPROPRIATE
*        LENGTH FIELDS, DISPLACEMENT FIELDS, AND CONSTANTS,
*        DEPENDING ON WHETHER THE EXTRACT ROUTINE WILL BE USED OR
*        NOT, GENERATE THE REPLACEMENT TREE IN GENERATED CORE,
*        CHANGE THE CONDITIONS FOR BRANCHING IN RUNNING PROGRAM
*        IF THE RECORDS ARE TO BE COLLATED IN DESCENDING ORDER IN
*        THE FIRST SEQUENCE, AND OTHERWISE INITIALIZE THE
*        COMPARE INSTRUCTIONS IN THE RUNNING PROGRAM
*
*        USED AS A DSECT IN - N/A
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                       CALLING SEQUENCE -
*                           LOAD  EP=IERAOH,DCB=
*                           LR    R15,R0
*                           BALR  R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPISRTG    PPILEXFF
*        PPIAXERT   PPIX61+4
*        PPIDDOL1   PPICNTL
*        PPISPGN1   PPINET+4
*        PPILEXFD
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPISPGN1
*        REPLACEMENT TREE IS CREATED IN GENERATED CORE
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL -
*        BR R14 - RETURN TO LOAD ROUTINE IERRC9
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS -
*        WOCDISP - FULL WORD USED TO HOLD DISPLACEMENT FIELD FOR
*                  ORING THE DISPLACEMENT FIELDS IN THE COMPARE
*                  INSTRUCTIONS IN THE RUNNING PROGRAM IN ORDER
*                  TO INITIALIZE THEM AS NECESSARY
*        WOCLGTH - FULL WORD USED TO HOLD LENGTH FIELD FOR
*                  COMPARE INSTRUCTIONS
*        WRSAVC9 - FULL WORD USED TO HOLD THE ADDRESS OF THE
*                  CALLING ROUTINE IERRC9
*
*        NOTES -
*        THIS MODULE IS USED WITH VARIABLE LENGTH RECORDS WITH A
*        SINGLE CONTROL FIELD FOR A POLYPHASE SORT
*
IERAOH   CSECT
*
         USING *,R11
         USING IERRCA,R13
         USING DIERROH,R14
*
IERMOA   LR    R11,R15             SET PROGRAM BASE REGISTER
         ST    R14,WRSAVC9
         L     R14,PPINET+4        SET DSECT REGISTER FOR IERROH
*
*        DETERMINE IF EXTRACTING AND SET SWITCH IN NETWORK
*        ACCORDINGLY
*
         PPITEST  PPIEXTRT         EXTRACTING ?
         BZ    OCNOEXT             NO, BRANCH
         LA    R6,255              CONSTANT X'FF'
         STH   R6,KCSWITCH+2       SET EXT SWITCH ON IN IERROH
*
*        SET BASE REGISTER FOR EXTRACT ROUTINE
*
         L     R12,PPIAXERT        SET BASE REGISTER OF EXTRACT ROUTINE
*
*        DETERMINE IF MODIFICATION EXIT 61 IS ACTIVE AND STORE
*        ITS ADDR IN EXTRACT ROUTINE IF NECESSARY
*
         PPITEST  PPIME61          USER EXIT E61 REQUESTED ?
         BZ    OCNOUSER            NO, BRANCH
         L     R6,PPIX61+4         ADDR OF USER MODIFICATION RTN
         ST    R6,0(,R12)          ADDR OF USER MODIFICATION IN EXTRACT
*
*        SET UP LENGTH FIELDS, DISPLACEMENT FIELD, AND CONSTANTS
*        AS REQUIRED IF EXTRACTING
*
OCNOUSER LH    R6,PPILEXFF         LEN OF EXTRACTED FIELD ROUNDED FULL
         LA    R6,4(,R6)           INCREMENT BY 4 FOR TREE ADDR
         ST    R6,KCINCDEC         STORE IN NETWORK AS INC OR DEC
         LA    R6,4                CONSTANT OF 4 FOR DISPLACEMENT
         STH   R6,WOCDISP          SET UP DISPLACEMENT
         STH   R6,WOCDISP+2        FIELDS FOR ORING
         LH    R6,PPILEXFD         LEN OF EXTRACTED FIELD FOR COMPARES
         ST    R6,WOCLGTH          LENGTH FIELD FOR COMPARE INSTS
         B     OCGOGO
*
*        SET UP LENGTH FIELDS, DISPLACEMENT FIELDS AND CONSTANTS
*        AS REQUIRED IF NOT EXTRACTING
*
OCNOEXT  LH    R4,PPIDD0L1         DISPLACEMENT OF FIRST CONTROL FIELD
         LA    R4,4(,R4)           INCREMENT DISPLACEMENT FOR TREE ADDR
         STH   R4,WOCDISP          SET UP DISPLACEMENT
         STH   R4,WOCDISP+2        FIELDS FOR ORING
         LA    R4,4                CONSTANT OF 4
         ST    R4,KCINCDEC         STORE LEN NETWORK AS INC OR DEC
         SR    R4,R4               ZERO REG
         IC    R4,PPIDD0L1+3       LENGTH OF 1ST CONTROL FIELD FOR CLC
         ST    R4,WOCLGTH          LENGTH FIELD FOR COMPARE INSTS
*
*        DETERMINE SIZE OF AREA FOR GENERATING THE TREE, RESET
*        THE ADDR OF THE GENERATED AREA BY THIS AMOUNT, AND SAVE
*        THIS ADDR FOR THE NETWORK AS THE TREE ADDR AND FOR THE
*        NEXT ROUTINE AS THE ADDR OF THE GENERATED AREA
*
OCGOGO   L     R8,PPISRTG          G OR NUMBER OF RECORDS FOR TREE
         LA    R10,1               RECORD COUNTER-RECORDS TREE CAN HOLD
         LA    R2,12               BYTES PER NODE
         LR    R5,R8               G OR NUMBER OF RECORDS FOR TREE
         SR    R5,R10              FORM G-1
         SR    R4,R4               ZERO REG
         MR    R4,R2               CALCULATE NUMBER OF BYTES IN TREE
         LA    R9,36               SIZE OF MINIMUM TREE
         CR    R5,R9               CALCULATED SIZE >= MINIMUM ?
         BNL   OCOKSIZE            YES, BRANCH
         LR    R5,R9               SET TREE SIZE TO MINIMUM
OCOKSIZE PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTICS ?
         BZ    AOHNOMES            NO, BRANCH
         USING DIERAMA,R9          SET UP BASE REG FOR MESSAGE MOD
         ST    R9,OASAVEJ          SAVE R9
         STM   R14,R1,AOHSAVO      SAVE REGISTERS
         L     R9,PPIAMA+4         SET MSG BASE REG
         L     R0,PPISPGN1         LOAD NUMBER TO BE CONVERTED
         L     R15,PPICONV+4       LOAD ADDR OF CONVERSION ROUTINE
         BAS   R14,4(,R15)         CALL CONVERSION RTN
         MVC   IER904B,2(R1)       MOVE FORMATTED ADDR INTO MSG
         L     R9,OASAVEJ          RESTORE R9
         LM    R14,R1,AOHSAVO      RESTORE REGISTERS
         DROP  R9
AOHNOMES L     R6,PPISPGN1         ADDR OF GENERATED CODE
         SR    R6,R5               DECREMENT ADDR OF GENERATED CODE
         SRL   R6,2                ROUND DOWN TO
         SLL   R6,2                FULL WORDS
         ST    R6,PPISPGN1         RESET NEW ADDR OF GENERATED CODE
         ST    R6,WCTREE           STORE THIS TREE ADDR IN NETWORK
         PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTICS ?
         BZ    OANOMESS            NO, BRANCH
         USING DIERAMA,R9          SET UP BASE REG FOR MESSAGE MOD
         STM   R14,R1,AOHSAVO      SAVE REGISTERS
         ST    R9,OASAVEJ          SAVE R9
         L     R9,PPIAMA+4         SET MSG BASE REG
         L     R0,PPISPGN1         LOAD NUMBER TO BE CONVERTED
         L     R15,PPICONV+4       LOAD ADDR OF CONVERSION ROUTINE
         BAS   R14,4(R15)          CALL CONVERSION RTN
         MVC   IER904A,2(R1)       MOVE FORMATTED ADDR INTO MSG
         LM    R0,R1,IER904        IER904I TREE ADDR FROM
         L     R15,PPIADSSC        LOAD ADDR OF PRINT ROUTINE
         BAS   R14,12(,R15)        CALL PRINT MESSAGE RTN
         L     R9,OASAVEJ          RESTORE R9
         LM    R14,R1,AOHSAVO      RESTORE REGISTERS
         DROP  R9
*
*        SET UP ANY ADDITIONAL CONSTANTS REQUIRED TO GENERATE
*        TREE
*
OANOMESS LR    R9,R6               NEXT LEVEL ADDR FOR PREVIOUS LEVEL
         LA    R7,2                WAY OR NODE COUNTER
         LA    R4,WCLTNODE         ADDR OF LAST TEST NODE
         SR    R5,R5               SET FORMAT OF THIS NODE TO ZERO
*
*        GENERATE THE REQUIRED TREE
*
OCSTTREE STM   R4,R5,0(R6)         STORE NLA AND FORMAT OF NODE
         LA    R10,1(,R10)         INC RECORD COUNTER BY 1 EACH NODE
         CR    R10,R8              RECORDS TREE HOLDS NOW TO REQD NO
         BNL   OCENOUGH            NO MORE NODES REQUIRED
         LA    R6,12(,R6)          INCREMENT TO LOCATION OF NEXT NODE
         LR    R4,R9               SET NEXT LEVEL ADDR
         BCT   R7,OCSTTREE         BRANCH IF NODE COUNTER ¬ 0
         LA    R7,2                RESET NODE OR WAY COUNTER
         LA    R9,12(,R9)          INCREMENT NEXT LEVEL ADDR
         B     OCSTTREE
*
*        SAVE TREE INFORMATION FOR THE NETWORK
*
OCENOUGH STM   R7,R9,WCSAVE        SAVE FILLING REGISTERS
*
*        IF COLLATING ORDER OF FIRST SEQUENCE IS TO BE DECENDING,
*        REVERSE THE NECESSARY CONDITIONAL BRANCHES IN THE
*        RUNNING ROUTINE
*
         PPITEST  PPIPH1CO         COLLATING ORDER DESCENDING ?
         BZ    OCASCEND            NO, BRANCH ITS ASCENDING
         XI    OCCASE24+7,X'60'    REVERSE CONDITIONAL BRANCH IN NETWOR
         XI    OCC14A+1,X'60'      REVERSE CONDITIONAL BRANCH IN NETWOR
         XI    OCNOTON2+27,X'60'   REVERSE CONDITIONAL BRANCH IN SEQCK
*
*        INITIALIZE THE DISPLACEMENT FIELDS IN THE COMPARE
*        INSTRUCTIONS IN THE RUNNING ROUTINE AS NECESSARY
*
OCASCEND OC    OCCASE24+2(4),WOCDISP   INITIAL DISP IN CLC IN NETWORK
         OC    OCCASE14+10(4),WOCDISP  INITIAL DISP IN CLC IN NETWORK
         OC    OCNOTON2+22(4),WOCDISP  INITIAL DISP IN CLC IN SEQCK
*
*        INITIALIZE THE LENGTH FIELDS IN THE COMPARE INSTRUCTIONS
*        IN THE RUNNING ROUTINE AS NECESSARY
*
         L     R4,WOCLGTH          LENGTH OF 1ST CONTROL FIELD FOR CLC
         STC   R4,OCCASE24+1       SET LENGTH FIELD IN CLC IN NETWORK
         STC   R4,OCCASE14+9       SET LENGTH FIELD IN CLC IN NETWORK
         STC   R4,OCNOTON2+21      SET LENGTH FIELD IN CLC IN SEQCK
*
*        EXIT TO NEXT ASSIGNMENT ROUTINE
*
         L     R14,WRSAVC9         RESTORE RETURN ADDR
         BR    R14                 RETURN TO LOAD ROUTINE
*
*        WORK AREAS
*
WOCDISP  DC    F'0'                HOLD DISP FIELDS FOR ORING
WOCLGTH  DC    F'0'                HOLD LENGTH FIELD FOR INIT
WRSAVC9  DC    F'0'                SAVE REGISTER R14
OASAVEJ  DC    F'0'
AOHSAVO  DC    4F'0'
*
*        IERROH
*
DIERROH  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERROH SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERROHI
*
*        IERAMA
*
DIERAMA  DSECT
*
         COPY  AMAMAIN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERAOI   0101-20211-20211-1200-00114-00114-00000-RELEASE 00
AOI      TITLE 'IERAOI - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERAOI
*
*        MODULE FUNCTION/OPERATION -
*        ASSIGNMENT ROUTINE FOR THE BALANCED TAPE SORT ALGORITHM
*        SETS APPROPRIATE PARAMETER LIMITS AND ALSO SETS
*        INDICATORS FOR THE OPEN ROUTINE
*
*        USED AS A DSECT IN - N/A
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM
*                       CALLING SEQUENCE -
*                            L     R15,IERMOI - ENTRY POINT
*                            B     R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIMRGMX   PPIMRGAL   PPITPTBL
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPIDEPHO   PPIDBSVA
*
*        EXTERNAL ROUTINES -
*        EXTRN IERROI - RUNNING PROG SORT ALGORITHM
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS NORMAL -
*        KIERAGAX V(IERMGA) - DCB GENERATION ROUTINE
*
*        EXITS - ERROR N/A
*
*        TABLES/WORK AREAS - N/A
*
IERAOI   CSECT
*
         USING *,R11               PROG BASE REG
         USING IERRCA,R13          PPI BASE REG
*
*        MODULE ENTRY POINT
*
IERMOI   LR    R11,R15
         ST    R14,RKSAVC9         SAVE R14
         L     R14,PPIALG+4        GET ALGO ADDR
         USING DIERROI,R14         RUNNING BAL SORT ALG
         MVC   IERROITL(2),PPIMRGMX  SET TAPE TABLE POINTER LIMIT
         MVC   IERROILT(2),PPIMRGMX  SET RESET PTR LMT CTR
         MVC   IERROLMT(2),PPIMRGAL  SET LMT FOR EXCEED SORT CAPACITY
         LA    R4,PPITPTBL+1
         ST    R4,IERROITP         SET TAPE POINTER TO FIRST UNIT
         MVC   PPIDEPHO+3(1),0(R4) SET DCB INCR FOR WRITE RTN
         LH    R4,PPIMRGAL         ALTERNATE MERGE ORDER
         LH    R5,PPIMRGMX         MAX MERGE ORDER
         AR    R4,R5
         STC   R4,PPIBDSVA         SAVE TOTAL NO ENTRIES IN TP TBL
*                                  THIS SUM USED BY BLK/DEBLK
*
*        SET THE ADDRESS OF THE TAPE TABLE POINTER LIMIT ADDRESS
*        IN QUESTION = PPITPTBL + 2(M-1)
*
         S     R5,KAOIONE
         SLA   R5,1
         LA    R4,PPITPTBL
         AR    R4,R5
         ST    R4,IERROILA
*
*        SET THE OPEN BITS ON OF THE FIRST M UNITS IN THE TAPE
*        TABLE
*
         LA    R4,PPITPTBL
         LH    R5,PPIMRGMX
AOISOB   OI    0(R4),X'40'
         LA    R4,2(,R4)
         BCT   R5,AOISOB
         L     R14,RKSAVC9         RESTORE R14
         BR    R14
*
RKSAVC9  DC    F'0'
         BR    R15
*
         DC    0F'0'
KAOIONE  DC    XL4'1'
*
         DROP  R11,R14
*
DIERROI  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERROI SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERROII
*
*        MODULE EXTERNAL REFERENCES
*
DIERRMA  DSECT
*
*        MODULE NAME - IERRMA
*
         COPY  RMAMAIN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERAOJ   0101-20211-20211-1200-00146-00146-00000-RELEASE 00
AOJ      TITLE 'IERAOJ - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERAOJ
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 1 ASSIGNMENT FOR THE POLYPHASE SORT ALGORITHM
*        THE FUNCTION OF THIS MODULE IS TO SET UP PARAMETERS IN
*        AND INITIALIZE PPI AND THE RUNNING PROGRAM
*
*        USED AS A DSECT IN - N/A
*
*        MACROS USED - SMPPI
*
*        ENTRY POINT - ENTRY FROM IERRC9
*                      CALLING SEQUENCE -
*                          LOAD  EP=IERAOJ,DCB=
*                          LR    R15,R0
*                          BALR  R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPITPTBL
*        PPIMRGMX
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPIDEPHO+3
*        PPITPTBL
*        PPIMRGMX
*        PPIMRGAL
*        PPIBDSVA
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS N/A
*
*        EXITS - NORMAL -
*        BR R14 - RETURN TO LOAD ROUTINE, IERRC9
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS - NONE
*
*        NOTES - NONE
*
IERAOJ   CSECT
*
         USING *,R11
         USING IERRCA,R13
         USING DIERROJ,R9
         USING DIERRMA,R10
*
IERMOI   LR    R11,R15             SET PROGRAM BASE REGISTER
         L     R9,PPIALG+4         SET DSECT REGISTER OF RUNNING MOD
         L     R10,PPIRMA+4        SET DSECT REGISTER OF MESSAGE MOD
*
*        SET THE MAXIMUM MERGE ORDER, THE TOTAL NO OF WORK UNITS,
*        AND ALTERNATE MERGE ORDER TO (ONE)
*
         LH    R4,PPIMRGMX         MERGE ORDER = M
         LR    R5,R4
         LA    R4,1(,R4)           INCR BY 1 FOR NO WORK UNITS
         STC   R4,PPIBDSVA         STORE FOR BLOCK/DEBLOCK
         LA    R7,1                CONSTANT OF 1
         STH   R7,PPIMRGAL         SET ALTERNATE MERGE ORDER TO (ONE)
*
*        SET OPEN BIT ON IN FIRST (M) UNITS IN TAPE TABLE
*
         LR    R6,R5               COUNTER OF (N-1) EQUALS (M)
         LA    R8,PPITPTBL         ADDR OF TAPE TABLE
OJSETON  OI    0(R8),X'40'         SET OPEN BIT ON IN FIRST UNIT ETC
         LA    R8,2(,R8)           INCREMENT ADDR TO NEXT UNIT
         BCT   R6,OJSETON          BRANCH IF MORE OPEN BITS TO BE SET
*
*        SET TOTAL NUMBER OF SEQUENCES TO DISTRIBUTED TO (M) IN
*        RUNNING ROUTINE
*
         ST    R5,WOJTOTAL         NUMBER OF SEQUENCES TO DISTRIBUTE
*
*        SET THE UPDATED AND ORIGINAL FIBONACCI COUNT TO (ONE) IN
*        THE RUNNING PROGRAM FOR THE FIRST M COUNTERS
*
         LR    R6,R5               COUNTER OF (N-1) EQUALS (M)
         LA    R8,PPITPTBL         ADDRESS OF TAPE TABLE
OJSETFIB STH   R7,68(,R8)          SET FIRST FUTURE FIB TO (ONE) ETC
         STH   R7,102(,R8)         SET FIRST ORIGINAL FIB TO (ONE) ETC
         LA    R8,2(,R8)           INCREMENT ADDR TO NEXT COUNTER
         BCT   R6,OJSETFIB         BRANCH IF MORE FIBS TO BE SET
*
*        SET A COUNT OF (N), (N-1), (N-2) IN THE RUNNING ROUTINE
*
         LR    R6,R5               COUNT OF (N-1)
         SR    R6,R7               CALCULATE (N-2)
         STH   R4,WOJCTN           COUNT OF (N) IN RUNNING ROUTINE
         STH   R5,WOJCTN1          COUNT OF (N-1) IN RUNNING ROUTINE
         STH   R6,WOJCTN2          COUNT OF (N-2) IN RUNNING ROUTINE
*
*        SET AN ALL ODD COUNT OF (N) AND A PERMUTE COUNT OF (N-1)
*        IN ALGORITHM
*
         STH   R4,WOJALODD         ALL ODD COUNT (N) IN ALGORITHM
         STH   R5,WOJPERM          PERMUTE COUNT (N-1) IN ALGORITHM
*
*        CALCULATE INCREMENT TO LAST UNIT IN TAPE TABLE AND STORE
*        AS A POINTER AND AN INCREMENT IN THE RUNNING ROUTINE
*
         SLL   R6,1                MULTIPLY (N-2) BY 2
         STH   R6,WOJPOINT         STORE AS A POINTER IN ALGORITHM
         STH   R6,WOJINCPT         STORE AS AN INCREMENT IN ALGORITHM
*
*        SET THE OUTPUT UNIT INDICATION IN PPIA FOR WRITE ROUTINE
*
         IC    R4,PPITPTBL+1(R6)   OUTPUT UNIT DESIGNATOR
         STC   R4,PPIDEPHO+3       SET OUTPUT UNIT DESIGNATOR FOR WRITE
*
*        EXIT TO NEXT ASSIGNMENT ROUTINE
*
         BR    R14                  RETURN TO LOAD ROUTINE
*
*        IERROJ - POLYPHASE SORT ALGORITHM
*
*
DIERROJ  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERROJ SOURCE
*
*----------------------------------------------------------------------
*
         COPY IERROJI
*
*        IERRMA - MESSAGE MODULE
*
*
DIERRMA  DSECT
*
         COPY  RMAMAIN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERAOK   0101-20211-20211-1200-00153-00153-00000-RELEASE 00
AOK      TITLE 'IERAOK - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERAOK
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 1 ALGORITHM ASSIGNMENT FOR BALN DISK TECHNIQUE
*        THIS MODULE INITIALIZES AN INTERNAL CONTROL TABLE
*        CONSISTING OF -
*        1. DISK ADDR TO START WRITING STRINGS FOR EACH AREA
*        2. DISK AREA TO START WRITING DIRECTORY FOR EACH AREA
*        3. DETERMINE BLOCKING FACTOR FOR DIRECTORY
*
*        USED AS A DSECT IN - N/A
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                       CALLING SEQUENCE -
*                       L    R15,0
*                       BALR R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIADSSC   PPISEQCT    PPIBDSVA   PPISTAR
*        PPIENDAR   PPINDSKAR   PPIPDWA
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPIDEPHO   PPIDIRAD   PPIDSKED   PPIMRGMX
*        PPIMRGOP
*
*        EXTERNAL ROUTINES - IERRMA
*
*        EXITS - NORMAL - IERRC9
*
*        EXITS - ERROR - NONE
*
*        TABLES/WORK AREAS -
*        PPI
*        INTERNAL CONTROL TABLE TO DETERMINE WHERE TO WRITE -
*          1.  STRINGS
*          2.  DIRECTORY NOTES -
*        ALL INITIALIZATION TAKES PLACE BETWEEN IERAOK, PPI
*        AND DSECT OF IERROK
*
IERAOK   CSECT
*
         USING *,R11
         USING DIERROK,R9
         USING IERRCA,R13
         USING DIERRMA,R14
*
IERMOI   LR    R11,R15
         L     R9,PPIALG+4         R9 -> IERROK
*
*        MOVE SORTWORK START ADDRS TO TABLE IN IERROK
*
AOKASSMT LH    R8,PPINDSKA         R8 = NO DISK AREAS
         BCTR  R8,0                DECR BY 1
         LA    R4,TABLE+4          R4 -> FIRST SLOT IN TABLE TO FILL
         LA    R5,PPISTAR          R5 -> FIRST PPISTAR DEFINITION
AOKLOOPA MVC   0(8,R4),0(R5)       MOVE PPISTAR M0000TTR TO TABLE
         LA    R4,20(,R4)          INCR TO NEXT TABLE ENTRY
         LA    R5,8(,R5)           INCR TO NEXT PPISTAR ENTRY
         BCT   R8,AOKLOOPA         TABLE FULL ? NO, LOOP
*
*        STORE FIRST SEQUENCE AREA ADDR TO WRITE IN PPI
*
         MVC   PPIDEPHO,PPISTAR    MOVE ADDR OF WHERE TO WRITE FIRST
*                                  SEQ INTO PPI IE TTR = M000001
*
*        LOAD TABLE WITH STARTING ADDR FOR DICTIONARY WRITES
*        FROM ENDING ADDR IN PPI
*
         LH    R8,PPINDSKA         R8 = NO DISK AREAS
         BCTR  R8,0                DECR BY 1
         LA    R4,TABLE+12         R4 -> FIRST SLOT IN DIRECTORY
         LA    R5,PPIENDAR         R5 -> FIRST END ADDR IN PPI
AOKLOOPB MVC   0(8,R4),0(R5)       MOVE PPIENDAR ENTRY INTO TABLE
         LA    R4,20(,R4)          INCR TO NEXT TABLE ENTRY
         LA    R5,8(,R5)           INCR TO NEXT PPIENDAR ENTRY
         BCT   R8,AOKLOOPB         TABLE FULL ? NO, LOOP
*
*        BLOCK ADDR OF FIRST DICTIONARY IN DICTIONARY BLOCK
*
         MVC   WCLBKAR(8),PPISTAR  BLOCK FIRST AREA IN DICTIONARY
*                                  IN IERROK
*
*        REDUCE ALL DATA ENDING ADDR IN PPI BY 2 TRACKS
*        TO ALLOW AN INITIAL TWO TRACKS FOR THE SORTWK DIRECTORY AREA
*
         LH    R8,PPINDSKA         R8 = NO DISK AREAS
         BCTR  R8,0                DECR BY 1
         LA    R5,PPIENDAR         R5 -> FIRST END ADDR IN PPI
         SR    R6,R6               CLEAR WORK REG
AOKLOOPC ICM   R6,B'0011',5(R5)    R6 = ENDING TT
         BCTR  R6,0                DECR BY 2
         BCTR  R6,0
         STH   R6,5(,R5)           STORE RESULT BACK IN PPIENDAR
         LA    R5,8(,R5)           INCR TO NEXT PPIENDAR ENTRY
         BCT   R8,AOKLOOPC         ALL END ADDR AREAS IN PPI REDUCED
*                                  BY 2 TRACKS YET ?, NO LOOP
*
*        INITIALIZE WPOINT TO THE FIRST ENTRY IN TABLE
*
         LA    R6,TABLE            R6 -> TABLE
         ST    R6,WPOINT           UPDATE WPOINT IN IERROK
*
*        SET LIMIT OF SORT TABLE TO NO OF AREAS LESS 1
*
         LA    R8,20
         LH    R5,PPINDSKA         R5 = NO OF DISK AREAS
         BCTR  R5,0                DECR BY 1
         MR    R4,R8               MULT R8(20) BY (NO AREAS-1)=R5 PROD
         AR    R6,R5               ADD TBL LGTH(PROD)TO BEG TABLE ADDR
         ST    R6,WTBLLIMT
         BR    R14                 RETURN TO LOADER IERRC9
*
         DROP  R11
*
*
***********************************************************************
*
*        IERROK
*
***********************************************************************
*
DIERROK  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERROK SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERROKI
*
DIERRMA  DSECT
*
*        MODULE NAME - IERRMA
*
*        THIS MODULE CONTAINS ALL OF THE MESSAGES THAT ARE
*        REQUIRED FOR PHASE 1 RUNNING PROGRAM
*
         COPY  RMAMAIN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERAOL   0101-20211-20211-1200-00165-00165-00000-RELEASE 00
AOL      TITLE 'IERAOL - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERAOL
*
*        MODULE FUNCTION/OPERATION -
*        GENERATE THE REQUIRED EQUALS ROUTINE TO BE USED BY THE
*        RUNNING PROGRAMS. THIS IS DONE BY INITIALIZING THE CODE
*        FOUND AT THE END OF THIS ROUTINE AND MOVING THIS CODE TO
*        THE LOCATION SPECIFIED IN PPIA
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACROS USED BY MODULE - N/A
*
*        ENTRY POINTS - ENTRY IERAOL
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPICNTL    PPIPCF01   PPINUMCF
*        PPIFCF01   PPIAXERT
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED - N/A
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL -
*        BRANCH TO SSC VIA R12
*
*        TABLES/WORK AREAS - N/A
*
*        NOTES - N/A
*
IERAOL   CSECT
*
         USING *,R11
         USING IERRCA,R13
*
         IERENTRY 'IERAOL &SYSDATE &SYSTIME'
*
         STM   R2,R11,0(R12)       SAVE SSC REGISTERS
         LR    R11,R15
*
*        CHECK FOR MERGE ONLY AND SET BRANCH TO BYPASS THE
*        INCREMENTING OF THE CONTROL FIELD DISPLACEMENTS FOR A
*        SORT
*
         PPITEST  PPIMERGO         MERGE ONLY ?
         BZ    OLSORT              NO, BRANCH
         OI    OLSETBC+1,X'F0'     SET BRANCH INSTRUCTION TO BRANCH
*
*        SET UP NECESSARY REGISTERS FOR INITIALIZING THE CODE
*        FOR THE EQUALS ROUTINE
*
OLSORT   LA    R8,OLCF2            ADDR OF CODE TO INITIALIZE
         LA    R5,PPIPCF01         ADDR OF CONTROL FIELD DATA
         LH    R6,PPINUMCF         NUMBER OF CONTROL FIELDS
         LA    R7,1                CONSTANT OF 1
*
*        INITIALIZE THE INDICATED COMPARE INSTRUCTION
*
OLNEXTCF SR    R6,R7               DECREMENT COUNT OF CONTROL FIELD
         LA    R5,6(,R5)           INCREMENT TO DATA FOR NEXT CF
         LH    R9,0(,R5)           DISPLACEMENT OF THIS CONTROL FIELD
OLSETBC  NOP   OLMERGE             INITIALIZED TO BRANCH IF MERGE ONLY
         LA    R9,4(,R9)           INC DISPLACEMENT FOR TREE ADDR
OLMERGE  STH   R9,WOLHOLD          SET UP DISPLACEMENT
         STH   R9,WOLHOLD          SET UP DISPLACEMENT
         STH   R9,WOLHOLD+2        FIELDS FOR ORING
         OC    2(4,R8),WOLHOLD     INITIALIZE DISPLACEMENTS IN CLC INST
         IC    R9,3(0,R5)          LENGTH OF THIS CONTROL FIELD
         STC   R9,1(0,R8)          SET LENGTH IN CLC INSTRUCTION
*
*        DETERMINE IF IT IS NECESSARY TO REVERSE THE OPERANDS OF
*        THIS COMPARE INSTRUCTION, AND REVERSE AS NECESSARY
*
         SR    R9,R9               ZERO R9
         SR    R10,R10             ZERO R10
         IC    R9,PPIFCF01         FORMAT AND SEQUENCE BYTE OF CF1
         IC    R10,5(,R5)          FORMAT AND SEQUENCE BYTE OF THIS CF
         LA    R9,4(,R9)           ADD 4 TO EACH BYTE
         LA    R10,4(,R10)         AND DIVIDE
         SRL   R9,2                EACH BYTE
         SRL   R10,2               BY 4
         LA    R4,17               CONSTANT 17
         CR    R9,R4               IF THE
         BNH   OLCKRK              VALUES IN
         LR    R9,R7               REGISTERS
OLCKRK   CR    R10,R4              R10 OR R9 ARE
         BNH   OLCKIFEQ            GREATER THAN 17
         LR    R10,R7              SET THEM TO 1
OLCKIFEQ NR    R9,R7               MASK OFF ALL BUT LAST BIT
         NR    R10,R7              MASK OFF ALL BUT LAST BIT
         CR    R9,R10              EQUALS ?
         BE    OLLASTCK            EQ, THE OPERANDS IN CLC INST OK
         LH    R9,2(,R8)           FIRST OPERAND OF CLC INST
         LH    R10,4(,R8)          SECOND OPERAND OF CLC INST
         STH   R9,4(,R8)           RESTORE THE OPERANDS
         STH   R10,2(,R8)          IN REVERSE ORDER
*
*        CHECK IF ALL COMPARE INSTRUCTIONS ARE INITIALIZED
*
OLLASTCK CR    R6,R7               CHECK IF COUNT OF CF'S IS ONE
         BE    OLSETBR             EQ, IT IS THE LAST CONTROL FIELD
         LA    R8,8(0,R8)          INC ADDR OF CODE TO BE INIT BY 8
         B     OLNEXTCF            CONTINUE INITIALIZING THE CLC INSTS
*
*        INITIALIZE THE BRANCH INSTRUCTION FOLLOWING THE LAST
*        COMPARE TO AN UNCONDITIONAL BRANCH
*
OLSETBR  LA    R9,254              CONSTANT X'FE'
         STC   R9,7(,R8)           FORCE AN UNCONDITIONAL BRANCH
*
*        MOVE THE INITIALIZED EQUALS ROUTINE TO ITS DESIGNATED
*        LOCATION AND RETURN TO SSC
*
         L     R4,PPIAXERT         ADDR OF EQUALS ROUTINE
         MVC   0(88,R4),OLCF2      MOVE INITIALIZED EQ RTN INTO POSIT
OLRETRN  SR    R15,R15             SET RETURN CODE TO ZERO
         LM    R2,R11,0(R12)       RESET SSC REGISTERS
         BR    R14                 RETURN TO SSC
*
*        THE FOLLOWING CODE IS INITIALIZED AS NECESSARY BY THIS
*        ROUTINE
*
*        THE INITIALIZED CODE IS THEN MOVED TO THE LOCATION
*        DESIGNATED IN THE PPIA. THIS IS THEN USED AS THE RUNNING
*        EQUALS ROUTINE
*
OLCF2    CLC   0(1,R3),0(R2)       COMPARE SECOND CTRL FLDS OF RECDS
         BNER  R14                 NE, RETURN TO NETWORK
OLCF3    CLC   0(1,R3),0(R2)       COMPARE THIRD CTRL FLDS OF RECDS
         BNER  R14                 NE, RETURN TO NETWORK
OLCF4    CLC   0(1,R3),0(R2)       COMPARE FOURTH CTRL FLDS OF RECDS
         BNER  R14                 NE, RETURN TO NETWORK
OLCF5    CLC   0(1,R3),0(R2)       COMPARE FIFTH CTRL FLDS OF RECDS
         BNER  R14                 NE, RETURN TO NETWORK
OLCF6    CLC   0(1,R3),0(R2)       COMPARE SIXTH CTRL FLDS OF RECDS
         BNER  R14                 NE, RETURN TO NETWORK
OLCF7    CLC   0(1,R3),0(R2)       COMPARE SEVENTH CTRL FLDS OF RECDS
         BNER  R14                 NE, RETURN TO NETWORK
OLCF8    CLC   0(1,R3),0(R2)       COMPARE EIGTH CTRL FLDS OF RECDS
         BNER  R14                 NE, RETURN TO NETWORK
OLCF9    CLC   0(1,R3),0(R2)       COMPARE NINTH CTRL FLDS OF RECDS
         BNER  R14                 NE, RETURN TO NETWORK
OLCF10   CLC   0(1,R3),0(R2)       COMPARE TENTH CTRL FLDS OF RECDS
         BNER  R14                 NE, RETURN TO NETWORK
OLCF11   CLC   0(1,R3),0(R2)       COMPARE ELEVENTH CTRL FLDS OF RECDS
         BNER  R14                 NE, RETURN TO NETWORK
OLCF12   CLC   0(1,R3),0(R2)       COMPARE TWELFTH CTRL FLDS OF RECDS
         BR    R14                 UNCONDITIONAL RETURN TO NETWORK
*
*        WORK AREA
*
WOLHOLD  DC    F'0'                CONTAIN DISPS FOR ORING
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERAOM   0101-20211-20211-1200-01350-01350-00000-RELEASE 00
AOM      TITLE 'IERAOM - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERAOM
*
*        MODULE FUNCTION/OPERATION -
*        THIS ROUTINE GENERATES THE REQUIRED EXTRACT ROUTINE TO
*        BE USED BY THE RUNNING PROGRAMS. THIS IS DONE BY
*        INITIALIZING THE CODE FOUND AT THE END OF THIS ROUTINE
*        FOR THE PROPER CONTROL FIELD AND MOVING THIS CODE TO THE
*        LOCATION SPECIFIED IN PPIA
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACROS USED BY MODULE - SMPPI
*
*        ENTRY POINTS - ENTRY IERAOM
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIPBUFF   PPIFFF    PPIPCF01
*        PPINUMCF   PPIAXERT
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPILEXFD   PPILEXFF   PPILAB01
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL -
*        RETURN TO SSC VIA R14
*
*        EXITS - ERROR -
*        N/A
*
*        TABLES/WORK AREAS -
*        WOMHOLD  - CONTAIN DISP FIELD FOR ORING
*        WOMRETNR - SAVE REGISTER SAVE ADDRESS
*
*        NOTES - N/A
*
IERAOM   CSECT
*
         USING *,R11
         USING IERRCA,R13
*
         IERENTRY 'IERAOM &SYSDATE &SYSTIME'
*
         STM   R2,R11,0(R12)       SAVE SSC REGISTERS
         LR    R11,R15
         ST    R12,WOMRETNR        SAVE REGISTER SAVE ADDR
*
*        SET UP NECESSARY REGISTERS FOR INITIALIZING THE CODE
*        FOR THE EXTRACT ROUTINE
*        GENERATE THE CONSTANT OF F'S IN THE EXTRACT ROUTINE
*
         L     R6,PPIPBUFF         DISP TO PACKING BUFFER IN EXT RTN
         L     R7,PPIFFF           DISP TO CONSTANT IN EXTRACT ROUTINE
         LH    R9,PPINUMCF
         CH    R9,K12              MORE THAN 12 CONTROL FIELDS ?
         BH    OM002               YES, BRANCH
         LA    R8,PPIPCF01         ADDR OF CONTROL FIELD DATA
OM001    L     R12,PPIAXERT        ADDR OF EXTRACT ROUTINE
         LR    R4,R6               DISPLACEMENT OF PACKING BUFFER
         SR    R4,R7               DISP OF CONSTANT RESULT = LENGTH
         LTR   R4,R4               TEST REGISTER
         BZ    OMBYPASS            ZERO, NO CONSTANT NEEDED
         LA    R3,255              CONSTANT X'FF'
         LR    R2,R12              ADDR OF EXTRACT ROUTINE
         AR    R2,R7               DISP OF CONSTANT RESULT = START
OMSTOFF  STC   R3,0(,R2)           STORE A BYTE OF THE CONSTANT
         LA    R2,1(,R2)           INCREMENT ADDR OF CONSTANT
         BCT   R4,OMSTOFF          COUNT ¬ 0, STORE ANOTHER BYTE
OMBYPASS LA    R12,4(,R12)         INC FOR SPACE FOR ADDR OF USER RTN
         LA    R10,4               DISPLACEMENT IN EXTRACTED PORTION
         LR    R5,R10              DISPLACEMENT IN EXTRACT ROUTINE
*
*        THROUGH THE COMBINATION OF THE IDENTIFICATION BYTE AND
*        THE FOLLOWING BRANCH TABLE AN INDEXED BRANCH IS
*        PERFORMED WHICH BRANCHES TO THE CASE WHICH INITIALIZES
*        THE CODE FOR THE CONTROL FIELD IDENTIFIED
*
OMNOLAST LA    R4,OMBTABLE         ADDR OF BRANCH TABLE
         LA    R1,LONGINIT         LOAD BASE REG
         USING OMCASE7L,R1
         SR    R3,R3               ZERO REG
         IC    R3,5(,R8)           FORMAT AND SEQUENCE BYTE OF THIS CF
         B     0(R3,R4)            BRANCH TO PROPER CASE THRU TABLE
*
OM002    L     R8,PPIADDCF         ADDR OF CONTROL FIELD DATA > 12
         B     OM001
*
*        BRANCH TABLE
*
OMBTABLE B     OMCASE1
         B     OMCASE2
         B     OMCASE3
         B     OMCASE4
         B     OMCASE5
         B     OMCASE6
         B     OMCASE7
         B     OMCASE8
         B     OMCASE9
         B     OMCASE10
         B     OMCASE11
         B     OMCASE12
         B     OMCASE13
         B     OMCASE14
         B     OMCASE15
         B     OMCASE16
         B     OMCASE17
         B     OMCASE17
         B     OMCASE17
         B     OMCASE17
         B     OMCASE17
         B     OMCASE17
         B     OMCASE17
         B     OMCASE24
*
*        INITIALIZES THE CODE WHICH IS USED TO EXTRACT
*        ALPHAMERIC OR UNSIGNED BINARY BYTE FIELDS WHICH ARE
*        ASCENDING
*
OMCASE1  NC    OMAOUBBA+2(4),KOMZERO  ZERO D FIELDS IN CODE TO BE INIT
         ST    R10,WOMHOLD          DISPLACEMENT OF TO ADDRESS
         OC    OMAOUBBA(4),WOMHOLD  SET DISP OF FIRST OP IN MOVE INST
         MVC   OMAOUBBA+1(1),3(R8)  SET LENGTH IN MOVE INSTRUCTION
         OC    OMAOUBBA+4(2),0(R8)  SET DISP OF 2ND OP IN MOVE INST
         MVC   0(6,R12),OMAOUBBA    MOVE SEGMENT TO EXTRACT ROUTINE
         LA    R12,6(,R12)          INCREMENT ADDR OF EXTRACT RTN
         LA    R5,6(,R5)            INCREMENT DISPLACEMENT IN EXT RTN
         B     OMISITND
*
*        INITIALIZES THE CODE WHICH IS USED TO EXTRACT
*        ALPHAMERIC OR UNSIGNED BINARY BYTE FIELDS WHICH ARE
*        DECENDING
*
OMCASE2  NC    OMAOUBBD+2(4),KOMZERO  ZERO DISPLACEMENT FIELDS
         NC    OMAOUBBD+8(4),KOMZERO  IN CODE TO BE INITIALIZED
         ST    R10,WOMHOLD            DISPLACEMENT OF TO ADDR
         OC    OMAOUBBD(4),WOMHOLD    SET DISP OF 1ST OP IN MOVE INST
         MVC   OMAOUBBD+1(1),3(R8)    SET LENGTH IN MOVE INSTRUCTION
         OC    OMAOUBBD+4(2),0(R8)    SET DISP OF 2ND OP IN MOVE INST
         OC    OMAOUBBD+6(4),WOMHOLD  SET DISP OF FIRST OP IN XC INST
         MVC   OMAOUBBD+7(1),3(R8)    SET LENGTH IN XC INSTRUCTION
         ST    R7,WOMHOLD             DISP IN RUNNING EXT OF STR OF F'S
         OC    OMAOUBBD+8(4),WOMHOLD  SET DISP OF 2ND OP IN XC INST
         MVC   0(12,R12),OMAOUBBD     MOVE SEGMENT TO EXTRACT RTN
         LA    R12,12(,R12)           INCREMENT ADDR OF EXTRACT RTN
         LA    R5,12(,R5)             INCR DISPLACEMENT IN EXT RTN
         B     OMISITND
*
*        INITIALIZES THE CODE WHICH IS USED TO EXTRACT NORMALIZED
*        FLOATING POINT FIELDS WHICH ARE ASCENDING
*
OMCASE3  NC    OMFLPTA+2(4),KOMZERO    ZERO DISPLACEMENT
         NC    OMFLPTA+8(2),KOMZERO    FIELDS IN
         NC    OMFLPTA+12(2),KOMZERO   CODE TO BE
         NC    OMFLPTA+16(4),KOMZERO   INITIALIZED
         NC    OMFLPTA+22(2),KOMZERO
         NC    OMFLPTA+26(2),KOMZERO
         ST    R10,WOMHOLD             DISPLACEMENT OF TO ADDR
         OC    OMFLPTA(4),WOMHOLD      SET DISP OF 1ST OP IN MOVE INST
         MVC   OMFLPTA+1(1),3(R8)      SET LENGTH IN MOVE INSTRUCTION
         OC    OMFLPTA+4(2),0(R8)      SET DISP OF 2ND OP IN MOVE INST
         OC    OMFLPTA+8(2),0(R8)      SET DISP IN TM INSTRUCTION
         OC    OMFLPTA+14(4),WOMHOLD   SET DISP OF 1ST OP IN XC INST
         OC    OMFLPTA+24(4),WOMHOLD   SET DISP IN XI INSTRUCTION
         MVC   OMFLPTA+15(1),3(R8)     SET LENGTH IN XC INSTRUCTION
         ST    R7,WOMHOLD              DISP IN RUN EXT OF STR OF F'S
         OC    OMFLPTA+16(4),WOMHOLD   SET DISP OF 2ND OP IN XC INST
         LA    R4,24(0,R5)             INC DISP IN EXTRACT ROUTINE
         ST    R4,WOMHOLD              DISP IN RUNNING EXTRACT FOR BR
         OC    OMFLPTA+10(4),WOMHOLD   SET DISP IN BZ INSTRUCTION
         LA    R4,4(0,R4)              INC BY 4 BYTES
         ST    R4,WOMHOLD              DISP IN RUNNING EXTRACT FOR BR
         OC    OMFLPTA+20(4),WOMHOLD   SET DISP IN BRANCH INSTRUCTION
         MVC   0(28,R12),OMFLPTA       MOVE SEGMENT TO EXTRACT ROUTINE
         LA    R12,28(,R12)            INCREMENT ADDR OF EXTRACT RTN
         LA    R5,28(,R5)              INCREMENT DISPLACEMT IN EXT RTN
         B     OMISITND
*
*        INITIALIZES THE CODE WHICH IS USED TO EXTRACT NORMALIZED
*        FLOATING POINT FIELDS WHICH ARE DECENDING
*
OMCASE4  NC    OMFLPTD+2(4),KOMZERO    ZERO DISPLACEMENT
         NC    OMFLPTD+8(2),KOMZERO    FIELDS IN
         NC    OMFLPTD+12(2),KOMZERO   CODE TO BE
         NC    OMFLPTD+16(2),KOMZERO   INITIALIZED
         NC    OMFLPTD+20(2),KOMZERO
         NC    OMFLPTD+24(4),KOMZERO
         MVI   OMFLPTD+19,X'00'        SET CONDITIONAL BRANCH TO A NOP
         ST    R10,WOMHOLD             DISPLACEMENT OF TO ADDR
         OC    OMFLPTD(4),WOMHOLD      SET DISP OF 1ST OP IN MOVE INST
         MVC   OMFLPTD+1(1),3(R8)      SET LENGTH IN MOVE INSTRUCTION
         OC    OMFLPTD+4(2),0(R8)      SET DISP OF 2ND OP IN MOVE INST
         OC    OMFLPTD+8(2),0(R8)      SET DISP IN TM INSTRUCTION
         OC    OMFLPTD+14(4),WOMHOLD   SET DISP IN XI INSTRUCTION
         LA    R4,1(,R10)              INC BY 1 IN EXTRACTED PORTION
         ST    R4,WOMHOLD              DISP FOR D1 FIELD IN XC INST
         OC    OMFLPTD+22(4),WOMHOLD   SET DISP OF 1ST OP IN XC INST
         LA    R3,1                    CONSTANT  OF 1
         IC    R4,3(,R8)               LENGTH OF CONTROL FIELD
         SR    R4,R3                   DECREMENT LENGTH BY 1
         STC   R4,OMFLPTD+23           SET LENGTH FIELD IN XC INST
         ST    R7,WOMHOLD              DISP IN RUNING EXT OF STR OF F'S
         OC    OMFLPTD+24(4),WOMHOLD   SET DISP OF 2ND OP IN XC INST
         LA    R4,28(,R5)              INC DISP IN EXTRACT RTN
         ST    R4,WOMHOLD              DISP IN RUNNING EXTRACT FOR BR
         OC    OMFLPTD+10(4),WOMHOLD   SET DISP IN BO INSTRUCTION
         LA    R4,28(0,R5)             INC DISPLACEMENT IN EXTRACT RTN
         ST    R4,WOMHOLD              DISP FOR BC INSTRUCTION
         OC    OMFLPTD+18(4),WOMHOLD   SET D2 FIELD IN BC INST
         CLI   3(R8),X'00'             TEST CF LEN FOR 1 BYTE
         BNE   *+8
         MVI   OMFLPTD+19,X'F0'        SET BC INSTRUCTION TO BRANCH
         MVC   0(28,R12),OMFLPTD       MOVE SEGMENT TO EXTRACT ROUTINE
         LA    R12,28(,R12)            INCREMENT ADDR OF EXTRACT RTN
         LA    R5,28(,R5)              INCREMENT DISPLACEMT IN EXT RTN
         B     OMISITND
*
*        INITIALIZES THE CODE WHICH IS USED TO EXTRACT SIGNED
*        BINARY BYTE FIELDS WHICH ARE ASCENDING
*
OMCASE5  NC    OMSBBA+2(4),KOMZERO  ZERO DISPLACEMENT FIELDS IN
         NC    OMSBBA+8(2),KOMZERO  CODE TO BE INITIALIZED
         ST    R10,WOMHOLD          DISPLACEMENT OF TO ADDR
         OC    OMSBBA(4),WOMHOLD    SET DISP OF FIRST OP IN MOVE INST
         MVC   OMSBBA+1(1),3(R8)    SET LENGTH IN MOVE INSTRUCTION
         OC    OMSBBA+4(2),0(R8)    SET DISP OF 2ND OP IN MOVE INST
         OC    OMSBBA+6(4),WOMHOLD  SET DISP IN XI INSTRUCTION
         MVC   0(10,R12),OMSBBA     MOVE SEGMENT TO EXTRACT ROUTINE
         LA    R12,10(,R12)         INCREMENT ADDR OF EXTRACT ROUTINE
         LA    R5,10(,R5)           INCREMENT DISPLACEMENT IN EXT RTN
         B     OMISITND
*
*        INITIALIZES THE CODE WHICH IS USED TO EXTRACT SIGNED
*        BINARY BYTE FIELDS WHICH ARE DECENDING
*
OMCASE6  NC    OMSBBD+2(4),KOMZERO     ZERO DISPLACEMENT
         NC    OMSBBD+8(2),KOMZERO     FIELDS IN CODE
         NC    OMSBBD+12(2),KOMZERO    TO BE INITIALIZED
         NC    OMSBBD+16(4),KOMZERO
         MVI   OMSBBD+11,X'00'         SET CONDITIONAL BRANCH TO A NOP
         ST    R10,WOMHOLD             DISPLACEMENT OF TO ADDR
         OC    OMSBBD(4),WOMHOLD       SET DISP OF 1ST OP IN MOVE INST
         MVC   OMSBBD+1(1),3(R8)       SET LENGTH IN MOVE INSTRUCTION
         OC    OMSBBD+4(2),0(R8)       SET DISP OF 2ND OP IN MOVE INST
         OC    OMSBBD+6(4),WOMHOLD     SET DISP IN XI INSTRUCTION
         LA    R4,1(0,R10)             INC BY 1 IN EXTRACTED PORTION
         ST    R4,WOMHOLD              DISP FOR D1 FIELD IN XC INST
         OC    OMSBBD+14(4),WOMHOLD    SET DISP OF 1ST OP IN XC INST
         LA    R3,1                    CONSTANT  OF 1
         IC    R4,3(,R8)               LENGTH OF CONTROL FIELD
         SR    R4,R3                   DECREMENT LENGTH BY 1
         STC   R4,OMSBBD+15            SET LENGTH FIELD IN XC INST
         ST    R7,WOMHOLD              DISP IN RUNING EXT OF STR OF F'S
         OC    OMSBBD+16(4),WOMHOLD    SET DISP OF 2ND OP IN XC INST
         LA    R4,20(,R5)              INC DISP IN EXTRACT ROUTINE
         ST    R4,WOMHOLD              DISP FOR BC INSTRUCTION
         OC    OMSBBD+10(4),WOMHOLD    SET D2 FIELD IN BC INST
         CLI   3(R8),X'00'             TEST CNTL FIELD LEN FOR 1 BYTE
         BNE   *+8
         MVI   OMSBBD+11,X'F0'         SET BC INSTRUCTION TO BRANCH
         MVC   0(20,R12),OMSBBD        MOVE SEGMENT TO EXTRACT ROUTINE
         LA    R12,20(,R12)            INCR ADDR OF EXTRACT ROUTINE
         LA    R5,20(,R5)              INCR DISPLACEMENT IN EXT RTN
         B     OMISITND
*
*        INITIALIZES THE CODE WHICH IS USED TO EXTRACT MULTI-
*        BYTE UNPACKED DECIMAL FIELDS WHICH ARE ASCENDING
*
OMCASE7  CLI   3(R8),X'0F'              MORE THAN 16 BYTES ?
         BH    OMCASE7L                 YES, BRANCH
         NC    OMUDMBA+2(4),KOMZERO     ZERO DISPLACEMENT
         NC    OMUDMBA+8(4),KOMZERO     FIELDS IN
         NC    OMUDMBA+14(4),KOMZERO    CODE TO BE
         NC    OMUDMBA+20(2),KOMZERO    INITIALIZED
         NC    OMUDMBA+24(2),KOMZERO
         NC    OMUDMBA1+2(2),KOMZERO
         NC    OMUDMBA1+6(2),KOMZERO
         NC    OMUDMBA1+10(2),KOMZERO
         NC    OMUDMBA1+14(4),KOMZERO
         NC    OMUDMBA1+20(2),KOMZERO
         NC    OMUDMBA1+24(2),KOMZERO
         SR    R3,R3                    ZERO REGISTER
         IC    R3,3(,R8)                BYTE PORTION OF LEN OF THIS CF
         LA    R4,1(,R3)                INC FIELD BY ONE FOR ROUNDING
         SRL   R4,1                     DIVIDE BY 2
         LR    R2,R4                    SAVE LENGTH OF L1 FIELD
         SLL   R4,4                     MOVE TO POSITION FOR L1 FIELD
         OR    R4,R3               COMBINE L1 AND L2  FIELD IN ONE BYTE
         STC   R4,OMUDMBA+1        SET LENGTH FIELDS IN PACK INST
         LA    R4,9(,R6)           DISPLACEMENT TO END OF PACKING BUFF
         SR    R4,R2               SUB REAL LENGTH OF FIELD LESS ONE
         LA    R3,1                CONSTANT OF 1
         SR    R4,R3               DECREMENT TO DISP BY ONE
         ST    R4,WOMHOLD          DISP OF FIRST OPERAND
         OC    OMUDMBA(4),WOMHOLD       SET D1 FIELD IN PACK INST
         OC    OMUDMBA+4(2),0(R8)       SET D2 FIELD IN PACK INST
         OC    OMUDMBA+14(4),WOMHOLD    SET D2 FIELD IN MVO INST
         LA    R4,0(R2,R10)             DISP TO LAST BYTE IN TO LOC
         ST    R4,WOMHOLD          DISP OF 1 ST OPERAND IN UNPACK INSTR
         OC    OMUDMBA+6(4),WOMHOLD     SET D1 FIELD IN UNPACK INST
         LA    R4,8(,R6)                DISP TO SIGN BYTE
         ST    R4,WOMHOLD          DISP OF 2 ND OPERAND OF UNPACK INSTR
         OC    OMUDMBA+8(4),WOMHOLD     SET D2 FIELD IN UNPACK INST
         OC    OMUDMBA+18(4),WOMHOLD    SET D1 FIELD IN FIRST TM INST
         OC    OMUDMBA1(4),WOMHOLD      SET D1 FIELD IN SECOND TM INST
         ST    R10,WOMHOLD              DISP OF 1ST OPERAND IN MVO INST
         OC    OMUDMBA+12(4),WOMHOLD    SET D1 FIELD IN MVO INST
         LR    R4,R2               L1 FIELD
         LA    R3,1                CONSTANT OF 1
         SR    R4,R3               CALC L2 FIELD FOR MVO INST
         STC   R4,OMUDMBA1+13      SET LENGTH FIELD IN XC INST
         SLL   R2,4                MOVE TO POSITION FOR L1 FIELD
         OR    R4,R2               COMBINE L1 AND L2 FIELD INTO 1 BYTE
         STC   R4,OMUDMBA+13       SET LENGTH FIELDS IN MVO INST
         OC    OMUDMBA1+8(4),WOMHOLD    SET D1 FIELD IN XI INST
         OC    OMUDMBA1+22(4),WOMHOLD   SET D1 FIELD IN OI INST
         LA    R4,1(,R10)          INC BY 1 IN EXTRACTED PORTION
         ST    R4,WOMHOLD          STORE DISP
         OC    OMUDMBA1+12(4),WOMHOLD   SET D1 FIELD IN XC INST
         ST    R7,WOMHOLD          DISP IN RUNNING EXT OF STRING OF F'S
         OC    OMUDMBA1+14(4),WOMHOLD   SET D2 FIELD IN XC INST
         LA    R4,48(,R5)          INC DISP IN EXTRACT ROUTINE
         ST    R4,WOMHOLD          DISP FOR BZ AND BO INSTRUCTIONS
         OC    OMUDMBA+22(4),WOMHOLD    SET D2 FIELD IN BZ INST
         OC    OMUDMBA1+4(4),WOMHOLD    SET D2 FIELD IN BO INST
         LA    R4,4(0,R4)          INCREMENT BY 4 BYTES
         ST    R4,WOMHOLD          DISP FOR BRANCH INSTRUCTION
         OC    OMUDMBA1+18(4),WOMHOLD SET D2 FIELD IN BRANCH INST
         MVC   0(52,R12),OMUDMBA   MOVE SEGMENT TO EXTRACT ROUTINE
         LA    R5,52(,R5)          INCREMENT DISPLACEMENT IN EXT RTN
         LA    R12,52(,R12)        INCREMENT ADDR OF EXTRACT ROUTINE
         B     OMISITND
*
*        INITIALIZES THE CODE WHICH IS USED TO EXTRACT MULTI-
*        BYTE UNPACKED DECIMAL FIELDS WHICH ARE DECENDING
*
OMCASE8  CLI   3(R8),X'0F'              MORE THAN 16 BYTES ?
         BH    OMCASE8L                 YES, BRANCH
         NC    OMUDMBD+2(4),KOMZERO     ZERO DISPLACEMENT
         NC    OMUDMBD+8(4),KOMZERO     FIELDS IN
         NC    OMUDMBD+14(4),KOMZERO    CODE TO BE
         NC    OMUDMBD+20(2),KOMZERO    INITIALIZED
         NC    OMUDMBD+24(2),KOMZERO
         NC    OMUDMBD1+2(2),KOMZERO
         NC    OMUDMBD1+6(2),KOMZERO
         NC    OMUDMBD1+10(2),KOMZERO
         NC    OMUDMBD1+14(2),KOMZERO
         NC    OMUDMBD1+18(2),KOMZERO
         NC    OMUDMBD1+22(4),KOMZERO
         SR    R3,R3               ZERO REG
         IC    R3,3(,R8)           BYTE PORTION OF LENGTH OF THIS CF
         LA    R4,1(,R3)           INC FIELD BY ONE FOR ROUNDING
         SRL   R4,1                DIVIDE BY 2
         LR    R2,R4               SAVE LENGTH OF L1 FIELD
         SLL   R4,4                MOVE TO POSITION FOR L1 FIELD
         OR    R4,R3               COMBINE L1 AND L2  FIELD IN ONE BYTE
         STC   R4,OMUDMBD+1        SET LENGTH FIELDS IN PACK INST
         LA    R4,9(,R6)           DISPLACEMENT TO END OF PACKING BUFF
         SR    R4,R2               SUB REAL LENGTH OF FIELD LESS ONE
         LA    R3,1                CONSTANT OF 1
         SR    R4,R3               DECREMENT TO DISP BY ONE
         ST    R4,WOMHOLD          DISP OF FIRST OPERAND
         OC    OMUDMBD(4),WOMHOLD  SET D1 FIELD IN PACK INST
         OC    OMUDMBD+4(2),0(R8)  SET D2 FIELD IN PACK INST
         OC    OMUDMBD+14(4),WOMHOLD     SET D2 FIELD IN MVO INST
         LA    R4,0(R2,R10)        DISP TO LAST BYTE IN TO LOCATION
         ST    R4,WOMHOLD          DISP OF 1 ST OPERAND IN UNPACK INSTR
         OC    OMUDMBD+6(4),WOMHOLD      SET D1 FIELD IN UNPACK INST
         LA    R4,8(0,R6)          DISP TO SIGN BYTE
         ST    R4,WOMHOLD          DISP OF 2 ND OPERAND OF UNPACK INSTR
         OC    OMUDMBD+8(4),WOMHOLD      SET D2 FIELD IN UNPACK INST
         OC    OMUDMBD+18(4),WOMHOLD     SET D1 FIELD IN FIRST TM INST
         OC    OMUDMBD1(4),WOMHOLD       SET D1 FIELD IN SECOND TM INST
         ST    R10,WOMHOLD               DISP OF FIRST OPER IN MVO INST
         OC    OMUDMBD+12(4),WOMHOLD     SET D1 FIELD IN MVO INST
         LR    R4,R2               L1 FIELD
         LA    R3,1                CONSTANT OF 1
         SR    R4,R3               CALC L2 FIELD FOR MVO INST
         STC   R4,OMUDMBD1+21      SET LENGTH FIELD IN XC INST
         SLL   R2,4                MOVE TO POSITION FOR L1 FIELD
         OR    R4,R2               COMBINE L1 AND L2 FIELD INTO 1 BYTE
         STC   R4,OMUDMBD+13       SET LENGTH FIELDS IN MVO INST
         OC    OMUDMBD1+16(4),WOMHOLD    SET D1 FIELD IN XI INST
         OC    OMUDMBD1+8(4),WOMHOLD     SET D1 FIELD IN OI INST
         LA    R4,1(,R10)                INC BY 1 IN EXTRACTED PORTION
         ST    R4,WOMHOLD                STORE DISP
         OC    OMUDMBD1+20(4),WOMHOLD    SET D1 FIELD IN XC INST
         ST    R7,WOMHOLD                DISP IN RUN EXT OF STR OF F'S
         OC    OMUDMBD1+22(4),WOMHOLD    SET D2 FIELD IN XC INST
         LA    R4,42(,R5)                INC DISP IN EXTRACT ROUTINE
         ST    R4,WOMHOLD                DISP FOR BZ AND BO INSTRUCT
         OC    OMUDMBD+22(4),WOMHOLD     SET D2 FIELD IN BZ INST
         OC    OMUDMBD1+4(4),WOMHOLD     SET D2 FIELD IN BO INST
         LA    R4,10(,R4)                INCREMENT BY 10 BYTES
         ST    R4,WOMHOLD                DISP FOR BRANCH INSTRUCTION
         OC    OMUDMBD1+12(4),WOMHOLD    SET D2 FIELD IN BRANCH INST
         MVC   0(52,R12),OMUDMBD   MOVE SEGMENT TO EXTRACT ROUTINE
         LA    R12,52(,R12)        INCREMENT ADDR OF EXTRACT ROUTINE
         LA    R5,52(,R5)          INCREMENT DISPLACEMENT IN EXT RTN
         B     OMISITND
*
*        INITIALIZES THE CODE WHICH IS USED TO EXTRACT MULTI-
*        BYTE PACKED DECIMAL FIELDS WHICH ARE ASCENDING
*
OMCASE9  L     R15,=A(OMCASE9L)     ADDRESS VIA ADCON
         BR    R15
*
*        INITIALIZES THE CODE WHICH IS USED TO EXTRACT MULTI-
*        BYTE PACKED DECIMAL FIELDS WHICH ARE DECENDING
*
OMCASE10 NC    OMPDMBD+2(4),KOMZERO    ZERO DISPLACEMENT
         NC    OMPDMBD+8(4),KOMZERO    FIELDS IN
         NC    OMPDMBD+14(2),KOMZERO   CODE TO BE
         NC    OMPDMBD+18(2),KOMZERO   INITIALIZED
         NC    OMPDMBD+22(2),KOMZERO
         NC    OMPDMBD1+2(2),KOMZERO
         NC    OMPDMBD1+6(2),KOMZERO
         NC    OMPDMBD1+10(2),KOMZERO
         NC    OMPDMBD1+14(2),KOMZERO
         NC    OMPDMBD1+18(4),KOMZERO
         SR    R4,R4               ZERO REG
         IC    R4,3(,R8)           BYTE PORTION OF LENGTH OF THIS CF
         LR    R3,R4               SAVE LENGTH OF THIS CF
         AH    R4,0(,R8)           DISPLACEMENT OF THIS CF
         ST    R4,WOMHOLD          DISPLACEMENT TO SIGN BYTE OF THIS CF
         OC    OMPDMBD+2(4),WOMHOLD    SET D2 FIELD OF UNPACK INST
         OC    OMPDMBD+12(4),WOMHOLD   SET D1 FIELD OF FIRST TM INST
         OC    OMPDMBD+20(4),WOMHOLD   SET D1 FIELD OF SECOND TM INST
         OC    OMPDMBD+10(2),0(R8)     SET D2 FIELD IN MVO INST
         ST    R10,WOMHOLD         DISPLACEMENT IN EXTRACTED PORTION
         OC    OMPDMBD+6(4),WOMHOLD    SET D1 FIELD IN MVO INST
         OC    OMPDMBD1+12(4),WOMHOLD  SET D1 FIELD IN XI INST
         OC    OMPDMBD1+4(4),WOMHOLD   SET D1 FIELD IN OI INST
         LA    R4,1(,R10)          DISP IN EXTRACTED PORTION PLUS 1
         ST    R4,WOMHOLD          STORE DISPLACEMENT
         OC    OMPDMBD1+16(4),WOMHOLD  SET D1 FIELD IN XC INST
         LR    R4,R3               LENGTH OF CONTROL FIELD
         AR    R4,R10              DISP IN EXTRACTED PORTION
         ST    R4,WOMHOLD          DISPLACEMENT TO SIGN BYTE
         OC    OMPDMBD(4),WOMHOLD  SET D1 FIELD IN UNPACK INST
         LA    R2,1                CONSTANT OF 1
         LR    R4,R3               LENGTH OF CONTROL FIELD
         SR    R4,R2               DECREMENT BY ONE
         STC   R4,OMPDMBD1+17      SET LENGTH FIELD IN XC INST
         SLL   R3,4                PREPARE L1 FIELD FOR MVO INST
         OR    R4,R3               COMBINE LI AND L2 FIELDS
         STC   R4,OMPDMBD+7        SET LENGTH FIELDS IN MVO INST
         ST    R7,WOMHOLD          DISPLACEMENT TO CONSTANT OF F'S
         OC    OMPDMBD1+18(4),WOMHOLD  SET D2 FIELD IN XC INST
         LA    R4,36(0,R5)         INC DISP IN EXTRACT ROUTINE
         ST    R4,WOMHOLD          DISP FOR BZ AND BO INSTRUCTIONS
         OC    OMPDMBD+16(4),WOMHOLD  SET D2 FIELD IN BZ INST
         OC    OMPDMBD1(4),WOMHOLD    SET D2 FIELD IN BO INST
         LA    R4,10(,R4)             INC DISPLACEMENT BY 10
         ST    R4,WOMHOLD             DISP FOR BRANCH INST
         OC    OMPDMBD1+8(4),WOMHOLD  SET D2 FIELD IN BRANCH INST
         MVC   0(46,R12),OMPDMBD   MOVE SEGMENT TO EXTRACT ROUTINE
         LA    R12,46(,R12)        INCREMENT ADDR OF EXTRACT ROUTINE
         LA    R5,46(,R5)          INCREMENT DISPLACEMENT IN EXT RTN
         B     OMISITND
*
*        INITIALIZES THE CODE WHICH IS USED TO EXTRACT SINGLE
*        BYTE PACKED DECIMAL FIELDS WHICH ARE ASCENDING
*
OMCASE11 NC    OMPDSBA+2(4),KOMZERO    ZERO DISPLACEMENT
         NC    OMPDSBA+8(2),KOMZERO    FIELDS IN
         NC    OMPDSBA+12(2),KOMZERO   CODE TO BE
         NC    OMPDSBA+16(2),KOMZERO   INITIALIZED
         NC    OMPDSBA1+2(2),KOMZERO
         NC    OMPDSBA1+6(2),KOMZERO
         NC    OMPDSBA1+10(2),KOMZERO
         NC    OMPDSBA1+14(2),KOMZERO
         NC    OMPDSBA1+18(2),KOMZERO
         OC    OMPDSBA+4(2),0(R8)      SET D2 FIELD IN UNPK INST
         OC    OMPDSBA+8(2),0(R8)      SET D1 FIELD IN FIRST TM INST
         OC    OMPDSBA+16(2),0(R8)     SET D1 FIELD IN SECOND TM INST
         ST    R10,WOMHOLD             DISP IN EXTRACTED PORTION
         OC    OMPDSBA(4),WOMHOLD      SET D1 FIELD IN UNPK INST
         OC    OMPDSBA1+4(4),WOMHOLD   SET D1 FIELD IN NI INST
         OC    OMPDSBA1+8(4),WOMHOLD   SET D1 FIELD IN XI INST
         OC    OMPDSBA1+16(4),WOMHOLD  SET D1 FIELD IN OI INST
         LA    R4,34(,R5)              INC DISP IN EXTRACT ROUTINE
         ST    R4,WOMHOLD              DISP FOR BZ INSTRUCTION
         OC    OMPDSBA+10(4),WOMHOLD   SET D2 FIELD IN BZ INST
         LA    R4,4(,R4)               INCREMENT DISPLACEMENT BY 4
         ST    R4,WOMHOLD              DISP FOR BO AND BRANCH INSTRUCT
         OC    OMPDSBA1(4),WOMHOLD     SET D2 FIELD IN BO INST
         OC    OMPDSBA1+12(4),WOMHOLD  SET D2 FIELD IN BRANCH INST
         MVC   0(38,R12),OMPDSBA       MOVE SEGMENT TO EXTRACT ROUTINE
         LA    R12,38(,R12)            INCREMENT ADDR OF EXTRACT RTN
         LA    R5,38(,R5)              INCREMENT DISPLACEMT IN EXT RTN
         B     OMISITND
*
*        INITIALIZES THE CODE WHICH IS USED TO EXTRACT SINGLE
*        BYTE PACKED DECIMAL FIELDS WHICH ARE DECENDING
*
OMCASE12 NC    OMPDSBD+2(4),KOMZERO    ZERO DISPLACEMENT
         NC    OMPDSBD+8(2),KOMZERO    FIELDS IN
         NC    OMPDSBD+12(2),KOMZERO   CODE TO BE
         NC    OMPDSBD+16(2),KOMZERO   INITIALIZED
         NC    OMPDSBD1+2(2),KOMZERO
         NC    OMPDSBD1+6(2),KOMZERO
         NC    OMPDSBD1+10(2),KOMZERO
         NC    OMPDSBD1+14(2),KOMZERO
         NC    OMPDSBD1+18(2),KOMZERO
         OC    OMPDSBD+4(2),0(R8)      SET D2 FIELD IN IC INST
         OC    OMPDSBD+8(2),0(R8)      SET D1 FIELD IN FIRST TM INST
         OC    OMPDSBD+16(2),0(R8)     SET D1 FIELD IN SECOND TM INST
         ST    R10,WOMHOLD             DISP IN EXTRACTED PORTION
         OC    OMPDSBD(4),WOMHOLD      SET D1 FIELD IN UNPK INST
         OC    OMPDSBD1+12(4),WOMHOLD  SET D1 FIELD IN NI INST
         OC    OMPDSBD1+16(4),WOMHOLD  SET D1 FIELD IN XI INST
         OC    OMPDSBD1+4(4),WOMHOLD   SET D1 FIELD IN OI INST
         LA    R4,30(,R5)              INC DISP IN EXTRACT ROUTINE
         ST    R4,WOMHOLD              DISP FOR BZ AND BO INSTRUCTIONS
         OC    OMPDSBD+10(4),WOMHOLD   SET D2 FIELD IN BZ INST
         OC    OMPDSBD1(4),WOMHOLD     SET D2 FIELD IN BO INST
         LA    R4,8(0,R4)              INCREMENT DISPLACEMENT BY 8
         ST    R4,WOMHOLD              DISP FOR BRANCH INSTRUCTION
         OC    OMPDSBD1+8(4),WOMHOLD   SET D2 FIELD IN BRANCH INST
         MVC   0(38,R12),OMPDSBD       MOVE SEGMENT TO EXTRACT ROUTINE
         LA    R12,38(,R12)            INCREMENT ADDR OF EXTRACT RTN
         LA    R5,38(,R5)              INCREMENT DISPLACEMT IN EXT RTN
         B     OMISITND
*
*        INITIALIZES THE CODE WHICH IS USED TO EXTRACT SINGLE
*        BYTE UNPACKED DECIMAL FIELDS WHICH ARE ASCENDING
*
OMCASE13 NC    OMUDSBA+2(2),KOMZERO    ZERO DISPLACEMENT
         NC    OMUDSBA+6(2),KOMZERO    FIELDS IN
         NC    OMUDSBA+10(2),KOMZERO   CODE TO BE
         NC    OMUDSBA+14(2),KOMZERO   INITIALIZED
         NC    OMUDSBA+18(2),KOMZERO
         NC    OMUDSBA1+2(2),KOMZERO
         NC    OMUDSBA1+6(2),KOMZERO
         NC    OMUDSBA1+10(2),KOMZERO
         NC    OMUDSBA1+14(2),KOMZERO
         NC    OMUDSBA1+18(2),KOMZERO
         OC    OMUDSBA+2(2),0(R8)      SET D2 FIELD IN IC INST
         OC    OMUDSBA+10(2),0(R8)     SET D1 FIELD IN FIRST TM INST
         OC    OMUDSBA+18(2),0(R8)     SET D1 FIELD IN SECOND TM INST
         ST    R10,WOMHOLD             DISP IN EXTRACTED PORTION
         OC    OMUDSBA+4(4),WOMHOLD    SET D2 FIELD IN STC INST
         OC    OMUDSBA1+4(4),WOMHOLD   SET D1 FIELD IN NI INST
         OC    OMUDSBA1+8(4),WOMHOLD   SET D1 FIELD IN XI INST
         OC    OMUDSBA1+16(4),WOMHOLD  SET D1 FIELD IN OI INST
         LA    R4,36(0,R5)             INC DISP IN EXTRACT ROUTINE
         ST    R4,WOMHOLD              DISP FOR BZ INSTRUCTION
         OC    OMUDSBA+12(4),WOMHOLD   SET D2 FIELD IN BZ INST
         LA    R4,4(0,R4)              INCREMENT DISPLACEMENT BY 4
         ST    R4,WOMHOLD              DISP FOR BO AND BRANCH INSTRUCT
         OC    OMUDSBA1(4),WOMHOLD     SET D2 FIELD IN BO INST
         OC    OMUDSBA1+12(4),WOMHOLD  SET D2 FIELD IN BRANCH INST
         MVC   0(40,R12),OMUDSBA       MOVE SEGMENT TO EXTRACT ROUTINE
         LA    R12,40(0,R12)           INCREMENT ADDR OF EXTRACT RTN
         LA    R5,40(0,R5)             INCREMENT DISPLACEMT IN EXT RTN
         B     OMISITND
*
*        INITIALIZES THE CODE WHICH IS USED TO EXTRACT SINGLE
*        BYTE UNPACKED DECIMAL FIELDS WHICH ARE DECENDING
*
OMCASE14 NC    OMUDSBD+2(2),KOMZERO    ZERO DISPLACEMENT
         NC    OMUDSBD+6(2),KOMZERO    FIELDS IN
         NC    OMUDSBD+10(2),KOMZERO   CODE TO BE
         NC    OMUDSBD+14(2),KOMZERO   INITIALIZED
         NC    OMUDSBD+18(2),KOMZERO
         NC    OMUDSBD1+2(2),KOMZERO
         NC    OMUDSBD1+6(2),KOMZERO
         NC    OMUDSBD1+10(2),KOMZERO
         NC    OMUDSBD1+14(2),KOMZERO
         NC    OMUDSBD1+18(2),KOMZERO
         OC    OMUDSBD+2(2),0(R8)      SET D2 FIELD IN IC INST
         OC    OMUDSBD+10(2),0(R8)     SET D1 FIELD IN FIRST TM INST
         OC    OMUDSBD+18(2),0(R8)     SET D1 FIELD IN SECOND TM INST
         ST    R10,WOMHOLD             DISP IN EXTRACTED PORTION
         OC    OMUDSBD+4(4),WOMHOLD    SET D2 FIELD IN STC INST
         OC    OMUDSBD1+12(4),WOMHOLD  SET D1 FIELD IN NI INST
         OC    OMUDSBD1+16(4),WOMHOLD  SET D1 FIELD IN XI INST
         OC    OMUDSBD1+4(4),WOMHOLD   SET D1 FIELD IN OI INST
         LA    R4,32(,R5)              INC DISP IN EXTRACT ROUTINE
         ST    R4,WOMHOLD              DISP FOR BZ AND BO INSTRUCTIONS
         OC    OMUDSBD+12(4),WOMHOLD   SET D2 FIELD IN BZ INST
         OC    OMUDSBD1(4),WOMHOLD     SET D2 FIELD IN BO INST
         LA    R4,8(,R4)               INCREMENT DISPLACEMENT BY 8
         ST    R4,WOMHOLD              DISP FOR BRANCH INSTRUCTION
         OC    OMUDSBD1+8(4),WOMHOLD   SET D2 FIELD IN BRANCH INST
         MVC   0(40,R12),OMUDSBD       MOVE SEGMENT TO EXTRACT ROUTINE
         LA    R12,40(,R12)            INCREMENT ADDR OF EXTRACT RTN
         LA    R5,40(,R5)              INCREMENT DISPLACEMT IN EXT RTN
         B     OMISITND
*
*        INITIALIZES THE CODE WHICH IS USED TO EXTRACT UNSIGNED
*        BINARY BIT FIELDS WHICH ARE ASCENDING
*
OMCASE15 NC    OMUBBITA+2(4),KOMZERO   ZERO DISPLACEMENT
         NC    OMUBBITA+8(2),KOMZERO   FIELDS IN
         NC    OMUBBITA+12(2),KOMZERO  CODE TO BE
         NC    OMUBBITA+16(2),KOMZERO  INITIALIZED
         NC    OMUBBITA+20(2),KOMZERO
         SR    R3,R3                   ZERO REG
         STC   R3,OMUBBITA+7           ZERO MASK IN FIRST BRANCH INST
         STC   R3,OMUBBITA+15          ZERO MASK IN SECOND BRANCH INST
         OC    OMUBBITA+4(2),0(R8)     SET D2 FIELD IN MVC INST
         ST    R10,WOMHOLD             DISPLACEMT IN EXTRACTED PORTION
         OC    OMUBBITA(4),WOMHOLD     SET D1 FIELD IN MVC INST
         OC    OMUBBITA+10(4),WOMHOLD  SET D1 FIELD IN FIRST NI INST
         LA    R4,14(,R5)              INC DISP IN EXTRACT ROUTINE
         ST    R4,WOMHOLD              DISP FOR FIRST BRANCH INST
         OC    OMUBBITA+6(4),WOMHOLD   SET D2 FIELD IN FIRST BR INST
         LA    R4,8(,R4)               INC BY 8
         ST    R4,WOMHOLD              DISP FOR SECOND BRANCH INST
         OC    OMUBBITA+14(4),WOMHOLD  SET D2 FIELD IN SECOND BC INST
         IC    R3,3(,R8)               BYTE PORTION OF LENGTH OF CF
         SLL   R3,3                    MULTIPLY BY 8
         SR    R4,R4                   ZERO REGISTER
         IC    R4,4(,R8)               BITS PORTION OF LENGTH OF CF
         AR    R4,R3                   TOTAL THE BITS
         SR    R3,R3                   ZERO REGISTER
         IC    R3,2(,R8)               BITS PORTION OF DISP OF CF
         AR    R4,R3                   TOTAL THE BITS
         LR    R2,R4                   SAVE THIS BIT TOTAL
         LA    R4,7(,R4)               INCR TOTAL BY 7 FOR ROUNDING
         SRL   R4,3                    DIVIDE BY 8
         STC   R4,OMUBBITA+1           SET LENGTH FIELD IN MVC INST
         LR    R1,R4                   MOVE TO OTHER REGISTER
         LA    R4,255                  CONSTANT X'FF'
         NR    R1,R4                   MASK OUT HIGH ORDER BITS
         AR    R1,R10                  ADD DISP IN EXTRACTED PORTION
         ST    R1,WOMHOLD              DISP FOR D1 FIELD OF 2ND NI INST
         OC    OMUBBITA+18(4),WOMHOLD  SET D1 FIELD IN SECOND NI INST
         SRL   R4,0(R3)                FORM MASK FOR HIGH ORDER BITS
         STC   R4,OMUBBITA+11          SET MASK IN FIRST NI INST
         LTR   R3,R3                   TEST REGISTER FOR NON ZERO
         BNE   OMHIGHA                 BRANCH IF BITS TO ZERO
         LA    R4,240                  CONSTANT X'F0'
         STC   R4,OMUBBITA+7           SET FIRST BC INST TO BRANCH
OMHIGHA  LA    R3,7                    CONSTANT X'07'
         NR    R2,R3                   MASK OUT HIGH ORDER BITS
         LA    R4,8                    CONSTANT X'08'
         SR    R4,R2                   FORM SHIFT FOR LOW ORDER MASK
         LA    R3,255                  CONSTANT X'FF'
         SLL   R3,0(R4)                FORM MASK FOR LOW ORDER BITS
         STC   R3,OMUBBITA+19          SET MASK IN SECOND NI INST
         LTR   R2,R2                   TEST REGISTER FOR NON ZERO
         BNE   OMLOWA                  BRANCH IF BITS TO ZERO
         LA    R4,240                  CONSTANT X'F0'
         STC   R4,OMUBBITA+15          SET SECOND BC INST TO BRANCH
OMLOWA   MVC   0(22,R12),OMUBBITA      MOVE SEGMENT TO EXTRACT ROUTINE
         LA    R12,22(,R12)            INCREMENT ADDR OF EXTRACT RTN
         LA    R5,22(,R5)              INCREMENT DISPLACEMT IN EXT RRN
         B     OMISITND
*
*        INITIALIZES THE CODE WHICH IS USED TO EXTRACT UNSIGNED
*        BINARY BIT FIELDS WHICH ARE DECENDING
*
OMCASE16 NC    OMUBBITD+2(4),KOMZERO   ZERO DISPLACEMENT
         NC    OMUBBITD+8(2),KOMZERO   FIELDS IN
         NC    OMUBBITD+12(2),KOMZERO  CODE TO BE
         NC    OMUBBITD+16(2),KOMZERO  INITIALIZED
         NC    OMUBBITD+20(2),KOMZERO
         NC    OMUBBITD+24(4),KOMZERO
         SR    R3,R3                   ZERO REGISTER
         STC   R3,OMUBBITD+7           ZERO MASK IN FIRST BRANCH INST
         STC   R3,OMUBBITD+15          ZERO MASK IN SECOND BRANCH INST
         OC    OMUBBITD+4(2),0(R8)     SET D2 FIELD IN MVC INST
         ST    R10,WOMHOLD             DISPLACEMENT IN EXTRACTED PORTN
         OC    OMUBBITD(4),WOMHOLD     SET D1 FIELD IN MVC INST
         OC    OMUBBITD+10(4),WOMHOLD  SET D1 FIELD IN FIRST NI INST
         OC    OMUBBITD+22(4),WOMHOLD  SET D1 FIELD IN XC INST
         LA    R4,14(,R5)              INC DISP IN EXTRACT ROUTINE
         ST    R4,WOMHOLD              DISP FOR FIRST BRANCH INST
         OC    OMUBBITD+6(4),WOMHOLD   SET D2 FIELD IN FIRST BR INST
         LA    R4,8(,R4)               INC BY 8
         ST    R4,WOMHOLD              DISP FOR SECOND BRANCH INST
         OC    OMUBBITD+14(4),WOMHOLD  SET D2 FIELD IN SECOND BC INST
         ST    R7,WOMHOLD              DISP TO CONSTANT OF F'S
         OC    OMUBBITD+24(4),WOMHOLD  SET D2 FIELD IN XC INST
         IC    R3,3(,R8)               BYTE PORTION OF LENGTH OF CF
         SLL   R3,3                    MULTIPLY BY 8
         SR    R4,R4                   ZERO REG
         IC    R4,4(,R8)               BITS PORTION OF LENGTH OF CF
         AR    R4,R3                   TOTAL THE BITS
         SR    R3,R3                   ZERO REGISTER
         IC    R3,2(,R8)               BITS PORTION OF DISP OF CF
         AR    R4,R3                   TOTAL THE BITS
         LR    R2,R4                   SAVE THIS BIT TOTAL
         LA    R4,7(,R4)               INCR TOTAL BY 7 FOR ROUNDING
         SRL   R4,3                    DIVIDE BY 8
         STC   R4,OMUBBITD+1           SET LENGTH FIELD IN MVC INST
         STC   R4,OMUBBITD+23          SET LENGTH FIELD IN XC INST
         LR    R1,R4                   MOVE TO OTHER REGISTER
         LA    R4,255                  CONSTANT X'FF'
         NR    R1,R4                   MASK OUT HIGH ORDER BITS
         AR    R1,R10                  ADD DISP IN EXTRACTED PORTION
         ST    R1,WOMHOLD              DISP FOR D1 FIELD OF 2ND NI INST
         OC    OMUBBITD+18(4),WOMHOLD  SET D1 FIELD IN SECOND NI INST
         SRL   R4,0(R3)                FORM MASK FOR HIGH ORDER BITS
         STC   R4,OMUBBITD+11          SET MASK IN FIRST NI INST
         LTR   R3,R3                   TEST REGISTER FOR NON ZERO
         BNE   OMHIGHD                 BRANCH IF BITS TO ZERO
         LA    R4,240                  CONSTANT X'F0'
         STC   R4,OMUBBITD+7           SET FIRST BC INST TO BRANCH
OMHIGHD  LA    R3,7                    CONSTANT X'07'
         NR    R2,R3                   MASK OUT HIGH ORDER BITS
         LA    R4,8                    CONSTANT X'08'
         SR    R4,R2                   FORM SHIFT FOR LOW ORDER MASK
         LA    R3,255                  CONSTANT X'FF'
         SLL   R3,0(R4)                FORM MASK FOR LOW ORDER BITS
         STC   R3,OMUBBITD+19          SET MASK IN SECOND NI INST
         LTR   R2,R2                   TEST REGISTER FOR NON ZERO
         BNE   OMLOWD                  BRANCH IF BITS TO ZERO
         LA    R4,240                  CONSTANT X'F0'
         STC   R4,OMUBBITD+15          SET SECOND BC INST TO BRANCH
OMLOWD   MVC   0(28,R12),OMUBBITD      MOVE SEGMENT TO EXTRACT ROUTINE
         LA    R12,28(,R12)            INCREMENT ADDR OF EXTRACT RTN
         LA    R5,28(,R5)              INCREMENT DISPLACEMT IN EXT RTN
         B     OMISITND
*
*        INITIALIZES THE CODE WHICH IS USED TO EXTRACT THE TYPE
*        CONTROL FIELD LISTED -
*              1 ALPHAMERIC OR UNSIGNED BINARY BYTES WITH USER EXIT
*              2 SIGNED BINARY BYTES WITH USER EXIT
*              3 FLOATING POINT WITH USER EXIT
*              4 UNPACKED DECIMAL MULTI-BYTE WITH USER EXIT
*              5 PACKED DECIMAL MULTI-BYTE WITH USER EXIT
*              6 UNPACKED DECIMAL SINGLE-BYTE WITH USER EXIT
*              7 PACKED DECIMAL SINGLE-BYTE WITH USER EXIT
*
*
OMCASE17 NC    OMEXITS+2(4),KOMZERO    ZERO DISPLACEMENT FIELDS
         NC    OMEXITS+8(2),KOMZERO    IN CODE TO BE
         NC    OMEXITS+12(2),KOMZERO   INITIALIZED
         ST    R10,WOMHOLD             DISPLACEMT IN EXTRACTED PORTION
         OC    OMEXITS(4),WOMHOLD      SET D1 FIELD IN MVC INST
         OC    OMEXITS+4(2),0(R8)      SET D2 FIELD IN MVC INST
         MVC   OMEXITS+1(1),3(R8)      SET LENGTH FIELD IN MVC INST
         OC    OMEXITS+10(4),WOMHOLD   SET D2 FIELD IN SECOND LA INST
         LH    R4,PPINUMCF             GET NUMBER OF CONTROL FIELDS +
         LA    R4,1(,R4)               FOR USE AS COUNTER OF ORDER
*                                      FOR CONTROL FIELD FOR USER EXIT
         SR    R4,R9                   CALC WHICH CONTROL FIELD THIS IS
         STH   R4,OMEXITS+8            SET D2 FIELD IN FIRST LA INST
         MVC   0(32,R12),OMEXITS       MOVE SEGMENT TO EXTRACT ROUTINE
         LA    R12,32(,R12)            INCREMENT ADDR OF EXTRACT RTN
         LA    R5,32(,R5)              INCREMENT DISPLACEMT IN EXT RTN
         B     OMISITND
*
*        INITIALIZES THE CODE WHICH IS USED TO EXTRACT UNSIGNED
*        BINARY BIT FIELDS WITH USER EXIT
*
OMCASE24 NC    OMUBBITE+2(4),KOMZERO   ZERO DISPLACEMENT
         NC    OMUBBITE+8(2),KOMZERO   FIELDS IN
         NC    OMUBBITE+12(2),KOMZERO  CODE TO BE
         NC    OMUBBITE+16(2),KOMZERO  INITIALIZED
         NC    OMUBBITE+20(2),KOMZERO
         NC    OMUBBIT1+2(2),KOMZERO
         NC    OMUBBIT1+6(2),KOMZERO
         SR    R3,R3                   ZERO REGISTER
         STC   R3,OMUBBITE+7           ZERO MASK IN FIRST BRANCH INST
         STC   R3,OMUBBITE+15          ZERO MASK IN SECOND BRANCH INST
         OC    OMUBBITE+4(2),0(R8)     SET D2 FIELD IN MVC INST
         ST    R10,WOMHOLD             DISPLACEMENT IN EXTRACTED PORTON
         OC    OMUBBITE(4),WOMHOLD     SET D1 FIELD IN MVC INST
         OC    OMUBBITE+10(4),WOMHOLD  SET D1 FIELD IN FIRST NI INST
         LA    R4,14(,R5)              INC DISP IN EXTRACT ROUTINE
         ST    R4,WOMHOLD              DISP FOR FIRST BRANCH INST
         OC    OMUBBITE+6(4),WOMHOLD   SET D2 FIELD IN FIRST BR INST
         LA    R4,8(,R4)               INC BY 8
         ST    R4,WOMHOLD              DISP FOR SECOND BRANCH INST
         OC    OMUBBITE+14(4),WOMHOLD  SET D2 FIELD IN SECOND BC INST
         IC    R3,3(,R8)               BYTE PORTION OF LENGTH OF CF
         SLL   R3,3                    MULTIPLY BY 8
         SR    R4,R4                   ZERO REGISTER
         IC    R4,4(,R8)               BITS PORTION OF LENGTH OF CF
         AR    R4,R3                   TOTAL THE BITS
         SR    R3,R3                   ZERO REGISTER
         IC    R3,2(,R8)               BITS PORTION OF DISP OF CF
         AR    R4,R3                   TOTAL THE BITS
         LR    R2,R4                   SAVE THIS BIT TOTAL
         LA    R4,7(,R4)               INCR TOTAL BY 7 FOR ROUNDING
         SRL   R4,3                    DIVIDE BY 8
         STC   R4,OMUBBITE+1           SET LENGTH FIELD IN MVC INST
         LR    R1,R4                   MOVE TO OTHER REG
         LA    R4,255                  CONSTANT X'FF'
         NR    R1,R4                   MASK OUT HIGH ORDER BITS
         AR    R1,R10                  ADD DISP IN EXTRACTED PORTION
         ST    R1,WOMHOLD              DISP FOR D1 FIELD OF 2ND NI INST
         OC    OMUBBITE+18(4),WOMHOLD  SET D1 FIELD IN SECOND NI INST
         SRL   R4,0(R3)                FORM MASK FOR HIGH ORDER BITS
         STC   R4,OMUBBITE+11          SET MASK IN FIRST NI INST
         LTR   R3,R3                   TEST REGISTER FOR NON ZERO
         BNE   OMHIGHE                 BRANCH IF BITS TO ZERO
         LA    R4,240                  CONSTANT X'F0'
         STC   R4,OMUBBITE+7           SET FIRST BC INST TO BRANCH
OMHIGHE  LA    R3,7                    CONSTANT X'07'
         NR    R2,R3                   MASK OUT HIGH ORDER BITS
         LA    R4,8                    CONSTANT X'08'
         SR    R4,R2                   FORM SHIFT FOR LOW ORDER MASK
         LA    R3,255                  CONSTANT X'FF'
         SLL   R3,0(R4)                FORM MASK FOR LOW ORDER BITS
         STC   R3,OMUBBITE+19          SET MASK IN SECOND NI INST
         LTR   R2,R2                   TEST REGISTER FOR NON ZERO
         BNE   OMLOWE                  BRANCH IF BITS TO ZERO
         LA    R4,240                  CONSTANT X'F0'
         STC   R4,OMUBBITE+15          SET SECOND BC INST TO BRANCH
OMLOWE   ST    R10,WOMHOLD             DISPLACEMENT IN EXTRACTED PORTN
         OC    OMUBBIT1+4(4),WOMHOLD   SET D2 FIELD IN SECOND LA INST
         LH    R4,PPINUMCF             GET NUMBER OF CONTROL FIELDS +
         LA    R4,1(,R4)               FOR USE AS COUNTER OF ORDER
*                                      FOR CONTROL FIELD FOR USER EXIT
         SR    R4,R9                   CALC WHICH CONTROL FIELD THIS IS
         STH   R4,OMUBBIT1+2           SET D2 FIELD IN FIRST LA INST
         MVC   0(48,R12),OMUBBITE      MOVE SEGMENT TO EXTRACT ROUTINE
         LA    R12,48(,R12)            INCREMENT ADDR OF EXTRACT RTN
         LA    R5,48(,R5)              INCREMENT DISPLACEMT IN EXT RTN
         B     OMISITND
*
*        INCREMENT POSITION IN EXTRACTED PORTION BY LENGTH OF
*        THIS CONTROL FIELD
*
OMISITND CLI   5(R8),X'18'         CF UNPACKED DECIMAL ASCENDING ?
         BE    OMITISUD            YES, BRANCH
         CLI   5(R8),X'1C'         CF UNPACKED DECIMAL DECENDING ?
         BNE   OMNOTUD             NO, BRANCH
OMITISUD SR    R4,R4               ZERO REG
         IC    R4,3(,R8)           BYTE PORTION OF LENGTH OF LAST CF
         LA    R4,1(,R4)           INCREMENT BY ONE BYTE
         SRL   R4,1                DIVIDE BY 2
         B     OMSKIP
*
OMNOTUD  SR    R4,R4               ZERO REGISTER
         IC    R4,3(,R8)           BYTE PORTION OF LENGTH OF LAST CF
         SLL   R4,3                MULTIPLY BY 8
         SR    R3,R3               ZERO REGISTER
         IC    R3,4(,R8)           BITS PORTION OF LENGTH OF LAST CF
         AR    R4,R3               TOTAL THE BITS
         IC    R3,2(,R8)           BITS PORTION OF DISP OF LAST CF
         AR    R4,R3               TOTAL THE BITS
         LA    R4,7(,R4)           INCREMENT TOTAL BY 7 FOR ROUNDING
         SRL   R4,3                DIVIDE BY 8
OMSKIP   LA    R4,1(,R4)           INC BY ONE BYTE FOR ACTUAL DISP
         CL    R4,K256             256 BYTE FIELD ?
         BE    OMNOBIT             YES, BRANCH
         LA    R3,255              CONSTANT OF X'FF'
         B     OMNOBIT+4
*
OMNOBIT  LA    R3,511              CONSTANT OF X'1FF' FOR 256 BYTE FLD
         NR    R4,R3               KEEP LAST BYTE
OMNOBIT1 AR    R10,R4              INC DISP IN EXT PORTION BY LTH
*
*        INCREMENT TO CONTROL FIELD DATA FOR NEXT CONTROL FIELD
*        AND CHECK IF THE PREVIOUS FIELD WAS THE LAST
*
         LA    R8,6(,R8)           INCREMENT TO DATA FOR NEXT CF
         BCT   R9,OMNOLAST         LAST CONTROL FIELD
*
*        MOVE THE ENDING SEGMENT TO THE GENERATED EXTRACT
*        ROUTINE AND STORE THE LENGTH OF THE EXTRACTED FIELDS AS
*        REQUIRED FOR THE COMPARE INSTRUCTIONS AND AS AN ADDR
*        INCREMENT ROUNDED TO FULL WORDS IN PPIA
*
         LA    R3,5                CONSTANT OF 1+4
         SR    R10,R3              DECREMENT BY 1+4 (4 IS TREE ADDR)
         STH   R10,PPILEXFD        LTH OF EXTRACTED FIELDS FOR COMPARES
         LA    R10,4(,R10)         INC BY 3+1 BYTES TO ROUND TO FULL WD
         SRL   R10,2               SHIFT OFF 2 BITS
         SLL   R10,2               RESTORE TO POSITION
         STH   R10,PPILEXFF        LTH OF EXTRACTED FIELDS ROUNDED FULL
         MVC   0(2,R12),OMEND      MOVE ENDING SEGMENT TO EXTRACT ROUT
*
*        RETURN TO SSC
*
OMRETRN  L     R12,WOMRETNR        RESET REG SAVE ADDR
         SR    R15,R15             SET RETURN CODE REG TO ZERO
         LM    R2,R11,0(R12)       RESET SSC REGS
         BR    R14                 RETURN TO SSC
*
*        EXTRACT ALPHAMERIC OR UNSIGNED BINARY BYTE FIELDS WHICH
*        ARE ASCENDING
*
OMAOUBBA MVC   0(1,R3),0(R2)       MOVE CONTROL FIELD TO EXTRACT POSIT
*
*        EXTRACT ALPHAMERIC OR UNSIGNED BINARY BYTE FIELDS WHICH
*        ARE DECENDING
*
OMAOUBBD MVC   0(1,R3),0(R2)       MOVE CONTROL FIELD TO EXTRACT POSIT
         XC    0(1,R3),0(R12)      INVERT THIS CONTROL FIELD
*
*        EXTRACT NORMALIZED FLOATING POINT FIELDS WHICH ARE
*        ASCENDING
*
OMFLPTA  MVC   0(1,R3),0(R2)       MOVE CONTROL FIELD TO EXTRACT POSIT
         TM    0(R2),X'80'         TEST SIGN
         BZ    0(,R12)             PLUS, BRANCH
         XC    0(1,R3),0(R12)      INVERT THIS CONTROL FIELD
         B     0(,R12)
         XI    0(R3),X'80'         INVERT SIGN BIT
*
*        EXTRACT NORMALIZED FLOATING POINT FIELDS WHICH ARE
*        DECENDING
*
OMFLPTD  MVC   0(1,R3),0(R2)       MOVE CONTROL FIELD TO EXTRACT POSIT
         TM    0(R2),X'80'         TEST SIGN
         BO    0(,R12)             MINUS, BRANCH
         XI    0(R3),X'7F'         INVERT ALL BUT SIGN BIT OF BYTE ONE
         NOP   0(,R12)             BRANCH IF CF IS ONLY 1 BYTE
         XC    0(1,R3),0(R12)      INVERT REMAINDER OF FIELD
*
*        EXTRACT SIGNED BINARY BYTE FIELDS WHICH ARE ASCENDING
*
OMSBBA   MVC   0(1,R3),0(R2)       MOVE CONTROL FIELD TO EXTRACT POSIT
         XI    0(R3),X'80'         INVERT SIGN BIT
*
*        EXTRACT SIGNED BINARY BYTE FIELDS WHICH ARE DECENDING
*
OMSBBD   MVC   0(1,R3),0(R2)       MOVE CONTROL FIELD TO EXTRACT POSIT
         XI    0(R3),X'7F'         INVERT ALL BUT SIGN BIT OF BYTE ONE
         NOP   0(,R12)             BRANCH IF CF IS ONLY 1 BYTE
         XC    0(1,R3),0(R12)      INVERT REMAINDER OF FIELD
*
*        EXTRACT MULTI-BYTE UNPACKED DECIMAL FIELDS WHICH ARE
*        ASCENDING
*
OMUDMBA  PACK  0(1,R12),0(1,R2)    PACK CONTROL FIELD IN PACKING BUFFER
         UNPK  0(1,R3),0(1,R12)    SIGN BYTE FROM BUFFER TO EXTRACT POS
         MVO   0(2,R3),0(1,R12)    REMAINDER OF FIELD TO EXTRACT POSIT
         TM    0(R12),X'01'        TEST SIGN IN PACKING BUFFER
         BZ    0(,R12)             PLUS, BRANCH
OMUDMBA1 TM    0(R12),X'0F'        TEST SIGN IN PACKING BUFFER
         BO    0(,R12)             PLUS, BRANCH
         XI    0(R3),X'0F'         INVERT LAST FOUR BITS OF BYTE ONE
         XC    0(1,R3),0(R12)      INVERT REMAINDER OF FIELD
         B     0(,R12)
         OI    0(R3),X'F0'         SET SIGN TO PLUS
*
*        EXTRACT MULTIPLE-BYTE UNPACKED DECIMAL FIELDS WHICH ARE
*        DECENDING
*
OMUDMBD  PACK  0(1,R12),0(1,R2)    PACK CONTROL FIELD IN PACKING BUFFER
         UNPK  0(1,R3),0(1,R12)    SIGN BYTE FROM BUFFER TO EXTRACT POS
         MVO   0(2,R3),0(1,R12)    REMAINDER OF FIELD TO EXTRACT POSIT
         TM    0(R12),X'01'        TEST SIGN IN PACKING BUFFER
         BZ    0(,R12)             PLUS, BRANCH
OMUDMBD1 TM    0(R12),X'0F'        TEST SIGN IN PACKING BUFFER
         BO    0(,R12)             PLUS, BRANCH S
         OI    0(R3),X'F0'         SET SIGN TO PLUS
         B     0(,R12)
         XI    0(R3),X'0F'         INVERT LAST FOUR BITS OF BYTE ONE
         XC    0(1,R3),0(R12)      INVERT REMAINDER OF FIELD
*
*        EXTRACT MULTI-BYTE PACKED DECIMAL FIELDS WHICH ARE
*        ASCENDING
*
OMPDMBA  UNPK  0(1,R3),0(1,R2)     SIGN BYTE TO EXTRACT POSITION
         MVO   0(2,R3),0(1,R2)     REMAINDER OF FIELD TO EXTRACT POSIT
         TM    0(R2),X'01'         TEST SIGN WITH RECORD
         BZ    0(,R12)             PLUS, BRANCH
         TM    0(R2),X'0F'         TEST SIGN'WITH RECORD
OMPDMBA1 BO    0(,R12)             PLUS, BRANCH
         XI    0(R3),X'0F'         INVERT LAST FOUR BITS OF BYTE ONE
         XC    0(1,R3),0(R12)      INVERT REMAINDER OF FIELD
         B     0(,R12)
         OI    0(R3),X'F0'         SET SIGN TO PLUS
*
*        EXTRACT MULTIPLE-BYTE PACKED DECIMAL FIELDS WHICH ARE
*        DECENDING
*
OMPDMBD  UNPK  0(1,R3),0(1,R2)     SIGN BYTE TO EXTRACT POSITION
         MVO   0(2,R3),0(1,R2)     REMAINDER OF FIELD TO EXTRACT POSIT
         TM    0(R2),X'01'         TEST SIGN WITH RECORD
         BZ    0(,R12)             PLUS, BRANCH
         TM    0(R2),X'0F'         TEST SIGN WITH RECORD
OMPDMBD1 BO    0(,R12)             PLUS, BRANCH
         OI    0(R3),X'F0'         SET SIGN TO PLUS
         B     0(,R12)
         XI    0(R3),X'0F'         INVERT LAST FOUR BITS OF BYTE ONE
         XC    0(1,R3),0(R12)      INVERT REMAINDER OF FIELD
*
*        EXTRACT SINGLE BYTE PACKED DECIMAL FIELDS WHICH ARE
*        ASCENDING
*
OMPDSBA  UNPK  0(1,R3),0(1,R2)     SIGN BYTE TO EXTRACT POSITION
         TM    0(R2),X'01'         TEST SIGN WITH RECORD
         BZ    0(,R12)             PLUS, BRANCH
         TM    0(R2),X'0F'         TEST SIGN WITH RECORD
OMPDSBA1 BO    0(,R12)             PLUS, BRANCH
         NI    0(R3),X'0F'         SET SIGN MINUS
         XI    0(R3),X'0F'         INVERT LAST FOUR BITS OF BYTE
         B     0(,R12)
         OI    0(R3),X'F0'         SET SIGN PLUS
*
*        EXTRACT SINGLE BYTE PACKED DECIMAL FIELDS WHICH ARE
*        DECENDING
*
OMPDSBD  UNPK  0(1,R3),0(1,R2)     SIGN BYTE TO EXTRACT POSITION
         TM    0(R2),X'01'         TEST SIGN'WITH RECORD
         BZ    0(,R12)             PLUS, BRANCH
         TM    0(R2),X'0F'         TEST SIGN'WITH RECORD
OMPDSBD1 BO    0(,R12)             PLUS, BRANCH
         OI    0(R3),X'F0'         SET SIGN PLUS
         B     0(,R12)
         NI    0(R3),X'0F'         SET SIGN MINUS
         XI    0(R3),X'0F'         INVERT LAST FOUR BITS OF BYTE
*
*        EXTRACT SINGLE BYTE UNPACKED DECIMAL FIELDS WHICH ARE
*        ASCENDING
*
OMUDSBA  IC    R5,0(0,R2)          LOAD CONTROL FIELD
         STC   R5,0(0,R3)          STORE CONTROL FIELD IN EXTRACT POSIT
         TM    0(R2),X'10'         TEST SIGN WITH RECORD
         BZ    0(,R12)             PLUS, BRANCH
         TM    0(R2),X'F0'         TEST SIGN WITH RECORD
OMUDSBA1 BO    0(,R12)             PLUS, BRANCH
         NI    0(R3),X'0F'         SET SIGN MINUS
         XI    0(R3),X'0F'         INVERT LAST FOUR BITS OF BYTE
         B     0(,R12)
         OI    0(R3),X'F0'         SET SIGN PLUS
*
*        EXTRACT SINGLE BYTE UNPACKED DECIMAL FIELDS WHICH ARE
*        DECENDING
*
OMUDSBD  IC    R5,0(0,R2)          LOAD CONTROL FIELD
         STC   R5,0(0,R3)          STORE CONTROL FIELD IN EXTRACT POSIT
         TM    0(R2),X'10'         TEST SIGN WITH RECORD
         BZ    0(,R12)             PLUS, BRANCH
         TM    0(R2),X'F0'         TEST SIGN WITH RECORD
OMUDSBD1 BO    0(,R12)             PLUS, BRANCH
         OI    0(R3),X'F0'         SET SIGN PLUS
         B     0(,R12)
         NI    0(R3),X'0F'         SET SIGN MINUS
         XI    0(R3),X'0F'         INVERT LAST FOUR BITS OF BYTE
*
*        EXTRACT UNSIGNED BINARY BIT FIELDS WHICH ARE ASCENDING
*
OMUBBITA MVC   0(1,R3),0(R2)       MOVE CONTROL FIELD TO EXTRACT POSIT
         NOP   0(,R12)             BRANCH IF NO HIGH ORDER BITS TO ZERO
         NI    0(R3),X'00'         ZERO NECESSARY HIGH ORDER BITS
         NOP   0(,R12)             BRANCH IF NO LOW ORDER BITS TO ZERO
         NI    0(R3),X'00'         ZERO NECESSARY LOW ORDER BITS
*
*        EXTRACT UNSIGNED BINARY BIT FIELDS WHICH ARE DECENDING
*
OMUBBITD MVC   0(1,R3),0(R2)       MOVE CONTROL FIELD TO EXTRACT POSIT
         NOP   0(,R12)             BRANCH IF NO HIGH ORDER BITS TO ZERO
         NI    0(R3),X'00'         ZERO NECESSARY HIGH ORDER BITS
         NOP   0(,R12)             BRANCH IF NO LOW ORDER BITS TO ZERO
         NI    0(R3),X'00'         ZERO NECESSARY LOW ORDER BITS
         XC    0(1,R3),0(R12)      INVERT ALL OF FIELD
*
*        EXTRACT THE TYPE CONTROL FIELD LISTED -
*              1 ALPHAMERIC OR UNSIGNED BINARY BYTES WITH USER EXIT
*              2 SIGNED BINARY BYTES WITH USER EXIT
*              3 FLOATING POINT WITH USER EXIT
*              4 UNPACKED DECIMAL MULTI-BYTE WITH USER EXIT
*              5 PACKED DECIMAL MULTI-BYTE WITH USER EXIT
*              6 UNPACKED DECIMAL SINGLE-BYTE WITH USER EXIT
*              7 PACKED DECIMAL SINGLE-BYTE WITH USER EXIT
*
OMEXITS  MVC   0(1,R3),0(R2)       MOVE CONTROL FIELD TO EXTRACT POSIT
         LA    R0,0                WHICH CONTROL FIELD THIS IS
         LA    R1,0(,R3)           ADDR OF THIS CF IN EXTRACTED PORTION
         STM   R0,R1,PPILAB01      STORE AS PARAMETER LIST FOR USER
         LA    R1,PPILAB01         SET ADDR OF PARAMETER LIST
         LR    R4,R14              SAVE NETWORK RETURN ADDR
         L     R15,0(,R12)         ADDR OF USER EXIT
         BASR  R14,R15             LINK TO USER EXIT
         LR    R14,R4              RESTORE NETWORK RETURN ADDR
*
*        EXTRACT UNSIGNED BINARY BIT FIELDS WITH USER EXIT
*
OMUBBITE MVC   0(1,R3),0(R2)       MOVE CONTROL FIELD TO EXTRACT POSIT
         NOP   0(,R12)             BRANCH IF NO HIGH ORDER BITS TO ZERO
         NI    0(R3),X'00'         ZERO NECESSARY HIGH ORDER BITS
         NOP   0(,R12)             BRANCH IF NO LOW ORDER BITS TO ZERO
         NI    0(R3),X'00'         ZERO NECESSARY LOW ORDER BITS
OMUBBIT1 LA    R0,0                WHICH CONTROL FIELD THIS IS
         LA    R1,0(,R3)           ADDR OF THIS CF IN EXTRACTED PORTION
         STM   R0,R1,PPILAB01      STORE AS PARAMETER LIST FOR USER
         LA    R1,PPILAB01         SET ADDR OF PARAMETER LIST
         LR    R4,R14              SAVE NETWORK RETURN ADDR
         L     R15,0(,R12)         ADDR OF USER EXIT
         BASR  R14,R15             LINK TO USER EXIT
         LR    R14,R4              RESTORE NETWORK RETURN ADDR
*
*        THE FOLLOWING CODE IS INSERTED AT THE END OF THE
*        PREVIOUSLY GENERATED EXTRACT SEGMENTS
*
*        THIS CODE IS FOLLOWED BY THE REQUIRED CONSTANTS WHICH
*        WERE GENERATED INTO THE EXTRACT AREA AT THE START
*
OMEND    BR    R14                 RETURN TO NETWORK
*
*        CONSTANTS
*
KOMZERO  DC    X'F000F000'         USED TO ZERO DISPLACEMENT FIELDS
K256     DC    A(256)              CONSTANT OF 256
K12      DC    H'12'
K16      DC    H'15'
*
         LTORG                     TO ENSURE ADDRESSABILITY
*
*        WORK AREAS
*
WOMHOLD  DC    F'0'                CONTAIN DISP FIELD FOR ORING
WOMRETNR DC    F'0'                SAVE REGISTER SAVE ADDR
*
*        INITIALIZES THE CODE WHICH IS USED TO EXTRACT UNPACKED
*        DECIMAL FIELDS WHICH ARE ASCENDING AND WHOSE LENGTHS ARE
*        BETWEEN 17 AND 32 BYTES
*
LONGINIT DC    0F'0'
*
OMCASE7L NC    OMUDLA+2(4),KOMZERO      ZERO DISPLACEMENT
         NC    OMUDLA+8(4),KOMZERO      FIELDS IN CODE
         NC    OMUDLA+14(4),KOMZERO     TO BE INITIALIZED
         NC    OMUDLA+20(4),KOMZERO
         NC    OMUDLA+26(2),KOMZERO
         NC    OMUDLA+30(2),KOMZERO
         NC    OMUDLA1+2(2),KOMZERO
         NC    OMUDLA1+6(2),KOMZERO
         NC    OMUDLA1+10(2),KOMZERO
         NC    OMUDLA1+14(4),KOMZERO
         NC    OMUDLA1+20(2),KOMZERO
         NC    OMUDLA1+24(2),KOMZERO
         SR    R3,R3                    ZERO REG
         IC    R3,3(,R8)                BYTE PORTION OF LENGTH OF CF
         SH    R3,K16                   SUBTRACT 16
         LA    R4,1(,R3)                ADD ONE FOR ROUNDING
         SRL   R4,1                     DIVIDE BY TWO
         LR    R2,R4                    SAVE L1 FIELD FOR FIRST PACK
*                                       INSTRUCTION
         SLL   R4,4                     MOVE TO POSITION FOR L1 FIELD
         BCTR  R3,0                     DECREMENT BY ONE TO OBTAIN L2
         OR    R4,R3                    COMBINE L1 AND L2 IN ONE BYTE
         STC   R4,OMUDLA+1              SET LENGTH FIELDS IN FIRST PACK
         LA    R4,7(,R2)                L FIELD FOR
         STC   R4,OMUDLA1+13            XC INSTRUCTION
         ST    R10,WOMHOLD              DISP IN THE EXTRACTED PORTION
         OC    OMUDLA(4),WOMHOLD        D1 FIELD IN FIRST PACK
         OC    OMUDLA1+8(4),WOMHOLD     D FIELD IN XI
         OC    OMUDLA1+22(4),WOMHOLD    D FIELD IN OI
         LA    R4,1(,R10)               OBTAIN D1 FIELD
         ST    R4,WOMHOLD               FOR
         OC    OMUDLA1+12(4),WOMHOLD    XC INSTRUCTION
         LA    R4,8(R2,R10)             OBTAIN D1 FIELD
         ST    R4,WOMHOLD               FOR
         OC    OMUDLA+12(4),WOMHOLD     UNPK INSTRUCTION
         LA    R4,1(R2,R10)             OBTAIN D1 FILD
         ST    R4,WOMHOLD               FOR
         OC    OMUDLA+18(4),WOMHOLD     MVO INSTRUCTION
         OC    OMUDLA+4(2),0(R8)        D2 FIELD IN FIRST PACK
         LH    R4,0(,R8)                OBTAIN DISP TO CF
         LA    R4,1(R4,R3)              CALCULATE D2 FOR SECOND PACK
         ST    R4,WOMHOLD               INIT SECOND
         OC    OMUDLA+8(4),WOMHOLD      PACK INSTRUCTION
         ST    R6,WOMHOLD               DISP TO PACKING BUFFER
         OC    OMUDLA+6(4),WOMHOLD      D1 FIELD FOR SECOND PACK
         OC    OMUDLA+20(4),WOMHOLD     D2 FIELD FOR MVO
         LA    R4,8(,R6)                OBTAIN DISPLACEMENT TO LAST
         ST    R4,WOMHOLD               BYTE OF THE PACKING BUFFER
         OC    OMUDLA+14(4),WOMHOLD     D2 FIELD FOR UNPK
         OC    OMUDLA+24(4),WOMHOLD     D FIELD IN FIRST TM
         OC    OMUDLA1(4),WOMHOLD       D FIELD IN SECOND TM
         ST    R7,WOMHOLD               DISP TO STRING OF FFS
         OC    OMUDLA1+14(4),WOMHOLD    D2 FIELD IN XC
         LA    R4,54(,R5)               INC DISP IN EXTRACT ROUTINE
         ST    R4,WOMHOLD               DISP FOR BZ AND BO
         OC    OMUDLA+28(4),WOMHOLD     D FIELD IN BZ
         OC    OMUDLA1+4(4),WOMHOLD     D FIELD IN BO
         LA    R4,4(,R4)                INCREMENT BY FOUR
         ST    R4,WOMHOLD               DISP FOB B INSTRUCTION
         OC    OMUDLA1+18(4),WOMHOLD    D FIELD IN B INSTRUCTION
         MVC   0(58,R12),OMUDLA         MOVE SEGMENT TO EXTRACT ROUTINE
OMZDLEX  LA    R5,58(,R5)               INCREMENT DISP IN EXT ROUTINE
         LA    R12,58(,R12)             INCREMENT ADDRESS OF EXT ROUT
         LR    R4,R2                    CALCULATE ACTUAL LENGTH OF
         LA    R4,9(,R4)                EXTRACTED PORTION OF CF
         B     OMNOBIT1
*
*        INITIALIZES THE CODE WHICH IS USED TO EXTRACT UNPACKED
*        DECIMAL FIELDS WHICH ARE DESCENDING AND WHOSE LENGTHS
*        ARE BETWEEN 17 AND 32 BYTES
*
OMCASE8L NC    OMUDLD+2(4),KOMZERO      ZERO DISPLACEMENT
         NC    OMUDLD+8(4),KOMZERO      FIELDS IN CODE
         NC    OMUDLD+14(4),KOMZERO     TO BE INITIALIZED
         NC    OMUDLD+20(4),KOMZERO
         NC    OMUDLD+26(2),KOMZERO
         NC    OMUDLD+30(2),KOMZERO
         NC    OMUDLD1+2(2),KOMZERO
         NC    OMUDLD1+6(2),KOMZERO
         NC    OMUDLD1+10(2),KOMZERO
         NC    OMUDLD1+14(2),KOMZERO
         NC    OMUDLD1+18(2),KOMZERO
         NC    OMUDLD1+22(4),KOMZERO
         SR    R3,R3                    ZERO REG
         IC    R3,3(,R8)                BYTE PORTION OF LENGTH OF CF
         SH    R3,K16                   SUBTRACT 16
         LA    R4,1(,R3)                ADD ONE FOR ROUNDING
         SRL   R4,1                     DIVIDE BY TWO
         LR    R2,R4                    SAVE L1 FIELD FOR FIRST PACK
*                                       INSTRUCTION
         SLL   R4,4                     MOVE TO POSITION FOR L1 FIELD
         BCTR  R3,0                     DECREMENT BY ONE TO OBTAIN L2
         OR    R4,R3                    COMBINE L1 AND L2 IN ONE BYTE
         STC   R4,OMUDLD+1              SET LENGTH FIELDS IN FIRST PACK
         LA    R4,7(,R2)                L FIELD FOR
         STC   R4,OMUDLD1+21            XC INSTRUCTION
         ST    R10,WOMHOLD              DISP IN THE EXTRACTED PORTION
         OC    OMUDLD(4),WOMHOLD        D1 FIELD IN FIRST PACK
         OC    OMUDLD1+8(4),WOMHOLD     D FIELD IN OI
         OC    OMUDLD1+16(4),WOMHOLD    D FIELD IN XI
         LA    R4,1(,R10)               OBTAIN D1 FIELD
         ST    R4,WOMHOLD               FOR
         OC    OMUDLD1+20(4),WOMHOLD    XC INSTRUCTION
         LA    R4,8(R2,R10)             OBTAIN D1 FIELD
         ST    R4,WOMHOLD               FOR
         OC    OMUDLD+12(4),WOMHOLD     UNPK INSTRUCTION
         LA    R4,1(R2,R10)             OBTAIN D1 FIELD
         ST    R4,WOMHOLD               FOR
         OC    OMUDLD+18(4),WOMHOLD     MVO INSTRUCTION
         OC    OMUDLD+4(2),0(R8)        D2 FIELD IN FIRST PACK
         LH    R4,0(,R8)                OBTAIN DISP TO CF
         LA    R4,1(R4,R3)              CALCULATE D2 FOR SECOND PACK
         ST    R4,WOMHOLD               INIT SECOND
         OC    OMUDLD+8(4),WOMHOLD      PACK INSTRUCTION
         ST    R6,WOMHOLD               DISP TO PACKING BUFFER
         OC    OMUDLD+6(4),WOMHOLD      D1 FIELD FOR SECOND PACK
         OC    OMUDLD+20(4),WOMHOLD     D2 FIELD FOR MVO
         LA    R4,8(,R6)                OBTAIN DISPLACEMENT TO LAST
         ST    R4,WOMHOLD               BYTE OF THE PACKING BUFFER
         OC    OMUDLD+14(4),WOMHOLD     D2 FIELD FOR UNPK
         OC    OMUDLD+24(4),WOMHOLD     D FIELD IN FIRST TM
         OC    OMUDLD1(4),WOMHOLD       D FIELD IN SECOND TM
         ST    R7,WOMHOLD               DISP TO STRING OF FFS
         OC    OMUDLD1+22(4),WOMHOLD    D2 FIELD IN XC
         LA    R4,48(,R5)               INC DISP IN EXTRACT ROUTINE
         ST    R4,WOMHOLD               DISP FOR BZ AND BO
         OC    OMUDLD+28(4),WOMHOLD     D FIELD IN BZ
         OC    OMUDLD1+4(4),WOMHOLD     D FIELD IN BO
         LA    R4,10(0,R4)              INCREMENT BY TEN
         ST    R4,WOMHOLD               DISP FOR B INSTRUCTION
         OC    OMUDLD1+12(4),WOMHOLD    D FIELD IN B INSTRUCTION
         MVC   0(58,R12),OMUDLD         MOVE SEGMENT TO EXTRACT ROUTINE
         B     OMZDLEX
*
*        INITIALIZES THE CODE WHICH IS USED TO EXTRACT MULTI-
*        BYTE PACKED DECIMAL FIELDS WHICH ARE ASCENDING
*
OMCASE9L NC    OMPDMBA+2(4),KOMZERO    ZERO DISPLACEMENT
         NC    OMPDMBA+8(4),KOMZERO    FIELDS IN
         NC    OMPDMBA+14(2),KOMZERO   CODE TO BE
         NC    OMPDMBA+18(2),KOMZERO   INITIALIZED
         NC    OMPDMBA+22(2),KOMZERO
         NC    OMPDMBA1+2(2),KOMZERO
         NC    OMPDMBA1+6(2),KOMZERO
         NC    OMPDMBA1+10(4),KOMZERO
         NC    OMPDMBA1+16(2),KOMZERO
         NC    OMPDMBA1+20(2),KOMZERO
         SR    R4,R4               ZERO REG
         IC    R4,3(,R8)           BYTE PORTION OF LENGTH OF THIS CF
         LR    R3,R4               SAVE LENGTH OF THIS CF
         AH    R4,0(,R8)           DISPLACEMENT OF THIS CF
         ST    R4,WOMHOLD          DISPLACEMENT OF SIGN BYTE OF THIS CF
         OC    OMPDMBA+2(4),WOMHOLD    SET D2 FIELD OF UNPACK INST
         OC    OMPDMBA+12(4),WOMHOLD   SET D1 FIELD OF FIRST TM INST
         OC    OMPDMBA+20(4),WOMHOLD   SET D1 FIELD OF SECOND TM INST
         OC    OMPDMBA+10(2),0(R8)     SET D2 FIELD OF MVO INST
         ST    R10,WOMHOLD         DISPLACEMENT IN EXTRACTED PORTION
         OC    OMPDMBA+6(4),WOMHOLD    SET D1 FIELD IN MVO INST
         OC    OMPDMBA1+4(4),WOMHOLD   SET D1 FIELD IN XI INST
         OC    OMPDMBA1+18(4),WOMHOLD  SET D1 FIELD IN OI INST
         LA    R4,1(,R10)          DISP IN EXTRACTED PORTION PLUS 1
         ST    R4,WOMHOLD          STORE DISPLACEMENT
         OC    OMPDMBA1+8(4),WOMHOLD   SET D1 FIELD IN XC INST
         LR    R4,R3               LENGTH OF CF
         AR    R4,R10              DISP IN EXTRACTED PORTION
         ST    R4,WOMHOLD          DISPLACEMENT TO SIGN BYTE
         OC    OMPDMBA(4),WOMHOLD  SET D1 FIELD IN UNPACK INST
         LA    R2,1                CONSTANT OF 1
         LR    R4,R3               LENGTH OF CF
         SR    R4,R2               DECREMENT BY ONE
         STC   R4,OMPDMBA1+9       SET LENGTH FIELD IN XC INST
         SLL   R3,4                PREPARE L1 FIELD FOR MVO INST
         OR    R4,R3               COMBINE LI AND L2 FIELDS
         STC   R4,OMPDMBA+7        SET LENGTH FIELDS IN MVO INST
         ST    R7,WOMHOLD          DISPLACEMENT TO CONSTANT OF F'S
         OC    OMPDMBA1+10(4),WOMHOLD  SET D2 FIELD IN XC INST
         LA    R4,42(,R5)          INC DISP IN EXTRACT ROUTINE
         ST    R4,WOMHOLD          DISP FOR BZ AND BO INSTRUCTIONS
         OC    OMPDMBA+16(4),WOMHOLD   SET D2 FIELD IN BZ INST
         OC    OMPDMBA1(4),WOMHOLD     SET D2 FIELD IN BO INST
         LA    R4,4(,R4)           INC DISPLACEMENT BY 4
         ST    R4,WOMHOLD          DISP FOR BRANCH INST
         OC    OMPDMBA1+14(4),WOMHOLD  SET D2 FIELD IN BRANCH INST
         MVC   0(46,R12),OMPDMBA   MOVE SEGMENT TO EXTRACT ROUTINE
         LA    R12,46(,R12)        INCREMENT ADDR OF EXTRACT ROUTINE
         LA    R5,46(,R5)          INCREMENT DISPLACEMENT IN EXT RTN
         B     OMISITND
*
*        THE FOLLOWING CODE IS USED TO EXTRACT UNPACKED DECIMAL
*        FIELDS WHICH ARE ASCENDING AND WHOSE LENGTHS ARE BETWEEN
*        17 AND 32 BYTES
*
OMUDLA   PACK  0(1,R3),0(1,R2)          PACK THE FIRST (LENGTH-16)
*                                       BYTES OF CF INTO EXTRACT POS
         PACK  0(9,R12),0(16,R2)        PACK REMAINING 16 BYTES
*                                       INTO PACKING BUFFER
         UNPK  0(1,R3),0(1,R12)         SIGN BYTE FROM BUF TO EXT POS
         MVO   0(8,R3),0(8,R12)         REMAINDER OF PACK BUF TO EXT PO
         TM    0(R12),X'01'             TEST SIGN IN PACK BUFFER
         BZ    0(,R12)                  PLUS, BRANCH
OMUDLA1  TM    0(R12),X'0F'             TEST SIGN IN PACK BUF
         BO    0(,R12)                  PLUS, BRANCH
         XI    0(R3),X'0F'              INVERT LAST 4 BITS OF BYTE ONE
         XC    0(1,R3),0(R12)           INVERT REMAINDER OF FIELD
         B     0(,R12)                  BRANCH *+8
         OI    0(R3),X'F0'              SET SIGN TO PLUS
*
*        THE FOLLOWING CODE IS USED TO EXTRACT UNPACKED DECIMAL
*        FIELDS WHICH ARE DESCENDING AND WHOSE LENGTHS ARE
*        BETWEEN 17 AND 32 BYTES
*
OMUDLD   PACK  0(1,R3),0(1,R2)          PACK THE FIRST (LENGTH-16)
*                                       BYTES OF CF INTO EXTRACT POS
         PACK  0(9,R12),0(16,R2)        PACK REMAINING 16 BYTES
*                                       INTO PACKING BUFFER
         UNPK  0(1,R3),0(1,R12)         SIGN BYTE FROM BUF TO EXT POS
         MVO   0(8,R3),0(8,R12)         REMAINDER OF PACK BUF TO EXT PO
         TM    0(R12),X'01'             TEST SIGN IN PACK BUFFER
         BZ    0(,R12)                  PLUS, BRANCH TO XI
OMUDLD1  TM    0(R12),X'0F'             TEST SIGN IN PACK BUFFER
         BO    0(,R12)                  PLUS, BRANCH TO XI
         OI    0(R3),X'F0'              SET SIGN TO PLUS
         B     0(,R12)                  BRANCH *+14
         XI    0(R3),X'0F'              INVERT LAST FOUR BITS OF BYTE 1
         XC    0(0,R3),0(R12)           INVERT REMAINDER OF FIELD
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERAON   0101-20211-20211-1200-00215-00215-00000-RELEASE 00
AON      TITLE 'IERAON - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERAON
*
*        MODULE FUNCTION/OPERATION -
*        ASSIGNMENT ROUTINE FOR THE OSCILLATING ALGORITHM
*        INITIALIZES CONSTANTS IN RUNNING PROGRAM AND PPI.
*        BUILDS THE SEQUENCE DISTRIBUTION TABLE IN GENERATED
*        CORE. IT INITIALIZES THE ODOMETER TABLE. IT ALSO
*        CALCULATES THE RMAX VALUE FOR THE CAPACITY OF A
*        WORKTAPE
*
*        USED AS A DSECT IN - N/A
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                       CALLING SEQUENCE -
*                           L    R15,ASSG
*                           BALR R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIALG     PPITDTBL
*        PPIMRGMX   PPICNTL
*        PPISPGN1   PPIODOM
*        PPIDEPHO
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPIBDSVA - SET TO NO WORK UNITS (1 BYTE)
*        PPISPGN1 - UPDATED
*        TABLES ARE INITIALIZED
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL -
*        BR R14 - RETURN TO IERRC9
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS - N/A
*
*        NOTES -
*        THIS MODULE IS USED WHEN THE OSCILLATING TECHNIQUE IS
*        SELECTED
*
IERAON   CSECT
*
         USING *,R11               MODULE BASE REGISTER
         USING DIERRON,R8          BASE REG FOR ALGORITHM DSECT
         USING IERRCA,R13          PPI COMMON BASE REGISTER
*
         LR    R11,R15             SET BASE REG
         L     R8,PPIALG+4         SET BASE REG FOR DSECT
         LH    R1,PPIMRGMX         SET MERGE ORDER IN RUNNING PROGRAM
         STH   R1,KMRG
         STH   R1,KMRGMX
         BCTR  R1,0                DECREMENT R1
         STH   R1,KMRG1
         STH   R1,KNM2             SET NO WORK UNITS IN PPI AND
         LA    R1,2(,R1)           RUNNING PROGRAM
         ST    R1,KTTCNT
         STH   R1,KWKUNTS
         STC   R1,PPIBDSVA
*
*        TEST IF CHECKPOINT/RESTART IS ACTIVE
*        IF ACTIVE MODIFY THE CONDITION CODE OF THE NECESSARY
*        INSTRUCTION IN IERRON SO THAT IT WILL BECOME A NOP
*
         PPITEST  PPICHKPT         CHECKPOINT REQUESTED ?
         BZ    AON100              NO, BRANCH
         MVI   RON0200+1,X'00'     MODIFY THE INSTRUCTION
         MVI   RON391+1,X'00'      MODIFY THE INSTRUCTION
*
*        BUILD SEQUENCE DISTRIBUTION TABLE IN GENERATED CORE
*
AON100   L     R2,PPISPGN1
         SRL   R2,2                GEN CORE ADDR - (NO WORK UNITS * 4)
         SLL   R2,2
         SLL   R1,2
         SR    R2,R1
         ST    R2,KASEQTAB         SET TABLE ADDR IN IERRON
         ST    R2,PPISPGN1
         SH    R1,K2
         STC   R1,AON010+1
         MVI   0(R2),X'00'
AON010   MVC   1(0,R2),0(R2)
*
*        SET TABLE ADDR AND CONSTANTS IN IERRON
*
         LA    R2,PPITPTBL         SET DEPHO TO INDICATE FIRST OUTPUT
         MVC   PPIDEPHO+3(1),1(R2)   UNIT
         ST    R2,KLOWLMT          SET UPPER AND LOWER TAPE TABLE LMT
         ST    R2,KATPTBL
         ST    R2,KTTSV
         LH    R1,PPIMRGMX         (NO WORK UNITS - 1) * 2
         SLL   R1,1
         A     R1,KLOWLMT
         ST    R1,KUPLMT
         LA    R1,PPIODOM          SET ODOMETER ADDRS
         ST    R1,KAODOM
         IC    R1,PPIBDSVA
         SLL   R1,2
         BCTR  R1,0                DECR R1
         BCTR  R1,0                DECR R1
         STC   R1,RON400+1
*
*        SET SEQUENCE MASK ACCORDING TO COLLATING ORDER FOR EACH
*        LEVEL
*
         PPITEST  PPIPH1CO         COLLATING ORDER DESCENDING ?
         BO    AON070              YES, BRANCH
         L     R2,KMSKASC
AON020   ST    R2,KSEQMSK
         PPITEST  PPIUOSEQ         USERS OUTPUT SEQUENCE DESCENDING ?
         BO    AON080              YES, BRANCH
         IC    R2,KUSRASC          ASC
AON025   STC   R2,KUSEROUT
*
*        INITIALIZE ODOMETER TABLE
*
*        SET ALL EVEN LEVEL ODOMETERS TO FIRST UNIT IN TAPE TABLE
*        SET ALL ODD LEVEL ODOMETERS TO LAST LEVEL IN TAPE TABLE
*
         LA    R3,PPIODOM
         LA    R1,16
         L     R4,KLOWLMT
         L     R5,KUPLMT
AON030   ST    R4,0(,R3)
         LA    R3,4(,R3)
         BCT   R1,AON090           DECR R1 BEFORE BRANCH
*
*        SET OPEN BIT ON FOR EACH WORK UNIT
*
AON040   LA    R4,PPITPTBL
         LH    R1,KWKUNTS
AON050   OI    0(R4),X'40'
         LA    R4,2(,R4)
         BCT   R1,AON050           DECREMENT NUMBER OF UNITS, LOOP
*
*        CALCULATE RMAX
*
*        FIXED LENGTH RECORDS =
*        NUMBER OF RECORDS THAT CAN BE CONTAINED ON
*        ONE FULL REEL AT SORT BLOCKING RMAX = NMAX/(N-2)
*
*        VARIABLE LENGTH RECORDS =
*        NUMBER OF BYTES THAT CAN BE CONTAINED ON
*        ONE FULL REEL OF TAPE AT SORT BLOCKING
*        RMAX = (NMAX * RCDL2)/(N-2)
*
         SR    R4,R4
         LH    R6,KNM2             N-2
         L     R5,PPINMAX
         PPITEST  PPIFIX           FIXED LENGTH RECORDS ?
         BO    AON060              YES, BRANCH
         MH    R5,PPIRCDL2         NO, VARIABLE LENGTH RECORDS
AON060   DR    R4,R6
         ST    R5,PPIRMAX
         BR    R14                 RETURN
*
AON070   L     R2,KMSKDEC
         B     AON020              GOTO CHECK OUTPUT SEQUENCE
*
AON080   IC    R2,KUSRDEC
         B     AON025              BRANCH TO STORE USER'S SEQUENCE
*
AON090   ST    R5,0(,R3)
         LA    R3,4(,R3)
         BCT   R1,AON030           DECREMENT NO WORK UNIT
         B     AON040              GOTO SET OPEN BITS FOR WORK UNITS
*
         DC    0F'0'               FULL WORD BOUNDARY
*
KMSKASC  DC    X'00005555'         ASCENDING SEQUENCE MASK
KMSKDEC  DC    X'0000AAAA'         DECENDING SEQUENCE MASK
KUSRASC  DC    X'00'               OUTPUT ASCENDING SEQUENCE INDICATOR
KUSRDEC  DC    X'10'               OUTPUT DECENDING SEQUENCE INDICATOR
*
*        IERRON
*
DIERRON  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRON SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRONI
*
*        IERRMB
*
IERRMB   DSECT
*
         COPY  RMBMAIN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
*        DCB
*
         PRINT NOGEN
*
         DCBD  DSORG=(PS),DEVD=(TA)
*
         PRINT GEN
*
         SMPPI
*
         END
./ ADD NAME=IERAOO   0101-20211-20211-1200-00123-00123-00000-RELEASE 00
AOO      TITLE 'IERAOO - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERAOO - NOT SUPPORTED
*
*        MODULE FUNCTION/OPERATION -
*        DISK SORT ALGORITHM ASSIGNMENT
*        THIS MODULE INITIALIZES THE RUNNING PROGRAM FOR THE
*        FOLLOWING ITEMS -
*        STARTING AND ENDING DRUM ADDRESSES IN THE SORT TABLE
*        INITIALIZING POINTERS AND BLOCKING FOR ADDRESSES
*        ESTABLISHING SIZE OF SORT TABLE (NO OF AREAS INVOLVED)
*
*        MODULES IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACROS USED BY MODULE - N/A
*
*        ENTRY POINTS - ENTRY IERMOI
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPINDSKA   PPISTAR    PPIENDAR
*        PPILAB01   PPISEQCT   PPICNTL
*        PPIMRGOP
*
*        OUTPUT - PPI FIELDS ALTERED OR INITIALIZED -
*        PPIMRGMX   PPIWKARE
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS -
*        DSECT IERRCA - PPI
*        DSECT IERRO3 - RUNNING PROG
*
*        EXITS - NORMAL - EXIT TO NEXT ASSIGNMENT ROUTINE
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS - N/A
*
*        NOTES -
*        THIS MODULE IS RESTRICTED TO 2301 DRUM OPERATIONS ONLY
*
IERAOO   CSECT
*
         USING DIERROO,R9
         USING *,R11
         USING IERRCA,R13
         USING DIERRMA,R14
*
IERMOI   LR    R11,R15
         L     R9,PPIALG+4         SET BASE REG
AOOASSMT LH    R8,PPINDSKA         GET TOTAL NUMBER OF AREAS
         BCTR  R8,0                REDUCE BY 1
         LA    R4,TABLE+4          GET ADDR OF FST SLOT IN TBL TO FILL
         LA    R5,PPISTAR          GET ADDR OF FST AREA TO FILL WITH
AOOLOOPA MVC   0(8,R4),0(R5)       FILL TABLE SLOT
         LA    R4,20(,R4)          BUMP ADDR TO NEXT SLOT IN TABLE
         LA    R5,8(,R5)           BUMP ADDR TO NEXT AREA IN PPI
         BCT   R8,AOOLOOPA         LOOP IF TABLE NOT FULL
         MVC   PPIDEPHO(8),PPISTAR PUT FIRST SEQ WRITE ADDR IN PPI
*
*        LOAD TABLE WITH STARRTING ADDR FOR DICT WRITES
*        FROM ENDING ADDR IN PPI
*
         LH    R8,PPINDSKA         GET TOTAL NUMBER OF AREAS
         BCTR  R8,0                REDUCE BY 1
         LA    R4,TABLE+12         GET ADDR OF FIRST SLOT IN DIRECTORY
         LA    R5,PPIENDAR         GET ADDR OF FIRST END ADDR IN PPI
AOOLOOPB MVC   0(8,R4),0(R5)       FILL TABLE SLOT
         LA    R4,20(,R4)          BUMP ADDR TO NEXT SLOT IN TABLE
         LA    R5,8(,R5)           BUMP ADDR TO NEXT AREA IN PPI
         BCT   R8,AOOLOOPB         LOOP IF TABLE NOT FULL
         MVC   WCLBKAR(8),PPISTAR  BLOCK FIRST AREA IN DICTIONARY
*
*        REDUCE ALL ENDING ADDR IN PPI BY 2 TRACKS
*
         LH    R8,PPINDSKA         GET TOTAL NUMBER OF AREAS
         BCTR  R8,0                REDUCE BY 1
         LA    R5,PPIENDAR         GET ADDR OF FIRST END ADDR IN PPI
AOOLOOPC SR    R6,R6               CLEAR REG
         IC    R6,6(,R5)           GET HEAD NO FROM ENDING DISK ADDR
         LA    R7,2                SET CONSTANT
         SR    R6,R7               REDUCE TRACKS FOR DIRECTORY
         STC   R6,6(,R5)           RESTORE HEAD NO TO END ADDR IN PPI
         LA    R5,8(,R5)           BUMP TO NEXT PPI AREA ADDR
         BCT   R8,AOOLOOPC         LOOP IF ALL END AREAS NOT REDUCED
         LA    R6,TABLE            GET TABLE ADDR
         ST    R6,WPOINT           SET POINTER TO FIRST TABLE POSITION
         LA    R8,20
         LH    R5,PPINDSKA         GET TOTAL NUMBER OF AREAS
         BCTR  R5,0                REDUCE BY 1
         MR    R4,R8               MLTPY R8(20)XRF (NO AREAS)=R5 PROD
         AR    R6,R5               ADD TBL LGTH(PROD)TO BEG TABLE ADDR
         ST    R6,WTBLLIMT         RESTRICT SORT TBL TO # AREAS LESS 1
         BR    R14
*
DIERROO  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERROO SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERROOI
*
DIERRMA  DSECT
*
*        MODULE NAME - IERRMA
*
*        THIS MODULE CONTAINS ALL OF THE MESSAGES THAT ARE
*        REQUIRED FOR PHASE 1 RUNNING PROGRAM
*
         COPY  RMAMAIN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERAOP   0101-20211-20211-1200-00165-00165-00000-RELEASE 00
AOP      TITLE 'IERAOP - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERAOP
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 2 AND 3 ASSIGNMENT ROUTINE FOR A 1-16 WAY MERGE
*        NETWORK RUNNING PROGRAM IERROP WITH MULTIPLE CONTROL
*        FIELDS
*
*        THE FUNCTION OF THIS MODULE IS TO SET THE NETWORK
*        COMPARE INSTRUCTIONS WITH A LENGTH AND DISPLACEMENT
*        ATTRIBUTE AND TO SET THE NETWORKS PHASE-2/PHASE-3
*        SWITCHES ACCORDING TO THE PHASE
*
*        USED AS A DSECT IN - N/A
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM
*                       CALLING SEQUENCE -
*                           LA   R15,VALUE
*                           BALR R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPINETM   PPIDDOL1
*        PPICNTL   PPIAXERT
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED - NONE
*
*        EXTERNAL ROUTINES -
*        EXTRN IERROP
*        EXTRN IERRMC
*
*        EXTERNAL PARAMETERS - NONE
*
*        EXITS - NORMAL - IERRC9 - CALLER ROUTINE FOR ASSIGNMENT
*
*        EXITS - ERROR - IERRMC - MESSAGE MODULE
*
*        TABLES/WORK AREAS - N/A
*
*        NOTES - NONE
*
IERAOP   CSECT
*
         USING *,R11
         USING IERRCA,R13
         USING DIERRMC,R15
*
IERMO1   LR    R11,R15
         ST    R14,RKSAVC9         SAVE RETURN ADDR
         L     R14,PPINET+4
         USING DIERROP,R14
         PPITEST  PPIPH3           PHASE 3 OR MRG ONLY ?
         BO    AOPPH3              FALL THRU IF PHASE 2
         L     R14,PPINETM+4
*
*        IN PHASE 2 THE PHASE 2 SWITCHES ARE AS SHOWN IN LISTING
*        THE FOLLOWING SECTION SETS UP THE NETWORK COMPARE
*        INSTRUCTIONS
*
AOPCIS   IC    R4,PPIDD0L1+3
         STC   R4,IERROPWH+1            LENGTH ATTRIBUTE
         OC    IERROPWH+2(2),PPIDD0L1   DISPLACEMENT ATTRIBUTE
         OC    IERROPWH+4(2),PPIDD0L1
         STC   R4,IERROPL4+1
         OC    IERROPL4+2(2),PPIDD0L1
         OC    IERROPL4+4(2),PPIDD0L1
         STC   R4,IERROPL2+1
         OC    IERROPL2+2(2),PPIDD0L1
         OC    IERROPL2+4(2),PPIDD0L1
         STC   R4,IERROPL1+1
         OC    IERROPL1+2(2),PPIDD0L1
         OC    IERROPL1+4(2),PPIDD0L1
         STC   R4,IERROC14+1
         OC    IERROC14+2(2),PPIDD0L1
         OC    IERROC14+4(2),PPIDD0L1
         STC   R4,IERROC13+1
         OC    IERROC13+2(2),PPIDD0L1
         OC    IERROC13+4(2),PPIDD0L1
         STC   R4,IERROC15+1
         OC    IERROC15+2(2),PPIDD0L1
         OC    IERROC15+4(2),PPIDD0L1
         STC   R4,IERROC11+1
         OC    IERROC11+2(2),PPIDD0L1
         OC    IERROC11+4(2),PPIDD0L1
         STC   R4,IERROPS4+1
         OC    IERROPS4+2(2),PPIDD0L1
         OC    IERROPS4+4(2),PPIDD0L1
         STC   R4,IERROPU4+1
         OC    IERROPU4+2(2),PPIDD0L1
         OC    IERROPU4+4(2),PPIDD0L1
         STC   R4,IERROPU2+1
         OC    IERROPU2+2(2),PPIDD0L1
         OC    IERROPU2+4(2),PPIDD0L1
         STC   R4,IERROPU1+1
         OC    IERROPU1+2(2),PPIDD0L1
         OC    IERROPU1+4(2),PPIDD0L1
         STC   R4,IERDOSCK+1
         OC    IERDOSCK+2(2),PPIDD0L1
         OC    IERDOSCK+4(2),PPIDD0L1
         STC   R4,IERROC6+1
         OC    IERROC6+2(2),PPIDD0L1
         OC    IERROC6+4(2),PPIDD0L1
         STC   R4,IERROC5+1
         OC    IERROC5+2(2),PPIDD0L1
         OC    IERROC5+4(2),PPIDD0L1
         STC   R4,IERROC7+1
         OC    IERROC7+2(2),PPIDD0L1
         OC    IERROC7+4(2),PPIDD0L1
         STC   R4,IERROC3+1
         OC    IERROC3+2(2),PPIDD0L1
         OC    IERROC3+4(2),PPIDD0L1
         STC   R4,IERROP4S+1
         OC    IERROP4S+2(2),PPIDD0L1
         OC    IERROP4S+4(2),PPIDD0L1
         STC   R4,IERDOICP+1
         OC    IERDOICP+2(2),PPIDD0L1
         OC    IERDOICP+4(2),PPIDD0L1
         L     R12,PPIAXERT        SET BASE REG OF EQUALS RTN
*
*        EXIT TO NEXT ASSIGNMENT PHASE
*
         L     R14,RKSAVC9
         BR    R14                 NEXT ASSIGNMENT ROUTINE
*
*        SET THE NETWORK FOR PHASE 3
*
AOPPH3   OI    IERDOBWR+1,X'F0'
         OI    IERDOM1+1,X'F0'
         OI    IERDOCPS+1,X'F0'
         OI    IERDOIP3+1,X'F0'
         B     AOPCIS              BRANCH TO SET COMPARE INSTR SECTION
*
RKSAVC9  DC    F'0'                NEXT ASSGN RTN ADDR
*
         DROP  R11,R14,R15
*
*        IERROP
*
DIERROP  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERROP SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERROPI
*
*        IERRMC
*
DIERRMC  DSECT
*
         COPY  RMCMAIN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERAOQ   0101-20211-20211-1200-00250-00250-00000-RELEASE 00
AOQ      TITLE 'IERAOQ - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERAOQ
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 2 AND 3 ASSIGNMENT ROUTINE FOR A 1-16 WAY MERGE
*        NETWORK RUNNING IERROQ WITH A SINGLE CONTROL FIELD
*        THE FUNCTION OF THIS MODULE IS TO -
*        1. SET THE NETWORK COMPARE INSTRUCTIONS WITH A LENGTH AND
*           DISPLACEMENT ATTRIBUTE
*        2. SET THE NETWORKS PHASE-2/PHASE-3 SWITCHES ACCORDING TO
*           THE PHASE
*        3. DETERMINE THE AMOUNT OF CORE REQUIRED FOR EXTRACT
*           POSITIONS IF EXTRACTING
*        4. SET THE NETWORK EXTRACT SWITCHES ACCORDING TO WHETHER
*           EXTRACTION IS TO BE DONE OR NOT
*
*        USED AS A DSECT IN - N/A
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - CALLING SEQUENCE -
*                           LA   R15,VALUE
*                           BALR R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPINETM    PPIDDOL1
*        PPILEXFF   PPIX61
*        PPISPGN1   PPICNTL
*        PPIAXERT   PPILEXFD
*        PPIMRGOP
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPIBDSVA   PPISPGN1
*
*        EXTERNAL ROUTINES -
*        EXTRN IERROQ
*        EXTRN IERRMC
*        EXTRN E61
*
*        EXTERNAL PARAMETERS - NONE
*
*        EXITS - NORMAL -
*        IERRC9 - CALLER ROUTINE FOR ASSIGNMENT RTN
*        E61    - EXTRACT EXIT
*
*        EXITS - ERROR -
*        IERRMC - MESSAGE MODULE
*
*        TABLES/WORK AREAS - N/A
*
*        NOTES - NONE
*
IERAOQ   CSECT
*
         USING *,R11
         USING IERRCA,R13
         USING DIERRMC,R15
*
IERMO1   LR    R11,R15
         ST    R14,RKSAVC9
         L     R14,PPINET+4
         PPITEST  PPIPH3           PHASE 3 ?
         BO    *+8                 YES
         L     R14,PPINETM+4       NO
         USING AIERROQ,R14
         PPITEST  PPIEXTRT         EXTRACTING ?
         BZ    AONNEXT             NO, BRANCH
*
*        SET THE EXTRACT SWITCHES TO YES IF NEEDED
*        DETERMINE THE AMOUNT OF CORE REQD FOR THE EXTR POS
*        PPIMRGMX IS USED IF BALANCED TECHNIQUE
*        PPIBDSVA MINUS ONE IS USED IF POLYPHASE TECHNIQUE
*        PPIMRGOP IS USED IF A DISK SORT
*
         PPITEST  PPIMERGO         MERGE ONLY ?
         BO    AOQNPOLY            YES, BRANCH
         PPITEST  PPITAPE          TAPE SORT ?
         BZ    AOQDISK             NO, BRANCH
         PPITEST  PPIPOLY          POLY PHASE SORT ?
         BZ    AOQNPOLY            NO, BRANCH
         PPITEST  PPIPH3           PHASE 3 ?
         BO    AOQNPOLY            YES, BRANCH
         SR    R4,R4
         IC    R4,PPIBDSVA         NUMBER OF ENTRIES IN TAPE TABLE
         S     R4,KAOONE
         ST    R4,KAOTECH          STORE IN DETERMINE AMT CORE CONSTANT
         B     AOQDET              ALIGN CNTL FLDS
*
AOQDISK  MVC   KAOTECH+2(2),PPIMRGOP STORE MRG ORD IN AMT CORE CONST
         B     AOQDET              ALIGN CNTL FLDS
*
AOQNPOLY MVC   KAOTECH+2(2),PPIMRGMX  STORE MRG ORD IN AMT CORE CON
AOQDET   XI    IERDOET+1,X'F0'
         LH    R3,PPILEXFF         LEN OF EXTR CTRL FLDS FROM PPI
         LA    R3,3(0,R3)          ALIGN EXTR CNTL FLDS UPWARD TO WORD
         N     R3,KAORNDUP         BOUNDARY IF THEY AREN'T ALREADY
         A     R3,KAOFOUR          ADD ACTUAL ADDR BYTES TO CNTRL FLD
         ST    R3,IERDOEXL         STORE IN MERGE NETWORK
         SR    R2,R2
         L     R10,KAOTECH         MERGE ORDER FROM TECHNIQUE USED
         A     R10,KAOONE          MRG ORD + 1
         MR    R2,R10              DETERM AMT CORE REQD FOR EXTR POS
         L     R6,PPISPGN1         PROGRAM GENERATOR ADDR
*
*        CHECK IF PPISPGN1 IS ON A FULL WORD BOUNDARY
*        IF NOT IT IS ROUNDED DOWNWARD TO A FULL WORD BOUNDARY
*
         TM    PPISPGN1+3,X'03'
         BZ    AOQNRNDU            NO ALIGNMENT NECESSARY
         LA    R6,3(,R6)
         N     R6,KAORNDUP
         S     R6,KAOFOUR
AOQNRNDU SR    R6,R3               UPDATE PROG GEN ADDR
         ST    R6,PPISPGN1         STORE PROG GEN ADDR
         ST    R6,IERDOAGE         BEG ADDR OF GEN EXTR POS IN MRG NTWK
         L     R12,PPIAXERT        SET BASE REG FOR EXTR RTN
         L     R2,PPIX61+4
         ST    R2,0(,R12)          SET USER EXIT ADDR IN EXTR RTN
         MVC   PPIDD0L1+3(1),PPILEXFD+1  MOVING THE LENGTH AND DISPLAC
         MVC   PPIDD0L1(2),KAOFOUR+2     ATTRIBUTE FOR CMP INSTR SET
*
*        DETERMINE WHICH PHASE IS BEING EXECUTED AND SET THE
*        APPROPRIATE SWITCHES
*
AOQPHT   PPITEST  PPIPH3           PHASE 3
         BO    AOQPH3              YES, BRANCH
*
*        SET THE NETWORK COMPARE INSTRUCTIONS
*
AOQCIS   IC    R4,PPIDD0L1+3
         STC   R4,IERROQWH+1            LENGTH ATTRIBUTE
         OC    IERROQWH+2(2),PPIDD0L1   DISPLACEMENT ATTRIBUTE
         OC    IERROQWH+4(2),PPIDD0L1
         STC   R4,IERROQL4+1
         OC    IERROQL4+2(2),PPIDD0L1
         OC    IERROQL4+4(2),PPIDD0L1
         STC   R4,IERROQL2+1
         OC    IERROQL2+2(2),PPIDD0L1
         OC    IERROQL2+4(2),PPIDD0L1
         STC   R4,IERROQL1+1
         OC    IERROQL1+2(2),PPIDD0L1
         OC    IERROQL1+4(2),PPIDD0L1
         STC   R4,IERDOSCK+1
         OC    IERDOSCK+2(2),PPIDD0L1
         OC    IERDOSCK+4(2),PPIDD0L1
         STC   R4,IERROC14+1
         OC    IERROC14+2(2),PPIDD0L1
         OC    IERROC14+4(2),PPIDD0L1
         STC   R4,IERROC13+1
         OC    IERROC13+2(2),PPIDD0L1
         OC    IERROC13+4(2),PPIDD0L1
         STC   R4,IERROC15+1
         OC    IERROC15+2(2),PPIDD0L1
         OC    IERROC15+4(2),PPIDD0L1
         STC   R4,IERROC11+1
         OC    IERROC11+2(2),PPIDD0L1
         OC    IERROC11+4(2),PPIDD0L1
         STC   R4,IERROQS4+1
         OC    IERROQS4+2(2),PPIDD0L1
         OC    IERROQS4+4(2),PPIDD0L1
         STC   R4,IERROQU4+1
         OC    IERROQU4+2(2),PPIDD0L1
         OC    IERROQU4+4(2),PPIDD0L1
         STC   R4,IERROQU2+1
         OC    IERROQU2+2(2),PPIDD0L1
         OC    IERROQU2+4(2),PPIDD0L1
         STC   R4,IERROQU1+1
         OC    IERROQU1+2(2),PPIDD0L1
         OC    IERROQU1+4(2),PPIDD0L1
         STC   R4,IERROC6+1
         OC    IERROC6+2(2),PPIDD0L1
         OC    IERROC6+4(2),PPIDD0L1
         STC   R4,IERROC5+1
         OC    IERROC5+2(2),PPIDD0L1
         OC    IERROC5+4(2),PPIDD0L1
         STC   R4,IERROC7+1
         OC    IERROC7+2(2),PPIDD0L1
         OC    IERROC7+4(2),PPIDD0L1
         STC   R4,IERROC3+1
         OC    IERROC3+2(2),PPIDD0L1
         OC    IERROC3+4(2),PPIDD0L1
         STC   R4,IERROQ4S+1
         OC    IERROQ4S+2(2),PPIDD0L1
         OC    IERROQ4S+4(2),PPIDD0L1
         STC   R4,IERDOICP+1
         OC    IERDOICP+2(2),PPIDD0L1
         OC    IERDOICP+4(2),PPIDD0L1
*
*        EXIT TO NEXT ASSIGNMENT ROUTINE
*
         L     R14,RKSAVC9
         BR    R14                 NEXT ASSGN RTN
*
*        NOT EXTRACTING
*
AONNEXT  XI    IERROBWR+1,X'F0'
         XI    IERXTRT1+1,X'F0'
         XI    IERXTRT2+1,X'F0'
         XI    IERDOSET+1,X'F0'
         MVI   ROQMERG+1,X'F0'     MODIFY BRANCH CONDITION IN ROQ
         B     AOQPHT              BRANCH TO PHASE TEST
*
*        PHASE 3 SETTINGS
*
AOQPH3   XI    IERROBB1+1,X'F0'
         XI    IERNEXTR+1,X'F0'
         XI    IERDOCPS+1,X'F0'
         B     AOQCIS              GOTO SET COMPARE INSTR
*
         DC    0F'0'
KAOTECH  DC    XL4'0'
KAOONE   DC    XL4'1'
KAOFOUR  DC    XL4'4'
KAORNDUP DC    X'FFFFFFFC'
*
RKSAVC9  DC    F'0'                RETURN ADDR TO IERRC9
*
         DROP  R11,R14,R15
*
*        IERROQ
*
AIERROQ  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERROQ SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERROQI
*
*        IERRMC
*
*        THIS DSECT CONTAINS ALL OF THE MESSAGES THAT ARE
*        REQUIRED FOR PHASE 3 OR MERGE ONLY RUNNING PROGRAM
*
DIERRMC  DSECT
*
         COPY  RMCMAIN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERAOR   0101-20211-20211-1200-00160-00160-00000-RELEASE 00
AOR      TITLE 'IERAOR - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERAOR
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 2 BALANCED ALGORITHM ASSIGNMENT - TAPE
*        THIS MODULE CONTROLS -
*        1. ODD OR EVEN PASS OF PHASE 2 MERGE
*        2. MERGE ORDERS
*        3. SETTING POINTERS TO INITIAL OUTPUT UNITS IN TAPE TABLE
*        4. FLIP INPUT-OUTPUT BITS IN TABLE DEPENDING ON ODD OR
*           EVEN PASS
*        5. INITIALIZE COUNTERS FOR CONTROL OF DROPPING OUT
*           UNITS AS THEY BECOME FULL DURING A PASS
*
*        USED AS A DSECT IN - N/A
*
*        MACROS USED SMPPI
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                       CALLING SEQUENCE -
*                           L     R15,0
*                           BALR  R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIADSSC   PPISEQCT
*        PPITPTBL   PPICNTL
*
*        OUTPUT PPI FIELDS INITIALIZED OR ALTERED -
*        PPIDEPHO   PPIMRGAL
*        PPIMRGMX   PPIMRGOP
*        PPITPPT
*
*        EXTERNAL ROUTINES -
*        EXTRN IERRMB - ERROR MESSAGE PRINT ROUTINE
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL - IERRC9
*
*        EXITS - ERROR - NONE
*
*        TABLES/WORK AREAS - ALL CONTAINED IN PPI
*
*        NOTES -
*        ALL INITIALIZING TAKES PLACE BETWEEN IERAOR, DSECT OF
*        IERROR AND PPI
*
IERAOR   CSECT
*
         USING *,R11
*
IERMOT   LR    R11,R15
         ST    R14,RKSAVC9
         USING DIERROR,R14
         USING IERRCA,R13
         L     R14,PPIALG+4
AORASSMT MVC   KSVMAX(2),PPIMRGMX  SV MAX TO RESET WITH BEFORE EOP EXIT
         CLI   PPITPPT+3,X'00'     FIRST PASS ?
         BNE   AORGOA              NO, BRANCH
         MVC   PPITPPT(2),PPIMRGMX    SAVE MAX MERGE ORDER
         MVC   PPITPPT+2(2),PPIMRGAL  SAVE ALT MERGE ORDER
         LA    R6,2
         STH   R6,PPISEQCT+8       SET PERPETUAL MRG CTR
         B     AORGOB
*
*        EVEN NUMBERED PHASE 2 PASS
*
AORGOA   PPITEST  PPIEVNOD         EVEN/ODD SWITCH ON ?
         BO    AORGOC              YES, BRANCH
*
*        SET '1' IN LOAD CHARACTER
*
AORGOB   MVI   PPIMRGOP+1,X'C0'    SECOND BYTE OF 2 BYTE AREA
*
*        SET POINTER FOR RUNNING PROG TO STARTING POINT
*        ON RIGHT SIDE OF TABLE
*
         LA    R4,PPITPTBL
         ST    R4,KTBLPTCX         SET PTR AT ST PT OF INPUT SIDE
         LH    R5,PPITPPT          GET MAX MRG
         SLL   R5,1                MULTPY BY 2 (BYTES PER UNIT OF TBL)
         AR    R4,R5
         ST    R4,KTBLPTAX
         ST    R4,KTBLPTBX
         ST    R4,KTBL2            SAVE POINTER TO 2ND HALF OF TABLE
AORRT    MVC   PPIDEPHO+3(1),1(R4)  SET CTR = ORIG MAX MRG
         LH    R4,PPITPPT           FOR PROPAGATING LOAD CHAR
AORGOF   LA    R5,PPITPTBL         GET START POINTER OF TABLE
AORLOOPA MVC   0(1,R5),PPIMRGOP+1  PROPAGATE LOAD CHAR TO LEFT OF TAB
         LA    R5,2(,R5)           BUMP TABLE POINTER
         BCT   R4,AORLOOPA         DECREMENT CTR BY 1, LOOP IF ¬= 0
*                                  SWITCH EOTBL ON ?
SWEOTBL  NOP   AORGOE              NO, FALL THRU
         LH    R4,PPITPPT+2        SET CTR = ALT MRG ORDER
         XI    PPIMRGOP+1,X'80'    REVERSE LOAD CHAR
         XI    SWEOTBL+1,X'F0'     TURN ON SWEOTBL
         L     R5,KTBL2            ADDR OF 2ND HALF OF TABLE
         B     AORLOOPA
*
*        LOAD CHAR LEFT AT '40' FROM LAST PASS (ODD)
*        SET POINTER FOR RUNNING PROG TO STARTING POINT ON LEFT
*        SIDE OF TABLE
*
AORGOC   LA    R4,PPITPTBL
         ST    R4,KTBLPTAX         ST PT (USED FOR RESETTING TRVLG PTR)
         ST    R4,KTBLPTBX         TRAVELING POINTER
         LH    R5,PPITPPT          GET MAX MRG
         SLL   R5,1
         AR    R4,R5
         ST    R4,KTBLPTCX
         ST    R4,KTBL2            SAVE POINTER TO 2ND HALF OF TABLE
         LA    R4,PPITPTBL
         B     AORRT
AORGOE   PPIFLIP  PPIEVNOD         REVERSE ODD-EVEN PASS SWITCH
*                                  SET UP CTR OF ORIGINAL MAX MRG TO
         MVC   KMRGCTRX(2),PPIMRGMX  DET EOP, WHEN LOAD PT REACHED
         LH    R4,PPIMRGAL         SET TABLE-LIMIT CTR IN IERROR =
         STH   R4,KLIMITX          CHGING ALT MRG ORD
*                                  SET COUNTER TO KNOW WHEN ALL UNITS
         MVC   KEOVCTX+2(2),PPIMRGAL   REACH EOV, EG NMAX EXCEEDED
         MVC   PPISEQCT(4),PPISEQCT+4  MOVE NO STRINGS OUT TO IN SLOT
         SR    R4,R4
         ST    R4,PPISEQCT+4       ZERO OUT SLOT FOR NEXT PASS
         L     R14,RKSAVC9
         BR    R14
*
RKSAVC9  DC    F'0'
KTBL2    DC    A(0)                POINTER TO 2ND HALF OF TAPE TABLE
*
*        IERROR
*
DIERROR  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERROR SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRORI
*
*        IERRMB
*
*        THIS DSECT CONTAINS ALL OF THE MESSAGES THAT ARE
*        REQUIRED FOR PHASE 2 RUNNING PROGRAM
*
DIERRMB  DSECT
*
         COPY  RMBMAIN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERAOS   0101-20211-20211-1200-00192-00192-00000-RELEASE 00
AOS      TITLE 'IERAOS - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERAOS
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 2 ALGORITHM ASSIGNMENT FOR POLYPHASE TAPE. THIS
*        MODULE CONTROLS -
*        1. INPUT VS OUTPUT UNIT
*        2. SET MERGE ORDER
*        3. KEEP FIBONACCI NUMBERS STRAIGHT BY DECIDING DUMMY
*           STRINGS VS REAL STRINGS
*
*        USED AS A DSECT IN - N/A
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                       CALLING SEQUENCE -
*                           L     R15,0
*                           BALR  R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIADSSC   PPIBDSVA   PPIDEPHO
*        PPICNTL    PPITPTBL
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPIMRGMX
*
*        EXTERNAL ROUTINES -
*        EXTRN - IERRMB
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL - IERRC9
*
*        EXITS - ERROR - NONE
*
*        TABLES/WORK AREAS - PPI ONLY
*
*        NOTES -
*        ALL INITIALIZING TAKES PLACE BETWEEN IERAOS, DSECT OF
*        IERROS AND PPI
*
IERAOS   CSECT
*
         USING *,R11
         USING DIERROS,R14
         USING IERRCA,R13
*
IERMOT   LR    R11,R15
         ST    R14,RKSAVC9
         L     R14,PPIALG+4
*
*        CHECK IF CHECKPOINT HAS BEEN INDICATED. IF REQUESTED
*        OVERLAY THE NECESSARY INSTRUCTIONS IN IERROS TO LINK TO
*        THE CHECKPOINT MODULE
*
         PPITEST  PPICHKPT         CHECKPOINT REQUESTED ?
         BZ    AOS100              NO
         MVI   ROSSKIP+1,X'00'     MODIFY BRANCH IN ROS
*
*        SET POINTER TO STARTING POINT OF EACH AREA
*        IN THE TAPE TABLE
*
AOS100   LA    R4,PPITPTBL
*
*        ZERO OUT ALL BEGINNING DUMMY CTRS
*
         LA    R5,102(,R4)
         MVI   0(R5),X'00'
         MVC   1(33,R5),0(R5)      ZERO THE OTHER 33 BYTES (34 TOTAL)
         LH    R9,PPIMRGMX         SET MERGE MAX FOR POSITIONING
         SLL   R9,1
         AR    R9,R4               FIND POSITION IN TP TBL OF OUT UNIT
         MVC   PPIDEPHO+3(1),1(R9) SET OUTPUT UNIT INCR
*
*        ALL TAPES HAVE ENDING DUMMY STRINGS ?
*
AOSTART  LA    R5,68(,R4)          GET STARTING POINT
         LH    R6,PPIMRGMX         GET LIMIT OF 'M' INPUT TAPES
AOSLOOPA CLC   0(2,R5),KZERO       CTR ZERO ?
         BE    AOSSTOUT            ALL TAPES DO NOT HAVE ENDING DUMMYS
         LA    R5,2(,R5)           YES, LOOK AT NEXT CTR
         BCT   R6,AOSLOOPA         BRANCH TO COMPARE NEXT CTR
*
*        DECREMENT ALL ENDING DUMMY CTRS BY 1
*
         LA    R5,68(,R4)
         LH    R6,PPIMRGMX
AOSLOOPB LH    R7,0(,R5)           GET THIS CTR
         BCTR  R7,0                DECR BY 1
         STH   R7,0(,R5)           STORE CTR
         LA    R5,2(,R5)           BUMP TO NEXT CTR
         BCT   R6,AOSLOOPB         BRANCH TO GET NEXT CTR
*
*        INCREMENT BEG DUMMY CTR FOR INITIAL OUTPUT TAPE
*
         LA    R5,102(0,R4)        GET ST PT
         LH    R6,PPIMRGMX         GET M
         SLL   R6,1                CALC DISPLACEMENT
         AR    R5,R6               ADD DISPLC TO ST PT
         LH    R6,0(,R5)           GET CTR
         LA    R6,1(,R6)           ADD 1
         STH   R6,0(,R5)           PUT BACK
*
*        REVERSE SEQUENCE INDICATOR
*
         PPIFLIP  PPIPH1CO
         B     AOSTART             REVIEW DUMMIES AGAIN
*
*        SET INPUT BITS
*        ENDING DUMMY=0 AND REALS=+ BIT IS ON
*        ENDING DUMMY=+             BIT IS OFF
*        ENDING DUMMY=0 AND REALS=0 BIT IS OFF
*
AOSSTOUT LH    R8,PPIMRGMX        GET LIMIT OF 'M' INPUT TAPES
AOSLOOPC LA    R7,68(,R4)         GET ST PT OF ENDING DUMMY COUNTERS
         LA    R6,34(,R4)         GET ST PT OF REAL STRING COUNTERS
         CLC   0(2,R7),KZERO      END DUMMY CTR ZERO ?
         BNE   AOSOFF             NO, THERE IS A DUM,TURN OFF INPUT BIT
         CLC   0(2,R6),KZERO      YES, IS REAL STRING CTR ZERO
         BE    AOSOFF             YES, NO DUM AND NO REALS,TURN OFF BIT
         OI    0(R4),X'80'        TURN INPUT BIT ON FOR THIS UNIT
*
*        BUMP TO NEXT UNIT
*
AOSNXT   LA    R4,2(,R4)
         BCT   R8,AOSLOOPC        IF NOT END INPUTS THEN LOOP
         B     AOSMRG             GO DETERMINE NEW MRG ORDER
*
*        TURN INPUT BIT OFF FOR THIS UNIT
*        LEAVE OPEN BIT ALONE
*
AOSOFF   NI    0(R4),X'7F'
         B     AOSNXT              CHECK NEXT UNIT
*
*        SET MERGE ORDER = NO TAPES WITH REAL RECORDS AND NO END
*        DUMMIES
*
AOSMRG   SR    R7,R7               CLEAR FOR NEW MERGE ORDER
         LA    R4,PPITPTBL+34      PICK UP REAL STRING COUNTER
         LA    R8,PPITPTBL+68      PICK UP END DUMMIES CTR
         LH    R6,PPIMRGMX
AOSLOOPD CLC   0(2,R4),KZERO
         BNE   AOSDUMS             THERE IS A REAL, SEE IF ANY DUMS
AOSRETN  LA    R4,2(,R4)           BUMP TO NEXT UNIT
         LA    R8,2(,R8)
         BCT   R6,AOSLOOPD         IF END OF INPUTS, DROP THRU
         STH   R7,PPIMRGMX         PUT NEW MERGE ORDER IN MAX
*
*        EXIT TO NXT ASSIGNMENT ROUTINE
*
         L     R14,RKSAVC9
         BR    R14                 NEXT ASSIGNMENT ROUTINE
*
AOSDUMS  CLC   0(2,R8),KZERO       ANY END DUMMIES HERE?
         BNE   AOSRETN             YES, DON'T ADD TO MERGE ORDER
AOSINCMG LA    R7,1(,R7)           ADD 1 TO MERGE ORDER
         B     AOSRETN             CHECK NEXT UNIT
*
RKSAVC9  DC    F'0'                NEXT ASSGN RTN ADDR
*
*        IERROS
*
DIERROS  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERROS SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERROSI
*
*        IERRMB
*
*        THIS DSECT CONTAINS ALL OF THE MESSAGES THAT ARE
*        REQUIRED FOR PHASE 2 RUNNING PROGRAM
*
DIERRMB  DSECT
*
         COPY  RMBMAIN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERAOT   0101-20211-20211-1200-00187-00187-00000-RELEASE 00
AOT      TITLE 'IERAOT - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERAOT
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 2 ASSIGNMENT MODULE FOR BALN TECHNIQUE ALGORITHM
*        THIS MODULE INITIALIZES AN INTERNAL CONTROL TABLE
*        CONSISTING OF -
*        1. DISK ADDR TO START WRITING STRINGS FOR EACH AREA (OUTPUT)
*        2. DISK ADDR TO START READING STRINGS FOR EACH AREA (INPUT)
*        3. DISK ADDR TO START WRITING DIRECTORY FOR EACH AREA (OUTPUT)
*        4. DISK ADDR TO START READING DIRECTORY FOR EACH AREA (INPUT)
*        5. NO STRINGS IN
*        6. NO STRINGS OUT
*
*        USED AS A DSECT IN - N/A
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                       CALLING SEQUENCE -
*                           L    R15,0
*                           BALR R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIENDAR   PPICNTL
*        PPILAB01   PPIWKARE
*        PPINDSKA   PPISEQCT
*        PPISTAR
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPIDEPHO   PPIDIRAD
*        PPIMRGAL   PPIMRGMX
*        PPIMRGOP
*
*        EXTERNAL ROUTINES -
*        EXTRN IERRMB
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL - IERRC9
*
*        EXITS - ERROR - NONE
*
*        TABLES/WORK AREAS -
*        PPI
*        INTERNAL CONTROL TABLE (IN IERROT) TO DETERMINE WHERE
*        TO READ AND WRITE -
*        STRINGS
*        DIRECTORY
*
*        NOTES -
*        ALL INITIALIZING TAKES PLACE BETWEEN IERAOT, IERROT AND PPI
*
IERAOT   CSECT
*
         USING *,R11
         USING IERRCA,R13
*
         LR    R11,R15             PRIME AOT BASE REGISTER
         ST    R14,RKSAVC9         SAVE IERRC9 RETURN ADDR
         L     R14,PPIALG+4        R14 -> IERROT
         USING DIERROT,R14
*
*        CHECK IF CHECKPOINT HAS BEEN INDICATED. IF REQUESTED
*        OVERLAY THE NECESSARY INSTRUCTIONS IN IERROT TO LINK TO
*        THE CHECKPOINT MODULE
*
         PPITEST  PPICHKPT         CHECKPOINT REQUESTED ?
         BZ    AOT100              NO
         MVI   ROT300+1,X'00'      YES, MODIFY BRANCH IN ROT
*
*        MOVE START ADDR INTO TABLE - WHERE TO RECORD NEXT STRING
*
AOT100   LA    R4,WTABLE           R4 -> WTABLE
         LH    R5,PPINDSKA         R5 = NO OF SORTKWK AREAS
         LA    R6,PPISTAR          R6 -> PPISTAR
AOTLOOPA MVC   4(8,R4),0(R6)       MOVE PPISTAR ENTRY INTO WTABLE
*                                  PPISTAR ENTRY WILL HAVE TT = 0000
         LA    R4,36(,R4)          INCR TO NEXT ENTRY IN WTABLE
         LA    R6,8(,R6)           INCR TO NEXT ENTRY IN PPISTAR
         BCT   R5,AOTLOOPA         LOOP UNTIL ALL ENTRIES PROCESSED
*
*        PUT ENDING ADDR IN TABLE -
*        (1) WHERE TO WRITE DICT
*        (2) WHERE TO READ DICT FROM PH 1
*
         LA    R4,WTABLE           R4 -> WTABLE
         LH    R5,PPINDSKA         R5 = NO OF SORTKWK AREAS
         LA    R6,PPIENDAR         R6 -> PPIENDAR
AOTLOOPB MVC   12(8,R4),0(R6)      MOVE PPIENDAR INTO 'WRITE' DICT SLOT
*                                  PPIENDAR ENTRY WILL HAVE TT SET
         MVC   20(8,R4),0(R6)      MOVE PPIENDAR INTO 'READ' DICT SLOT
*                                  PPIENDAR ENTRY WILL HAVE TT SET
         LA    R4,36(,R4)          INCR TO NEXT ENTRY IN WTABLE
         LA    R6,8(,R6)           INCR TO NEXT ENTRY IN PPIENDAR
         BCT   R5,AOTLOOPB         LOOP UNTIL ALL ENTRIES PROCESSED
*
*        INITIALIZE POS-IN-BLK TO ADDR OF PPILAB01
*        WHERE READ PUTS BLK/DICT
*
         LA    R4,WTABLE
         LH    R5,PPINDSKA
         LA    R6,PPILAB01         R6 -> PPILAB01
AOTLOOPC ST    R6,28(,R4)          STORE ADDR IN ALL TABLE ENTRIES
         LA    R4,36(,R4)          INCR TO NEXT AREA IN TABLE
         BCT   R5,AOTLOOPC         GOTO LOOPC
*
*        INITIALIZE NEW SEQ COUNTERS IN TABLE TO ZERO
*
         LA    R4,0
         LH    R10,PPINDSKA        GET NO DISK AREAS
         LA    R9,WTABLE
         LA    R9,32(,R9)          GET SLOT IN TABLE
AOTLOOPD STH   R4,0(,R9)           FILL SLOT
         LA    R9,36(,R9)          BUMP ADDR TO NEXT SLOT
         BCT   R10,AOTLOOPD        GOTO LOOPD
*
*        STORE OLD SEQ COUNTERS INTO TABLE
*
         LH    R10,PPINDSKA        GET NO AREAS
         LA    R4,PPISEQCT         GET ADDR OF COUNTERS
         LA    R9,WTABLE
         LA    R9,34(,R9)          GET SLOT IN TABLE
AOTLOOPE MVC   0(2,R9),0(R4)       FILL 1 SLOT
         LA    R9,36(,R9)          BUMP TO NEXT SLOT
         LA    R4,2(,R4)
         BCT   R10,AOTLOOPE        TABLE FULL, NO LOOP
         MVC   WNODSKA,PPINDSKA    MOVE NO OF DISK AREAS TO IERROT
         PPITEST  PPIDMCO          MERGE TABLE COLLATING ORDER DESCD ?
         BO    AOTDECND            YES, BRANCH
         B     AOTOUT              GO SET MRG ORDER, DON'T FLIP TABLE
*
*        REVERSE DATA IN TABLE FOR DECENDING PROCESS
*
AOTDECND LA    R9,WTABLE           R9 -> WTABLE
         LH    R5,PPINDSKA         R5 = NO OF SORTWK AREAS
         BCTR  R5,0                REDUCE NO AREAS BY 1
         LA    R6,36               GEN MULTIPLIER CONST (L'WTABLE ENT)
         MR    R4,R6               MULTIPICAND IN R5, PROD = R5
*                                  DISPLACEMENT TO NTH ADDR IN TABLE
         LA    R10,0(R5,R9)        GET ADDR OF NTH POS IN TABLE
AOTLOOPF MVC   PPIWKARE(36),0(R10)  MOVE DATA FROM NTH POS TO WORK AREA
         MVC   0(36,R10),0(R9)     MOVE DATA FROM FIRST POS TO NTH POS
         MVC   0(36,R9),PPIWKARE   MOVE DATA FROM WORK AREA TO 1ST POS
         LA    R9,36(,R9)          INCR FIRST POS REG TO NXT AREA ADDR
         LA    R7,36               CONSTANT DECREMENT (L'WTABLE ENTRY)
         SR    R10,R7              DECR NTH POS REG TO PREVIOUS POS
         CLR   R9,R10              COMPARE ADDR OF WTABLE TO NTH REG
         BL    AOTLOOPF            REVERSAL NOT COMPLETE, LOOP
*                                  TABLE COMPLETELY REVERSED
AOTOUT   LA    R9,WTABLE           R9 -> TABLE ADDR
         LH    R5,PPINDSKA         R5 = NO OF SORKWK AREAS
         BCTR  R5,0
         BCTR  R5,0                REDUCE NO AREAS BY 2 (TO BEG N-1)
         LA    R6,36               MULTIPLIER CONSTANT (L'WTABLE ENT)
         MR    R4,R6               DISPLACEMENT TO N-1 POS --- PROD=R5
         AR    R9,R5               GET ADDR N-1 POS
         MVC   PPIMRGMX(2),34(R9)  SET MRG MAX = SEQCT IN POS N-1
         L     R14,RKSAVC9
         BR    R14                 RETURN
*
RKSAVC9  DC    F'0'                RETURN ADDR
*
         DROP  R11,R14
*
*        IERROT
*
DIERROT  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERROT SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERROTI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERAOU   0101-20211-20211-1200-00151-00151-00000-RELEASE 00
AOU      TITLE 'IERAOU - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERAOU
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 2 AND 3 ASSIGNMENT ROUTINE FOR A 1-8 WAY MERGE
*        NETWORK RUNNING PROGRAM IERROU WITH MULTIPLE CONTROL
*        FIELDS
*        THE FUNCTION OF THIS MODULE IS TO SET THE NETWORK
*        COMPARE INSTRUCTIONS WITH A LENGTH AND DISPLACEMENT
*        ATTRIBUTE AND TO SET THE NETWORKS PHASE-2/PHASE-3
*        SWITCHES ACCORDING TO THE PHASE
*
*        USED AS A DSECT IN - N/A
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - CALLING SEQUENCE -
*                           LA   R15,VALUE
*                           BALR R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPINETM   PPIDDOL1
*        PPICNTL   PPIAXERT
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED - NONE
*
*        EXTERNAL ROUTINES -
*        EXTRN IERROU
*        EXTRN IERRMC
*
*        EXTERNAL PARAMETERS - NONE
*
*        EXITS - NORMAL -
*        IERRC9 - CALLER ROUTINE FOR ASSIGNMENT RTN
*
*        EXITS - ERROR -
*        IERRMC - MESSAGE MODULE
*
*        TABLES/WORK AREAS - N/A
*
*        NOTES - NONE
*
IERAOU   CSECT
*
         USING *,R11
         USING IERRCA,R13
         USING DIERRMC,R15         MESSAGE MODULE
*
*        MODULE ENTRY POINT
*
IERMO1   LR    R11,R15
         ST    R14,RKSAVC9
         L     R14,PPINET+4        SET UP IF PHASE 3
         USING DIERROU,R14
         PPITEST  PPIPH3           PHASE 3 ?
         BO    AOUPH3              FALL THRU IF PHASE 2
         L     R14,PPINETM+4       RESET IF PHASE 2
*
*        IN PHASE 2, THE PHASE 2 SWITCHES ARE AS SHOWN IN LISTING
*        THE FOLLOWING SECTION SETS UP THE NETWORK COMPARE
*        INSTRUCTIONS
*
*        PPIDD0L1                  MERGE NETWORK'S MAJOR CONTROL FIELD
*                                  BYTE 1-2 DISPLACEMENT TO FIELD
*                                  BYTE 4   LENGTH
*
AOUCIS   IC    R4,PPIDD0L1+3       R4 = L'MAJOR CONTROL FIELD
         STC   R4,IERDOM8+1           LENGTH ATTRIBUTE
         OC    IERDOM8+2(2),PPIDD0L1  DISPLACEMENT ATTRIBUTE
         OC    IERDOM8+4(2),PPIDD0L1
         STC   R4,IERDOM4+1
         OC    IERDOM4+2(2),PPIDD0L1
         OC    IERDOM4+4(2),PPIDD0L1
         STC   R4,IERDOM2+1
         OC    IERDOM2+2(2),PPIDD0L1
         OC    IERDOM2+4(2),PPIDD0L1
         STC   R4,IERDOSCK+1
         OC    IERDOSCK+2(2),PPIDD0L1
         OC    IERDOSCK+4(2),PPIDD0L1
         STC   R4,IERDOCK6+1
         OC    IERDOCK6+2(2),PPIDD0L1
         OC    IERDOCK6+4(2),PPIDD0L1
         STC   R4,IERDOCK5+1
         OC    IERDOCK5+2(2),PPIDD0L1
         OC    IERDOCK5+4(2),PPIDD0L1
         STC   R4,IERDOCK7+1
         OC    IERDOCK7+2(2),PPIDD0L1
         OC    IERDOCK7+4(2),PPIDD0L1
         STC   R4,IERDOCK3+1
         OC    IERDOCK3+2(2),PPIDD0L1
         OC    IERDOCK3+4(2),PPIDD0L1
         STC   R4,IERDOCK4+1
         OC    IERDOCK4+2(2),PPIDD0L1
         OC    IERDOCK4+4(2),PPIDD0L1
         STC   R4,IERDOICP+1
         OC    IERDOICP+2(2),PPIDD0L1
         OC    IERDOICP+4(2),PPIDD0L1
*
*        END OF THE SECTION WHICH SETS UP THE COMPARE
*        INSTRUCTIONS
*
         L     R12,PPIAXERT        SET BASE REG OF EQUALS ROUTINE
*
*        EXIT TO NEXT ASSIGNMENT RTN
*
         L     R14,RKSAVC9
         BR    R14                 NEXT ASSGN RTN
*
*        SET THE NETWORK FOR PHASE 3
*
AOUPH3   OI    IERDOM1+1,X'F0'
         OI    IERDOBWR+1,X'F0'
         OI    IERDOCPS+1,X'F0'
         OI    IERDOIP3+1,X'F0'
         B     AOUCIS              BRANCH TO SET COMPARE INSTR SECTION
*
RKSAVC9  DC    F'0'                NEXT ASSGN RTN ADDR
*
         DROP R11,R14,R15
*
*        IERROU
*
DIERROU  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERROU SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERROUI
*
*        IERRMC
*
*        THIS DSECT CONTAINS ALL OF THE MESSAGES THAT ARE
*        REQUIRED FOR PHASE 3 OR MERGE ONLY RUNNING PROGRAM
*
DIERRMC  DSECT
*
         COPY  RMCMAIN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERAOV   0101-20211-20211-1200-00222-00222-00000-RELEASE 00
AOV      TITLE 'IERAOV - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERAOV
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 2 AND 3 ASSIGNMENT ROUTINE FOR A 1-8 WAY MERGE
*        NETWORK RUNNING PROGRAM IERROV WITH A SINGLE CONTROL
*        FIELD
*        THE FUNCTION OF THIS MODULE IS TO -
*        SET THE NETWORK COMPARE INSTRUCTIONS WITH A LENGTH AND
*        DISPLACEMENT ATTRIBUTE
*        SET THE NETWORKS PHASE-2/PHASE-3 SWITCHES ACCORDING TO
*        THE PHASE
*        DETERMINE THE AMOUNT OF STORAGE REQUIRED FOR EXTRACT
*        POSITIONS IF EXTRACTING
*        SET THE NETWORK EXTRACT SWITCHES ACCORDING TO WHETHER
*        EXTRACTION IS TO BE DONE OR NOT
*
*        USED AS A DSECT IN - N/A
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - CALLING SEQUENCE -
*                           LA   R15,VALUE
*                           BALR R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPINETM    PPIDDOL1   PPIX61
*        PPILEXFF   PPIMRGOP   PPICNTL
*        PPIAXERT   PPILEXFD   PPIMRGMX
*        PPISPGN1
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPIBDSVA   PPISPGN1
*
*        EXTERNAL ROUTINES -
*        IERROV
*        IERRMC
*        E61
*
*        EXTERNAL PARAMETERS - NONE
*
*        EXITS - NORMAL -
*        IERRC9 - CALLER ROUTINE FOR ASSIGNMENT RTN
*        E61    - EXTRACT EXIT
*
*        EXITS - ERROR -
*        IERRMC - MESSAGE MODULE
*
*        NOTES - NONE
*
IERAOV   CSECT
*
         USING *,R11
         USING IERRCA,R13
         USING DIERRMC,R15         MESSAGE MODULE
*
*        MODULE ENTRY POINT
*
IERMO1   LR    R11,R15
         ST    R14,RKSAVC9
         L     R14,PPINET+4
         PPITEST  PPIPH3           PHASE 3 ?
         BO    *+8                 YES
         L     R14,PPINETM+4       NO
         USING AIERROV,R14
         PPITEST  PPIEXTRT         EXTRACTING ?
         BZ    AONNEXT             NO, BRANCH
*
*        SET THE EXTRACT SWITCHES TO YES
*        THIS ALSO DETERMINES THE AMOUNT OF CORE REQD FOR THE
*        EXTR POS
*        PPIMRGMX IS USED IF BALANCED TECHNIQUE
*        PPIBDSVA MINUS ONE IS USED IF POLYPHASE TECHNIQUE
*        PPIMRGOP IS USED IF A DISK SORT
*
         PPITEST  PPIMERGO         MERGE ONLY ?
         BO    AOVNPOLY            YES, BRANCH
         PPITEST  PPITAPE          TAPE SORT ?
         BZ    AOVDISK             NO, BRANCH
         PPITEST  PPIPOLY          POLY TECHNIQUE ?
         BZ    AOVNPOLY            NO, BRANCH
         PPITEST  PPIPH3           PHASE 3 ?
         BO    AOVNPOLY            YES, BRANCH
         SR    R4,R4
         IC    R4,PPIBDSVA         NUMBER OF ENTRIES IN TAPE TABLE
         BCTR  R4,0                DECR COUNT
         ST    R4,KAOTECH          STORE IN DETERMINE AMT CORE CONSTANT
         B     AOVDET              SET EXTRACT BRANCH IN ROV
*
AOVDISK  MVC   KAOTECH+2(2),PPIMRGOP  STORE MRG ORD IN AMT CORE CONST
         B     AOVDET              SET EXTRACT BRANCH IN ROV
*
AOVNPOLY MVC   KAOTECH+2(2),PPIMRGMX  STORE MERGE ORD IN AMT CORE CON
AOVDET   XI    IERDOET+1,X'F0'
         LH    R3,PPILEXFF         LEN OF EXTR CTRL FLDS FROM PPI
         LA    R3,3(,R3)           ALIGN EXTR CNTL FLDS UPWARD TO WORD
         N     R3,KAORNDUP         BOUNDARY IF THEY AREN'T ALREADY
         LA    R3,4(,R3)           ADD ACTUAL ADDR BYTES TO CNTRL FLD
         ST    R3,IERDOEXL         STORE IN MERGE NETWORK
         SR    R2,R2
         L     R10,KAOTECH         MERGE ORDER FROM TECHNIQUE USED
         LA    R10,1(,R10)         MERGE ORDER + 1
         MR    R2,R10              DETERM AMT CORE REQD FOR EXTR POS
         L     R6,PPISPGN1         PROGRAM GENERATOR ADDR
*
*        CHECK WHETHER OR NOT PPISPGN1 IS ON A FULL WORD
*        BOUNDARY
*        IF NOT IT IS ROUNDED DOWNWARD TO A FULL WORD BOUNDARY
*
         TM    PPISPGN1+3,X'03'
         BZ    AOVNRNDU            NO ALIGNMENT NECESSARY
         LA    R6,3(,R6)
         N     R6,KAORNDUP
         S     R6,KAOFOUR
AOVNRNDU SR    R6,R3               UPDATE PROG GEN ADDR
         ST    R6,PPISPGN1         STORE PROG GEN ADDR
         ST    R6,IERDOAGE         BEG ADDR OF GEN EXTR POS IN MRG NTWK
         L     R12,PPIAXERT        SET BASE REG FOR EXTR RTN
         L     R2,PPIX61+4
         ST    R2,0(,R12)          SET USER EXIT ADDR IN EXTR RTN
         MVC   PPIDD0L1+3(1),PPILEXFD+1   MOVING THE LENGTH AND DISPLAC
         MVC   PPIDD0L1(2),KAOFOUR+2      ATTRIBUTE FOR CMP INSTR SET
*
*        DETERMINE WHICH PHASE IS BEING EXECUTED AND SET THE
*        APPROPRIATE SWITCHES
*
AOVPHT   PPITEST  PPIPH3           PHASE 3 ?
         BO    AOVPH3              YES, BRANCH
*
*        SET THE NETWORK COMPARE INSTRUCTIONS
*
AOVCIS   IC    R4,PPIDD0L1+3
         STC   R4,IERDOM8+1        LENGTH ATTRIBUTE
         OC    IERDOM8+2(2),PPIDD0L1  DISPLACEMENT ATTRIBUTE
         OC    IERDOM8+4(2),PPIDD0L1
         STC   R4,IERDOM4+1
         OC    IERDOM4+2(2),PPIDD0L1
         OC    IERDOM4+4(2),PPIDD0L1
         STC   R4,IERDOM2+1
         OC    IERDOM2+2(2),PPIDD0L1
         OC    IERDOM2+4(2),PPIDD0L1
         STC   R4,IERDOSCK+1
         OC    IERDOSCK+2(2),PPIDD0L1
         OC    IERDOSCK+4(2),PPIDD0L1
         STC   R4,IERDOCK6+1
         OC    IERDOCK6+2(2),PPIDD0L1
         OC    IERDOCK6+4(2),PPIDD0L1
         STC   R4,IERDOCK5+1
         OC    IERDOCK5+2(2),PPIDD0L1
         OC    IERDOCK5+4(2),PPIDD0L1
         STC   R4,IERDOCK7+1
         OC    IERDOCK7+2(2),PPIDD0L1
         OC    IERDOCK7+4(2),PPIDD0L1
         STC   R4,IERDOCK3+1
         OC    IERDOCK3+2(2),PPIDD0L1
         OC    IERDOCK3+4(2),PPIDD0L1
         STC   R4,IERDOCK4+1
         OC    IERDOCK4+2(2),PPIDD0L1
         OC    IERDOCK4+4(2),PPIDD0L1
         STC   R4,IERDOICP+1
         OC    IERDOICP+2(2),PPIDD0L1
         OC    IERDOICP+4(2),PPIDD0L1
*
*        EXIT TO NEXT ASSIGNMENT RTN
*
         L     R14,RKSAVC9
         BR    R14                 NEXT ASSIGNMENT RTN
*
*        NOT EXTRACTING
*
AONNEXT  XI    IERXTRT1+1,X'F0'
         XI    IERXTRT2+1,X'F0'
         MVI   ROVMERG+1,X'F0'     MODIFY BRANCH CONDITION IN ROV
         XI    IERDOBWR+1,X'F0'
         XI    IERDOSET+1,X'F0'
         B     AOVPHT              BRANCH TO PHASE TEST
*
*        PHASE 3 SETTINGS
*
AOVPH3   XI    IERDOCPS+1,X'F0'
         XI    IERDOBB1+1,X'F0'
         XI    IERNEXTR+1,X'F0'
         B     AOVCIS              GOTO SET COMPARE INSTR
*
KAOFOUR  DC    F'4'                CONSTANT OF FOUR
KAOTECH  DC    XL4'0'              DETERMINE AMT CORE CONSTANT
KAORNDUP DC    X'FFFFFFFC'         USED FOR BOUNDARY ALIGNMENT
RKSAVC9  DC    F'0'                ADDR OF NEXT ASSIGNMENT RTN
*
         DROP  R11,R14,R15
*
*        IERROV
*
AIERROV  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERROV SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERROVI
*
*        IERRMC
*
*        THIS DSECT CONTAINS ALL OF THE MESSAGES THAT ARE
*        REQUIRED FOR PHASE 3 OR MERGE ONLY RUNNING PROGRAM
*
DIERRMC  DSECT
*
         COPY  RMCMAIN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERAOW   0101-20211-20211-1200-00096-00096-00000-RELEASE 00
AOW      TITLE 'IERAOW - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERAOW
*
*        MODULE FUNCTION/OPERATION -
*        THIS MODULE IS AN ASSIGNMENT ROUTINE FOR MODULE IERROW.
*        ITS FUNCTION IS TO SET UP INSTRUCTION CONSTANTS IN
*        RUNNING PROGRAM
*
*        USED AS A DSECT IN - N/A
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                       CALLING SEQUENCE-
*                       L    R15,ASSG
*                       BALR R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIINT   PPINET
*
*        OUTPUT PPI FIELDS INITIALIZED OR ALTERED - N/A
*
*        RUNNING PROGRAM IS INITIALIZED
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL -
*        IERRC9 - RETURN TO LOAD MODULE
*                 BR  R14
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS - N/A
*
*        NOTES -
*        THIS MODULE IS USED ONLY WHEN THE OSC OR CRCX TECHNIQUES
*        ARE SELECTED. IT IS USED WITH MCF FIXED LENGTH RECORDS
*
IERAOW   CSECT
*
         USING *,R11
         USING IERRCA,R13
         USING IERROW,R9
         USING IERROA,R10
*
         LR    R11,R15             SET MODULE BASE REG
         L     R9,PPIINT+4         SET BASE REGS
         L     R10,PPINET+4        FOR DSECTS
*
*        TAKE CODE FROM SORT NETWORK AND PLACE IT IN
*        INITIALIZATION ROUTINE RUNNING PROGRAM SO IT CAN LATER
*        BE USED TO RESET THE NETWORK
*
         MVC   KICON2(4),OACASE44
         MVC   KICON3(4),OACAS27
         MVC   KICON4(4),OACAS15
         MVC   KICON5(4),OACASE41
         MVC   KICON6(10),OAC8A
         MVC   KICON7(4),OAGCT+4
         MVC   KICON8(12),OAPICK
         MVC   KICON9(4),OAMODLOC
         MVC   KICON10(8),OAMODNEW
         BR    R14
*
IERROW   DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERROW SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERROWI
*
IERROA   DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERROA SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERROAI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERAOX   0101-20211-20211-1200-00099-00099-00000-RELEASE 00
AOX      TITLE 'IERAOX - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERAOX
*
*        MODULE FUNCTION/OPERATION -
*        ASSIGNMENT ROUTINE FOR MODULE IERROX.
*        SET UP INSTRUCTION CONSTANTS IN RUNNING PROGRAM IERROX
*
*        USED AS A DSECT IN - N/A
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM:IERRC9
*                       CALLING SEQUENCE -
*                           L    R15,ASSG
*                           BALR R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIINT   PPINET
*        INSTRUCTIONS IN SORT
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        RUNNING PROGRAM IS INITIALIZED
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL -
*                BR R14 - RETURN TO IERRC9
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS - N/A
*
*        NOTES -
*        THIS MODULE IS USED WHEN THE OSCILLATING AND CRCX
*        TECHNIQUES ARE USED. IT IS USED WITH SINGLE CONTROL
*        FIELD FIXED LENGTH RECORDS
*
IERAOX   CSECT
*
         USING *,R11
         USING IERRCA,R13
         USING IERROX,R9
         USING IERROB,R10
*
         LR    R11,R15             SET MODULE BASE REG
         L     R9,PPIINT+4         SET BASE REGS
         L     R10,PPINET+4        FOR DSECTS
*
*        TAKE CODE FROM SORT NETWORK AND PLACE IT IN
*        INITIALIZATION ROUTINE RUNNING PROGRAM SO IT CAN LATER
*        BE USED TO RESET THE NETWORK
*
         MVC   KICON2(4),OACASE44
         MVC   KICON3(4),OACAS27
         MVC   KICON4(4),OACAS15
         MVC   KICON5(4),OACASE41
         MVC   KICON6(10),OAC8A
         MVC   KICON7(4),OAGCT+4
         MVC   KICON8(12),OAPICK
         MVC   KICON9(4),OAMODLOC
         MVC   KICON10(8),OAMODNEW
         BR    R14
*
*        IERROX
*
IERROX   DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERROX SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERROXI
*
*        IERROB
*
IERROB   DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERROB SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERROBI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERAOY   0101-20211-20211-1200-00094-00094-00000-RELEASE 00
AOY      TITLE 'IERAOY - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERAOY
*
*        MODULE FUNCTION/OPERATION -
*        ASSIGNMENT ROUTINE FOR IERROY
*        ITS SOLE FUNCTION IS TO SET UP INSTRUCTION CONSTANTS IN
*        RUNNING PROGRAM
*
*        USED AS A DSECT IN - N/A
*
*        MACROS USED SMPPI
*
*        ENTRY POINTS - ENTRY FROM IERRCE
*                       CALLING SEQUENCE -
*                           L    R15,ASSG
*                           BALR R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIINT   PPINET
*        INSTRUCTIONS IN SORT
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        RUNNING PROGRAM IS INITIALIZED
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL -
*                BR R14 - RETURN TO IERRC9
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS - N/A
*
*        NOTES -
*        THIS MODULE IS USED ONLY WHEN THE OSCILLATING TECHNIQUE
*        IS USED. IT IS USED WITH MCF-VARIABLE LENGTH RECORDS
*
IERAOY   CSECT
*
         USING *,R11
         USING IERRCA,R13
         USING IERROY,R9
         USING IERROC,R10
*
         LR    R11,R15             SET MODULE BASE REG
         L     R9,PPIINT+4         SET BASE REGS
         L     R10,PPINET+4        FOR DSECTS
*
*        TAKE CODE FROM SORT NETWORK AND PLACE IT IN
*        INITIALIZATION ROUTINE RUNNING PROGRAM SO IT CAN LATER
*        BE USED TO RESET THE NETWORK
*
         MVC   KICON2(8),OCC7A
         MVC   KICON3(4),OCPICK
         MVC   KICON4(4),OCMODLOC
         MVC   KICON5(8),OCMODNEW
         BR    R14
*
*        IERROY
*
IERROY   DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERROY SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERROYI
*
*        IERROC
*
IERROC   DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERROC SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERROCI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERAOZ   0101-20211-20211-1200-00094-00094-00000-RELEASE 00
AOZ      TITLE 'IERAOZ - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERAOZ
*
*        MODULE FUNCTION/OPERATION -
*        ASSIGNMENT ROUTINE FOR MODULE IERROZ
*        ITS SOLE FUNCTION IS TO SET UP INSTRUCTION CONSTANTS IN
*        RUNNING PROGRAM
*
*        USED AS A DSECT IN - N/A
*
*        MACROS USED SMPPI
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                       CALLING SEQUENCE -
*                           L    R15,ASSG
*                           BALR R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIINT   PPINET
*        INSTRUCTIONS IN SORT
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        RUNNING PROGRAM IS INITIALIZED
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL -
*                BR R14 - RETURN TO IERRC9
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS - N/A
*
*        NOTES -
*        THIS MODULE IS USED FOR THE OSCILLATING TECHNIQUE
*        IT IS USED WITH SCF-VARIABLE LENGTH RECORDS
*
IERAOZ   CSECT
*
         USING *,R11
         USING IERRCA,R13
         USING IERROZ,R9
         USING IERROD,R10
*
         LR    R11,R15             SET MODULE BASE REG
         L     R9,PPIINT+4         SET BASE REGS
         L     R10,PPINET+4        FOR DSECTS
*
*        TAKE CODE FROM SORT NETWORK AND PLACE IT IN
*        INITIALIZATION ROUTINE RUNNING PROGRAM SO IT CAN LATER
*        BE USED TO RESET THE NETWORK
*
         MVC   KICON2(8),OCC7A
         MVC   KICON3(4),OCPICK
         MVC   KICON4(4),OCMODLOC
         MVC   KICON5(8),OCMODNEW
         BR    R14
*
*        IERROZ
*
IERROZ   DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERROZ SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERROZI
*
*        IERROD
*
IERROD   DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERROD SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRODI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERAO1   0101-20211-20211-1200-00348-00348-00000-RELEASE 00
AO1      TITLE 'IERAO1 - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERAO1
*
*        MODULE FUNCTION/OPERATION -
*        GENERAL ASSIGNMENT DASD MODULE FOR BOTH BALN AND CRCX.
*        THE FUNCTION OF THIS MODULE IS TO OPTIMIZE THE GIVEN
*        AREAS SO THAT THE MOST EFFICIENT DEVICE OVERLAP IS
*        ACQUIRED. THIS IS ACCOMPLISHED BY SORTING ON THE SIZE OF
*        AREAS AND THEN CHECKING CHANNELS AND UNITS SO AS TO
*        ALTERNATE DEVICES WHEN POSSIBLE
*
*        USED AS A DSECT IN - N/A
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS -  ENTRY FROM IERRCZ
*                        CALLING SEQUENCE -
*                            L     R15,=V(IERAO1)
*                            BALR  R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPINDSKA PPICNTL
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPIDSKED   PPISTAR   PPIENDAR
*        PPIDSKED WILL CONTAIN ORIGINAL AREA ENDING ADDRESSES SO
*        THAT ON PHASE TO PHASE TRANSFER PROPER CONTINUITY IS
*        MAINTAINED
*        PPISTAR AND PPIENDAR WILL CONTAIN THE REARRANGED
*        (OPTIMIZED) AREA ADDRESSES
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL -
*        BR R14 - RETURN TO IERRCZ
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS -
*        WORKTAB - CHANNEL, DEVICE AND SIZE TABLE
*
*        NOTES - THIS MODULE IS RESTRICTED TO DASD SORTS
*
IERAO1   CSECT
*
         USING *,R11               SET NORMAL BASE = R11
         USING IERRCA,R13          PPI
*
         IERENTRY 'IERAO1 &SYSDATE &SYSTIME'
*
         STM   R2,R11,0(R12)       SAVE REGS
         LR    R11,R15
*
*        INITIALIZE REGISTERS
*
         LA    R9,PPIDSKED         R9 -> CU ADDR/SIZE TABLE
         LA    R4,WORKTAB          R4 -> WORK TABLE
         LH    R5,PPINDSKA         R5  = NUMBER OF SORTWK AREAS
*
*        MOVE THE AREA UCB ADDRS AND SIZES FROM PPIDSKED TO WORKTAB
*
AO1001   MVC   1(4,R4),0(R9)       MOVE A FOUR BYTE ENTRY FROM PPIDSKED
*                                  INTO WORKTAB
         LA    R4,5(,R4)           INCR POINTERS
         LA    R9,4(,R9)
         BCT   R5,AO1001           END OF TABLE ? NO, BRANCH
         PPITEST  PPI2314          CRCX SORT ?
         BO    AO1OUT              YES, DO NOT OPTIMIZE FOR CRCX
*
*        FOR BALN SORTS ONLY
*
*        SORT THE AREAS IN WORKTAB ACCORDING TO SIZE
*        WITH A BUBBLE SORT
*
         LA    R10,5               SET SUBTRACT VALUE
         LA    R9,WORKTAB          R9 -> WORKTAB
         LR    R6,R9               R6 -> WORKTAB
         LH    R5,PPINDSKA         R5 = NUMBER OF DISK AREAS
AO1SET1  LA    R8,5(,R6)           R8 -> NEXT ENTRY IN WORKTAB
         BCT   R5,AO1KEEP          SIFT FINISHED ? NO, BRANCH
         B     AO1CONT             YES, BRANCH
*
AO1KEEP  LR    R7,R6               SET PT = P1
AO1SIFT  CLC   3(2,R8),3(R6)       COMPARE P1 VS P2
         BNL   AO1RESET            NOT LOW, BRANCH
         MVC   KMOVEX(5),0(R6)
         MVC   0(5,R6),0(R8)       SWITCH ENTRIES AT P1 AND P2
         MVC   0(5,R8),KMOVEX
*
         LR    R8,R6               SET  P2 = P1
         SR    R6,R10                   P1 = P1-4
         CR    R6,R9               P1 VS P0
         BNL   AO1SIFT             NOT LOW, GO BACK THRU TABLE
AO1RESET LA    R6,5(,R7)           SET P1 = PT+5
         B     AO1SET1             BRANCH TO NEXT COMPARE
*
*        FOR BALN SORTS ONLY
*
*        SET UP THE POINTER TO THE LAST ENTRY IN WORKTAB. IT IS
*        FOUND BY ADDING 5 TIMES THE NUMBER OF WORK AREAS
*        (PPINDSKA) MINUS 1 TO THE BEGINNING ADDR OF THE TABLE
*
AO1CONT  SR    R6,R6               R5 = LAST ENTRY IN THE WORK TABLE
         LA    R7,5                (WORKTAB) TO BE OPTIMIZED
         LH    R9,PPINDSKA
         BCTR  R9,0
         MR    R6,R9               R5 = A(WORKTAB) + 5 X (PPINDSKA-1)
         LA    R5,WORKTAB
         LR    R4,R5               SET UP POINTER TO FIRST ENTRY
         AR    R5,R7
*
*        CALL THE OPTIMIZER SUBROUTINE TO OPTIMIZE THE WORK
*        AREAS BY CHANNEL
*
         BAS   R10,AO1OPTIM        CALL OPTIMIZER SUBROUTINE
*
*        MODIFY THE OPTIMIZER SUBROUTINE TO OPTIMIZE THE WORK
*        AREAS BY DEVICE AND LINKS TO THE SUBROUTINE. IT ALTERS
*        THE INSTRUCTIONS LABELED AO1DEC1 AND AO1DEC2 WITHIN
*        THE SUBROUTINE TO TAKE THE BRANCHES APPROPRIATELY
*        FOR DEVICE OPTIMIZING
*
         NI    AO1DEC1+1,X'0F'
         NI    AO1DEC2+1,X'0F'     NOP THE BRANCH INSTRUCTIONS
         BAS   R10,AO1OPTIM        CALL OPTIMIZER
*
*        FOR BOTH BALN AND CRCX TECHNIQUES
*
*        ORDER ACTUAL ADDRS VIA OPTIMIZED AREA KEYS IN SIZE
*        CHANNEL TABLE MOVE SCRAMBLED ADDRS (DISK) TO WORK AREA,
*        THEN USE TABLE KEYS TO SET THEM BACK IN THE SAME ORDERED
*        FASHION AS THE TABLE IS IN
*
AO1OUT   MVC   KWORKBEG(17*8),PPISTAR   MOVE ALL 17 START M000000R
         MVC   KWORKEND(17*8),PPIENDAR  MOVE ALL 17 END M0000TTR
         LA    R6,PPISTAR     R6 -> DISK ADDR TABLE START ADDR
         LA    R7,PPIENDAR    R7 -> DISK ADDR TABLE END ADDR
         LH    R8,PPINDSKA    SET LIMIT CTR = N
         LA    R3,WORKTAB     R3 -> STARTING POINT OF CHANNEL/SIZE TAB
AO1LOOPB LA    R4,KWORKBEG    R4 -> STARTING POINT OF WORK AREAS
         LA    R5,KWORKEND    R5 -> ENDING POINT OF WORK AREAS
         SR    R2,R2          GET AREA KEY FROM TABLE
         IC    R2,0(,R3)
*
*        MULTIPLY KEY BY 8 TO CALC DISPL FROM STARTING POINT OF
*        BEGINNING AND END ADDR IN ORDER TO PICK OUT APPROPRIATE
*        ADDR THAT MATCH THEIR AREA KEY
*
         SLL   R2,3
*
*        ADD DISPL TO BEG AND END STARTING POINTS OF WORK AREAS
*
         AR    R4,R2
         AR    R5,R2
*
*        MOVE APPROPRIATE BEG AND END ADDR BACK TO NEXT SLOT IN PPI
*
         MVC   0(8,R6),0(R4)
         MVC   0(8,R7),0(R5)
         LA    R3,5(,R3)           BUMP TABLE PTR BY 4
*
         LA    R6,8(,R6)           BUMP BEG AND END DISK ADDR
         LA    R7,8(,R7)           PTRS IN PPI BY 8
*
*        AT END OF TABLE ?
*
         BCT   R8,AO1LOOPB         NO, BRANCH AND GET NEXT ADDR
*
*        CONVERT WORK NOS IN DISK ADDR TO DCB INCREMENTS PRIOR TO ALG
*
         LA    R6,PPISTAR         R6 -> DISK START ADDR
         LA    R9,PPIENDAR        R9 -> END DISK ADDR
         LH    R10,PPINDSKA       NO OF DISK AREAS
AO1LOOP  IC    R1,0(0,R6)         GET WORK UNIT NO (M)
         SLL   R1,2               CONVERT TO INCREMENT IN DCB TABLE
         STC   R1,0(,R6)          PUT BACK IN PPISTAR
         STC   R1,0(,R9)          PUT BACK IN PPIENDAR (SAME INCRM'T)
         LA    R6,8(,R6)          BUMP TO NEXT DISK AREA
         LA    R9,8(,R9)          BUMP TO NEXT DISK AREA
         BCT   R10,AO1LOOP        END OF AREAS ?, NO, LOOP
         PPITEST  PPI2314         USING CRCX ALGORITHM ?
         BO    AO1EXIT            YES,  SKIP MOVE INSTRUCTION
*                                 BALN - COPY 6 EXTENT END ADDRS
         MVC   PPIDSKED(6*8),PPIENDAR    OVER CUNN TABLE FOR LATER
AO1EXIT  LM    R2,R11,0(R12)
*
*        EXIT TO SSC
*
         SR    R15,R15             ZERO RETURN CODE
         BR    R14
*
*        AO1OPTIM
*
*        OPTIMIZER ROUTINE WHICH GOES THROUGH THE WORK
*        TABLE AND OPTIMIZES THE WORK AREAS BY CHANNEL AND UNIT
*        ADDRESS AS PROVIDED FROM THE UCB
*
*        ON ENTRY -
*        R4 -> FIRST WORKTAB ENTRY
*        R5 -> LAST WORKTAB ENTRY
*
*        THE FOLLOWING INSTRUCTION SETS A SWITCH
*        SET AO1CONT1 TO A NOP
*
AO1OPTIM NI    AO1CONT1+1,X'0F'    SET SWITCH ON
         LA    R8,5                INITIALIZE CONSTANTS
         LA    R2,5(,R4)           R2 -> NEXT WORKTAB ENTRY
AO1LOOP3 LR    R6,R5               SET R6 = R5, LAST WORKTAB ENTRY
AO1LOOP1 CR    R6,R2               FIRST PASS COMPLETE ?
         BE    AO1CONT1            YES, BRANCH
         LR    R9,R6               SET
         SR    R9,R8                    R9=R6-5
         LR    R7,R9
         SR    R7,R8                    R7=R6-10
*
*        THE FOLLOWING INSTRUCTION WILL BE MODIFIED BY THE MAIN
*        ROUTINE BEFORE THIS SUBROUTINE IS ENTERED TO OPTIMIZE ON
*        DEVICE. THE UNCONDITIONAL BRANCH TO THE BRANCH AND LINK
*        TO A01CHAN WILL BE CHANGED TO A NOP AND WILL FALL THRU
*        TO A BRANCH AND LINK TO AO1DEV
*
AO1DEC1  B     AO1GO1              BRANCH IF CHANNEL OPTIMIZATION
         BAS   R3,AO1DEV           CALL DEVICE RTN
AO1MOD1  SR    R6,R8               SET R6 = R6-5
         B     AO1LOOP1            CONTINUE THRU LOOP
*
AO1GO1   BAS   R3,AO1CHAN          CALL CHANNEL RTN
         B     AO1MOD1
*
*        THE FOLLOWING INSTRUCTION IS A FIRST TIME SWITCH. THE
*        FIRST TIME IT IS SET TO A NOP. AFTER ITS FIRST
*        EXECUTION, IT IS SET TO AN UNCONDITIONAL BRANCH
*
AO1CONT1 B     AO1RET1
*
         OI    AO1CONT1+1,X'F0'    SET SWITCH OFF
         LR    R9,R2               REINITIALIZE POINTERS
AO1LOOP2 CR    R9,R5               END OF THIS LOOP ?
         BE    AO1LOOP3            YES, RETURN FOR THIRD PASS
         LR    R6,R9               SET
         SR    R6,R8                    R6=R9-5
         LA    R7,5(,R9)                R7=R9+5
*
*        THE FOLLOWING INSTRUCTION WILL BE MODIFIED FOR DEVICE
*        OPTIMIZATION
*
AO1DEC2  B     AO1GO2              BRANCH IF CHANNEL OPTIMIZATION
*
         BAS   R3,AO1DEV           CALL DEVICE RTN
AO1MOD2  LA    R9,5(,R9)           SET R9=R9+5
         B     AO1LOOP2            CONTINUE LOOP
*
AO1GO2   BAS   R3,AO1CHAN          CALL CHANNEL RTN
         B     AO1MOD2
*
AO1RET1  BR    R10                 RETURN FROM OPTIMIZER SUBROUTINE TO
*                                  MAIN ROUTINE
*
*        THE FOLLOWING SUBROUTINES AO1DEV AND AO1CHAN
*        ARE THE ONE THAT ACTUALLY DO THE ENTRY COMPARE
*        AND EXCHANGE OF ENTRIES IF NECESSARY
*
*        AO1DEV COMPARES THE DEVICES CONTAINED IN THE ENTRIES
*        POINTED TO BY R6 AND R9. IF EQUAL IT COMPARES THE SIZES
*        POINTED TO BY R9 AND R7. IF BOTH ARE EQUAL, IT EXCHANGES
*        THE ENTRIES R7 AND R9
*
AO1DEV   CLC   2(1,R6),2(R9)       COMPARE DEVICES IN TWO ENTRIES
         BNE   AO1RET2             NOT EQUAL, BRANCH
         CLC   3(2,R9),3(R7)       EQUAL, COMPARE SIZES OF NEXT TWO
         BNE   AO1RET2             NOT EQUAL, BRANCH
         CLC   1(1,R9),1(R7)       EQUAL, COMPARE CHANNEL OF NEXT TWO
         BNE   AO1RET2             NOT EQUAL, BRANCH
AO1EXC   MVC   KMOVEX(5),0(R9)     EXCHANGE ENTRIES POINTED TO BY
         MVC   0(5,R9),0(R7)       R9 AND R7
         MVC   0(5,R7),KMOVEX
AO1RET2  BR    R3                  EXIT TO OPTIMIZER
*
*        AO1CHAN COMPARES THE CHANNELS IN THE ENTRIES POINTED TO
*        BY R6 AND R9. IF EQUAL IT COMPARES THE SIZES OF THE
*        NEXT TWO ENTRIES. IF EQUAL, IT EXCHANGES THEM
*
AO1CHAN  CLC   1(1,R6),1(R9)       COMPARE CHANNELS AT R6 AND R9
         BNE   AO1RET2             NOT EQUAL, BRANCH
         CLC   3(2,R9),3(R7)       EQUAL, COMPARE SIZES OF NEXT TWO
         BNE   AO1RET2             NOT EQUAL, BRANCH
*                                  CHANGES SW1 TO AN UNCON BRANCH
         B     AO1EXC              GOTO EXCHANGE
*
*        CHANNEL, DEVICE AND SIZE TABLE FOR UP TO 17 ENTRIES
*
WORKTAB  DC    AL1(00)             SORTWK NUMBER
         DC    XL4'00'             CU ADDR/NO OF TRACKS
         DC    AL1(01)
         DC    XL4'00'
         DC    AL1(02)
         DC    XL4'00'
         DC    AL1(03)
         DC    XL4'00'
         DC    AL1(04)
         DC    XL4'00'
         DC    AL1(05)
         DC    XL4'00'
         DC    AL1(06)
         DC    XL4'00'
         DC    AL1(07)
         DC    XL4'00'
         DC    AL1(08)
         DC    XL4'00'
         DC    AL1(09)
         DC    XL4'00'
         DC    AL1(10)
         DC    XL4'00'
         DC    AL1(11)
         DC    XL4'00'
         DC    AL1(12)
         DC    XL4'00'
         DC    AL1(13)
         DC    XL4'00'
         DC    AL1(14)
         DC    XL4'00'
         DC    AL1(15)
         DC    XL4'00'
         DC    AL1(16)
         DC    XL4'00'
*
*        WORK TABLES
*
KWORKBEG DC    17D'0'              BEGINNING M0000TTR (TT)
KWORKEND DC    17D'0'              ENDING    M0000TTR (TT)
*
KSWITCH  DC    X'00'
KMOVEX   DC    XL5'00'             TEMPORARY HOLD AREA FOR TABLE ENTRY
*                                  TABLE AREAS IN ORDERING PROCESS
KEQUALSW DC    X'01'               SET UP ON
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERAO2   0101-20211-20211-1200-00773-00773-00000-RELEASE 00
AO2      TITLE 'IERAO2 - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERAO2
*
*        MODULE FUNCTION/OPERATION -
*        OPTIMIZATION PHASE TAPE TABLE ROUTINE
*        THE FUNCTION OF THIS MODULE IS TO OPTIMIZE THE
*        ARRANGEMENT OF WORK SO AS TO EFFECT THE MOST EFFICIENT
*        BALANCED SORT. THIS IS DONE EVEN IF THE POLYPHASE
*        TECHNIQUE IS TO BE UTILIZED
*
*        USED AS A DSECT IN - N/A
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM IERRCZ
*                       CALLING SEQUENCE -
*                            LA   R15,VALUE
*                            BALR R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIMRGAL   PPICNTL   PPITPBL
*        PPIMRGMX   PPITPPT
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPITPTBL
*
*        EXTERNAL ROUTINES - NONE
*
*        EXTERNAL PARAMETERS - NONE
*
*        EXITS - NORMAL -
*        IERRC9 - CALLER PROGRAM FOR ASSIGNMENT PROG
*
*        EXITS - ERROR -
*        IERRC9 - CALLER PROGRAM FOR ASSIGNMENT PROG
*
*        TABLES/WORK AREAS -
*        A TAPE TABLE, POINTED TO BY PPITPTBL, IS MANIPULATED BY
*        IERAO2 AN INDEX TABLE, POINTED TO BY KINDEXPT, IS
*        MANIPULATED BY IERAO2
*
*        NOTES - NONE
*
IERAO2   CSECT
*
         USING *,R11
         USING IERRCA,R13
*
         IERENTRY 'IERAO2 &SYSDATE &SYSTIME'
*
         STM   R2,R11,0(R12)       SAVE REGS
         LR    R11,R15
         PPITEST  PPIINWRK         INPUT UNIT ALSO A WORK UNIT ?
         BO    AO2GOZ              YES, SAVE SORTWK01 AND UPDATE TABLE
*
*        CHANNEL ENVIRONMENT TESTING
*
AO2ETST  PPITEST  PPITAU           IN A CHANNEL SWITCHING ENVIRONMENT ?
         BO    AO2GOA              YES, BYPASS OPTIMIZE SECT OF RTN
         PPITEST  PPINCHAN         IN A 1 CHANNEL ENVIRONMENT ?
         BO    AO2GOA              YES, BYPASS OPTIMIZE SECT OF RTN
         PPITEST  PPIOSC           OSCILLATING
         BO    AO2GOA              YES, BYPASS OPTIMIZATION
*
*        THE TAPE TABLE IS SCANNED SO AS TO COLLECT UNITS ON THE
*        SAME CHANNEL IE THOSE UNITS ON THE SAME CHANNEL ARE
*        PUT IN THE SAME POSITION OF A TABLE CALLED KCOLLAR
*
*        AN INDEX TABLE IS ALSO SETUP WHICH CONTAINS THE
*        BEGINNING ADDRESS OF WHERE IN KCOLLAR A COLLECTION OF
*        UNITS IS AND HOW MANY ARE REPRESENTED THEREIN
*
         LA    R1,PPITPTBL
         ST    R1,KPTR1            SET TO START PT OF TAPE TBL
         LA    R1,2(,R1)
         ST    R1,KPTR2            SET TO KPTR1 + 4
         LA    R1,KINDEX
         ST    R1,KINDXPT          SET PTR TO FIRST POS OF INDEX TBL
         LA    R2,KCOLLAR
         ST    R2,KCOLLPTR         SET PTR TO FIRST POS OF COLLECT AREA
         ST    R2,4(,R1)           PUT FIRST COLLECT ADDR IN INDEX TBL
         LH    R3,PPIMRGMX
         AH    R3,PPIMRGAL         TOTAL ENTRIES IN TBL
         L     R4,KLMTADJ
         SR    R3,R4               TOTAL ENTRIES MINUS ONE
         ST    R3,KLMTCTAX         LMT OF TRAVELING PTR OF TAPE TBL
         ST    R3,KLMTCTBX         LMT OF PERMANENT PTR OF TAPE TBL
         LA    R4,1
         ST    R4,0(,R1)           PRIME FIRST CTR TO ONE
         L     R3,KPTR1
         MVC   0(2,R2),0(R3)       FIRST UNIT OF TBL TO COLLECT AREA
         L     R4,KCOLLPTR
         L     R5,KINDXLMT
         LA    R5,1(,R5)
         ST    R5,KINDXLMT
         LA    R4,2(,R4)
         ST    R4,KCOLLPTR         INCR COLLECT PTR
         MVC   KSVCTA(4),KLMTCTAX  SAVE CTR LMT FOR RESET
         LA    R5,KPUSETBL
         ST    R5,KPUSEPTR
         ST    R5,KUSEPT
         LA    R4,1
         STC   R4,0(,R5)           THIS UNIT USED SET
         LA    R5,2(,R5)           INCR USED TBL PTR
         ST    R5,KPUSEPTR
AO2GOF   CLI   KLMTCTAX+3,X'00'    LIMIT FOR ZERO TRVL PTR END TBL ?
         BE    AO2GOE              YES, BRANCH
         L     R1,KPUSEPTR
         CLI   0(R1),X'01'         TEST THIS UNIT (PREV USED) ?
         BE    AO2GOC              YES, FALL THRU
         L     R2,KPTR1
         L     R1,KPTR2
         CLC   0(1,R2),0(R1)       THE CHANNELS OF THESE 2 UNITS EQ ?
         BNE   AO2GOC              YES, FALL THRU
*
*        ADD 1 TO CTR POINTED AT
*
         L     R4,KINDXPT
         L     R5,0(,R4)
         LA    R5,1(,R5)
         ST    R5,0(,R4)
*
*        MOVE UNIT AT PTR 2 TO COLLECT AREA
*
         L     R4,KPTR2
         L     R5,KCOLLPTR
         MVC   0(2,R5),0(R4)
*
*        SET 1 IN INPUT BYTE OF UNIT JUST USED IN TAPE TABLE
*
         L     R4,KPUSEPTR
         LA    R6,1
         STC   R6,0(,R4)
*
*        BUMP COLLECT PTR
*
         LA    R5,2(,R5)
         ST    R5,KCOLLPTR
*
*        DECREMENT LIMIT CTR A BY 1
*
AO2GOC   L     R4,KLMTCTAX
         LA    R5,1
         SR    R4,R5
         ST    R4,KLMTCTAX
*
*        BUMP PTR 2 BY 2 (BYTES)
*
         L     R4,KPTR2
         LA    R4,2(,R4)
         ST    R4,KPTR2
         L     R4,KPUSEPTR
         LA    R4,2(,R4)
         ST    R4,KPUSEPTR
         B     AO2GOF
*
*        LIMIT CTR B EQUAL ZERO ?
*        (END OF COLLECTING LIKE CHANNELS)
*
AO2GOE   CLI   KLMTCTBX+3,X'00'
         BE    AO2GOL              NO, FALL THRU
*
*        DECREMENT LIMIT CTR B BY 1
*
         L     R4,KLMTCTBX
         LA    R5,1
         SR    R4,R5
         ST    R4,KLMTCTBX
*
*        BUMP PTR 1 BY 2
*
         L     R4,KPTR1
         LA    R4,2(,R4)
         ST    R4,KPTR1
*
*        SET PTR 2 = PTR 1+2
*
         LA    R4,2(,R4)
         ST    R4,KPTR2
         L     R4,KUSEPT
         LA    R4,2(,R4)
         ST    R4,KUSEPT
*
*        SET LIMIT CTR A = SAVED CTR A MINUS 1 AND SAVE NEW CTR A
*
         L     R4,KSVCTA
         LA    R5,1
         SR    R4,R5
         ST    R4,KLMTCTAX
         ST    R4,KSVCTA
*
*        HAS UNIT BEEN USED ?
*
         L     R6,KUSEPT
         CLI   0(R6),X'01'
         BE    AO2GOE              IF UNIT HAS BEEN(1 ON), BRANCH
         LA    R7,1
         STC   R7,0(,R6)
         LA    R6,2(,R6)
         ST    R6,KPUSEPTR
*
*        BUMP CTR PTR BY 8 (END OF 1 PASS, ALL LIKE CHANNELS
*        COLLECTED)
*
         L     R7,KINDXPT
         LA    R7,8(,R7)
         ST    R7,KINDXPT
*
*        ADD 1 TO CTR TBL LIMIT (FOR NXT PHASE OF ORDERING)
*
         L     R4,KINDXLMT
         LA    R4,1(,R4)
         ST    R4,KINDXLMT
*
*        PUT NXT EMPTY SLOT FR COLL AREA IN INDEX
*
         L     R1,KCOLLPTR
         L     R2,KINDXPT
         ST    R1,4(,R2)
*
*        ADD 1 TO COUNT IN INDEX
*
         L     R3,0(,R2)
         LA    R3,1(,R3)
         ST    R3,0(,R2)
*
*        MOVE UNIT AT PTR 1 TO COLL AREA
*
         L     R4,KPTR1
         MVC   0(2,R1),0(R4)
*
*        BUMP COLL PTR BY 2
*
         LA    R1,2(,R1)
         ST    R1,KCOLLPTR
         B     AO2GOF
*
*        FORCE OUT LAST ITEM
*        HAS UNIT BEEN USED ?
*
AO2GOL   L     R6,KUSEPT
         CLI   0(R6),X'01'
         BE    AO2GOG
*
*        BUMP CTR PTR BY 8
*
         L     R7,KINDXPT
         LA    R7,8(,R7)
         ST    R7,KINDXPT
*
*        ADD 1 TO CTR TBL LIMIT
*
         L     R4,KINDXLMT
         LA    R4,1(,R4)
         ST    R4,KINDXLMT
*
*        PUT NEXT EMPTY SLOT FROM COLL AREA IN INDEX
*
         L     R1,KCOLLPTR
         L     R2,KINDXPT
         ST    R1,4(,R2)
*
*        ADD 1 TO COUNT IN INDEX
*
         L     R3,0(,R2)
         LA    R3,1(,R3)
         ST    R3,0(,R2)
*
*        MOVE UNIT AT PTR 1 TO COLL AREA
*
         L     R4,KPTR1
         LA    R4,2(,R4)
         MVC   0(2,R1),0(R4)
*
*        SORTING COLLECTED LIKES
*        SORT THE ENTRIES IN KINDEX BY NUMBER OF UNITS FROM HIGH
*        TO LOW SO AS TO FACILITATE FINDING A COMBINATION OF THE
*        NUMBER OF UNITS ON CHANNELS FOR THE OPTIMINAL ACTION
*
*        SET PTR X AND PTR Y = START POINTER OF INDEX AND
*        INDEX+8 RESPV
*
AO2GOG   LA    R1,KINDEX
         ST    R1,KPTRX
         LA    R1,8(,R1)           BUMP BY 8
         ST    R1,KPTRY
*
*        SET INDEX LIMIT FOR PTR X AND PTR Y
*
         MVC   KPTRXLMT(4),KINDXLMT
         MVC   KPTRYLMT(4),KINDXLMT
         MVC   KDXLM(4),KINDXLMT
*
*        KPTRY LIMIT =0 ?
*
AO2GOJ   CLI   KPTRYLMT+3,X'01'
         BE    AO2GOH
*
*        DECREMENT Y LIMIT BY 1
*
         L     R1,KPTRYLMT
         LA    R2,1
         SR    R1,R2
         ST    R1,KPTRYLMT
*
*        COMPARE COUNT AT PTR Y TO COUNT AT PTR X
*
         L     R2,KPTRY
         L     R3,KPTRX
         CLC   3(1,R2),3(R3)
         BNH   AO2GOI              CTR Y IS <= THAN  X
*
*        SWAP COUNTS AND ADDRS AT X AND Y
*
         MVC   KORDSWAP(8),0(R3)
         MVC   0(8,R3),0(R2)
         MVC   0(8,R2),KORDSWAP
*
*        BUMP PTR Y BY 8
*
AO2GOI   LA    R2,8(,R2)
         ST    R2,KPTRY
         B     AO2GOJ
*
*        KPTRX LIMIT= 1 ?
*
AO2GOH   CLI   KPTRXLMT+3,X'01'
         BE    AO2GOK
*
*        BUMP PTR X BY 8
*
         L     R1,KPTRX
         LA    R1,8(,R1)
         ST    R1,KPTRX
*
*        RESET PTR Y = PTR X +8
*
         LA    R1,8(,R1)
         ST    R1,KPTRY
*
*        DECREMENT LIMIT OF ENTRIES IN INDEX TBL BY 1
*
         L     R2,KINDXLMT
         LA    R3,1
         SR    R2,R3
         ST    R2,KINDXLMT
*
*        RESET PTR X AND PTR Y TBL LIMITS = NEW INDEX TBL LIMIT
*
         ST    R2,KPTRXLMT
         ST    R2,KPTRYLMT
         B     AO2GOJ
*
*        IN TABLE 2 ARE THOSE ENTRIES FROM KINDEX WHICH ARE ON
*        THE SAME CHANNEL AS THE INPUT DEVICE. IN TABLE 1 ARE
*        THOSE ENTRIES FROM KINDEX WHICH ARE ON CHANNELS OTHER
*        THAN THE INPUT DEVICE. THE NUMBER OF UNITS IN EACH TABLE
*        IS ALSO KEPT
*
*        SET TABLE ADDRESSES
*
AO2GOK   L     R3,KDXLM
         LA    R4,KINDEX
         LA    R5,KTBL1
         LA    R6,KTBL2
*
*        IS UNIT ON SAME CHANNEL AS INPUT ?
*
AO2GON   L     R7,4(,R4)
         CLC   0(1,R7),PPITPPT     SAME CHANNEL AS INPUT ?
         BE    AO2GOM              YES, PLACE IN TBL2
*
*        PLACE UNIT IN TBL1
*
         MVC   0(8,R5),0(R4)       NO, PLACE IN TBL1
*
*        INCREMENT NUMBER OF ENTRIES, TOTAL COUNT, AND TBL1 ADDR
*
         L     R8,KTBL1LMT
         LA    R8,1(,R8)
         ST    R8,KTBL1LMT
         L     R8,0(,R4)
         L     R10,KTOTTBL1
         AR    R10,R8
         ST    R10,KTOTTBL1
         LA    R5,8(,R5)
*
*        INCREMENT INDEX TABLE ADDRESS BY 8
*
AO2GOP   LA    R4,8(,R4)
*
*        BRANCH TO AO2GON IF LIMIT IS NOT ZERO
*
         BCT   R3,AO2GON
*
*        DETERMINE NO REQUIRED FOR FIRST HALF OF TAPE TABLE
*
         LH    R3,PPIMRGMX
         AH    R3,PPIMRGAL
         LA    R3,1(,R3)
         SRL   R3,1
         ST    R3,K02QUOT          SAVE QUOTIENT
*
*        QUOTIENT EQUAL TO NO UNITS ON CHAN OTHER THAN INPUT ?
*
         C     R3,KTOTTBL1
         BE    AO2GOV
         BL    AO2GOR
*
*        QUOTIENT EQUAL TO NO UNITS ON SAME CHAN AS INPUT ?
*
         C     R3,KTOTTBL2
         BE    AO2GO8
*
*        IF BRANCH IS TAKEN, TAPE TBL IS SET UP FIRST FROM TBL2,
*        THEN TBL1
*
AO2GOV   L     R8,KTBL1LMT
         LA    R3,PPITPTBL
         LA    R4,KTBL1
AO2GOQ   L     R5,4(,R4)           SET UP TAPE TBL FROM TBL1 FIRST
         L     R6,0(,R4)           AND THEN FROM TBL 2OR VICE VERSA
         SLL   R6,1
         LR    R7,R6
         LTR   R6,R6
         BZ    AO2NMV
         S     R6,KROONE
         EX    R6,AO2MTT
         AR    R3,R7
         S     R8,KROONE
AO2NMV   LTR   R8,R8
*
*        IF TAPE TBL IS TO BE SET UP FIRST FROM TBL1, THE
*        INSTRUCT AT AO2BZT IS BZ AO2GOT. IF TAPE TBL IS TO BE
*        SET UP FIRST FROM TBL2, THE INSTRUCTION IS BZ AO2GO9
*        TBL1 IS FOR UNITS ON CHANNEL OTHER THAN INPUT
*        TBL2 IS FOR UNITS ON SAME CHANNEL AS INPUT
*
AO2BZT   BZ    AO2GOT
         LA    R4,8(,R4)
         B     AO2GOQ
*
*        THIS CODE INITIALIZES AO2GOQ CODE TO SET TAPE TABLE FROM
*        TBL2 - UNITS ON SAME CHANNEL AS INPUT DEVICE
*
AO2GOT   NOP   AO2GOS
         L     R8,KTBL2LMT
         LA    R4,KTBL2
         XI    AO2GOT+1,X'F0'
         B     AO2GOQ
*
*        THIS CODE IS EXECUTED SO THAT TAPE TBL IS SET UP FIRST
*        FROM TBL2
*
AO2GO8   L     R8,KTBL2LMT
         LA    R4,KTBL2
         LA    R3,PPITPTBL
         MVC   AO2BZT(4),AO2SBZ
         B     AO2GOQ
*
*        THIS CODE INITIALIZES AO2GOQ CODE TO SET TAPE TABLE FROM
*        TBL1 - UNITS ON CHANNEL OTHER THAN INPUT DEVICE
*
AO2GO9   NOP   AO2GOS
         L     R8,KTBL1LMT
         LA    R4,KTBL1
         XI    AO2GO9+1,X'F0'
         B     AO2GOQ
*
AO2GOM   MVC   0(8,R6),0(R4)       PLACE ITEM IN TBL2
         L     R8,KTBL2LMT
         LA    R8,1(,R8)
         ST    R8,KTBL2LMT
         L     R8,0(,R4)
         L     R10,KTOTTBL2
         AR    R10,R8
         ST    R10,KTOTTBL2
         LA    R6,8(,R6)
         B     AO2GOP
*
AO2GOS   PPITEST  PPIINWRK         INPUT UNIT A WORK UNIT ?
         BZ    AO2GOU
AO2GO7   MVC   0(2,R3),KSVINAWK    SET INPUT UNIT TO LAST POS IN TP TBL
AO2GOU   LH    R3,PPIMRGMX
         AH    R3,PPIMRGAL
         LA    R2,PPITPTBL
AO2GOU3  MVI   0(R2),X'00'         ZERO OUT CHANNEL DESIGN
         BCT   R3,AO2GOU2
         SR    R15,R15             RETURN CODE FOR SSC
         LM    R2,R11,0(R12)
         BR    R14                 SORT SYS CNTRL
*
AO2GOU2  LA    R2,2(0,R2)
         B     AO2GOU3
*
*        LOOKING FOR A COMBINATION OF NO IN KTBL1 THAT = QUOTIENT
*
AO2GOR   LA    R3,KINDEX
         ST    R3,KWINPT           SET WIN AREA POINTER
         LA    R3,KPUSETBL
         ST    R3,KLOSEPT          SET LOSE AREA POINTER
         ST    R3,KCOMFALS
         SR    R3,R3
         ST    R3,KPTRXLMT
         ST    R3,KPTRYLMT
         LA    R3,KTBL1
         ST    R3,KPTRX            SET PTR X TO BEGIN OF TBL1
         ST    R3,KCOMFAL1
         ST    R3,KPTRY            SET PTR Y TO BEGIN OF TBL2
         L     R4,K02QUOT          SET QUOTIENT
         L     R5,KTBL1LMT         SET LMT OF TBL1
         LR    R9,R5               SAVE TBL1 LMT
         L     R6,KTBL2LMT         SET LMT OF TBL2
AO2GOR1  L     R3,KPTRX
         C     R4,0(,R3)
         BL    AO2PLOSE
         L     R7,KWINPT
         MVC   0(8,R7),0(R3)       MOVE INTO WIN AREA
         LA    R7,8(,R7)
         ST    R7,KWINPT           INCR WIN PTR
         L     R7,KPTRXLMT
         LA    R7,1(,R7)
         ST    R7,KPTRXLMT         INCR NO OF ITEMS IN WIN AREA
         L     R7,0(,R3)
         SR    R4,R7               UPDATE QUOTIENT
AO2GOR2  BCT   R5,AO2BMP
         LTR   R4,R4
         BZ    AO2SFW              SET TP TBL FROM WIN AREA FIRST
         BCT   R9,AO2TA
*
*        LOOKING FOR A KTBL1 ENTRY + KTOTTBL2 = QUOTIENT
*        COMBINATION
*
         LA    R3,KTBL1
         ST    R3,KPTRX
         L     R5,KTBL1LMT
AO2BAK   L     R4,0(,R3)
         A     R4,KTOTTBL2
         C     R4,K02QUOT
         BE    AO2GOY
         BCT   R5,AO2G12
         B     AO2G11
*
AO2G12   LA    R3,8(,R3)
         B     AO2BAK
*
*        A KTBL1 ENTRY + KTOTTBL2 COMBINATION EQUALS QUOTIENT
*
*        THE FIRST HALF OF THE TAPE TBL IS THEREFORE SET UP FROM
*        THIS COMBINATION. THE SECOND HALF OF THE TAPE TBL IS
*        SET UP FROM THE REMAINING DEVICES
*
AO2GOY   LA    R4,PPITPTBL
AO2GO4   L     R5,0(,R3)
         SLL   R5,1
         LR    R7,R5
         S     R5,KROONE
         L     R8,4(,R3)
         EX    R5,AO2MVCT
         AR    R4,R7
         LA    R10,0
         ST    R10,0(,R3)
AO2BRND  BC    0,AO2RND
         LA    R3,KTBL2
         L     R9,KTBL2LMT
         XI    AO2BRND+1,X'F0'
         B     AO2GO4
*
AO2RND   LA    R3,8(,R3)
         BCT   R9,AO2GO4
         LA    R3,KTBL1
         L     R9,KTBL1LMT
AO2BACK  CLI   3(R3),X'00'
         BE    AO2DECR
         L     R5,0(,R3)
         L     R8,4(,R3)
         SLL   R5,1
         LR    R7,R5
         S     R5,KROONE
         EX    R5,AO2MVCT
         AR    R4,R7
AO2DECR  LA    R3,8(,R3)
         BCT   R9,AO2BACK
         LR    R3,R4
         B     AO2GOS
*
AO2BMP   L     R7,KPTRX
         LA    R7,8(,R7)
         ST    R7,KPTRX            INCR TO NEXT ITEM IN TBL1
         B     AO2GOR1
*
AO2PLOSE L     R7,KLOSEPT
         MVC   0(8,R7),0(R3)       MOVE INTO LOSE AREA
         LA    R7,8(,R7)
         ST    R7,KLOSEPT          INCR LOSE TBL PTR
         L     R7,KPTRYLMT
         LA    R7,1(,R7)           INCR NO ITEMS IN LOSE AREA
         ST    R7,KPTRYLMT
         B     AO2GOR2
*
AO2TA    L     R3,KPTRY            INCR PTRY TO NEXT UNIT IN TBL1
         LA    R3,8(,R3)
         ST    R3,KPTRY
         ST    R3,KPTRX            SET PTRX TO PTRY VALUE
         L     R4,K02QUOT          RESET QUOTIENT
         LA    R3,KINDEX
         ST    R3,KWINPT           RESET WIN AREA PTR
         L     R3,KCOMFAL1
         L     R10,KCOMFALS
         MVC   0(8,R10),0(R3)
         LA    R3,8(0,R3)
         ST    R3,KCOMFAL1
         LA    R10,8(,R10)
         ST    R10,KCOMFALS
         ST    R10,KLOSEPT
         L     R3,KFALCNT
         LA    R3,1(,R3)
         ST    R3,KFALCNT
         ST    R3,KPTRYLMT
         SR    R3,R3
         ST    R3,KPTRXLMT
         LR    R5,R9               SET NEW TBL1 LMT
         B     AO2GOR1
*
*        LOOKING FOR A KTBL1 COMBINATION + KTOTTBL2 = QUOTIENT
*
AO2G11   CLI   KTBL1LMT+3,X'01'
         BE    AO2GOV              NO COMBINATION = QUOT
         LA    R3,KTBL1
         ST    R3,KPTRX
         L     R9,KTBL1LMT
         S     R9,KROONE
AO2AGN   LR    R5,R9
         LA    R6,8
AO2ADD   L     R4,0(,R3)           COUNT AT KTBL1
         A     R4,0(R6,R3)
         A     R4,KTOTTBL2
         C     R4,K02QUOT
         BE    AO2FND
         LA    R6,8(,R6)
         BCT   R5,AO2ADD
         L     R3,KPTRX
         LA    R3,8(,R3)
         ST    R3,KPTRX
         BCT   R9,AO2AGN
         B     AO2GOV              NO COMBINATION = QUOT
*
AO2FND   LA    R4,PPITPTBL
         L     R5,8(,R3)
         SLL   R5,1
         LR    R7,R5
         S     R8,KROONE
         L     R8,12(,R3)
         EX    R5,AO2MVCT
         AR    R4,R7
         LA    R10,0
         ST    R10,8(,R3)
         B     AO2GO4
*
AO2SFW   L     R8,KPTRXLMT         NO ENTRIES IN WIN AREA
         LA    R3,PPITPTBL
         LA    R4,KINDEX
AO2GOX   L     R5,4(,R4)           SET UP TP TBL FIRST FROM WIN
         L     R6,0(,R4)           AREA AND THEN FROM LOSE AREA
         SLL   R6,1
         LR    R7,R6
         S     R6,KROONE
         EX    R6,AO2MVT
         AR    R3,R7
         S     R8,KROONE
         LTR   R8,R8
         BZ    AO2GOW
         LA    R4,8(,R4)
         B     AO2GOX
*
AO2GOW   NOP   AO2G10
         L     R8,KPTRYLMT
         LA    R4,KPUSETBL
         XI    AO2GOW+1,X'F0'
         B     AO2GOX
*
AO2G10   NOP   AO2GOS
         L     R8,KTBL2LMT
         LTR   R8,R8
         BZ    AO2GOS
         LA    R4,KTBL2
         XI    AO2G10+1,X'F0'
         B     AO2GOX
*
AO2GOZ   MVC   KSVINAWK(2),PPITPTBL SAVE INPUT FOR LATER INSERTION
*
*        UPDATE PPITPTBL BY ELIMINATING SORTWK01 FROM FURTHER
*        CONSIDERATION
*
         MVC   KLMTADJ(4),KOTWO
         LH    R3,PPIMRGMX
         LH    R4,PPIMRGAL
         AR    R3,R4               TOTAL NUMBER OF UNITS
         SLL   R3,1
         S     R3,KOTHRE
         EX    R3,AO2MVC
AO2GO6   B     AO2ETST             BRANCH TO ENVIRONMENT TEST
*
AO2GOA   CLI   KSVINAWK+1,X'00'
         BE    AO2GOU
         LA    R3,PPITPTBL
         LH    R4,PPIMRGMX
         AH    R4,PPIMRGAL
         SLL   R4,1
         S     R4,KOTWO
         AR    R3,R4
         B     AO2GO7
*
*        EXECUTED MOVE INSTRUCTIONS
*
AO2MTT   MVC   0(1,R3),0(R5)       SETTING UP TAPE TBL
AO2MVCT  MVC   0(1,R4),0(R8)       SETTING UP TAPE TBL
AO2MVT   MVC   0(1,R3),0(R5)       SETTING UP TAPE TBL
AO2MVC   MVC   PPITPTBL(0),PPITPTBL+2  ELIM SORTWK01 IN OPTIMIZATION
*
KLMTCTAX DC    F'0'                LIMIT FOR KPTR2
KLMTCTBX DC    F'0'                LIMIT FOR KPTR1
KINDEX   DC    XL24'0'
         DC    XL24'0'
KDXLM    DC    XL4'0'
KPTRXLMT DC    XL4'0'              LIMIT FOR KPTRX
KPTR1    DC    F'0'                PERMANENT PTR OF TAPE TBL
KPTR2    DC    F'0'                TRAVELING PTR OF TAPE TBL
KCOLLPTR DC    F'0'
KSVCTA   DC    F'0'
KINDXPT  DC    F'0'
KCOLLAR  DC    17F'0'
KINDXLMT DC    XL4'0'
KPTRX    DC    F'0'                PERMANENT PTR OF INDEX TBL FOR ORDER
KPTRY    DC    F'0'                TRAVELING PTR OF INDEX TBL FOR ORDER
KPTRYLMT DC    F'0'                LIMIT FOR KPTRY
KORDSWAP DC    2F'0'               SAVE AREA FOR SWAP OF KPTRX + Y INFO
KPUSETBL DC    XL32'0'
         DC    XL32'0'
         DC    XL4'0'
KPUSEPTR DC    F'0'
KROONE   DC    XL4'1'
KOTWO    DC    XL4'2'
KOTHRE   DC    XL4'3'
KLMTADJ  DC    XL4'1'
KSVINAWK DC    XL4'0'
KUSEPT   DC    F'0'
KTBL1    DC    XL32'0'
         DC    XL16'0'
KTBL2    DC    XL32'0'
         DC    XL16'0'
KTBL1LMT DC    XL4'0'
KTBL2LMT DC    XL4'0'
K02QUOT  DC    F'0'
KWINPT   DC    F'0'
KLOSEPT  DC    F'0'
AO2SBZ   BZ    AO2GO9
KTOTTBL1 DC    XL4'0'
KTOTTBL2 DC    XL4'0'
KCOMFAL1 DC    XL4'0'
KCOMFALS DC    XL4'0'
KFALCNT  DC    XL4'0'
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERAO3   0101-20211-20211-1200-00172-00172-00000-RELEASE 00
A03      TITLE 'IERAO3 - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERAO3 - NOT SUPPORTED
*
*        MODULE FUNCTION/OPERATION -
*        DISK MERGE ALGORITHM ASSIGNMENT
*        THIS MODULE INITIALIZES THE RUNNING PROGRAM FOR THE
*        FOLLOWING -
*        WHERE TO RECORD NEXT SEQ
*        WHERE TO RECORD NEXT DIRECTY BLOCK WHEN WRITING
*        WHERE TO RETRIEVE NEXT DIRECTORY BLOCK FROM WHEN READING
*        NEXT POSITION WITHIN BLOCK OF 8
*        NO NEW SEQS
*        NO OLD SEQS
*        ALL ABOVE = MERGE TABLE
*        ALSO POINTERS AND INITIAL PRIMING OF BLOCKED AREAS
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY IERMOT
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPINDSKA   PPISTAR    PPIENDAR
*        PPILAB01   PPISEQCT   PPICNTL
*        PPIMRGOP
*
*        OUTPUT - PPI FIELDS ALTERED OR INITIALIZED -
*        PPIMRGMX   PPIWKARE
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS -
*        DSECT IERRCA - MODEL PPI
*        DSECT IERRO3 - MODEL RUNNING PROG
*
*        EXITS - NORMAL - BLOCK ASSIGNMENT PROGRAM
*                         L   R14,AO3ROSV
*                         BR  R14
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS - N/A
*
*        NOTES -
*        THIS MODULE IS RESTRICTED TO 2301 DRUM OPERATIONS ONLY
*
IERAO3   CSECT
*
         USING *,R11
         USING IERRCA,R13
*
IERMOT   LR    R11,R15
         ST    R14,AO3ROSAV        SAVE R14 TO BRANCH TO LATER
         L     R14,PPIALG+4        LOAD R14 WITH ADDR OF IERRO3
         USING DIERRO3,R14
*
*        PUT START ADDR IN TABLE - WHERE TO RECORD NEXT STRING
*
         LA    R4,WTABLE
         LH    R5,PPINDSKA
         LA    R6,PPISTAR
AO3LOOPA MVC   4(8,R4),0(R6)
         LA    R4,36(,R4)          BUMP PTR TO NEXT AREA
         LA    R6,8(,R6)           BUMP PTR TO NEXT AREA
         BCT   R5,AO3LOOPA
*
*        PUT ENDING ADDR IN TABLE -
*        (1) WHERE TO WRITE DICTIONARY
*        (2) WHERE TO READ DICTIONARY FROM PHASE 1
*
         LA    R4,WTABLE
         LH    R5,PPINDSKA
         LA    R6,PPIENDAR
AO3LOOPB MVC   12(8,R4),0(R6)      PUT IN 'WRITE' DICT SLOT
         MVC   20(8,R4),0(R6)      PUT IN 'READ' DICT SLOT
         LA    R4,36(,R4)          BUMP TO NXT AREA IN TBL
         LA    R6,8(,R6)           BUMP TO NXT AREA IN PPIENDAR
         BCT   R5,AO3LOOPB
*
*        INITIALIZE POS-IN-BLK TO ADDR OF PPILAB01
*        WHERE READ PUTS BLK/DICT
*
         LA    R4,WTABLE
         LH    R5,PPINDSKA
         LA    R6,PPILAB01
AO3LOOPC ST    R6,28(,R4)          PUT ADDR LAB01 IN BLK-POS, ALL AREAS
         LA    R4,36(,R4)          BUMP TO NEXT AREA IN TABLE
         BCT   R5,AO3LOOPC
*
*        INITIALIZE NEW SEQ CTS IN TABLE TO ZERO IN ALL AREAS
*
         LA    R4,0
         LH    R10,PPINDSKA        GET NO DISK AREAS
         LA    R9,WTABLE
         LA    R9,32(,R9)          GET SLOT IN TABLE
AO3LOOPD STH   R4,0(,R9)           FILL SLOT
         LA    R9,36(,R9)          BUMP ADDR TO NEXT SLOT
         BCT   R10,AO3LOOPD
*
*        STORE SEQ COUNTERS IN TABLE (OLD SEQS)
*
         LH    R10,PPINDSKA        GET NO AREAS
         LA    R4,PPISEQCT         GET ADDR OF COUNTERS
         LA    R9,WTABLE
         LA    R9,34(,R9)          GET SLOT IN TABLE
AO3LOOPE MVC   0(2,R9),0(R4)       FILL 1 SLOT
         LA    R9,36(,R9)          BUMP TO NEXT SLOT
         LA    R4,2(,R4)
         BCT   R10,AO3LOOPE        TABLE FULL, NO LOOP
         LH    R4,PPINDSKA
         ST    R4,WNODSKA          STORE NO DISK AREAS IN IERRO3
*
*        TEST DISK MERGE TABLE COLLATING ORDER
*
         PPITEST  PPIDMCO          DESCENDING ?
         BO    AO3DECND            YES, BRANCH
         B     AO3OUT              GO SET MRG ORDER, DON'T FLIP TABLE
*
*        REVERSE DATA IN TABLE FOR DECENDING PROCESS
*
AO3DECND LA    R9,WTABLE           GET TABLE ADDR
         LH    R5,PPINDSKA         GET NO AREAS
         BCTR  R5,0                REDUCE NO AREAS BY 1
         LA    R6,36               GENERATE MULTIPLIER CONSTANT
         MR    R4,R6               MULTIPICAND IN R5, PROD= R5
*                                  (DISPLACEMENT TO NTH ADDR IN TABLE)
         LA    R10,0(R5,R9)        GET ADDR OF NTH POS IN TABLE
AO3LOOPF MVC   PPIWKARE(36),0(R10) MOVE DATA FROM NTH POS TO WORK AREA
         MVC   0(36,R10),0(R9)     MOVE DATA FROM FIRST POS TO NTH POS
         MVC   0(36,R9),PPIWKARE   MOVE DATA FROM WORK AREA TO 1ST POS
         LA    R9,36(,R9)          INCR FIRST POS REG TO NEXT AREA ADDR
         LA    R7,36               CONSTANT DECREMENT
         SR    R10,R7              DECR NTH POS REG TO PREVIOUS POS
         CLR   R9,R10              COMP FIRST REG TO NTH REG
         BL    AO3LOOPF            REVERSAL NOT COMPLETE, LOOP
*                                  TABLE COMPLETELY REVERSED
AO3OUT   LA    R9,WTABLE           GET TABLE ADDR
         LH    R5,PPINDSKA         GET NO AREAS
         LA    R7,2
         SR    R5,R7               REDUCE NO AREAS BY 2 (TO BEG N-1)
         LA    R6,36               MULTIPLIER CONSTANT
         MR    R4,R6               DISPLACEMENT TO N-1 POS --- PROD=R5
         AR    R9,R5               GET ADDR N-1 POS
         MVC   PPIMRGMX(2),34(R9)  SET MRG MAX = SEQCT IN POS N-1
         L     R14,AO3ROSAV        RESTORE RETURN R14
         BR    R14                 BRANCH
*
AO3ROSAV DC    F'0'
*
*        IERRO3
*
DIERRO3  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRO3 SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRO3I
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERAPA   0101-20211-20211-1200-00272-00272-00000-RELEASE 00
APA      TITLE 'IERAPA - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERAPA
*
*        MODULE FUNCTION/OPERATION -
*        THIS MODULE IS THE ASSIGNMENT ROUTINE FOR THE TAPE
*        WRITE ROUTINE
*        IT INITIALIZES THE TAPE WRITE TO ADJUST FOR ONE OR TWO
*        AREAS AND FOR FIXED OR VARIABLE LENGTH RECORDS
*        IN ADDITION IT GENERATES THE CHANNEL PROGRAMS IN
*        GENERATED STORAGE
*
*        USED AS A DSECT IN - N/A
*
*        MACROS USED -
*        SMPPI   DCBD
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                       CALLING SEQUENCE -
*                           L     R11,ASSG
*                           BALR  R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPISTDCB   PPICNTL
*        PPIDEPHO   PPISPGN1
*        PPILAB04   PPIBUF1
*        PPILAB07   PPIOPEN
*        PPILAB05   PPIWRT
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPISPGN1 - UPDATED TO BUILD CCWS
*        CONSTANTS AND INSTRUCTIONS IN IERRPA ARE INITIALIZED
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL - RETURN TO IERRC9
*                         BR R14
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS -
*        N/A
*
*        NOTES -
*        THIS MODULE IS USED FOR TAPE OPERATION IN THE SORT
*        PHASE
*
IERAPA   CSECT
*
         USING *,R11
         USING DIERRPA,R15
         USING IOBSTDRD,R8
         USING IERRCA,R13          ADDR OF PPI
         USING IHADCB,R9
*
IERMPA   LR    R11,R15
         L     R15,PPIWRT+4
         L     R1,PPISTDCB         R1 -> DCB TABLE
         PPITEST  PPIOSC           OSCILLATING SORT ?
         BZ    APA003              NO, BRANCH
*
*        OSCILLATING - SET FIRST DCB ADDR IN LAST IOB
*
         LA    R3,4
         L     R6,0(R3,R1)         R6 -> FIRST DCB
         IC    R3,PPIBDSVA         ACCESS NO WORK UNITS
         SLL   R3,2
         L     R9,0(R3,R1)         LAST DCB ADDR
         L     R8,DCBIOBAD         LAST IOB ADDR
         USING IOBSTDRD,R8
         ST    R6,IOBDCBPT         FIRST DCB IN LAST IOB
         ST    R8,RPAPTIOB         IOB PTR FOR RUNNING PROGRAM
         B     APA005
*
*        SET IOB POINTER FOR OTHER TECHNIQUES
*
APA003   SR    R3,R3
         IC    R3,PPIDEPHO+3       ACCESS INCREMENT FOR OUTPUT UNIT
         L     R9,0(R3,R1)         R9 -> DCB
         L     R2,DCBIOBAD         SET R2 = IOB ADDR
         ST    R2,RPAPTIOB         INITIALIZE IOB PTR IN RUNNING PROG
APA005   SR    R5,R5
         PPITEST  PPIFIX           FIXED LENGTH RECORDS ?
         BZ    APA020              NO, VARIABLE, BRANCH
         PPITEST  PPIBALN+PPIOSC   BALANCED OR OSCILLATING SORT ?
         BZ    APA030              NO, BRANCH
         MVC   RPAEOS(4),KNOP      OVERLAY BRANCH IN IERRPA
         B     APA030
*
*        VARIABLE LENGTH RECORDS
*
*        MODIFY RUNNING PROGRAM SO THAT EOS INDICATION WILL BE
*        MOVED INTO BUFFER AFTER THE BLOCK CHARACTER COUNT
*
APA020   MVC   RPA024(6),APAICON1
         MVC   RPAUPDAT(4),APAICON2
         MVC   RPA055(4),APAICON3
APA030   LH    R2,COUNT            COUNT = NO OF CCW'S
         LR    R3,R2
         L     R4,PPISPGN1         GENERATED CORE ADDR
         N     R4,KMASK            ALIGN TO DOUBLE WORD BOUNDARY
         MH    R3,K8               GET LENGTH OF CCW LIST
         SR    R4,R3
         SH    R4,K8
         ST    R4,RPAPT1(R5)
         ST    R4,PPISPGN1         UPDATE GENERATED CORE ADDR
         SR    R6,R6
         ST    R6,0(R4)
APA040   MVC   8(8,R4),MDLCCW
         BCT   R2,APA050
         NI    12(R4),255-CD       TURN CHAIN DATA OFF IN LAST CCW
         B     APA060
*
APA050   LA    R4,8(,R4)
         B     APA040
*
APA060   NOP   APA070              ONE TIME ONLY SWITCH
         MVI   APA060+1,X'F0'      SET SWITCH TO BRANCH
         SR    R1,R1
         ICM   R1,B'0111',PPILAB04+1  R1 -> FIRST OUTPUT BUFFER
         LH    R7,PPILAB07+2       R7 = BUFFER SIZE
         AR    R1,R7               CALCULATE POINTER TO RETURN TO BLOCK
         ST    R1,RPABPT1
         CLI   PPILAB07,X'01'      1 BUFFER ?
         BNH   APA080              NO SECOND OUTPUT BUFFER
APA065   LH    R2,COUNT
         LA    R5,4
         B     APA030
*
*        END OF CCW GENERATION
*
APA070   L     R1,RPAPT1
         L     R2,RPAPT2
         ST    R1,4(,R2)
         ST    R2,4(,R1)           SET POINTERS BACK AND FORTH
         L     R1,PPILAB05         SECOND OUTPUT
         AR    R1,R7               ADD PPILAB07, SECOND PTR FOR BLOCK
         ST    R1,RPABPT2          POINTS AT END OF BUFFER +1
         B     APA090
*
APA080   CLI   PPILAB04,X'80'      WILL WRITE TRY FOR ANOTHER BUFFER ?
         BNE   APA065              YES
         ST    R1,RPABPT2          NO, SET PT2 = PT1 FOR 1 AREA
         LA    R1,K0
         ST    R1,RPAPT2
         OI    RPAONE+1,X'F0'      SET SWITCH TO BRANCH IN RUNNING
*
*        PRINT OPTIONAL DIAGNOSTIC MESSAGES
*
APA090   PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTICS ?
         BZ    APA100              NO, BRANCH
         ST    R14,KMASK
         USING DIERAMA,R5
         L     R5,PPIAMA+4
         SR    R0,R0
         ICM   R0,B'0111',PPILAB04+1  R0 = OUTPUT BUFFER ADDR
         L     R15,PPICONV+4
         BAS   R14,4(,R15)
         MVC   IER902A,2(1)
         L     R0,PPILAB05
         L     R15,PPICONV+4
         BAS   R14,4(,R15)
         MVC   IER902B,2(1)
         LM    R0,R1,IER902        IER902I OUTPUT BUFFER ADDR
         L     R15,PPIADSSC
         BAS   R14,12(,R15)
*
         L     R0,PPISPGN1         OUTPUT CCW ADDR
         L     R15,PPICONV+4
         BAS   R14,4(,R15)
         MVC   IER907A,2(1)
         LM    R0,R1,IER907        IER907I OUTPUT CCW ADDR
         L     R15,PPIADSSC
         BAS   R14,12(,R15)
*
         L     R15,PPIWRT+4        OUTPUT IOB ADDR
         L     R0,RPAPTIOB
         L     R15,PPICONV+4
         BAS   R14,4(,R15)
         MVC   IER908A,2(1)
         LM    R0,R1,IER908        IER908I OUTPUT IOB ADDR
         L     R15,PPIADSSC
         BAS   R14,12(,R15)
*
         L     R0,PPIOPEN+4        OPEN LIST ADDR
         L     R15,PPICONV+4
         BAS   R14,4(,R15)
         MVC   IER909A,2(1)
         LM    R0,R1,IER909        IER909I OPEN LIST ADDR
         L     R15,PPIADSSC
         BAS   R14,12(,R15)
         L     R14,KMASK
         L     R15,PPIWRT+4
*
*        ACCESS USER ERROR OPTION AND ADDR OF USER ERROR EXIT
*        STORE IN IERRPA
*
         USING OPENLST,R4
APA100   L     R4,PPIOPEN+4        R4 -> OPEN LIST
         MVC   KERROPT(1),WRTOPT
         MVC   KERREXIT+1(3),WRTOPT+1
         MVC   KERROPT2(1),WRTOPT2
         MVC   KERREXT2+1(3),WRTOPT2+1
         BR    R14                 RETURN
*
*        CONSTANTS
*
MDLCCW   CCW   WRITET,0,SLI,0
*
         DC    0F'0'
KMASK    DC    X'FFFFFFF8'
COUNT    DC    AL2(1)
KNOP     NOP   *
K8       DC    H'8'
*
         DROP  R15
         USING DIERRPA,R11
APAICON1 MVC   4(4,R2),KEOS2       MOVE NOT EOS INDICATION TO BUFFER
APAICON2 MVI   5(R2),C'G'
APAICON3 MVI   6(R2),C'G'
*
*        DIERRPA
*
DIERRPA  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRPA SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRPAI
*
OPENLST  DSECT
*
         DC    19F'0'
RDOPT2   DC    X'20000000'
WRTOPT   DC    F'0'
WRTOPT2  DC    F'0'
         DC    9F'0'
*
*        IERAMA
*
DIERAMA  DSECT
*
         COPY  AMAMAIN
*
         PRINT NOGEN
*
         DCBD  DSORG=PS,DEVD=(TA,DA)
*
         PRINT GEN
*
*        IOB DSECT
*
         IERIOB
*
*        IERCCWEQ
*
         IERCCWEQ
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERAPB   0101-20211-20211-1200-00286-00286-00000-RELEASE 00
APB      TITLE 'IERAPB - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERAPB
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 1 ASSIGNMENT MODULE - DASD OPERATION
*        THE FUNCTION OF THIS MODULE IS TO GENERATE CHANNEL
*        COMMAND WORDS FOR WRITING DASD. IT ALSO INITIALIZES THE
*        O/P BUFFERS
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACROS USED BY MODULE - N/A
*
*        ENTRY POINTS - ENTRY FROM
*                       CALLING SEQUENCE -
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPISTIOB   PPILAB07   PPILAB04
*        PPILAB05   PPIFIL5Z   PPISRTBL
*        ADDRESSES OF O/P BUFFERS ARE USED FOR INITIALIZING THEM
*        FILE SIZE IS TESTED TO SEE IF USER HAS ENTERED THIS
*        PARAMETER
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPISPGN1   PPICNTL
*        GENERATED STORAGE IS REDUCED WHEN CREATING CCW'S
*        THE ESTIMATED SWITCH IS TURNED ON IF NO FILE SIZE IS
*        GIVEN
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS -
*        IERRC9 - RETURN TO MAIN LINE
*
*        EXITS - NORMAL -
*        APBEXIT IERMDA - NEXT SEQUENTIAL MODULE
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS -
*        MODEL OF CHANNEL COMMAND WORD LIST
*
IERAPB   CSECT
*
         USING *,R11               PROGRAM BASE
         USING DIERRPB,R10         IERRPB BASE
         USING DIERAP1,R12         TEMP BASE FOR DCB OPEN LIST
         USING IERRCA,R13          PPI BASE
         USING APBAMA,R4
         USING IHADCB,R3           DCB BASE REGISTER
*
         IERENTRY 'IERAPB &SYSDATE &SYSTIME'
*
         LR    R11,R15             SET BASE ADDR
         ST    R14,SAVER14         SAVE RETURN ADDR IN IERRC9
         L     R10,PPIWRT+4        SET BASE FOR IERRPB
         L     R12,PPIOPEN+4       SET BASE
         L     R9,AP1WRT           GET USER MOD ADDR
         ST    R9,RPBUSERX         SET IN IERRPB
         MVI   RPBUSERX,X'00'      TURN OFF OPTION
         DROP  R12
         USING IERIOB,R12
*
         LA    R5,8
         L     R12,PPISTIOB        R12 -> IOB
         SR    R12,R5              R12 -> PREFIXED IOB
         MVC   RPBDBSW,PPILAB07    SET DOUBLE BUFFERED SW IN IERRPB
         MVC   WTRKSW,PPILAB04     MOVE SWITCH IN HI-ORDER BYTE
*                                  TO IERRPB
         L     R5,PPISPGN1         R5 -> GENERATED STORAGE
         N     R5,APBMASK          ALIGN TO DBL WORD BOUNDRY
         LA    R15,24
         SR    R5,R15
         ST    R5,HOLDPR
         ST    R5,IOBSTART
         LA    R6,IOBCC            R6 -> CCHHR ADDR (IOB)
         STCM  R6,B'0111',APBIDCCW+1   SET IN SEARCH CCW
         STCM  R6,B'0111',RPBIDCCW+1   SET IN DIR CCW
         LA    R6,PPIWKARE             GET DIRECTORY BUFFER ADDR
         STCM  R6,B'0111',RPBCCW2+1    SET DIRECTORY BUFFER ADDR
         SR    R6,R6
         ICM   R6,B'0111',PPILAB04+1   R6 -> FIRST BUFFER ADDR
         LA    R7,RPBBUF1
         LA    R9,8
         LA    R8,2                SET LOOP COUNTER
APBCHNLP SR    R6,R9               CALC BUFFER WRITE ADDR
         STCM  R6,B'0111',APBCCW2+1  SET BUFFER ADDR IN CCW
         LA    R6,12(,R6)          SET FIXED BUFFER ADDR
         PPITEST  PPIVAR           VARIABLE LENGTH RECORDS ?
         BZ    APBSETBF            NO, FIXED, BRANCH
         LA    R6,4(,R6)           YES, SET 12+4 FOR VAR LENGTH RECORDS
APBSETBF ST    R6,0(,R7)           SET ADDR IN IERRPB
         LH    R7,PPISRTBL         GET BLOCKING FACTOR
         LA    R7,8(,R7)           CALC DATA LENGTH
         STH   R7,APBCCW2+6        SET CCW DATA LENGTH
         STCM  R5,B'0111',APBCTCCW+1  SET TIC ADDR
         MVC   0(24,R5),APBIDCCW   MOVE CCW CHAN PROG INTO GEN STORAGE
         BCT   R8,APBNXTBF         SECOND BUFFER ALLOCATION ?
         B     APBGENSV            BRANCH IF TWO CCW'S STRINGS INITED
*
APBNXTBF L     R6,PPILAB05         R6 -> NEXT BUFFER
         LA    R7,RPBBUF2
         SR    R5,R15
         ST    R5,IERALTCW         SET ALT CCW IN IOB
         B     APBCHNLP            GOTO CREATE SECOND BUFFER
*
APBGENSV ST    R5,PPISPGN1         SET NEW GEN CORE ADDR
*        LH    R8,PPINDSKA         NUMBER OF AREAS
*        BCTR  R8,0                OPEN N-1 AREAS
*        SR    R5,R5               CLEAR DISPLACEMENT REGISTER
*        SR    R7,R7
*        LA    R6,PPISTAR          GET PPISTAR POINTER
*APBDCB   IC    R7,PPISTAR(R5)      GET INCREMENT FROM M VALUE
*        L     R3,PPISTDCB(R7)     SET DCB BASE REG
*        MVC   DCBFDAD+1(7),1(R6)  SET ADDR IN DCB
*        LA    R6,8(,R6)           INCREMENT PPISTAR POINTER
*        LA    R5,8(,R5)           SET FOR NEXT PPISTAR
*        BCT   R8,APBDCB           LOOP TO PROCESS ALL SORTWK AREAS
         ICM   R7,B'1111',PPIFILSZ  GET USER COUNT, ZERO ?
         BNZ   BUFBMSGE            NON ZERO USER COUNT, BRANCH
         PPISETON PPIFSZE          ZERO, TURN ON ESTIMATED BIT
*
*        DIAGNOSTC MESSAGES
*
BUFBMSGE PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTICS ?
         BZ    APBENDAG            NO, BRANCH
         L     R4,PPIAMA+4         LOAD MESSAGE MODULE BASE REGISTER
         SR    R0,R0
         ICM   R0,B'0111',PPILAB04+1  R0 = ADDR OF BUFFER1
         L     R15,PPICONV+4       R15 -> CONVERT ROUTINE
         BAS   R14,4(,R15)         CALL CONVERT ROUTNE
         MVC   IER902A,2(R1)
         L     R0,PPILAB05         LOAD ADDR OF BUFFER2
         L     R15,PPICONV+4       R15 -> CONVERT ROUTINE
         BAS   R14,4(,R15)         CALL CONVERT ROUTINE
         MVC   IER902B,2(R1)
         LM    R0,R1,IER902        IER902I OUTPUT BUFFER ADDR
         L     R15,PPIADSSC        LOAD ADDR
         BAS   R14,12(,R15)        CALL MSG WRITER
*
*        CCW ADDR
*
         L     R0,IOBSTART         LOAD ADDR OF CCW
         L     R15,PPICONV+4       R15 -> CONVERT ROUTINE
         BAS   R14,4(,R15)         CALL CONVERT ROUTINE
         MVC   IER907A,2(R1)       MOVE FORMATTED ADDR INTO MSG
         LM    R0,R1,IER907        IER907I OUTPUT CCW ADDR
         L     R15,PPIADSSC        LOAD ADDR OF RCV
         BAS   R14,12(,R15)        CALL MSG WRITER
*
*        IOB ADDR
*
         L     R0,PPISTIOB         LOAD ADDR OF IOB
         L     R15,PPICONV+4       ADDR OF CONVERT ROUTINE
         BAS   R14,4(,R15)         CALL CONV RTN
         MVC   IER908A,2(R1)       MOVE FORMATTED ADDR INTO MSG
         LM    R0,R1,IER908        IER908I OUTPUT IOB ADDR
         L     R15,PPIADSSC        LOAD ADDR OF SSC
         BAS   R14,12(,R15)        CALL MSG WRITER
*
APBENDAG PPITEST  PPIVAR           VARIABLE LENGTH RECORDS ?
         BO    APBVARY             YES, BRANCH
*
*        RETURN TO IERRC9
*
APBEXIT1 L     R14,SAVER14         RESTORE RETURN ADDR
         SR    R15,R15             SET ZERO RETURN
         BR    R14                 EXIT FROM MODULE
*
*        SUBROUTINE FOR VARIABLE LENGTH RECORDS TO HANDLE THE
*        SITUATION OF RUNNING OUT OF EXTENT IN PHASE 2
*
*        THIS IS CAUSED BY THE RE-DISTRIBUTION OF VARIABLE
*        LENGTH RECORDS
*
APBVARY  LA    R2,PPIENDAR
         LH    R7,PPINDSKA         R7 = NUMBER OF DISK AREAS
         BCTR  R7,0                SUBTRACT ONE
*
*        PROCESS EACH PPIENDAR ENTRY
*
APBVARY0 SR    R5,R5               ZERO R5
         ICM   R5,B'0011',5(R2)    R5 = HIGH TT FROM PPIENDAR
         LA    R5,1(,R5)           R5 = NO OF TRACKS IN THIS SORTWK
         LA    R4,101
         LA    R6,1                SET ITERATION COUNTER TO 1
APBVARY6 CR    R5,R4               COMPARE NO TRKS IN SORTWK WITH R4
         BL    APBVARY7            < R4, BRANCH
         LA    R4,100(,R4)         ADD 100 TO COMPARE REG
         LA    R6,1(R6)            ADD 1 TO ITERATION COUNTER
         CH    R6,KH10             MORE THAN 10 ITERATIONS ?
         BL    APBVARY6            NO, LOOP AGAIN
*
*        NO OF TRACKS < R4 OR MORE THAN 10 INTERATIONS IE 1000 TRACKS
*
APBVARY7 SR    R5,R6               REDUCE TRACK COUNT BY SUBTRACTING
*                                  ITERATION COUNT IE 1 TRACK PER 100
*                                  TRACKS
         SR    R4,R4
         IC    R4,0(,R2)           GET DCB INCREMENT FROM ENDAR M VALUE
         BCTR  R5,0                CONVERT NO TRACKS BACK TO HIGH TT
         STH   R5,RPBCOMTB+2(R4)   STORE HIGH TT INTO RPBCOMTB
*
*        CALCULATE REDUCTION IN NMAX
*
         LH    R5,PPISRTBL         R5 = SORT BLOCK SIZE
         LH    R8,PPIRCDL5         R8 = MODAL RECORD SIZE (V ONLY)
         SR    R4,R4
         DR    R4,R8               BLO SIZE/REC SIZE=BLOCK FACTOR
         MR    R4,R6               BLOCK FACTOR * TRACKS SUBTRACTED
         L     R9,PPINMAX          GET NMAX
         SR    R9,R5               REDUCE NMAX - ADJ = NEW NMAX
         ST    R9,PPINMAX          UPDATE NMAX
         LA    R2,8(,R2)           INCR PPIENDAR PTR
         BCT   R7,APBVARY0         BACK TO DO AGAIN FOR NEXT AREA
         B     APBEXIT1            GOTO EXIT MODULE
*
*        CCW STRINGS MOVED INTO GOTTEN STORAGE
*
APBIDCCW CCW   SEARIDEQ,0,SLI+CC,05  START OF WRITE CCW
APBCTCCW CCW   TIC,0,SLI+CC,0        TIC CCW
APBCCW2  CCW   WRITECKD,0,SLI,0      WRITE CCW
*
SAVER14  DC    F'0'                RETURN ADDR SAVE AREA
APBMASK  DC    X'FFFF'             MASK
         DC    X'FFF8'             MASK
KH10     DC    H'10'
*
*        IERAMA
*
APBAMA   DSECT
*
         COPY  AMAMAIN
*
*        WRITE OPTION MODULE
*
DIERAP1  DSECT
         DC    19F'0'
AP1RD2   DC    F'0'
AP1WRT   DC    X'20000000'
         DC    10F'0'
*
         DROP  R3,R11,R12
*
*        IERRPB
*
DIERRPB  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRPB SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRPBI
*
*        CCW EQUATES
*
         IERCCWEQ
*
*        DSECTS
*
*        MAP IERIOB
*
         PRINT NOGEN
*
         IERIOB
*
         PRINT GEN
*
         PRINT NOGEN
*
         DCBD  DSORG=(PS),DEVD=(DA)
*
         PRINT GEN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERAPC   0101-20211-20211-1200-00149-00149-00000-RELEASE 00
APC      TITLE 'IERAPC - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERAPC
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 1 ASSIGNMENT MODULE FOR TAPE OR DISK
*        OPEN ALL FILES ASSOCIATED WITH THIS PHASE OF THE SORT
*        OPERATION
*        THE INPUT FILE IS NOT OPENED IF THE SORT HAS BEEN
*        ATTACHED
*        INITIATE A CHECKPOINT OPERATION IF THE CHECKPOINT FLAG
*        IS ON
*
*        USED AS A DSECT IN - N/A
*
*        MACROS USED -
*        SMPPI   CHKPT
*        OPEN    DCB
*
*        ENTRY POINTS - ENTRY FROM DEBLOCK ROUTINE
*                       CALLING SEQUENCE -
*                           LA  R15,IERAPC
*                           BR  R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPICNTL   PPIATPIE
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*
*        EXTERNAL ROUTINES -
*        IERAP1   - OPEN LIST
*        IERAMA   - MESSAGE MODULE
*        PPIADSSC - SORT SYSTEM CONTROL
*
*        EXTERNAL PARAMETERS -
*        IERAP1   - ADDR OF DCB OPENLIST
*        PPIADSSC - R0 -> MESSAGE
*                   R1 = L'MESSAGE
*
*        EXITS - NORMAL -
*        IERADM - ADDR OF NEXT MODULE
*
*        EXITS - ERROR -
*        PPIADSSC - UNSUCCESSFUL OPEN
*
*        TABLES/WORK AREAS -
*        SORTCKPT - DCB WORK AREA
*
*        NOTES - NONE
*
IERAPC   CSECT
*
         IERENTRY 'IERAPC &SYSDATE &SYSTIME'
*
         USING IERAPC,R11
         USING IERRCA,R13          PPI
         USING IHADCB,R2           DCB DSECT
         USING IERAMA,R15          MESSAGE MODULE
*
         LR    R11,R15             SET BASE REGISTER
         ST    R14,SAVER14         SAVE RETURN ADDR
         MVC   SORTCKPT+DCBDDNAM-IHADCB(4),PPIDDSRT  MOVE DDNAME PREFIX
*
*        BEGIN OPENING THE SPECIFIED FILES
*
         L     R4,PPIOPEN+4
         L     R3,0(,R4)           NO OF ENTRIES ON OPEN LIST
         LA    R4,4(,R4)           R4 -> FIRST DCB ADDR
*
*        CHECK IF ATTACH ADDR IS PRESENT
*        IF ADDR IS PRESENT BYPASS OPENING THE INPUT FILE
*
         ICM   R2,B'1111',PPIATP1E
         BNZ   APC04               PRESENT, BRANCH TO BYPASS OPEN
         USING IHADCB,R2
*
*        OPEN INPUT FILE
*
         L     R2,0(,R4)           R2 -> INPUT DCB
*
         OPEN  ((R2),INPUT)
*
         LTR   R15,R15             OPEN COMPLETED SUCCESSFULLY ?
         BNZ   APCERR              NO, ERROR
         B     APC04
*
*        OPEN ALL OUTPUT FILES
*
APC03    LA    R4,4(,R4)           UPDATE LIST POINTER
         L     R2,0(,R4)           R2 -> OUTPUT DCB
*
         OPEN  ((R2),OUTPUT)
*
         LTR   R15,R15             OPEN COMPLETED SUCCESSFULLY ?
         BNZ   APCERR              NO, ERROR
APC04    BCT   R3,APC03            OPEN LIST COMPLETED ?
*
*        CALL THE CHECKPOINT MODULE TO RESTORE BLOCK COUNTS FOR
*        THE INTERMEDIATE FILES AND ISSUE THE CHECKPOINT MACRO IF
*        THE USER HAS SPECIFIED CHECKPOINT
*
         PPITEST  PPICHKPT         CHECKPOINT ACTIVE ?
         BZ    APCCOMM             NO, BRANCH
         L     R15,PPICHKAD        YES, LOAD ADDR OF CHECKPOINT MODULE
         BASR  R14,R15             CALL CHECKPOINT MODULE
*
*        ENTIRE LIST HAS BEEN OPENED, LINK TO NEXT MODULE
*
APCCOMM  L     R14,SAVER14         RESTORE CALLERS RETURN ADDR
         SR    R15,R15             ZERO RETURN CODE
         BR    R14                 RETURN TO IERRC9
*
APCERR   L     R15,PPIAMA+4        OPEN UNSUCCESSFUL
         MVC   IER063A,DCBDDNAM    MOVE DDNAME INTO MSG
         LM    R0,R1,IER063        IER063A OPEN ERROR
         L     R15,PPIADSSC
         BAS   R14,12(,R15)        CALL PRINT MESSAGE RTN
         LR    R1,R0
         MVC   PPIABMNO,3(R1)      MOVE MSG NO INTO ABEND CODE
         L     R15,PPIADSSC
         BAS   R14,16(,R15)        TERMINATE THE JOB, NO RETURN
*
*        ADCONS AND WORK AREAS
*
SAVER14  DC    F'0'                RETURN ADDR
*
SORTCKPT DCB   MACRF=(W),DSORG=PS,DDNAME=SORTCKPT
*
         PRINT NOGEN
*
         DCBD  DSORG=PS,DEVD=(DA,TA)
*
         PRINT GEN
*
*        IERAMA
*
IERAMA   DSECT
*
         COPY  AMAMAIN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERAPD   0101-20211-20211-1200-00237-00237-00000-RELEASE 00
APD      TITLE 'IERAPD - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERAPD
*
*        MODULE FUNCTION/OPERATION -
*        ASSIGNMENT ROUTINE FOR THE TAPE WRITE ROUTINE
*        IT INITIALIZES THE TAPE WRITE TO ADJUST FOR ONE OR TWO
*        AREAS AND FOR THE FIXED OR VARIABLE LENGTH RECORDS. IT
*        ALSO SETS POINTERS IN THE RUNNING PROGRAM TO LOCATE THE
*        IOB AND BUFFERS AND GENERATES THE CHANNEL PROGRAMS IN
*        GENERATED STORAGE
*
*        USED AS A DSECT IN - N/A
*
*        MACROS USED -
*        SMPPI
*        CCW
*        DCBD
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                       CALLING SEQUENCE -
*                           L    R15,ASSG
*                           BALR R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPISTDCB   PPILAB07
*        PPIDEPHO   PPILAB05
*        PPICNTL    PPISPGN1
*        PPILAB04
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPISPGN1 - UPDATED TO SHOW LAST BYTE USED
*        CCWS ARE GENERATED
*        RUNNING PROGRAM IS INITIALIZED
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS -
*        PPIWRT  - ADDR OF RUNNING PROGRAM DSECT
*        PPIOPEN - ADDR OF OPEN LIST
*
*        EXITS - NORMAL - BR R14 RETURN TO IERRC9
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS - N/A
*
*        NOTES -
*        THIS IS A WRITE TAPE ROUTINE
*
IERAPD   CSECT
*
         USING *,R11
         USING IHADCB,R8
         USING IERRPD,R15
         USING IERRCA,R13          PPI
*
IERMPD   LR    R11,R15
         L     R15,PPIWRT+4
         L     R1,PPISTDCB         DCB TABLE
         SR    R3,R3
         IC    R3,PPIDEPHO+3       ACCESS INCREMENT FOR OUTPUT UNIT
         L     R8,0(R3,R1)         R8=DCB ADDR
         L     R2,DCBIOBAD         R2=IOB ADDR
         ST    R2,RPAPTIOB
         SR    R5,R5
         PPITEST  PPIBALN+PPIOSC   BALANCED OR OSCILLATING ?
         BZ    APA010              NEITHER, BRANCH
         MVC   RPAEOS(4),KNOP      OVERLAY BR IN
APA010   PPITEST  PPIFIX           FIXED LENGTH RECORDS ?
         BO    APA035              YES, GOTO FIXED
*
*        VARIABLE LENGTH RECORDS
*
*        MODIFY RUNNING PROGRAM SO THAT EOS INDICATION WILL BE
*        MOVED INTO BUFFER AFTER THE BLOCK CHARACTER COUNT
*
APA020   MVC   RPA024(6),APAICON1
         MVC   RPA055(4),APAICON3
         MVC   RPAUPDAT(4),APAICON4
*
*        FIXED LENGTH RECORDS
*
APA035   L     R4,PPISPGN1         GENERATED CORE ADDRESS
         N     R4,KMASK            ALIGN TO DOUBLE WORD BOUNDARY
         SH    R4,K16
         ST    R4,RPAPT1(R5)
         ST    R4,PPISPGN1         UPDATE GENERATED CORE ADDRESS
         SR    R6,R6
         ST    R6,0(,R4)
APA040   MVC   8(8,R4),MODELCCW
APA060   NOP   APA070              ONE TIME ONLY SWITCH
         MVI   APA060+1,X'F0'      SET SWITCH TO BRANCH
         SR    R1,R1
         ICM   R1,B'0111',PPILAB04+1
         PPITEST  PPIBLKF          BLOCK FORWARD ?
         BZ    APA063              NO
         PPITEST  PPIFIX           YES, FIXED LENGTH RECORDS ?
         BO    APA061              YES
         LA    R7,8                NO, VARIABLE
         MVC   RPA0018(4),APAICON5
         B     APA065              SKIP FIXED ROUTINE
*
APA061   LA    R7,4                FIXED
         MVC   RPA0018(4),APAICON6
         B     APA065              BRANCH AROUND
*
APA063   LH    R7,PPILAB07+2
APA065   AR    R1,R7
         ST    R1,RPABPT1          STORE PTR FPR RETURN TO BLOCK
         CLI   PPILAB09,X'01'
         BNH   APA080              NO SECOND OUTPUT BUFFER
         LA    R5,4
         B     APA035              DO SECOND BUFFER
*
*        END CCW GENERATION
*
APA070   L     R1,RPAPT1
         L     R2,RPAPT2
         ST    R1,4(,R2)
         ST    R2,4(,R1)           SET POINTERS BACK AND FORTH
         L     R1,PPILAB05         SECOND OUTPUT
         AR    R1,R7
         ST    R1,RPABPT2
         B     APA085              CHECK DIAGNOSTICS
*
APA080   ST    R1,RPABPT2          PT2 = PT1 FOR 1 AREA
         LA    R1,K0
         ST    R1,RPAPT2
         OI    RPAONE+1,X'F0'      SET SWITCH TO BRANCH IN RUNNING
*
*        PRINT DIAGNOSTIC MESSAGES
*
APA085   PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTICS ?
         BZ    APA0100             NO
         ST    R14,KMASK
         USING DIERAMB,R5
         L     R5,PPIAMB+4
         SR    R0,R0
         ICM   R0,B'0111',PPILAB04+1  R0 = BUFFER ADDR
         L     R15,PPICONV+4
         BAS   R14,4(,R15)         CALL CONVERT
         MVC   IER922A,2(1)        MOVE FORMATTED ADDR INTO MSG
         L     R0,PPILAB05
         L     R15,PPICONV+4
         BAS   R14,4(,R15)         CALL CONVERT
         MVC   IER922B,2(1)        MOVE FORMATTED ADDR INTO MSG
         LM    R0,R1,IER922        IER922I OUTPUT BUFFER ADDR
         L     R15,PPIADSSC
         BAS   R14,12(,R15)        PRINT MSG
         L     R0,PPISPGN1         CCW ADDR
         L     R15,PPICONV+4
         BAS   R14,4(,R15)         CALL CONVERT
         MVC   IER925A,2(1)        MOVE FORMATTED ADDR INTO MSG
         LM    R0,R1,IER925        IER925I OUTPUT CCW ADDR
         L     R15,PPIADSSC
         BAS   R14,12(,R15)        PRINT MSG
         L     R0,PPISTIOB         IOB TABLE ADDR
         L     R15,PPICONV+4
         BAS   R14,4(,R15)         CALL CONVERT
         MVC   IER926A,2(1)        MOVE FORMATTED ADDR INTO MSG
         LM    R0,R1,IER926        IER926I IOB TABLE ADDR
         L     R15,PPIADSSC
         BAS   R14,12(,R15)        CALL PRINT
         L     R14,KMASK
         L     R15,PPIWRT+4
*
*        ACCESS USER ERROR OPTION AND ADDRESS OF USER ERROR EXIT
*        STORE IN RUNNING PROGRAM
*
         USING OPENLST,R4
APA0100  L     R4,PPIOPEN+4        R4 = ADDR OF OPEN LIST
         MVC   KERROPT(1),WRTOPT
         MVC   KERREXIT+1(3),WRTOPT+1
         BR    R14                 THIS IS EXIT POINT FROM ROUTINE
*
MODELCCW CCW   WRITET,0,SLI,0
*
*        CONSTANTS
*
         DC    0F'0'
KMASK    DC    X'FFFFFFF8'         MASK
KNOP     NOP   0
K8       DC    H'8'                EIGHT
K16      DC    AL2(16)             SIXTEEN
         DROP  R11
         DROP  R15
         USING IERRPD,R11
APAICON1 MVC   4(4,R2),KEOS2       MOVE NOT EOS INDICATION TO BUFFER
APAICON3 MVI   6(R2),C'G'
APAICON4 MVI   5(R2),C'G'
APAICON5 LA    R1,8(,R1)
APAICON6 LA    R1,4(,R1)
*
IERRPD   DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRPD SOURCE
*
*----------------------------------------------------------------------
*
         COPY IERRPDI
*
DIERAMB  DSECT
*
         COPY  AMBMAIN
*
         PRINT NOGEN
*
         DCBD  DSORG=PS,DEVD=(TA)
*
         PRINT GEN
*
*        CCW EQUATES
*
         IERCCWEQ
*
*        IOB
*
         IERIOB
*
OPENLST  DSECT
         DC    33F'0'              OPENLST
WRDOPT   DC    F'0'                OPENLST
WRTOPT   DC    F'0'                OPENLST
         DC    10F'0'              OPENLST
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERAPE   0101-20211-20211-1200-00231-00231-00000-RELEASE 00
APE      TITLE 'IERAPE - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERAPE
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 2 ASSIGNMENT MODULE - DASD OPERATION
*        THE FUNCTION OF THIS MODULE IS TO GENERATE CHANNEL
*        COMMAND WORDS FOR WRITING DISK. IT ALSO INITIALIZES THE
*        O/P BUFFERS
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACROS USED BY MODULE -
*        SMPPI
*        DCB
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPISTIOB   PPILAB07   PPILAB04
*        PPILAB05   PPIFIL5Z   PPISRTBL
*        ADDRS OF O/P BUFFERS ARE USED FOR INITIALIZING THEM
*        FILE SIZE IS TESTED TO SEE IF THIS PARAMETER HAS BEEN
*        PROVIDED
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPISPGN1   PPICNTL
*        GENERATED CORE IS REDUCED WHEN CREATING CCW'S
*        THE ESTIMATED SWITCH IS TURNED ON IF NO FILE SIZE IS
*        GIVEN
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS -
*
*        RC9 - RETURN TO MAIN LINE
*
*        EXITS - NORMAL -
*        APEEXIT - IERM01 - NEXT SEQUENTIAL MODULE
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS -
*        MODEL OF CHANNEL COMMAND WORD LIST
*
*        NOTES -
*        THIS MODULE IS RESTRICTED TO 2311 DISK OPERATIONS ONLY
*
IERAPE   CSECT
*
         USING *,R11
         USING DIERRPE,R10
         USING DIERAP2,R12
         USING IERRCA,R13          R13 -> PPI
         USING IERAMB,R4
         USING IHADCB,R3           DCB BASE REGISTER
*
         LR    R11,R15
         STM   R0,R15,APEWREG      SAVE REGS
         L     R10,PPIWRT+4        SET BASE
         L     R12,PPIOPEN+4       SET BASE
         L     R9,AP2WRT           GET USER ADDR
         ST    R9,RPEUSERX         STOW IN IERRPE
         MVI   RPEUSERX,X'00'      TURN OFF OPTION
         DROP  R12
         USING IERIOB,R12
         L     R12,PPISTIOB        SET IOB BASE REG
         L     R12,0(,R12)
         LA    R5,8
         SR    R12,R5              SET IERIOB ADDRRESSABILITY
         ST    R12,IOBECBPT        SET ECB PTR IN IOB
         MVC   WSWTRK,PPILAB04     MOVE SWITCH IN HO-ORDER BYTE
*                                  TO IERRPE
         MVC   RPEDBSW,PPILAB07    SET DOUBLE BUFFER SW IN IERRPE
         L     R5,PPISPGN1         R5 -> GENERATED STORAGE
         N     R5,APEMASK          ALIGN TO DBL WORD
         LA    R15,24              ALLOCATE 24 BYTES FOR CCW STRING
         SR    R5,R15
         ST    R5,IOBSTART         STORE ADDR CCW STRING IN IOB
         ST    R5,HOLDPCW          STORE PRIME BUFFER IN IERRPE
         LA    R6,IOBCC            GET IOB ID ADDR FOR SERACH ID EQ
         STCM  R6,B'0111',APEIDCCW+1  SET IN SEARCH CCW
         STCM  R6,B'0111',RPESKID+1   SET IN DIR CCW IN IERRPE
         LA    R6,PPIWKARE            GET DIR BUFFER ADDR
         STCM  R6,B'0111',RPEBUFAD+1  SET DIR IN BUFF ADDR
         SR    R6,R6
         ICM   R6,B'0111',PPILAB04+1  R6 -> FIRST BUFFER ADDR
         LA    R7,RPEBUF1
         LA    R9,8
         LA    R8,2
APECHNLP SR    R6,R9               CALC BUFFER WRITE ADDR
         STCM  R6,B'0111',APECCW2+1  SET BUFFER ADDR IN CCW
         LA    R6,12(,R6)          CALC FIXED BUFFER ADDR
         PPITEST  PPIVAR           VARIABLE LENGTH RECORDS ?
         BZ    APESETBF            NO, BRANCH
         LA    R6,4(,R6)           YES, CALC VARIABLE BUFFER ADDR
APESETBF ST    R6,0(R7)            SET ADDR IN IERRPE
         LH    R7,PPISRTBL         GET BLOCKING FACTOR
         LA    R7,8(,R7)           CALC DATA LENGTH
         STH   R7,APECCW2+6        SET CCW DATA LENGTH
         STCM  R5,B'0111',APECTCCW+1  SET TIC CCW
         MVC   0(24,R5),APEIDCCW   PUT CHAN PROG IN GEN STORAGE
         BCT   R8,APENXTBF         TEST FOR SECOND BUFFER ALLOCATION
         B     APEGENSV            GO STORE UPDATED GEN CORE AODR
*
APENXTBF L     R6,PPILAB05         LOAD ADDR OF NEXT BUFFER
         LA    R7,RPEBUF2
         SR    R5,R15
         ST    R5,IERALTCW         SET ALT CCW IN IOB
         B     APECHNLP            GO CREATE SECOND BUFFER
*
APEGENSV ST    R5,PPISPGN1         SET NEW GEN CORE ADDR
*
*        LOOP THROUGH ALL THE DISK SORTWORK AREAS AND MOVE
*        THE PPISTAR DISK ADDRESS INTO THE RELEVANT DCB
*
*        LH    R8,PPINDSKA         R8 = NUMBER OF DISK SORTWORK AREAS
*        SR    R7,R7               ZERO DCB OFFSET REG
*        LA    R6,PPISTAR          R6 -> PPISTAR
*APEDCB   L     R3,PPISTDCB         R3 -> DCB TABLE
*        IC    R7,0(,R6)           R7 = OFFSET INTO DCB TABLE (M BYTE)
*        L     R3,0(R7,R3)         ADD OFFSET TO CALC DCB ADDR
*                                  MOVE BBCCHHR INTO DCB (NOT M BYTE)
*        LA    R6,8(,R6)           INCREMENT PPISTAR POINTER
*        BCT   R8,APEDCB           LOOP THRU ALL SORTWORK AREAS
*
*        END CHANNEL PROGRAM GENERATION
*
*        DIAGNOSTIC MESSAGES
*
*        BUFFER ADDR
*
APEMSGBR PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTICS ?
         BZ    APEENDAG            NO, BRANCH
         L     R4,PPIAMB+4         R4 -> IERAMB
         SR    R0,R0
         ICM   R0,B'0111',PPILAB04+1  R0 -> OUTPUT BUFFER 1
         L     R15,PPICONV+4       R15 -> CONVERT ROUTINE
         BAS   R14,4(,R15)         CALL CONVERT ROUTINE
         MVC   IER922A,2(R1)       MOVE CONVERTED DATA TO MSG AREA
         L     R0,PPILAB05         LOAD ADDR OF BUFFER2
         L     R15,PPICONV+4       R15 -> CONVERT ROUTINE
         BAS   R14,4(,R15)         CALL CONVERT ROUTINE
         MVC   IER922B,2(R1)       MOVE CONVERTED DATA TO MSG AREA
         LM    R0,R1,IER922        IER922I OUTPUT BUFFER ADDR
         L     R15,PPIADSSC        R15 -> MSG PRINT ROUTINE
         BAS   R14,12(,R15)        CALL PRINT RTN
*
*        CCW ADDR
*
         L     R0,IOBSTART         R0 -> CCW
         L     R15,PPICONV+4       -> CONVERT ROUTINE
         BAS   R14,4(,R15)         CALL CONVERSION ROUTINE
         MVC   IER925A,2(R1)       MOVE CONVERTED DATA TO MSG AREA
         LM    R0,R1,IER925        IER925I OUTPUT CCW ADDR
         L     R15,PPIADSSC        R15 -> MSG PRINT ROUTINE
         BAS   R14,12(,R15)        CALL MSG PRINT RTN
*
*        IOB ADDR
*
         L     R0,PPISTIOB         R0 -> IOB
         L     R15,PPICONV+4       -> CONVERSION ROUTINE
         BAS   R14,4(,R15)         CALL CONVERT ROUTINE
         MVC   IER926A,2(R1)       MOVE CONVERTED DATA TO MSG AREA
         LM    R0,R1,IER926        IER926I IOB TABLE ADDR
         L     R15,PPIADSSC        R15 -> MSG PRINT ROUTINE
         BAS   R14,12(,R15)        CALL MSG PRINT RTN
*
*        RETURN TO MAINLINE
*
APEENDAG LM    R0,R15,APEWREG      RESTORE REGISTERS
         LR    R11,R15
         BR    R14                 EXIT FROM MODULE
*
*        CONSTANTS
*
APEWREG  DC    11F'0'              REGISTER SAVE AREA
APEWR11  DC    5F'0'               REGISTER SAVE AREA
APEMASK  DC    X'FFFFFFF8'         ALIGNMENT MASK
*
APEIDCCW CCW   SEARIDEQ,0,SLI+CC,5
APECTCCW CCW   TIC,0,SLI+CC,0
APECCW2  CCW   WRITECKD,0,SLI,0
*
         DROP  R3,R10,R11
*
IERAMB   DSECT
*
         COPY  AMBMAIN
*
*        IERAP2
*
DIERAP2  DSECT
*
         DC    34F'0'              MANY ZEROS
AP2WRT   DC    X'20000000'         USER ADDR
         DC    10F'0'              ZEROS
*
*        IERRPE
*
DIERRPE  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRPE SOURCE
*
*----------------------------------------------------------------------
*
         COPY IERRPEI
*
*        IERIOB
*
         IERIOB
*
*        IERCCWEQ
*
         IERCCWEQ
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         PRINT NOGEN
*
         DCBD  DSORG=(PS)
*
         PRINT GEN
*
         END
./ ADD NAME=IERAPF   0101-20211-20211-1200-00425-00425-00000-RELEASE 00
APF      TITLE 'IERAPF - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE FUNCTION/OPERATION -
*        MERGE ONLY PHASE
*        THE FUNCTION OF THIS MODULE IS TO GENERATE ONE OUTPUT
*        DCB FOR WRITING AND ONE DCB FOR EACH UNIT OF MERGE
*        ORDER. THE ADDRESS OF EACH DCB WILL BE STORED IN THE DCB
*        ADDRESS TABLE. THE STARTING ADDRESS OF THE DCBTAB WILL
*        BE STORED IN PPI IN THE PPISTDCB FIELD. THE GENERATED
*        CORE STARTING ADDRESS WILL BE UPDATED AND STORED BACK IN
*        PPISPGN1. EACH INPUT DCB GENERATED WILL BE ASSIGNED ITS
*        OWN IDENTITY NUMBER FROM SORTIN01 TO SORTIN16
*
*        USED AS A DSECT IN - N/A
*
*        MACROS USED -
*        SMPPI DCB
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                       CALLING SEQUENCE -
*                           LOAD EP=IERAPF,DCB=
*                           LR      R15,R0
*                           BALR    R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIADSSC   PPILAB06   PPICNTL    PPIMRGMX
*        PPILAB07   PPILAB03   PPIAMC     PPIEOF
*        PPIRCV     PPIX38     PPIX39
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPISTDCB   PPISPGN1
*
*        EXTERNAL ROUTINES - NONE
*
*        EXTERNAL PARAMETERS -
*        PPIOPEN+4 - OPEN LIST ADDR
*        PPIAMC+4  - MESSAGE MODULE ADDR
*
*        EXITS - NORMAL - RETURN TO IERRC9
*                         BR    R14
*
*                       - USER READ OPTION EXIT
*                         L     R15,PPIX38+4
*                         BR    R15
*
*                       - USER WRITE OPTION EXIT
*                         L     R15,PPIX39+4
*                         BR    R15
*
*        EXITS - ERROR -
*        PPIAMC+4 - ILLEGAL OPTION NUMBER SPECIFIED BY USER
*        DCBSYNAD - QSAM WRITE ERROR
*
*        TABLES/WORK AREAS -
*        TBRANCH - BRANCH TABLE
*        TLDADR  - TABLE OF LOAD ADDR INSTRUCTIONS
*        WFULL   - WORK TABLES
*        WFULL01 -
*        FULL02  -
*        WREGSAV -
*
*        NOTES - N/A
*
IERAPF   CSECT
*
         USING *,R11               MODULE BASE REG LOADED EXTERNALLY
         USING IHADCB,R12          BASE REGISTER FOR DCB DSECT
         USING IERRCA,R13          PPI COMMON MODULE BASE REGISTER
         USING DIERAMC,R14         BASE REG FOR MESSAGE MODULE DSECT
*
IERMP3BG LR    R11,R15             SET BASE REGISTER.
         STM   R12,R14,WREGSV3     SAVE ORIGINAL REGS
         MVC   KOUTID(4),PPIDDSRT  MOVE DDNAME INTO DCB DDNAME
         MVC   KINPID(4),PPIDDSRT
*
*        GET STARTING ADDR OF GENERATED STORAGE
*        ALIGN IT TO A FULL WORD BOUNDRY
*
         L     R4,PPISPGN1
         SRL   R4,2
         SLL   R4,2
         LA    R12,SORTIN          R12 -> SORTIN DCB
*
*        CALL DCB INITIALIZATION ROUTINE AND RETURN
*
         BAS   R14,APFINITL        CALL INITIALIZATION RTN
*
*        ALLOCATE STORAGE NEEDED FOR DCBS
*
*        THERE WILL BE ONE DCB FOR EACH UNIT OF MERGE ORDER PLUS
*        ONE DCB FOR THE OUTPUT
*
         MVC   WFULL02+2(2),PPIMRGMX
         L     R7,WFULL02
         LA    R7,1(,R7)           R7 = MERGE ORDER + 1
         LR    R2,R7               SAVE COUNT
         SR    R6,R6
         LA    R8,SORTINL          R8 = L'SORTIN DCB
         MR    R6,R8               R7 = TOTAL NO OF DCB BYTES
         SR    R4,R7               R4 = START OF DCB AREA
*
*        ALLOCATE STORAGE NEEDED FOR THE DCB ADDR TABLE (DCBTAB)
*
         SLL   R2,2
         LR    R1,R4
         SR    R1,R2               R1 = START OF DCB TABLE
         ST    R1,PPISPGN1         NEW GEN STORAGE STARTING ADDR
         ST    R1,PPISTDCB         STARTING ADDR OF DCB ADDR TABLE
         PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTICS ?
         BZ    APFNOMES            NO, BRANCH
         L     R14,PPIAMC+4
         LR    R0,R1               LOAD ADDR TO BE CONVERTED
         L     R15,PPICONV+4       LOAD ADDR OF CONVERSION ROUTINE
         BAS   R14,4(,R15)         CALL CONVERT
         L     R14,PPIAMC+4
         MVC   IER944A,2(R1)       MOVE FORMATTED ADDR INTO MSG
         LM    R0,R1,IER944        IER944I DCB TABLE ADDR
         L     R15,PPIADSSC        LOAD ADDR OF PRINT ROUTINE
         BAS   R14,12(,R15)        CALL PRINT RTN
APFNOMES LR    R3,R4
         L     R1,PPISTDCB         RESTORE R1 AFTER PRINTING
*
*        SET UP THEORETIC DCB ADDR FOR TABLE ENTRIES
*
         LR    R3,R4
*
*        CHECK IF USER EXIT E39 IS ACTIVE
*
         PPITEST  PPIME39          EXIT E39 ACTIVE ?
         BO    APFGOUSR            YES, BRANCH
*
*        MOVE OUTPUT DCB INTO ALLOCATED CORE AND STORE THE ADDR
*        INTO THE DCB ADDR TABLE (DCBTAB)
*
APFMVOUT LA    R6,SORTIN           R6 -> SORTIN DCB
         LA    R7,SORTINL          L'SORTIN DCB
         MVC   0(SORTINL,R4),0(R6)
         ST    R3,0(,R1)           STORE SORTOUT DCB ADDR INTO TABLE
         B     APFIN               GO AND SET INPUT DCB INDICATOR
*
*        INITIALIZE INPUT DCB MODEL AND ASSIGN SORTIN IDENTITY
*        NUMBERS
*
APFIN    MVI   WINDIC,X'01'        SET INPUT DCB INDICATOR
         BAS   R14,APFINITL        CALL INITIALIZATION ROUTINE
*
*        CHECK IF USER EXIT E38 IS ACTIVE
*
         PPITEST  PPIME38          EXIT E38 ACTIVE ?
         BO    APFGOUSR            YES, SET UP LINKAGE TO USER
         B     APFMVIN             NO
*
*        STORE COMPLETED DCB (MODIFIED/UNMODIFIED) INTO
*        PREVIOUSLY ALLOCATED STORAGE AND PLACE THE DCB ADDR IN
*        THE DCB ADDR TABLE (DCBTAB). THE DCB WILL ALSO BE
*        ASSIGNED AN IDENTITY NUMBER (01,02,03,04, ETC)
*
APFMVIN  MVC   WFULL02+2(2),PPIMRGMX
         L     R8,WFULL02          R8 = MAX MERGE ORDER - ONE DCB
         SR    R9,R9               FOR EACH UNIT OF MERGE ORDER
APF01    LA    R9,1(,R9)
         LA    R4,SORTINL(,R4)     UPDATE ACTUAL DCB ADDR
         LA    R3,SORTINL(,R3)     UPDATE THEORETIC DCB ADDR
         LA    R1,4(,R1)           UPDATE DCB TABLE POINTER
         ST    R3,0(,R1)           PUT DCB ADDR INTO DCBTAB
*
*        SET UP DCB DDNAME
*
         SLL   R9,1
         LA    R10,KTABLE
         AR    R10,R9
         MVC   DCBDDNAM+6(2),0(R10)
         SRL   R9,1
         MVC   0(SORTINL,R4),0(R6)
*
*        CHECK IF ALL DCB HAVE BEEN GENERATED
*
         BCT   R8,APF01            NO, CONTINUE GENERATING DCBS
*
*        SET UP LINKAGE TO NEXT MODULE AND BRANCH
*
         LM    R12,R14,WREGSV3     RESTORE ORIGINAL REGS
         BR    R14                 RETURN TO IERRC9
*
*        COMMON ROUTINE USED TO CALL THE USER RTN AND RETURN WITH
*        THE ADDR OF THE USER OPTION LIST. THE MODEL DCB WILL
*        BE MODIFIED ACCORDING TO THE OPTIONS SPECIFIED ON THE
*        LIST
*
APFGOUSR STM   R1,R10,WREGSAVE
         TM    WINDIC,X'01'        INPUT DCB EXIT ?
         BO    APFUSR01            YES, BRANCH
         L     R15,PPIX39+4
         B     APFUSR02            GO SET UP RETURN FROM USER
*
APFUSR01 L     R15,PPIX38+4
APFUSR02 LA    R14,APFRTRN         SET UP RETURN FROM USER
         BR    R15                 GOTO USER FOR PARAMETER LIST
*
*        RETURN POINT FROM THE USER MODIFICATION PROGRAM
*
APFRTRN  LR    R8,R1               R8 -> USER PARAMETER LIST
         LA    R5,TLDADR           R5 -> LA INSTRUCTION TABLE
         LA    R7,TBRANCH          R7 -> BRANCH INSTR TABLE
*
*        START MODIFYING MODEL DCB USING THE USER OPTION LIST
*
APFSTMOD MVC   WUSRLST(4),0(R8)    GET WORD FROM OPTION LIST
         MVC   WFULL01+3(1),WUSRLST    OPTION NUMBER
         ICM   R4,B'1111',WFULL01
         BZ    APFUSR04            ALL OPTIONS SATISFIED ?
         CL    R4,KOUTMAX          CHECK OPTION NO FOR LEGAL VALUE
         BNL   APFFRST             CHECK IF FIRST ERROR
         SLL   R4,2
         EX    0,0(R4,R5)          NO, EXECUTE PROPER LA INSTRUCTION
         AR    R4,R7               ADD OPTION NUMBER TO THE BRANCH
*                                  TABLE STARTING ADDR
         BR    R4                  GOTO BRANCH TABLE
*
*        TABLE OF BRANCH INSTRUCTIONS USED TO REFERENCE THE
*        PROPER MOVE INSTRUCTION SET DEPENDING UPON OPTION NUMBER
*
TBRANCH  DC    F'0'                BR
         B     APFTRECH              AN
         B     APFTRECH                CH
         B     APFONECH                  TABLE
*
*        TABLE OF LOAD ADDR INSTRUCTIONS USED TO LOAD PROPER
*        MODEL DCB FIELD ADDR FOR REFERENCE BY THE MOVE
*        INSTRUCTION
*
TLDADR   DC    F'0'                LA TABLE
         LA    R6,DCBSYNA
         LA    R6,DCBEXLSA
         LA    R6,DCBEROPT
*
*        ERROR MESSAGE PRINTOUT - SET UP PARAMETERS FOR PRINT
*        MODULE
*
APFERR   STM   R0,R1,WREGSV2       SAVE REGS
         L     R14,PPIAMC+4
         LM    R0,R1,IER044        IER044I - EXIT E
         TM    WINDIC,X'01'        INPUT DCB ?
         BO    APFERR01            YES, BRANCH
         MVC   IER044B,KTAG+2
         B     APFERR02            CALL SSC
*
APFERR01 MVC   IER044B,KTAG
APFERR02 L     R15,PPIADSSC
         BAS   R14,12(,R15)        CALL SSC
*
*        RETURN POINT FROM PRINT MODULE
*
         LM    R0,R1,WREGSV2       RESTORE REGS
         B     APFUSR03            RETURN TO USER MODIFICATION RTN
*
*        MOVE USER OPTION DATA INTO PROPER DCB MODEL FIELDS
*
APFONECH TM    WINDIC,X'01'        INPUT DCB ?
         BO    APFONEB             YES,BRANCH
         B     APFFRST             NO
*
APFONEB  MVC   0(1,R6),WUSRLST+3
         B     APFUSR03            GOTO UPDATE USER PARM LST PTR
*
APFTRECH MVC   0(3,R6),WUSRLST+1
APFUSR03 LA    R8,4(,R8)           UPDATE USER PARAMETER LIST POINTER
*                                  TO GET NEXT ENTRY ON LIST
         B     APFSTMOD            CONTINUE MODIFYING MODEL DCB
*
*        RETURN TO MAIN PROGRAM
*
APFUSR04 MVI   WFRSTERR,X'00'      RESET ERROR INDICATOR
         LM    R1,R10,WREGSAVE     RESTORE REGS
         TM    WINDIC,X'01'        RETURN TO INPUT DCB ROUTINE ?
         BO    APFMVIN             YES, BRANCH
         B     APFMVOUT            NO
*
*        CHECK IF ERROR ENCOUNTERED IS THE FIRST ONE
*
APFFRST  TM    WFRSTERR,X'01'      FIRST OPTION ERROR ?
         BO    APFUSR03            NO, BRANCH
         MVI   WFRSTERR,X'01'      YES, SET INDICATOR
         B     APFERR              GOTO ERROR MSG RTN
*
*        COMMON DCB INITIALIZATION ROUTINE
*        USED FOR BOTH INPUT AND OUTPUT DCBS
*
APFINITL SR    R8,R8
         ST    R8,WFULL
         ST    R8,WFULL02
*
*        CHECK IF DCB TO BE INITIALIZED IS AN INPUT DCB
*
         TM    WINDIC,X'01'        INPUT DCB ?
         BO    APFINT07            YES, BRANCH
*
*        OUTPUT DCB INITIALIZATION
*
         MVC   DCBDDNAM,KOUTID     DCB DDNAME
         MVC   DCBBUFNO,PPILAB07   NUMBER OF OUTPUT BUFFERS
         MVC   DCBBUFCA,PPILAB06+1  8 BYTE CONTROL BUFFER ADDR
         MVC   DCBBUFL,PPILAB07+2   L'OUTPUT BUFFER
*
*        SET UP BFTEK, BFALN, AND MACRF FOR OUTPUT
*
         MVI   DCBBFTEK,DCBBFTS    SIMPLE BUFFERING
         PPITEST  PPIMVSO          VBS OUTPUT ?
         BO    APFVBS              YES, GO SET PUT MOVE MODE
         MVI   DCBMACR2,DCBMRPUT+DCBMRLCP
         B     APFINT05            GOTO TEST FOR FULL WORD ALIGNMENT
*
APFVBS   MVI   DCBMACR2,DCBMRPUT+DCBMRMVP  PUT MOVE MODE
         NI    DCBMACR2,255-DCBMRLCP       TURN OFF LOCATE MODE
*
*        CHECK BUFFER ALIGNMENT SPECIFIED
*
APFINT05 PPITEST  PPISWA           FULL WORD ALIGNMENT SPECIFIED ?
         BO    APFINT06            YES, BRANCH
         OI    DCBBFTEK,DCBBFAD    DOUBLE WORD ALIGNMENT
         B     APFCOMM             GOTO COMMON RTN
*
APFINT06 OI    DCBBFTEK,DCBBFAF1   FULL WORD ALIGNMENT
         B     APFCOMM             GOTO COMMON RTN
*
*        INPUT DCB INITIALIZATION
*
APFINT07 MVC   DCBDDNAM,KINPID     DDNAME SORTIN
         MVC   DCBBUFNO(4),WFULL
         MVC   DCBSYNA,WFULL
         MVC   DCBEXLSA,WFULL
         MVC   DCBBUFNO,PPILAB03   NUMBER OF INPUT BUFFERS
         MVC   DCBBUFL,PPILAB03+2  LENGTH OF EACH INPUT BUFFER
*
*        INSERT END OF DATA ROUTINE
*
         MVC   DCBEODA,PPIEOF+5
*
*        SET UP BFTEK, BFALN, AND MACRF FOR INPUT
*
         MVI   DCBBFTEK,DCBBFTS    SIMPLE BUFFERING
         PPITEST  PPIMVSI          VBS INPUT ?
         BO    APFVBSI             YES, BRANCH
         MVI   DCBMACR,DCBMRGET+DCBMRLCG  GET - LOCATE MODE
         B     APFINT09            GO TEST FOR FULL WORD ALIGNMENT
*
APFVBSI  MVI   DCBMACR,DCBMRGET+DCBMRMVG  GET MOVE MODE
         NI    DCBMACR,255-DCBMRLCG       TURN OFF LOCATE MODE
*
*        CHECK BUFFER ALIGNMENT SPECIFIED
*
APFINT09 PPITEST  PPISWA           FULL WORD ALIGNMENT SPECIFIED ?
         BO    APFINT10            YES, BRANCH
         OI    DCBBFTEK,DCBBFAD    DOUBLE WORD ALIGNMENT
         B     APFCOMM             BRANCH TO COMMON RTN
*
APFINT10 OI    DCBBFTEK,DCBBFAF1   FULL WORD ALIGNMENT
*
*        COMMON ROUTINE FOR BOTH INPUT AND OUTPUT DCBS
*
APFCOMM  MVI   DCBEROPT,DCBERABE
         MVI   DCBIFLG,DCBIFER     USE I/O SUPERVISOR ERROR ROUTINES
         L     R8,PPIADSSC         SYNAD ROUTINE ADDR
         MVC   DCBSYNAD,24(R8)
*
*        RETURN TO MAIN ROUTINE
*
         BR    R14                 GOTO MAIN ROUTINE
*
*        CONSTANTS
*
KOUTMAX  DC    F'4'                LOWEST ILLEGAL OPTION VALUE
*
KTABLE   DC    C'0001020304050607080910111213141516000000'
*
KINPID   DC    C'SORTIN  '
KOUTID   DC    C'SORTOUT '
*
KTAG     DC    C'3839'
*
*        WORK LOCATIONS
*
WFULL    DC    F'0'
WFULL01  DC    F'0'
WFULL02  DC    F'0'
WFRSTERR DC    F'0'                FIRST OPTION ERROR INDICATOR
WINDIC   DC    F'0'                USED FOR INDICATION -
WUSRLST  DC    F'0'                STORAGE FOR USER OPTION WORDS
WADJFCT  DC    F'0'                STORAGE FOR ADDR ADJUSTMENT FACTOR
WREGSAVE DC    12F'0'              SAVE REGISTER LOCATIONS
WREGSV2  DC    2F'0'
WREGSV3  DC    3F'0'
*
*        MODEL DATA CONTROL BLOCK
*
SORTIN   DCB   MACRF=(GL),DSORG=PS,DDNAME=SORTIN
*
SORTINL  EQU   *-SORTIN            L'SORTIN DCB
*
*        IERAMC
*
*        THIS MODULE CONTAINS ALL OF THE MESSAGES THAT ARE
*        REQUIRED FOR PHASE 3 ASSIGNMENT MODULES
*
DIERAMC  DSECT
*
         COPY  AMCMAIN
*
*        DCBD
*
         PRINT NOGEN
*
         DCBD  DSORG=(PS),DEVD=(TA)
*
         PRINT GEN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERAPG   0101-20211-20211-1200-00468-00468-00000-RELEASE 00
APG      TITLE 'IERAPG - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERAPG
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 1 ASSIGNMENT MODULE - STORAGE ALLOCATION
*        THE FUNCTION OF THIS MODULE IS TO ALLOCATE STORAGE FOR
*        INPUT AND OUTPUT BUFFERS, RECORD STORAGE AREA (RSA), AND
*        GENERATED STORAGE IN THE SORT PHASE. IT DOES THIS WITH
*        THE GETMAIN MACRO. THE INPUT BUFFER ADDRESS TABLE,
*        GETMAIN ADDRESS AND SIZE TABLES, AND RSA TABLE WILL BE
*        GENERATED IN PROGRAM GENERATED STORAGE AND THE ADDRESSES
*        PLACED IN PPILAB02, PPIGETMN, PPIGETSZ AND PPILAB08.
*        PPILAB02 IS ALSO WHERE GENERATED STORAGE STARTS FOR THE
*        NEXT ROUTINE NEEDING THIS STORAGE AREA - PPISPGN1. EXIT
*        E11 IS LINKED TO IN THIS MODULE IF IT HAS BEEN ACTIVATED
*        BY THE USER THROUGH THE MODS STMT
*
*        IF VARIABLE SPANNED RECORDS IN INPUT FILE A WORKAREA
*        EQUAL IN SIZE TO THE MAXIMUM RECORD LENGTH IS ALLOCATED
*        AND ITS ADDRESS STORED AS THE FOURTH WORD IN THE GETMAIN
*        ADDRESS AND SIZE TABLES
*
*        USED AS A DSECT IN - N/A
*
*        MACROS USED -
*        GETMAIN   SMPPI
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                          LOAD  EP=IERAPG,DCB=SORTLIB
*                          LR    R15,R0
*                          BALR  R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIBINSZ   PPIP1GC
*        PPIBUF1    PPIRCDL5
*        PPILAB03   PPISRTBL
*        PPILAB07   PPICNTL
*        PPICNTL    PPIX11
*        PPITAVLC
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPIGETMN   PPILAB06
*        PPIGETSZ   PPILAB07
*        PPILAB02   PPILAB08
*        PPILAB03   PPICNTL
*        PPILAB04   PPISRTG
*        PPILAB05   PPIBUF1
*        PPISPGN1
*
*        EXTERNAL ROUTINES -
*        PPIX11 - USER ROUTINE E11
*
*        EXTERNAL PARAMETERS - NONE
*
*        EXITS - NORMAL - IERRC9 RETURN VIA R14
*
*                       - USER EXIT E11 VIA CALL
*                         MACRO EXPANSION -
*                           L     R15,PPIX11+4
*                           BALR  R14,R15
*
*        EXITS - ERROR - NONE
*
*        TABLES/WORK AREAS -
*        SAVERET - SAVE R14
*
IERAPG   CSECT
*
         USING *,R11               MODULE BASE REGISTER
         USING IERRCA,R13          PPIA BASE REGISTER
         USING DIERAMA,R9
*
         IERENTRY 'IERAPG &SYSDATE &SYSTIME'
*
         LR    R11,R15             SET BASE REGISTER
         ST    R14,SAVERET         SAVE RETURN REGISTER
         L     R9,PPIAMA+4         SET MSG BASE REG
         PPISETON PPIPH1           SET PHASE 1 INDICATOR
         PPITEST  PPIME11          EXIT E11 ACTIVE ?
         BZ    APGBEG              NO, BRANCH
*
*        USER EXIT E11 ACTIVE
*
APGGOUSR L     R15,PPIX11+4        OBTAIN USER EXIT ADDR
         BASR  R14,R15             CALL THE EXIT
*
*        ALLOCATE GENERATED STORAGE
*        ONE OUTPUT BUFFER AND ONE INPUT BUFFER
*
APGBEG   LH    R0,PPILAB07+2       OUTPUT BUFFER SIZE
         LR    R8,R0               START ACCUMULATING STORAGE GOTTEN
*
         GETMAIN  R,LV=(0)         GETMAIN OUTPUT BUFFER
*
         ST    R1,PPILAB04         SAVE FIRST OUTPUT BUFFER ADDR
         PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTICS ?
         BZ    APGBEG1             NO, BRANCH
         MVC   IER911A,=CL10'Out Buffer'
         LH    R0,PPILAB07+2       OUTPUT BUFFER SIZE
         L     R15,PPICONV+4
         BAS   R14,4(,R15)         CALL CONVERT NUMBER
         MVC   IER911B,2(R1)
         L     R0,PPILAB04         OUTPUT BUFFER ADDR
         BAS   R14,4(,R15)         CALL CONVERT RTN
         MVC   IER911C,2(R1)
         LM    R0,R1,IER911        IER911I GETMAIN -
         L     R15,PPIADSSC        SET UP PRINT LINKAGE
         BAS   R14,12(,R15)        CALL PRINT MSG RTN
APGBEG1  MVI   PPILAB07,1          SET NO TO 1
         LH    R6,PPILAB03+2       INPUT BUFFER SIZE
         LA    R6,8(,R6)           INCLUDE BUFFER CONTROL BLOCK
         AR    R8,R6               ADD SIZE TO ACCUMULATING TOTAL
         LR    R0,R6
         PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTICS ?
         BZ    APGBEG2             NO, BRANCH
         L     R15,PPICONV+4       YES, CONVERT INPUT BUFFER SIZE
         BAS   R14,4(,R15)         CALL CONVERT RTN
         MVC   IER911B,2(R1)       MOVE ADDR INTO MSG
*
APGBEG2  GETMAIN  R,LV=(0)         GETMAIN INPUT BUFFER
*
         ST    R1,PPILAB06         SAVE CONTROL BLOCK ADDR
         PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTICS ?
         BZ    APGBEG3             NO, BRANCH
         MVC   IER911A,=CL10'In Buffer '
         LR    R0,R1               R0 -> INPUT BUFFER
         L     R15,PPICONV+4       CONVERT INPUT BUFFER ADDR
         BAS   R14,4(,R15)         CALL CONVERT RTN
         MVC   IER911C,2(R1)
         LM    R0,R1,IER911        IER911I GETMAIN -
         L     R15,PPIADSSC        SET UP PRINT LINKAGE
         BAS   R14,12(,R15)        CALL PRINT MSG RTN
APGBEG3  MVI   PPILAB03,1          SET NO TO 1
         L     R0,PPIP1GC          GENERATED STORAGE SIZE
         AR    R8,R0               ADD SIZE TO ACCUMULATING TOTAL
*
         GETMAIN  R,LV=(0)         GETMAIN GENERATED STORAGE AREA
*
         LR    R2,R1               ADJUST GEN STORAGE ADDR TO END
         PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTICS ?
         BZ    APGBEG4             NO, BRANCH
         LR    R12,R1
         MVC   IER911A,=CL10'Gen Area'
         L     R0,PPIP1GC          GENERATED STORAGE SIZE
         L     R15,PPICONV+4
         BAS   R14,4(,R15)         CALL CONVERT RTN
         MVC   IER911B,2(R1)
         LR    R0,R12              GET ADDR
         BAS   R14,4(,R15)         CALL CONVERT RTN
         MVC   IER911C,2(R1)
         LM    R0,R1,IER911        IER911I GETMAIN -
         L     R15,PPIADSSC        R15 -> PPIADSSC
         BAS   R14,12(,R15)        CALL MSG WRITER
         LR    R1,R12              RESTORE R1
APGBEG4  A     R1,PPIP1GC          AREA FOR PPISPGN1
*
*        GENERATE OPTIONAL DIAGNOSTIC MESSAGE
*
         PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTICS ?
         BZ    APGRTRN             NO, BRANCH
         LR    R12,R1              SAVE R1
         LR    R0,R1
         L     R15,PPICONV+4
         BAS   R14,4(,R15)         CALL CONVERT NUMBER
         MVC   IER910A,2(R1)       MOVE FORMATTED ADDR INTO MSG
         LM    R0,R1,IER910        IER910I GENERATED STORAGE END ADDR
         L     R15,PPIADSSC        SET UP PRINT LINKAGE
         BAS   R14,12(,R15)        CALL PRINT MSG RTN
         LR    R1,R12              RESTORE R1
*
APGRTRN  PPITEST  PPIMVSI          VBS INPUT ?
         BZ    APG001              NO, BRANCH
         SH    R1,KFOUR            VBS INPUT, 4 BYTES EXTRA FOR VBS
APG001   SH    R1,K36              ALLOCATE GETMAIN ADDR AND SIZE
         ST    R1,PPIGETMN         TABLES - EACH HAS 9 ENTRIES -
         ST    R2,0(,R1)           GEN STORAGE, 2 INPUT AND 2 OUTPUT
         MVC   4(4,R1),PPILAB04    and 4 RSA ENTRIES
         MVC   8(4,R1),PPILAB06
         LR    R2,R1
         LA    R2,12(,R2)          UPDATE GETMAIN ADDR TABLE POINTER -
*                                  FIRST 3 ENTRIES ARE GEN CORE, OUTPUT
*                                  BUFFER AND INPUT BUFFER CONTROL
*                                  BLOCK ADDRS
         PPITEST  PPIMVSI          VBS INPUT ?
         BZ    APG002              VBS, INCREASE TABLE WITH 1 WORD
         SH    R1,KFOUR            THE FOURTH WORD IN TABLE WILL
APG002   SH    R1,K36              CONTAIN SIZE OF WORKAREA FOR VBS
         ST    R1,PPIGETSZ         FIRST 3 ENTRIES ARE GEN CORE, OUTPUT
         MVC   0(4,R1),PPIP1GC     BUFFER AND INPUT BUFFER+8 SIZES
         LH    R0,PPILAB07+2       MAKE SURE TWO HIGH ORDER BYTES
         ST    R0,4(,R1)           ZERO IN SIZE TABLE ENTRY
         ST    R6,8(,R1)           INPUT BUFFER SIZE+8
         LR    R3,R1               UPDATE SIZE TABLE POINTER
         LA    R3,12(,R3)
         SH    R1,K40              RSA TABLE - EACH ENTRY IS 8 BYTES
         ST    R1,PPILAB08         IN LENGTH, ADDR AND SIZE
         SH    R1,KFOUR            BUFFER ADDR TABLE FOR ONE OR
         ST    R1,PPILAB02         TWO INPUT BUFFER ADDRS, ONLY ONE
         MVC   0(4,R1),PPILAB06    BUFFER GOTTEN SO FAR
         PPITEST  PPIMVSI          VBS INPUT ?
         BZ    APGNVRE             NO, BRANCH
         LH    R0,PPIRCDL1         LENGTH OF WORKAREA
         ST    R0,0(,R3)           STORE LENGTH IN GETMAIN SIZE TABLE
         AR    R8,R0               ADD SIZE TO ACCUMULATING TOTAL
*
         GETMAIN  R,LV=(0)         GETMAIN WORKAREA FOR VBS
*
         ST    R1,0(,R2)           STORE IN GETMAIN ADDR TABLE
         LA    R2,4(,R2)           UPDATE POINTER TO GETMAIN ADDR TABLE
         LA    R3,4(,R3)           UPDATE POINTER TO GETMAIN SIZE TABLE
APGNVRE  CLI   PPIBUF1+3,3         TOTAL BUFFERS CALC, 3 OR 4 ?
         BNL   APG020              YES
APG010   MVI   PPILAB04,X'80'      SET BIT TO INDICATE NO ADDITIONAL
*                                  GETMAIN BY PPIWRT
         SR    R0,R0
         ST    R0,PPILAB05         ZERO PPILAB05
KBRANCH  B     APGRSA              OBTAIN RSA
*
*        B/G HAVE CALCULATED EXTRA BUFFERS
*
APG020   CLC   PPILAB03+2(2),PPILAB07+2  ISSUE GETMAIN ON SMALLER
         BH    APG030              ISSUE GETMAIN ON OUTPUT SIZE
         BAS   R7,APGIN            TRY FOR INPUT BUFFER
         CLI   PPIBUF1+3,3         CALC NO BUFFERS = 3 ?
         BE    APG010              YES, DON'T TRY FOR OUTPUT
         LA    R7,APGRSA
         B     APGOUT              TRY FOR OUTPUT BUFFER
*
APG030   BAS   R7,APGOUT           TRY FOR OUTPUT BUFFER
         CLI   PPIBUF1+3,3         CALC NO BUFFERS = 3?
         BE    APGRSA              YES, DON'T TRY FOR EXTRA INPUT
         MVC   APGBR(4),KBRANCH    SET BRANCH TO SET UP RSA
         BAS   R7,APGIN            TRY FOR INPUT BUFFER
APGRSA   LR    R9,R2               GETMAIN ADDR TABLE POINTER
         LR    R10,R3              GETMAIN SIZE TABLE POINTER
         L     R2,PPIBINSZ         MIN VALUE FOR RSA IS
         SLL   R2,1
         A     R2,PPIBINSZ         3*BINSIZE
         ST    R2,KMIN
         L     R2,PPITAVLC
         SR    R2,R8               TOTAL DATA AREA SIZE MINUS AMOUNT
         ST    R2,KMAX             ACCUMULATED FOR BUFFERS, ETC IS
*                                  MAX FOR RSA
         GETMAIN  VU,LA=KMIN,A=KADDR  GET MIN RSA AT LEAST
*
         LA    R5,3                NO OF COND GETMAINS
         SR    R7,R7
         SR    R4,R4
         L     R6,PPILAB08         RSA TABLE ADDR
APG040   LA    R7,1(,R7)           ADD ONE TO COUNT
         MVC   0(8,R6),KADDR       PLACE ADDR AND SIZE IN RSA TABLE
         MVC   0(4,R9),KADDR       PLACE RSA ADDR AND SIZE
         MVC   0(4,R10),KSIZE      IN THE GETMAIN TABLES
         LA    R9,4(,R9)           UPDATE THE
         LA    R10,4(,R10)         GETMAIN TABLE POINTERS
         CLC   KMAX(4),KSIZE
         BH    APG060              TRY FOR MORE
         LTR   R4,R4               ALL RSA IN ONE CHUNK ?
         BZ    APG053              YES, G GOTTEN
*
*        EXIT FROM ROUTINE
*
APG050   CL    R4,PPISRTG          MAKE SURE CALC G NOT GREATER THAN
         BH    APG053              B/G CALC, USE PPISRTG
*
*        G LESS THAN PPISRTG
*
         BCTR  R4,0                RSA CONTAINS G+1 RECORDS
         ST    R4,PPISRTG          RESET PPISRTG
APG053   STC   R7,PPILAB08         SAVE NO OF RSA SEGMENTS
         SH    R10,KFOUR           SET SIGN BIT IN LAST GETMAIN
         MVI   0(R10),X'80'        SIZE TABLE ENTRY
         MVC   PPISPGN1,PPILAB02   SET GEN STORAGE ADDR FOR NEXT RTN
*
*        GENERATE OPTIONAL DIAGNOSTIC MESSAGES
*
         PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTICS ?
         BZ    APGNEXT             NO, BRANCH
         L     R9,PPIAMA+4         SET MSG BASE REG
         L     R0,PPILAB08         RSA NO AND ADDR
         L     R15,PPICONV+4
         BAS   R14,4(,R15)         CALL CONVERT NUMBER
         MVC   IER903A,2(R1)       MOVE FORMATTED ADDR INTO MSG
         LM    R0,R1,IER903        IER903I RSA TABLE ADDR
         L     R15,PPIADSSC        PRINT MESSAGE RTN
         BAS   R14,12(,R15)        CALL PRINT MSG RTN
         L     R0,PPILAB02         NUMBER TO BE CONVERTED
         L     R15,PPICONV+4
         BAS   R14,4(,R15)         CALL CONVERT NUMBER
         MVC   IER901A,2(R1)       MOVE FORMATTED ADDR INTO MSG
         LM    R0,R1,IER901        IER901I INPUT BUFFER TABLE
         L     R15,PPIADSSC        SET UP PRINT LINKAGE
         BAS   R14,12(,R15)        CALL PRINT MESSAGE RTN
*
APGNEXT  PPITEST  PPITAPE          TAPE SORT ?
         BO    APG055              YES, BRANCH
         LH    R6,PPILAB07+2       NO, DASD SORT
         LA    R2,8                RESET OUTPUT BUFFER SIZE AND
         SR    R6,R2
         STH   R6,PPILAB07+2       ADDR BY 8 BYTES - MBBCCHHR
         SR    R6,R6
         ICM   R6,B'0111',PPILAB04+1  R6 -> BUFFER
         AR    R6,R2               IS ONLY TO BE CONSIDERED BY WRITE
         ST    R6,PPILAB04
         CLI   PPILAB07,1          TWO OUTPUT BUFFERS ?
         BE    APG055              NO, BRANCH
         L     R6,PPILAB05         YES, ADJUST SECOND ADDR
         AR    R6,R2
         ST    R6,PPILAB05
APG055   L     R14,SAVERET         RETURN TO IERRC9
         BR    R14
*
*        ONLY PART OF RSA HAS BEEN GOTTEN
*
APG060   LA    R6,8(,R6)           UPDATE RSA TABLE POINTER
         L     R3,KMAX             RECALCULATE
         S     R3,KSIZE            MAX FOR GETMAIN = PREVIOUS MAX
         ST    R3,KMAX             MINUS AMOUNT RECEIVED
         SR    R2,R2               RECALCULATE
         DR    R2,R5               MIN FOR GETMAIN = NEW MAX/COUNT
         ST    R3,KMIN
         CL    R3,PPIBINSZ         KMIN < BINSIZE
         BNL   APG065              NO, KMIN > BINSIZE
         MVC   KMIN(4),PPIBINSZ    KMIN = BINSIZE
APG065   CLC   KMAX,PPIBINSZ       KMAX < BINSIZE
         BNL   APG066              NO, KMAX > BINSIZE
         MVC   KMAX,PPIBINSZ       KMAX = BINSIZE
APG066   L     R3,KSIZE            CALCULATE PRESENT G
         SR    R2,R2
         D     R2,PPIBINSZ
         AR    R4,R3               ACCUMULATED G
*
         GETMAIN  VC,LA=KMIN,A=KADDR  CONDITIONAL GETMAIN FOR RSA
*
         B     APG070(R15)         EXCEPTIONAL RETURN
APG070   BCT   R5,APG040           +00 REQUEST SATISFIED
*
*        REQUEST NOT SATISFIED OR REQUEST COUNT ZERO
*
         CLI   PPILAB07,1          +04 IF ONLY ONE OUTPUT BUFFER
         BE    APG050                  EXIT TO IERRC9
*
*        IF BLOCKING FACTOR GREATER THAN G
*        GIVE ONE OUTPUT BUFFER TO RSA
*
         LH    R3,PPISRTBL         BLOCKING FACTOR
         PPITEST  PPIFIX           FIXED LENGTH RECORDS ?
         BO    APG080              YES, BRANCH
*
*        VARIABLE LENGTH RECORDS
*        DETERMINE AVERAGE NO OF RCDS PER OUTPUT BUFFER
*
         SR    R2,R2
         LH    R5,PPIRCDL5         MODAL RECORD LENGTH
         DR    R2,R5               BLOCK CHAR CNT/MODAL RECORD LENGTH
APG080   CR    R3,R4               BLOCKING TO G
         BNH   APG050              LESS THAN OR EQUAL, EXIT
*
*        BLOCKING GREATER THAN G
*
         SR    R2,R2
         LH    R3,PPILAB07+2       PLACE BUFFER SIZE IN RSA TABLE
         ST    R3,4(,R6)
         D     R2,PPIBINSZ         DETERMINE NO OF BINS FIT IN BUFFER
         AR    R4,R3               ADD NO TO G
         MVI   PPILAB07,1          RESET BUFFER NO
         MVC   0(4,R6),PPILAB05    MOVE BUFFER ADDR INTO RSA TABLE
         LA    R7,1(,R7)           ADD ONE TO RSA COUNT
         SR    R1,R1               ZERO SECOND
         ST    R1,PPILAB05         BUFFER ADDR
         IC    R1,PPIBUF1+3        SUBTRACT ONE FROM
         BCTR  R1,0                PHASE 1 TOTAL BUFFERS
         STC   R1,PPIBUF1+3
         B     APG050              EXIT
*
*        GETMAIN ROUTINE - FIXED, SINGLE, CONDITIONAL
*
*        ON ENTRY -
*        R5   -> RETURN - STORAGE NOT AVAILABLE
*        R5+4 -> RETURN - STORAGE REQUEST SUCCESSFULL
*        R6   -> ADDR OF GETMAINED STORAGE
*        R15   = STORAGE SIZE
*
APGGETM  GETMAIN  EC,LV=(R15),A=(R6)
*                                  FILLED IN AT EXECUTION TIME
         B     APG090(R15)         ENTER BRANCH TABLE
APG090   B     4(,R5)              +00 REQUEST SATISFIED
         BR    R5                  +04 REQUEST NOT SATISFIED
*
*        OBTAIN EXTRA INPUT BUFFER IF STORAGE AVAILABLE
*
APGIN    LH    R15,PPILAB03+2      LV PARAMETER FOR EXTRA INPUT
         L     R6,PPILAB02
         SH    R6,KFOUR
         BAS   R5,APGGETM          EXTRA INPUT BUFFER
APGBR    B     APG010              STORAGE NOT AVAILABLE
*
*        STORAGE AVAILABLE
*
         ST    R6,PPILAB02         SAVE BUFFER ADDR IN BUFFER TABLE
         MVC   0(4,R2),0(R6)       AND GETMAIN ADDR TABLE
         MVC   4(4,R6),0(R6)       SWITCH INPUT BUFFER ADDR SO FIRST
         MVC   0(4,R6),PPILAB06    ENTRY HAS BUFFER CONTROL BLOCK
         LH    R0,PPILAB03+2
         ST    R0,0(,R3)           SIZE IN GETMAIN SIZE TABLE
         AR    R8,R0               ADD SIZE TO ACCUMULATING TOTAL
         LA    R2,4(,R2)           UPDATE GETMAIN
         LA    R3,4(,R3)           TABLE POINTERS
         MVI   PPILAB03,2          SET NO TO 2
         BR    R7                  RETURN TO MAINLINE
*
*        OBTAIN EXTRA OUTPUT BUFFER IF STORAGE AVAIALBLE
*
APGOUT   LH    R15,PPILAB07+2      LV PARAMETER FOR EXTRA BUFFER
         LA    R6,PPILAB05         A PARAMETER FOR EXTRA OUTPUT
         BAS   R5,APGGETM          EXTRA OUTPUT BUFFER
         B     APG010+4            STORAGE NOT AVAILABLE
*
*        STORAGE AVAILABLE
*
         MVC   0(4,R2),PPILAB05    SAVE ADDR IN GETMAIN TABLE
         LH    R0,PPILAB07+2       SIZE IN GETMAIN SIZE TABLE
         ST    R0,0(,R3)
         AR    R8,R0               ADD SIZE TO ACCUMULATING TOTAL
         LA    R2,4(,R2)           UPDATE GETMAIN
         LA    R3,4(,R3)           TABLE POINTERS
         MVI   PPILAB07,2          SET NO OF BUFFERS TO 2
         MVI   PPILAB04,X'80'      SET BIT TO INDICATE NO EXTRA
*                                  GETMAIN BY PPIWRT
         BR    R7                  RETURN TO MAINLINE
*
*        CONSTANTS
*
         DC    180F'0'             FILLER TO MAKE IERAPG THE
*                                  LARGEST ASSIGNMENT ROUTINE
KFOUR    DC    H'4'
K36      DC    H'36'
K40      DC    H'40'
*
KMIN     DC    F'0'          *     MINIMUM - PARAMETERS FOR
KMAX     DC    F'0'          |     MAXIMUM   VARIABLE
KADDR    DC    F'0'          |     ADDR
KSIZE    DC    F'0'          V     SIZE      GETMAINS
*
*        WORK AREAS
*
SAVERET  DC    F'0'                R14 SAVE AREA
*
*        LTORG
*
         LTORG
*
*        IERAMA
*
DIERAMA  DSECT
*
         COPY  AMAMAIN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERAPH   0101-20211-20211-1200-00378-00378-00000-RELEASE 00
APH      TITLE 'IERAPH - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERAPH
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 2 ASSIGNMENT MODULE - STORAGE ALLOCATION
*        THE FUNCTION OF THIS MODULE IS TO ALLOCATE STORAGE
*        FOR INPUT AND OUTPUT BUFFERS AND GENERATED STORAGE IN THE
*        INTERMEDIATE MERGE PHASE. IT DOES THIS WITH THE GETMAIN
*        MACRO. THE INPUT BUFFER ADDRESS TABLE AND THE GETMAIN
*        ADDRESS AND SIZE TABLES WILL BE GENERATED IN PROGRAM
*        GENERATED STORAGE AND THE TABLE ADDRESSES PLACED IN
*        PPILAB02, PPIGETMN, AND PPIGETSZ. PPILAB02 IS ALSO WHERE
*        GENERATED STORAGE STARTS FOR THE NEXT ROUTINE NEEDING THIS
*        STORAGE AREA - PPISPGN1. EXIT E21 IS LINKED TO IN THIS
*        MODULE IF IT HAS BEEN ACTIVATED BY THE USER THROUGH THE
*        MODS STMT
*
*        USED AS A DSECT IN - N/A
*
*        MACROS USED -
*        GETMAIN - FIXED, CONDITIONAL AND UNCONDITIONAL
*        SMPPI
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                          LOAD  EP=IERAPH,DCB=SORTLIB
*                          LR    R15,R0
*                          BALR  R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIBUF23   PPIP2GC
*        PPILAB07   PPICNTL
*        PPIX21     PPIMRGMX
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPIGETMN   PPILAB02
*        PPIGETSZ   PPILAB03
*        PPISPGN1   PPILAB04
*        PPICNTL    PPILAB05
*        PPILAB07
*
*        EXTERNAL ROUTINES -
*        PPIX21 - USER ROUTINE E21
*
*        EXTERNAL PARAMETERS - NONE
*
*        EXITS - NORMAL - RETURN VIA R14
*
*                       - USER EXIT E21 VIA CALL
*                         MACRO EXPANSION -
*                           L     R15,PPIX21+4
*                           BALR  R14,R15
*
*        EXITS - ERROR - NONE
*
*        TABLES/WORK AREAS -
*        WREGSV - SAVE RETURN REGISTER R14
*
IERAPH   CSECT
*
         USING *,R11               MODULE BASE REGISTER
         USING IERRCA,R13          PPIA BASE REGISTER
         USING DIERAMB,R9
*
         LR    R11,R15             SET BASE REGISTER
         ST    R14,WREGSV          SAVE RETURN REGISTER
         PPITEST  PPIPH2           FIRST PASS ?
         BO    APH010              NO, BYPASS GOING TO USER
         PPISETON PPIPH2           SET PHASE 2 INDICATOR
         PPITEST  PPIME21          EXIT E21 ACTIVE ?
         BZ    APH010              NO, BRANCH
*
*        USER EXIT E21 ACTIVE
*
APHGOUSR L     R15,PPIX21+4        OBTAIN USER ADDR
         BASR  R14,R15             CALL USER EXIT
*
*        ALLOCATED GENERATED STORAGE, ONE OUTPUT BUFFER AND M(MERGE
*        ORDER) INPUT BUFFERS
*
APH010   L     R0,PPIP2GC          GENERATED STORAGE SIZE
         BAS   R5,APHGETR          GENERATED STORAGE AREA
         LR    R2,R1               ADJUST GEN STOR ADDR TO END OF ITS
         A     R1,PPIP2GC          AREA FOR PPISPGN1
         L     R9,PPIAMB+4         SET MSG BASE REG
         PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTICS ?
         BZ    APHRTRN             NO, BRANCH
         BAS   R10,APHCONVT        CONVERSION ROUTINE LINKAGE
         MVC   IER920A,2(R1)       MOVE FORMATTED ADDR INTO MSG
         LM    R0,R1,IER920        IER920I GENERATED STORAGE END ADDR
         L     R15,PPIADSSC        SET UP PRINT LINKAGE
         BAS   R14,12(,R15)        CALL PRINT MSG RTN
         LM    R0,R1,WREGSV1       RESTORE API'S REGS
APHRTRN  LH    R3,PPIMRGMX         DETERMINE SIZE OF GETMAIN TABLE
         PPITEST  PPITAPE          TAPE SORT ?
         BO    *+8                 YES
         LH    R3,PPIMRGAL         DASD, MERGE MAX NOT SET YET
         SLL   R3,1                ((2*M +3)*4)*2
         LA    R3,3(,R3)           TABLES CONTAIN ADDR AND SIZES
         SLL   R3,2                OF GETMAINS AND IS SET UP LIKE THE
         SR    R1,R3               MULTIPLE GETMAIN AND FREEMAIN
         ST    R1,PPIGETMN         REQUIRE  ADDR OF SIZE AND ADDR
         ST    R2,0(,R1)
         LR    R10,R1              TABLES ARE PLACED IN PPI
         SR    R1,R3               THE FIRST ENTRY IN THE TABLES IS
         ST    R1,PPIGETSZ         THE GEN STORAGE ADDR AND ITS SIZE
         LR    R9,R1
         MVC   0(4,R1),PPIP2GC
         LH    R8,PPIMRGMX         NO FOR
         STH   R8,KSAVE
         LA    R8,1(,R8)           MULTIPLE GETMAIN
         LH    R6,PPILAB07+2       OUTPUT BUFFER SIZE
         STH   R6,PPILAB03+2       SET INPUT BUFFER SIZE
         PPITEST  PPITAPE          TAPE SORT ?
         BO    APHBEG              YES, BRANCH
*
*        DASD OPERATION
*
         MVI   APHDISK1+1,X'00'    SET DASD SWITCHES FOR ADDED
         MVI   APH050+1,X'00'      8 BYTE DISK ADDR FOR OUTPUT
         MVI   APHDISK2+1,X'00'    BUFFERS
         BCTR  R8,0                RESET MULT GETMAIN NO TO M
         LA    R0,8(,R6)           SIZE + 8 BYTE MBBCCHHR FOR DASD
         ST    R0,4(,R9)           SAVE SIZE IN SIZE TABLE
         LA    R9,4(,R9)           UPDATE SIZE TABLE POINTER
         BAS   R5,APHGETR          OUTPUT BUFFER
         ST    R1,4(,R10)          SAVE ADDR IN ADDR TABLE
         LA    R10,4(,R10)         UPDATE ADDR TABLE POINTER
*
*        DASD OPTIMIZATION ROUTINE
*
APH020   NI    APHSWTCH,X'00'      TURN OFF SWITCH A
         LH    R7,PPINDSKA         GET NO OF DISK AREAS - N
         SR    R6,R6               CLEAR R6
APH021   LH    R4,PPISEQCT(R6)     GET CURRENT STRING MAX
APH022   BCT   R7,APH027           N = N - 1, IF ¬= 0 TAKE BRANCH
         STH   R4,WMAXSEQ          SAVE MAX NO SEQ ON ANY AREA
         LH    R5,PPIMRGAL         GET MAX MERGE ORDER
APH022A  LR    R4,R5
APH022B  LH    R7,PPINDSKA         NO OF DISK AREAS
         SR    R0,R0
         LA    R6,PPISEQCT         GET ADDR OF SEQ CTRS
APH023   LH    R3,0(,R6)           GET NO OF SEQ FOR THIS AREA
         SR    R2,R2
         DR    R2,R4               NO SEQ/MRG ORD OR MRG ORD SQD
         LTR   R2,R2               ANY REMAINDER ?
         BZ    APH025              NO, BRANCH
APH024   LA    R3,1(,R3)           ADD 1
APH025   AR    R0,R3               RUNNING TOTAL OF SEQ AFTER MERGE
         LA    R6,2(,R6)           UP PTR TO NEXT SEQ CT
         BCT   R7,APH023           LOOP UNTIL DONE
         TM    APHSWCHB,X'01'      SWITCH B ON ?
         BO    APH026F             YES, GOTO EXIT THIS ROUTINE
         CR    R5,R0               MRG ORD = NO OF SEQ ?
         BNE   APH026              NO, BRANCH
         TM    APHSWTCH,X'01'      SWITCH A ON ?
         BO    APH025A             YES, BRANCH
         STH   R5,WTEMPMO          SAVE TEMP MERGE ORDER
         BCTR  R5,0                DECREASE MERGE ORDER BY 1
         OI    APHSWCHB,X'01'      SET SWITCH B ON
         B     APH022A             GO CALCULATE WITH MERGE ORDER 1 LESS
*
APH025A  CR    R5,R0               MRG ORD = NO OF SEQ ?
         BNE   APH026              NO, BRANCH
         B     APH026E             GOTO END OF MERGE OP RTN
*
APH026   BL    APH026B             MRG ORD < NO SEQ, BRANCH
         TM    APHSWTCH,X'01'      SWITCH ON ? (MORE THAN 1 PH 2 PASS)
         BO    APH026A             YES, BRANCH
         BCT   R5,APH022A          DECREASE MRG ORD BY 1 AND TRY THAT
APH026A  LR    R3,R4               GET CURRENT MRG ORD SQD
         SR    R2,R2
         DR    R2,R5               DIVIDE BY MRG ORD
         BCTR  R3,0                SUBTRACT 1
         MR    R2,R3               SQUARE IT
         LR    R4,R3               PUT BACK IN PROPER REGISTER
         BCT   R5,APH022B          DECREASE MRG ORD BY 1 AND TRY THAT
APH026B  CH    R5,PPIMRGAL         CURRENT MRG ORD = MAXIMUM
         BE    APH026C             YES, BRANCH
APH026G  LA    R5,1(,R5)           NO, UP IT BY 1
         B     APH026E             GOTO END OF MERGE OP
*
APH026C  LR    R3,R4               MORE THAN 1 PH 2 PASS
         MR    R2,R5               SQ MRG ORD
         LR    R4,R3
         TM    APHSWTCH,X'01'      MORE THAN 2 PHASE 2 PASSES ?
         BO    APH026E             YES, BRANCH (DON'T TRY TO OPT YET)
         OI    APHSWTCH,X'01'      SET SW TO INDICATE MORE THAN 1 PASS
         B     APH022B             GO SEE IF THERE WILL BE MORE THAN 2
*
APH026F  CH    R0,WTEMPMO          NO OF SEQ CHANGE ?
         BNE   APH026G             YES, GO USE LAST MERGE ORDER
APH026E  CH    R5,WMAXSEQ          MRG ORD < MAX SEQ ?
         BNH   APH026D             NO, BRANCH
         LH    R5,WMAXSEQ          SET MRG ORD TO MAX SEQ
APH026D  LR    R8,R5               PUT IN R8 FOR LATER USE
         STH   R5,PPIMRGOP         USE THIS MERGE ORDER
         STH   R8,KSAVE            SAVE IT
         LH    R6,PPILAB03+2       INPUT BUF SIZE
         B     APHBEG              END OF MRG OP ROUTINE
*
APH027   LA    R6,2(,R6)           I = I + 2
         CH    R4,PPISEQCT(R6)     CURRENT STRING MAX = NEW
         BL    APH021              CURRENT LOW, REPLACE WITH NEW
         B     APH022              UPDATE INDEX AND CONTINUE
*
APHBEG   LR    R3,R8               COUNT FOR MULTIPLE GETMAIN
         LA    R10,4(,R10)
         ST    R10,APHRKSAV
APH030   LA    R9,4(,R9)           PROPAGATE SORT BUFFER SIZE IN
         ST    R6,0(,R9)           SIZE TABLE
         LR    R0,R6
         BAS   R5,APHGETR          GOTO GETMAIN R
         ST    R1,0(,R10)
         LA    R10,4(,R10)
         BCT   R3,APH030           GOTO PROPAGATE SORT BUFFER SIZE
         MVI   0(R9),X'80'
         L     R10,APHRKSAV
         L     R2,PPIGETMN
         MVC   PPILAB04,4(R2)      SAVE FIRST OUTPUT BUFFER ADDR IN PPI
         MVI   PPILAB07,1          SET NO OF BUFFERS TO 1
         LH    R2,KSAVE            MERGE ORDER
         STC   R2,PPILAB03         SET INPUT NO BUFFERS TO M
         SLL   R2,2                ALLOCATE BUFFER ADDR TABLE FOR
         L     R1,PPIGETSZ         M BUFFERS - PPILAB02
         SR    R1,R2
         ST    R1,PPILAB02
         L     R4,PPIGETMN
         BCTR  R2,0                MOVE INPUT BUFFER ADDRS FROM
         EX    R2,KMOVE            GETMAIN TABLE TO BUFFER TABLE
         IC    R3,PPIBUF23         TOTAL NO BUFFERS FOR PHASE
         LH    R7,KSAVE            MERGE ORDER
         LA    R7,1(,R7)           M+1
         CR    R3,R7               B/G CALC > M+1 BUFFERS
         BH    APH050              YES, TRY FOR EXTRA
         MVI   PPILAB04,X'80'      SET BIT TO INDICATE NO EXTRA
*                                  GETMAIN BY PPIWRT
APH035   SR    R0,R0               ZERO PPILAB05
         ST    R0,PPILAB05
*
*        EXIT
*
APH040   MVC   PPISPGN1,PPILAB02   SET GEN STORAGE ADDR FOR NEXT RTN
         L     R9,PPIAMB+4         SET MSG BASE REG
         PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTICS ?
         BZ    APHDISK1            NO, BRANCH
         L     R1,PPILAB02         NUMBER TO BE CONVERTED
         BAS   R10,APHCONVT        CALL CONVERT LINKAGE
         MVC   IER921A,2(R1)       MOVE FORMATTED ADDR INTO MSG
         LM    R0,R1,IER921        IER921I INPUT BUFFER TABLE ADDR
         L     R15,PPIADSSC        SET UP PRINT LINKAGE
         BAS   R14,12(,R15)        CALL PRINT MSG RTN
         LM    R0,R1,WREGSV1       RESTORE APH'S REGS
APHDISK1 B     APH041              IF DISK, INSTRUCTION IS NOP
*
         SR    R4,R4
         ICM   R4,B'0111',PPILAB04+1  R4 -> BUFFER
         AH    R4,KEIGHT
         ST    R4,PPILAB04         FOR BLOCK RTN
APH041   L     R14,WREGSV          RETURN TO IERRC9
         BR    R14
*
APH050   B     APH055              IF DISK ADD 8 BYTES TO BUFFER
*
         LA    R6,8(,R6)           SIZE FOR MBBCCHHR - B IS NOP
APH055   STH   R6,APHGETC+6        LV PARAMETER AND
         LA    R1,PPILAB05
         ST    R1,APHGETC+8        A PARAMETER FOR EXTRA OUTPUT
         BAS   R5,APHGETC          EXTRA OUTPUT BUFFER
         B     APH035              STORAGE NOT AVAILABLE
*
*        STORAGE AVAILABLE
*
         MVI   PPILAB07,2          NO OF OUTPUT BUFFERS IS 2
         MVI   0(R9),X'00'         RESET SIGN BIT IN SIZE TABLE
         LA    R9,4(,R9)
         ST    R6,0(,R9)           AND ENTER OUTPUT BUFFER SIZE
         MVI   0(R9),X'80'         IN TABLE
         SLL   R8,2                PLACE OUTPUT BUFFER ADDR
         AR    R10,R8              R8 CONTAINED MULT GETMAIN COUNT
         MVC   0(4,R10),PPILAB05   IN GETMAIN ADDR TABLE
         MVI   PPILAB04,X'80'      SET BIT TO INDICATE NO EXTRA
*                                  GETMAIN BY PPIWRT
APHDISK2 B     APH058              IF DISK, INSTRUCTION IS NOP
*
         L     R4,PPILAB05         SET BUFFER ADDR
         AH    R4,KEIGHT
         ST    R4,PPILAB05         FOR BLOCK RTN
APH058   LA    R7,1(,R7)           M+2
         CR    R3,R7               CALC NO BUFFERS M+2 ?
         BE    APH040              YES, ONLY TRY FOR EXTRA BUFFERS ON
*                                  OUTPUT
*                                  NO, TRY FOR EXTRA INPUT BUFFERS
         SR    R3,R7               NO OF EXTRA INPUT BUFFERS CALC
         MVC   APHGETC+6(2),PPILAB07+2  LV PARAMETER FOR EXTRA INPUT
         L     R6,PPILAB02
         CH    R3,KSAVE            RESET NO OF EXTRA BUFFERS TO M IF
         BNH   APH060              TOTAL GREATER THAN 2*M - HAD M
         LH    R3,KSAVE            CUT BACK SINCE B/G CALC
APH060   SH    R6,KFOUR
         ST    R6,APHGETC+8        A PARAMETER FOR EXTRA INPUT
         BAS   R5,APHGETC          GOTO GETAMIN EC
         B     APH040              STORAGE NOT AVAILABLE
*
*        STORAGE AVAILABLE
*
         ST    R6,PPILAB02         SAVE BUFFER ADDR IN BUFFER TABLE
         MVI   0(R9),X'00'         RESET SIGN BIT IN SIZE TABLE
         LA    R9,4(,R9)
         LA    R10,4(,R10)         ENTER INPUT BUFFER SIZE
         MVC   1(3,R9),PPILAB07+1
         MVI   0(R9),X'80'         IN TABLE
         MVC   0(4,R10),0(R6)      SAVE BUFFER ADDR IN GETMAIN
*                                  ADDR TABLE
         IC    R1,PPILAB03         ADD ONE TO NO OF INPUT
         LA    R1,1(,R1)           BUFFERS FOR THE PHASE
         STC   R1,PPILAB03
         BCT   R3,APH060           TRY FOR ANOTHER BUFFER
         B     APH040              ALL CALC BUFFERS GOTTEN
*
*        GETMAIN (R FORM) - FIXED, SINGLE, UNCONDITIONAL
*
APHGETR  GETMAIN  R,LV=(0)
*
         BR    R5                  RETURN
*
*        GETMAIN ROUTINE - FIXED, SINGLE, CONDITIONAL
*
APHGETC  GETMAIN  EC,LV=80,A=APH010  LV AND A PARAMETERS ARE DUMMY
*                                  FILLED IN AT EXECUTION TIME
         B     APH070(R15)         BRANCH ACCORDING TO RETURN CODE
APH070   B     4(,R5)              +00 REQUEST SATISFIED
         BR    R5                  +04 REQUEST NOT SATISIFIED
*
APHCONVT STM   R0,R1,WREGSV1       SAVE REGS USED BY NUM CVT RTN
         LR    R0,R1
         L     R15,PPICONV+4
         BAS   R14,4(,R15)         GO CONVERT NUMBER
         BR    R10                 RETURN TO MAINLINE PROGRAM
*
*        SWITCHES
*
APHSWTCH DC    X'00'               SWITCH A
APHSWCHB DC    X'00'               SWITCH B
*
*        CONTANTS
*
KMOVE    MVC   0(1,R1),8(R4)       MOVE GETMAIN ADDR TABLE INTO
*                                  INPUT BUFFER ADDR TABLE
KFOUR    DC    H'4'
KEIGHT   DC    H'8'
KSAVE    DC    H'0'                MERG ORDER
*
*        WORK AREAS
*
WTEMPMO  DC    H'0'                TEMP MERGE ORDER SAVE AREA
WMAXSEQ  DC    H'0'                MAX SEQ PER AREA SAVE AREA
WREGSV   DC    F'0'                R14 SAVE AREA
APHRKSAV DC    F'0'                *
WREGSV1  DC    2F'0'               MESSAGE RTN REG SAVE AREA
*
         DC    175F'0'             MAKE THIS MOD AS BIG AS DCB GEN
*
*        IERAMB
*
DIERAMB  DSECT
*
         COPY  AMBMAIN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERAPI   0101-20211-20211-1200-00311-00311-00000-RELEASE 00
API      TITLE 'IERAPI - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERAPI
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 3/MERGE ONLY ASSIGNMENT MODULE - STORAGE ALLOCATION
*        THE FUNCTION OF THIS MODULE IS TO ALLOCATE STORAGE
*        FOR INPUT AND OUTPUT BUFFERS AND GENERATED STORAGE IN
*        PHASE 3 AND MERGE ONLY. IF VBS INPUT ALLOCATE M
*        WORKAREAS FOR INPUT AND IF VBS OUTPUT A WORKAREA FOR THE
*        OUTPUT FILE USING THE GETMAIN MACRO. THE INPUT BUFFER
*        ADDRESS TABLE AND THE GETMAIN ADDRESS AND SIZE TABLES
*        WILL BE GENERATED IN PROGRAM GENERATED STORAGE AND THE
*        TABLE ADDRESSES PLACED IN PPILAB02, PPIGETMN, AND
*        PPIGETSZ. PPILAB02 IS ALSO WHERE GENERATED STORAGE STARTS
*        FOR THE NEXT ROUTINE NEEDING THIS STORAGE AREA - PPISPGN1.
*        EXIT E31 IS LINKED TO IN THIS MODULE IF IT HAS BEEN
*        ACTIVATED BY THE USER THROUGH THE MODS STMT
*
*        USED AS A DSECT IN - N/A
*
*        MACROS USED -
*        GETMAIN - FIXED, CONDITIONAL AND UNCONDITIONAL
*        SMPPI
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                          LOAD  EP=IERAPI,DCB=SORTLIB
*                          LR    R15,R0
*                          BALR  R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPICNTL   PPILAB07
*        PPIX31    PPILAB09
*        PPIP3GC   PPIBUF23
*        PPIMRGMX
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPICNTL    PPILAB03
*        PPISPGN1   PPILAB04
*        PPIGETMN   PPILAB05
*        PPIGETSZ   PPILAB06
*        PPILAB02   PPILAB07
*
*        EXTERNAL ROUTINES -
*        PPIX31 - USER ROUTINE E31
*
*        EXTERNAL PARAMETERS - NONE
*
*        EXITS - NORMAL - IERRC9
*                         RETURN VIA R14
*
*                       - USER EXIT E31
*                         L     R15,PPIX31+4
*                         BALR  R14,R15
*
*        EXITS - ERROR - NONE
*
*        TABLES/WORK AREAS -
*        WREGSV  - SAVE RETURN REGISTER R14
*        PPIPSVA - GENERAL REGISTER SAVE AREA
*
*        NOTES -
*        THIS MODULE DEPENDS ON THE GETMAIN MACRO EXPANSION NOT
*        ALTERING
*
IERAPI   CSECT
*
         USING *,R11               MODULE BASE REGISTER
         USING IERRCA,R13          PPIA BASE REGISTER
         USING DIERAMC,R9
*
         LR    R11,R15             SET BASE REGISTER
         ST    R14,WREGSV          SAVE RETURN REGISTER
         PPISETON PPIPH3           SET PHASE 3 INDICATOR
         PPITEST  PPIME31          EXIT E31 ACTIVE ?
         BZ    APIBEG              NO, BRANCH
*
*        USER EXIT E31 ACTIVE
*
APIGOUSR L     R15,PPIX31+4        OBTAIN USER ADDR AND
         BASR  R14,R15             CALL USER EXIT
*
*        GETMAIN GENERATED STORAGE, ONE OUTPUT BUFFER AND
*        M (MERGE ORDER) INPUT BUFFERS
*
APIBEG   L     R0,PPIP3GC          R0 = L'GENERATED STORAGE
         BAS   R4,APIGETR          GETMAIN GENERATED STORAGE
         LR    R2,R1               SAVE ADDR IN R2
         A     R1,PPIP3GC          CALC GEN STORAGE END ADDR
         L     R9,PPIAMC+4         SET MSG BASE REG
         PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTICS ?
         BZ    APINDIAG            NO, BRANCH
         BAS   R10,APICONVT        CONVERSION ROUTINE LINKAGE
         MVC   IER940A,2(R1)       MOVE FORMATTED ADDR INTO MSG
         LM    R0,R1,IER940        IER940I GENERATED STORAGE END ADDR
         L     R15,PPIADSSC        SET UP PRINT LINKAGE
         BAS   R14,12(,R15)        CALL PRINT
         LM    R0,R1,WREGSV1       RESTORE API'S REGS SAVED BY APICONVT
*
APINDIAG LH    R3,PPIMRGMX
         AR    R3,R3               DETERMINE SIZE OF GETMAIN TABLES
         PPITEST  PPIMERGO         MERGE ONLY ?
         BZ    API001              NO, BRANCH
*                                  MERGE PROCESSING
         PPITEST  PPIMVSI          ((2*M+3)*4)*2 IF NOT VBS
         BZ    API001              NOT VBS INPUT, BRANCH
         AH    R3,PPIMRGMX         ((3*M+3)*4)*2 IF VBS IN, NO VBS OUT
API001   PPITEST  PPIMVSO          VBS OUTPUT ?
         BZ    API002              ((2*M+4)*4)*2 IF NOT VBS IN, VBS OUT
         LA    R3,1(,R3)           YES
API002   LA    R3,3(,R3)           ((3*M+4)*4)*2 IF VBS IN AND OUT
         SLL   R3,2                *4 FOR NUMBER OF WORDS REQUIRED
         SR    R1,R3
         ST    R1,PPIGETMN         SET ADDR OF GETMAIN ADDR TABLE
         ST    R2,0(,R1)           STORE ADDR OF GENERATED STORAGE
*                                  IN PPI
         LR    R2,R1               R2 -> GENERATED STORAGE
         SR    R1,R3
         ST    R1,PPIGETSZ         SET ADDR OF GETMAIN SIZE TABLE
         MVC   0(4,R1),PPIP3GC     MOVE SIZE OF GEN STORAGE INTO TABLE
         LH    R6,PPILAB09+2       THE SECOND ENTRY IN THE TABLES IS
         LA    R0,8(,R6)           THE OUTPUT BUFFER ADDR AND ITS
         ST    R0,4(,R1)           SIZE
         BAS   R4,APIGETR          OUTPUT BUFFER AND BUFFER CONTROL
*                                  BLOCK
         ST    R1,PPILAB06         BUFFER CONTROL BLOCK ADDR
         ST    R1,4(,R2)           SAVE ADDR IN GETMAIN ADDR TABLE
         LA    R1,8(,R1)
         ST    R1,PPILAB04         STORE FIRST OUTPUT BUFFER ADDR
         MVI   PPILAB07,1          NO OF OUTPUT BUFFERS SET TO 1
         L     R1,PPIGETSZ
         LA    R2,4(,R1)
         LH    R3,PPIMRGMX
         LR    R5,R3               ALLOCATE BUFFER ADDR TABLE FOR
         SLL   R5,2                M BUFFERS - PPILAB02
         SR    R1,R5
         ST    R1,PPILAB02
         LR    R8,R1
API010   SR    R0,R0
         ICM   R0,B'0011',PPILAB07+2    R0 = BUFFER SIZE
         LA    R2,4(,R2)           SET R2 TO FIRST SIZE
         ST    R0,0(,R2)           PROPAGATE SIZE IN LIST
         BAS   R4,APIGETR          CALL GETMAIN SUBROUTINE
         ST    R1,0(,R8)           STORE ADDR RETURNED IN LIST
         LA    R8,4(,R8)           INCREMENT R8 TO NEXT ENTRY
         BCT   R3,API010           LOOP UNTIL LIST IS EMPTY
         L     R1,PPIGETMN         R1 -> GETMAIN ADDR LIST
         L     R3,PPILAB02         PLACE M INPUT BUFFER ADDRS IN
         BCTR  R5,0                DECR FOR MVC
         EX    R5,KMOVE            MOVE BUFFER LIST INTO GETMAIN ADDR
*                                  LIST PLUS 8 MVC 8(1,R1),0(R3)
         LA    R5,1(,R5)           RESTORE R5
         LA    R7,8(R1,R5)         R7 -> WORKAREAS IN GETMAIN TAB
         PPITEST  PPIMERGO         MERGE ONLY ?
         BZ    API004              NO, BRANCH
         PPITEST  PPIMVSI          VBS INPUT ?
         BZ    API004              NO, BRANCH
         LH    R3,PPIMRGMX         SET R3 TO M
         AR    R5,R5               SET R5 TO 2*(4*M)
API003   LH    R0,PPIRCDL1
         BAS   R6,APIVRE           UPDATE TABLE
         BCT   R3,API003           M WORKAREAS YET
API004   PPITEST  PPIMVSO          VBS OUTPUT ?
         BZ    API005              NO, BRANCH
         LH    R0,PPIRCDL3         YES, WORKAREA FOR VBS OUTPUT
         BAS   R6,APIVRE           GETMAIN OUTPUT VBS WORKAREA
         ST    R1,PPIBDSVA+12
         LA    R5,4(,R5)
API005   STH   R5,PPIPSVA
         MVI   0(R2),X'80'         SET BIT TO INDICATE END OF LIST
         LH    R6,PPIMRGMX
         STC   R6,PPILAB03
         LA    R6,1(,R6)           M+1
         SR    R7,R7
         IC    R7,PPIBUF23+1       CHECK TO SEE IF B/G CALCULATED
         CR    R7,R6               > M+1 BUFFERS
         BH    API030              YES, TRY FOR EXTRA BUFFERS
         SR    R0,R0               NO, ZERO PPILAB05
         ST    R0,PPILAB05
         MVI   PPILAB04,X'80'      SET SW TO INDICATE NO ADDITIONAL
*                                  OUTPUT BUFFER GETMAIN BY PPIWRT
*
*        EXIT
*
API020   MVC   PPISPGN1,PPILAB02   SET GEN STORAGE ADDR FOR NEXT RTN
         MVC   PPILAB03+2(2),PPILAB07+2
         MVC   PPILAB07+2(2),PPILAB09+2
         L     R9,PPIAMC+4         SET MSG BASE REG
         PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTICS ?
         BZ    APINEXT             NO, BRANCH
         L     R1,PPILAB02         NUMBER TO BE CONVERTED
         BAS   R10,APICONVT        CALL CONVERT LINKAGE
         MVC   IER941A,2(R1)       MOVE FORMATTED ADDR INTO MSG
         LM    R0,R1,IER941        IER941I INPUT BUFFER TABLE ADDR
         L     R15,PPIADSSC        SET UP PRINT LINKAGE
         BAS   R14,12(,R15)        CALL PRINT MSG RTN
         LM    R0,R1,WREGSV1       RESTORE API'S REGS
APINEXT  L     R14,WREGSV          RETURN TO IERRC9
         BR    R14
*
*        B/G HAVE CALCULATED EXTRA BUFFERS - MORE THAN M+1
*
API030   MVC   APIGETC+6(2),PPILAB09+2   LV PARAMETER AND
         L     R3,PPIGETMN         LOAD R3 WITH
         AH    R3,PPIPSVA          PPIGETMN TABLE ADDR
         LA    R3,4(,R3)           POINT TO NEXT ENTRY-4
         LA    R1,PPILAB05
         ST    R1,APIGETC+8        A PARAMETER FOR EXTRA OUTPUT
         BAS   R4,APIGETC          EXTRA OUTPUT BUFFER
         ST    R1,PPILAB05         ZERO OUT PPILAB05
         B     API040              NO, STORAGE NOT AVAIL (R1 SET =0)
*                                  YES, STORAGE AVAILABLE
         MVI   PPILAB07,X'02'      SET NO OF OUTPUT BUFFERS TO 2
         MVI   PPILAB04,X'80'      SET SW TO INDICATE NO ADDITIONAL
*                                  OUTPUT BUFFER GETMAIN BY PPIWRT
         MVI   0(R2),X'00'         RESET SIGN BIT IN SIZE TABLE
         LA    R2,4(,R2)
         LH    R0,PPILAB09+2
         ST    R0,0(,R2)
         MVI   0(R2),X'80'         AND ENTER OUTPUT BUFFER SIZE
*                                  IN TABLE
         LA    R3,4(,R3)           UPDATE ADDR POINTER
         MVC   0(4,R3),PPILAB05    GETMAIN ADDR TABLE
API040   LA    R6,1(,R6)
         CR    R7,R6               CALC NO BUFFERS M+2 ?
         BE    API020              YES, ONLY TRY FOR EXTRA BUFFERS ON
*                                       OUTPUT
*                                  NO, TRY FOR EXTRA INPUT BUFFERS
         SR    R7,R6               NO OF EXTRA INPUT BUFFERS CALC
         MVC   APIGETC+6(2),PPILAB07+2  LV PARAMETER FOR EXTRA INPUT
         L     R6,PPILAB02
         CH    R7,PPIMRGMX         RESET NO OF EXTRA BUFFERS TO M IF
         BNH   API050              TOTAL GREATER THAN 2*M-  HAD M
         LH    R7,PPIMRGMX         CUT BACK SINCE B/G CALC
API050   SH    R6,KFOUR
         ST    R6,APIGETC+8        A PARAMETER FOR EXTRA INPUT
         BAS   R4,APIGETC          EXTRA INPUT BUFFER
         B     API020              NO, STORAGE NOT AVAILABLE (R1 SET=0)
         NOP   API020              DUMMY
         ST    R6,PPILAB02         YES, STORAGE AVAILABLE
*                                  SAVE BUFFER ADDR IN BUFFER TABLE
         MVI   0(R2),X'00'         RESET SIGN BIT IN SIZE TABLE
         LA    R2,4(,R2)
         LA    R3,4(,R3)           ENTER INPUT BUFFER SIZE
         MVI   0(R2),X'80'
         MVC   1(3,R2),PPILAB07+1  IN TABLE
         MVC   0(4,R3),0(R6)       SAVE BUFFER ADDR IN GETMAIN
*                                  ADDR TABLE
         IC    R1,PPILAB03         ADD ONE TO NO OF INPUT BUFFERS
         LA    R1,1(,R1)
         STC   R1,PPILAB03         FOR PHASE
         BCT   R7,API050           TRY FOR ANOTHER BUFFER
         B     API020              ALL CALC BUFFERS GOTTEN
*
*        GETMAIN (R FORM) - FIXED, SINGLE, UNCONDITIONAL
*
APIGETR  GETMAIN  R,LV=(0)
*
         BR    R4                  RETURN TO MAIN
*
*        GETMAIN (S FORM) - FIXED, SINGLE, CONDITIONAL
*
APIGETC  GETMAIN  EC,LV=80,A=API010  LV AND A PARAMTERS ARE DUMMY
*                                    FILLED IN AT EXECUTION TIME
         B     API060(R15)         BRANCH ACCORDING TO RETURN CODE
*                                  (00 OR 04 IN R15)
API060   B     8(,R4)              +00 REQUEST SATISFIED
         SR    R1,R1               +04 REQ NOT SATISFIED - SET R1 =0
         BR    R4                  RETURN TO MAINLINE
*
APICONVT STM   R0,R1,WREGSV1       SAVE REGS USED BY NUM CVT RTN
         LR    R0,R1
         L     R15,PPICONV+4
         BAS   R14,4(,R15)         GO CONVERT ADDR
         BR    R10                 RETURN TO CALLER
*
APIVRE   LA    R2,4(,R2)           UPDATE POINTER TO GETMAIN SIZE TABLE
         ST    R0,0(,R2)           STORE SIZE IN GETMAIN SIZE TABLE
         BAS   R4,APIGETR          GETMAIN FOR WORKAREAS
         ST    R1,0(,R7)           STORE ADDR IN GETMAIN ADDR TABLE
         LA    R7,4(,R7)           UPDATE POINTER
         BR    R6                  RETURN TO MAINLINE
*
*        CONSTANTS
*
KFOUR    DC    H'4'                CONSTANT 4
KMOVE    MVC   8(1,R1),0(R3)       MOVE INPUT BUFFER ADDR INTO
*                                  GETMAIN ADDR TABLE
*
*        WORK AREAS
*
WREGSV   DC    F'0'                REGISTER R14 SAVE AREA
WREGSV1  DC    2F'0'               MESSAGE RTN REG SAVE AREA
*
         DC    266F'0'             FORCE MODULE SIZE
*
*        IERAMC
*
DIERAMC  DSECT
*
         COPY  AMCMAIN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERAPJ   0101-20211-20211-1200-00232-00232-00000-RELEASE 00
APJ      TITLE 'IERAPJ - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERAPJ
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 2 ASSIGNMENT MODULE - TAPE OR DISK
*        THE FUNCTION OF THIS MODULE IS TO INTERROGATE PPI AND
*        INITIATE A CHECKPOINT OPERATION IF ONE HAS BEEN
*        SPECIFIED. THE MODULE WILL THEN OPEN ALL FILES
*        ASSOCIATED WITH PHASE TWO. THE MODULE IS USED FOR TAPE
*        READ BACKWARDS, TAPE/DISK READ FORWARDS AND WRITE DEVICE
*        HANDLING
*
*        USED AS A DSECT IN - N/A
*
*        MACROS USED -
*        CHKPT   OPEN
*        DCB     SMPPI
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                          LOAD  EP=IERAPJ,DCB=SORTLIB
*                          LR    RR,R0
*                          BALR  R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPICNTL
*
*        OUTPUT - ALL WORK FILES ARE OPEN
*
*        EXTERNAL ROUTINES -
*        IERAP2   - OPEN LIST
*        IERAMB   - MESSAGE MODULE
*        PPIADSSC - SORT SYSTEM CONTROL
*
*        EXTERNAL PARAMETERS -
*        IERAP2   - OPEN LIST
*        PPIADSSC - R0 -> MESSAGE
*                   R1  = L'MESSAGE
*
*        EXITS - NORMAL -
*        IERRC9 - RETURN VIA R14
*
*        EXITS - ERROR -
*        PPIADSSC - OPEN UNSUCCESSFUL
*
*        TABLES/WORK AREAS -
*        IERAP2 - LIST OF DCB ADDR
*        WREGSV - SAVE RETURN REGISTER R14
*
*        NOTES -
*        THIS MODULE IS ALWAYS EXECUTED IN PHASE 2
*
IERAPJ   CSECT
*
         USING *,R11               MODULE BASE REG
         USING IERRCA,R13          PPI COMMON MODULE BASE REGISTER
         USING IHADCB,R2           DCB DSECT
         USING IERAMB,R15          MESSAGE MODULE
*
         LR    R11,R15             SET BASE REGISTER
         ST    R14,WREGSV          SAVE RETURN REGISTER
         MVC   SORTCKPT+DCBDDNAM-IHADCB(4),PPIDDSRT  SET DDNAME PREFIX
         L     R4,PPIOPEN+4        OPEN LIST ADDR
         L     R3,0(,R4)           NO OF ENTRIES ON OPEN LIST
*
*        TAPE OR DISK
*
APJ02    PPITEST  PPITAPE          TAPE SORT ?
         BO    APJ05               YES, BRANCH
*
*        OPEN FILES FOR DISK OPERATION
*
         LA    R4,4(,R4)
         L     R2,0(,R4)           R2 -> OUTPUT DCB
         L     R15,PPIAMB+4        MOVE DDNAME TO ERROR MESSAGE IN CASE
         MVC   IER063A,DCBDDNAM    OF OPEN FAILURE
*
*        OPEN DISK OUTPUT FILE
*
         OPEN  ((R2),OUTPUT)
*
         TM    DCBOFLGS,DCBOFOPN   OPEN SUCCESSFUL COMPLETION ?
         BZ    APJERR              NO, ERROR
         B     APJ04               CHECK LIST FOR ALL OPEN ENTRIES
*
*        OPEN DISK INPUT FILE/FILES
*
APJ03    LA    R4,4(,R4)
         L     R2,0(,R4)           R2 -> INPUT DCB
         L     R15,PPIAMB+4        MOVE DDNAME TO ERROR MESSAGE IN CASE
         MVC   IER063A,DCBDDNAM    OF OPEN FAILURE
*
         OPEN  ((R2),(INOUT))
*
         TM    DCBOFLGS,DCBOFOPN   OPEN SUCCESSFUL COMPLETION ?
         BZ    APJERR              NO, ERROR
*
*        CHECK IF ALL LIST ENTRIES HAVE BEEN OPENED
*
APJ04    BCT   R3,APJ03            OPEN LIST COMPLETED ?
         B     APJCOMM             YES
*
*        OPEN FILES FOR TAPE OPERATION
*
APJ05    PPITEST  PPIREADF         READ FORWARD ON TAPE SET ?
         BZ    APJ06               NO, READ BACKWARDS IS NEEDED
*
*        READ FORWARDS IS USED ONLY TO SAVE A COPY PASS IN PHASE TWO
*        TO READ FORWARDS THE INPUT FILES NEED TO BE OPENED WITH
*        THE REREAD OPTION
*
         MVC   APJBR(4),KBRANCH    OVERLAY BRANCH INSTR TO GO OPEN
*                                  INPUT WITH REREAD OPTION
*                                  WILL BE BO APJ08
APJ06    LA    R4,4(,R4)           GET DCB ADDR
         SR    R2,R2
         ICM   R2,B'0111',1(R4)    R2 -> DCB
*
*        CHECK IF INPUT OR OUTPUT DCB TO BE OPENED
*
         L     R15,PPIAMB+4        MOVE DDNAME TO ERROR MESSAGE IN CASE
         MVC   IER063A,DCBDDNAM    OF OPEN FAILURE
         TM    0(R4),X'80'         INPUT DCB ?
APJBR    BO    APJ07               YES, BRANCH
*
*        OPEN TAPE OUTPUT FILE
*
         OPEN  ((R2),OUTPUT)
*
         TM    DCBOFLGS,DCBOFOPN   OPEN SUCCESSFUL COMPLETION ?
         BZ    APJERR              NO, ERROR
         BCT   R3,APJ06            ALL FILES BEEN OPENED ?
         B     APJCOMM             YES
*
*        OPEN TAPE INPUT FILE
*
APJ07    OPEN  ((R2),RDBACK)
*
         TM    DCBOFLGS,DCBOFOPN   OPEN SUCCESSFUL COMPLETION ?
         BZ    APJERR              NO, ERROR
         BCT   R3,APJ06            ALL FILES BEEN OPENED ?
*                                  YES
*
*        ENTIRE LIST HAS BEEN OPENED, LINK TO NEXT SEQUENTIAL MODULE
*
*        RESTORE THE BLOCK COUNTS IF IT IS A TAPE SORT AND LINKS
*        TO THE CHECKPOINT MODULE IF CHECKPOINT HAS BEEN
*        INDICATED
*
APJCOMM  PPITEST  PPITAPE          TAPE SORT ?
         BZ    APJ400              NO, NO BLOCK COUNTS TO BE RESTORED
         PPITEST  PPIREADF         READ FORWARD OPTION ?
         BO    APJ400              YES, DO NOT RESTORE BLOCK COUNTS
         SR    R1,R1               ZERO REG
         IC    R1,PPIBDSVA         LOAD NUMBER OF WORK UNITS
         LA    R2,PPITPTBL         LOAD START ADDR OF TAPE TABLE
*
*        LOOP TESTING THE INPUT BIT FOR EACH UNIT
*        IF THE INPUT BIT IS ON, THE BLOCK COUNT FOR THAT UNIT
*        IS MOVED INTO THE DCBBLKCT FIELD OF THE DCB ASSOCIATED
*        WITH THAT UNIT
*
APJ100   PPITEST  PPIPOLY          POLYPHASE SORT ?
         BO    APJ200              YES, DON'T TEST INPUT BIT
         TM    0(R2),X'80'         INPUT BIT ON FOR THIS UNIT ?
         BZ    APJ300              NO, BRANCH TO TEST NEXT UNIT
APJ200   TM    0(R2),X'40'         OPEN BIT SET FOR THIS UNIT ?
         BZ    APJ300              NO, DO NOT RESTORE BLOCK COUNT
         SR    R3,R3               ZERO REG
         L     R4,PPISTDCB         LOAD ADDR OF DCB TABLE
         IC    R3,1(,R2)           LOAD TAPE INCREMENT
         AR    R4,R3               ADDR OF DCB POINTER
         L     R4,0(,R4)           LOAD DCB ADDR
         LA    R5,PPIENDAR         LOAD STARTING ADDR OF SAVE AREA
         AR    R5,R3               GET ADDR OF BLOCK COUNT THIS UNIT
         DROP  R2
         USING IHADCB,R4
         MVC   DCBBLKCT,0(R5)      MOVE BLK CNT FROM SAVE AREA TO DCB
APJ300   LA    R2,2(,R2)           INCREMENT TAPE TABLE ADDR
         BCT   R1,APJ100           ALL UNITS TESTED ? NO LOOP AGAIN
APJ400   PPITEST  PPICHKPT         CHECKPOINT ACTIVE ?
         BZ    APJCOMM1            NO, BRANCH
         L     R15,PPICHKAD        LOAD ADDR OF CHECKPOINT MODULE
         BAS   R14,0(,R15)         CALL CHECKPOINT MODULE
APJCOMM1 L     R14,WREGSV          RETURN TO
         BR    R14                 IERRC9
*
*        OPEN TAPE INPUT FOR READ FORWARD
*
APJ08    OPEN  ((R2),(INPUT,REREAD))
*
         BCT   R3,APJ06            ALL FILES BEEN OPENED ?
         B     APJCOMM             YES
*
APJERR   L     R15,PPIAMB+4        OPEN UNSUCCESSFUL
         L     R1,IER063           R1 -> MSG TEXT
         MVC   PPIABMNO,3(R1)      MOVE MSG NO INTO ABEND NO
         LM    R0,R1,IER063        IER063A OPEN ERROR
         L     R15,PPIADSSC
         BAS   R14,12(,R15)        CALL PRINT MSG RTN
         L     R15,PPIADSSC
         BAS   R14,16(,R15)        TERMINATE THE JOB, NO RETURN
*
*        WORK LOCATIONS
*
WREGSV   DC    F'0'                RETURN ADDR
*
*        CONSTANTS
*
KBRANCH  BO    APJ08               OVERLAY FOR APJBR FOR REREAD OPTION
*
SORTCKPT DCB   MACRF=(W),DSORG=PS,DDNAME=SORTCKPT
*
         PRINT NOGEN
*
         DCBD  DSORG=(PS),DEVD=(DA,TA)
*
         PRINT GEN
*
IERAMB   DSECT
*
         COPY  AMBMAIN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERAPK   0101-20211-20211-1200-00653-00653-00000-RELEASE 00
APK      TITLE 'IERAPK - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERAPK
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 3 ASSIGNMENT MODULE - TAPE OPERATION
*        THE FUNCTION OF THIS MODULE IS TO GENERATE ONE (1)
*        OUTPUT DCB AND ONE (1) INPUT DCB FOR EACH INPUT FILE.
*        ONE (1) IOB AND ONE (1) ECB WILL BE GENERATED FOR EACH
*        INPUT FILE WITH THE INTERNAL ADDRESS POINTERS SET
*
*        THE MODULE WILL ALSO INTERROGATE PPI TO DETERMINE IF
*        USER EXITS HAVE BEEN ACTIVATED. IF EXITS HAVE BEEN
*        ACTIVATED, THE MODULE WILL GO TO THE USER FOR THE OPTION
*        LIST. THE OPTIONS WILL THEN BE USED TO MODIFY THE
*        APPROPRIATE DCB FIELDS
*
*        THE ADDRESSES OF ALL DCBS GENERATED WILL BE PLACED IN
*        BOTH THE OPEN LIST AND THE DCB ADDRESS TABLE
*
*        USED AS A DSECT IN - N/A
*
*        MACROS USED -
*        SMPPI DCB
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                       CALLING SEQUENCE -
*                           LOAD EP=IERAPK,DCB=
*                           LR   R15,R0
*                           BALR R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIRCDCT   PPIBDSVA   PPIDDSRT
*        PPIOPEN    PPIX38     PPIX39
*        PPIAMC     PPITPTBL   PPIMRGMX
*        PPILAB06   PPICNTL    PPISPGN1
*        PPITPPT    PPILAB07   PPIADSSC
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPISPGN1   PPISTDCB
*
*        EXTERNAL ROUTINES - NONE
*
*        EXTERNAL PARAMETERS -
*        PPIOPEN+4 - OPEN LIST ADDR
*        PPIAMC+4  - MESSAGE MODULE ADDR
*
*        EXITS - NORMAL - RETURN TO LOAD MODULE IERRC9
*                         BR    R14
*
*                       - USER READ OPTION EXIT
*                         L     R15,PPIX38+4
*                         BR    R15
*
*                       - USER WRITE OPTION EXIT
*                         L     R15,PPIX39+4
*                         BR    R15
*
*        EXITS - ERROR -
*        PPIAMC+4 - ILLEGAL OPTION NUMBER SPECIFIED BY USER
*        DCBSYNAD - QSAM WRITE ERROR
*
*        TABLES/WORK AREAS -
*        WFULL   - WORK AREA START
*        WREGSV3 - WORK AREA END
*        KTABLE  - WORK TABLE
*
*        NOTES - N/A
*
IERAPK   CSECT
*
         USING *,R11               MODULE BASE REG LOADED EXTERNALLY
         USING IHADCB,R12          BASE REGISTER FOR DCB DSECT
         USING IERRCA,R13          PPI COMMON MODULE BASE REGISTER
         USING DIERAMC,R14         BASE REG FOR MESSAGE MODULE DSECT
         USING OPENLST,R15         BASE REG FOR OPEN LIST DSECT
*
IERMP3BG LR    R11,R15             SET BASE REGISTER
         STM   R12,R14,WREGSV3     SAVE ORIGINAL REGS
         PPITEST  PPIREADF         READ FORWARD PASS ?
         BZ    AOYXDD              NO, BYPASS OVERLAY
         MVC   MODIOB+IOBINCAM-IERIOB,K1  SET TAPE BLOCK COUNTER
*
*        MOVE DDNAME INTO DCB DDNAME
*
AOYXDD   MVC   KOUTID(4),PPIDDSRT
         MVC   KINPID(4),PPIDDSRT
         L     R4,PPIADSSC
         MVC   ADCON6X(4),24(R4)   MOVE SYNAD ADDR INTO ADCON6X
         ICM   R4,B'1111',PPIRCDCT  ZERO FILE ?
         BNZ   AOYTECT             NOT ZERO FILE, BRANCH
*
*        A ZERO FILE, TURN OFF OPEN BITS ON ALL UNITS IN TAPE TABLE
*
         IC    R4,PPIBDSVA
         LA    R5,PPITPTBL
AOYZERT  MVI   0(R5),X'00'
         LA    R5,2(,R5)           INCR THRU TAPE TABLE
         BCT   R4,AOYZERT          GOTO INCR THRU TAPE TABLE
         B     APKSTART
*
AOYTECT  PPITEST  PPIPOLY          POLYPHASE SORT ?
         BO    AOYPOLY             YES, GOTO POLYPHASE PROCEDURE
         PPITEST  PPIOSC           OSCILLATING TECHNIQUE ?
         BO    APKSTART            YES, GENERATE DCBS
*
*        BALANCED TECHNIQUE PROCEDURE
*
*        PPIEVNOD IS CHECKED TO DETERMINE WHICH HALF OF THE TAPE
*        TABLE CONTAINS THE INPUT UNITS FOR PHASE 3
*        IF NOT ON THE INPUT IS FROM THE FIRST HALF OF THE TAPE
*        TABLE. IF ON THE INPUT IS FROM THE SECOND HALF OF THE
*        TAPE TABLE
*
         PPITEST  PPIEVNOD         EVEN/ODD SWITCH FOR BALANCED
         BO    AOYSSH              GOTO SEL INPUT FROM 2ND HALF OF TAB
*
*        THE INPUT UNITS ARE THEREFORE IN THE FIRST HALF OF THE
*        TAPE TABLE
*
         LA    R4,PPITPTBL         BEGINNING ADDR OF FIRST HALF OF TAB
         LH    R5,PPITPPT          NO OF UNITS IN FIRST HALF OF TABLE
         LR    R6,R4
         LR    R7,R5
         SLL   R7,1
         AR    R6,R7               BEGINNING ADDR OF 2ND HALF OF TABLE
         LH    R7,PPITPPT+2        NO OF UNITS IN 2ND HALF OF TABLE
AOYSIOB  LH    R8,PPIMRGMX         NO OF UNITS TO BE INPUT FOR PH 3
*
*        R4 - CONTAINS THE ADDR OF THAT PART OF THE TAPE TABLE
*             WHICH WILL BE INPUT FOR PHASE 3
*        R8 - CONTAINS THE NUMBER OF INPUT UNITS
*        R5 - CONTAINS THE LIMIT OF UNITS IN TABLE AS INDICATED BY R4
*        R6 - CONTAINS THE ADDR OF THAT PART OF THE TABLE WHICH
*             ARE NOT INPUT FOR PHASE 3
*        R7 - CONTAINS THE LIMIT OF UNITS IN TABLE AS INDICATED BY R6
*
*        SETTING OF THE APPROPRIATE INPUT AND OPEN BITS
*
         SR    R9,R9
AOYRESET MVI   0(R4),X'C0'
         BCT   R8,AOYDECR          GOTO INCR R4
         LA    R9,16(,R9)
         B     AOYDECR             GOTO INCR R4
*
         MVI   0(R4),X'00'
AOYDECR  LA    R4,2(,R4)
         BCT   R5,AOYRESET(R9)     BRANCH TO
AOYRST   MVI   0(R6),X'00'
         LA    R6,2(,R6)
         BCT   R7,AOYRST           GOTO INCR R4
         B     APKSTART
*
*        THE INPUT UNITS ARE IN THE SECOND HALF OF THE TAPE TABLE
*
AOYSSH   LA    R6,PPITPTBL         BEGIN ADDR OF FIRST HALF OF TABLE
         LH    R7,PPITPPT          NO OF UNITS IN 1 HALF OF TBL
         LR    R4,R6
         LR    R5,R7
         SLL   R5,1
         AR    R4,R5               BEGINNING ADDR OF 2ND HALF OF TABLE
         LH    R5,PPITPPT+2        NO OF UNITS IN 2 HALF OF TBL
         B     AOYSIOB             GOTO SET INPUT AND OPEN BITS
*
*        SET THE INPUT AND OPEN BITS IF THE POLYPHASE TECHNIQUE
*        BY CHECKING WHICH UNITS HAVE 1 STRING
*
AOYPOLY  LA    R4,PPITPTBL         BEGINNING ADDR OF TAPE TABLE
         SR    R5,R5
         IC    R5,PPIBDSVA         TOTAL NUMBER OF UNITS IN TAPE TABLE
         LA    R6,PPITPTBL+34      BEGINNING ADDR OF REAL STRING CTRS
AOYCF1   CLI   1(R6),X'01'         CHECK FOR REAL STRING CNT # 1
         BE    AOYSIOON            GOTO INSERT C0
         MVI   0(R4),X'00'
AOYINCR  LA    R4,2(,R4)           INCR THRU TAPE TABLE
         LA    R6,2(,R6)           INCR THRU REAL STRING COUNTERS
         BCT   R5,AOYCF1           GO CHK FOR REAL STRING CNT=1
         B     APKSTART
*
AOYSIOON MVI   0(R4),X'C0'
         B     AOYINCR             GOTO INCR THRU TABLES
*
APKSTART LA    R12,SORTWK          R12 -> SORTWK DCB
         LA    R12,SORTOUT         QSAM DCB MODEL
*
*        SET UP WORKING PARAMETERS FOR TAPE OPERATION
*
APK01    LA    R4,PPITPTBL         ADDR OF TAPE TABLE
         ST    R4,WTABLE
         ICM   R15,B'1111',PPIRCDCT   R15 = RECORD COUNT, ZERO ?
         BZ    APK01A                 ZERO, NO INPUT DCBS ARE REQUIRED
         MVC   WNUMDCB+2(2),PPIMRGMX  NO OF INPUT DCBS TO GENERATE
*
*        STORE TOTAL NUMBER OF DCBS TO OPEN AS THE FIRST ENTRY OF
*        THE OPEN LIST
*
APK01A   L     R15,PPIOPEN+4
         LA    R2,IERAP3A          NO OF DCB ENTRIES SLOT
         L     R4,WNUMDCB
         LA    R4,1(,R4)
         ST    R4,0(,R2)
         LA    R2,4(,R2)           UPDATE OPEN LIST POINTER
         ST    R2,WPARLST
         MVC   WTBLENT+3(1),PPIBDSVA  NUMBER OF WORK UNITS IN TAPE TAB
*
*        COMPUTE STORAGE REQUIRED FOR DCBS, IOBS, ECBS AND TABLES
*
         L     R4,PPISPGN1
         SRL   R4,2
         SLL   R4,2                GEN CORE BOUNDRY ALIGNED
*
*        COMPUTE STORAGE REQUIREMENTS FOR DCBS
*
         LA    R1,SORTOUTL         L'SORTOUT DCB
         SR    R6,R6               ZERO REG
         ICM   R8,B'1111',WNUMDCB  NO OF SORTWK DCBS, ZERO ?
         BZ    APK01B              NO SORTWK DCBS TO GENERATE
         LA    R7,SORTWKL          L'SORTWK DCB
         MR    R6,R8
         AR    R1,R7               R1 = TOTAL DCB BYTES REQUIRED
APK01B   SR    R4,R1               UPDATE ADDR POINTER
         ST    R4,WDCBADR          START OF DCB STORAGE AREA
*
*        COMPUTE PREFIXED IOB STORAGE REQUIREMENTS
*
         ICM   R6,B'1111',PPIRCDCT  R6 = RECORD COUNT, ZERO ?
         BZ    APK01C              YES, NO IOBS REQUIRED
         SR    R6,R6               ZERO REG
         LA    R7,MODIOBL          L'PREFIXED IOB
         MR    R6,R8
         SR    R4,R7               UPDATE ADDR POINTER
         ST    R4,WIOBADR          START OF PREFIXED IOB CORE AREA
*
*        COMPUTE STORAGE REQUIRED FOR DCB ADDR TABLE
*
APK01C   L     R3,WTBLENT          NO OF TAPE TABLE ENTRIES
         LA    R3,1(0,R3)          ADD 1 TO COUNT
         SLL   R3,2                NO OF ENTRIES TIMES 4
         SR    R4,R3               UPDATE ADDR POINTER
         ST    R4,WDCBTAB          START OF DCB ADDR TABLE
         ST    R4,PPISTDCB         UPDATE PPI
         ST    R4,PPISPGN1         UPDATE PPI
         PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTICS ?
         BZ    APKNOMES            NO, BRANCH
         STM   R14,R1,APKSAV       SAVE REGISTERS FOR PRINTING
         L     R14,PPIAMC+4        LOAD MESSAGE BASE REGISTER
         LR    R0,R4               LOAD ADDR TO BE CONVERTED
         L     R15,PPICONV+4       LOAD ADDR OF CONVERSION ROUTINE
         BAS   R14,4(,R15)         CALL CONVERT RTN
         L     R14,PPIAMC+4        LOAD MESSAGE BASE REGISTER
         MVC   IER944A,0(R1)       MOVE FORMATTED ADDR INTO MSG
         LM    R0,R1,IER944        IER944I DCB TABLE ADDR
         L     R15,PPIADSSC        LOAD ADDR OF PRINT ROUTINE
         BAS   R14,12(,R15)        CALL PRINT RTN
         LM    R14,R1,APKSAV       RESTORE REGISTERS AFTER PRINTING
APKNOMES SR    R6,R6
*
*        SET INDICATOR BIT IN FIRST BYTE OF ALL DCB ADDR TABLE
*        SLOTS
*
         SR    R6,R6               ZERO REG
         ST    R6,WFULL            ZERO WORK LOCATION
         MVI   WFULL,X'80'         INDICATOR BIT IN WORK LOCATION
         L     R6,WFULL            INDICATOR BIT IN REGISTER
         L     R3,WTBLENT          NO OF TABLE ENTRIES
         LA    R3,1(,R3)           ADD 1 TO COUNT
APK02    ST    R6,0(,R4)           STORE INDICATOR IN ADDR LIST
         BCT   R3,APK03            ALL INDICATORS STORED ?
         B     APK04               YES
*
APK03    LA    R4,4(,R4)           UPDATE TABLE POINTER
         B     APK02               CONTINUE STORING INDICATORS
*
*        GENERATE SORTOUT DCB
*
*        CHECK FOR USER MODIFICATION EXIT
*        MOVE COMPLETED DCB INTO ALLOCATED CORE, STORE DCB ADDR
*        IN PROPER TABLES AND UPDATE POINTERS
*
APK04    MVI   WINDIC,X'00'        SET INDICATOR FOR SORTOUT DCB
         B     APKINITL            GO OUT AND RETURN FROM THE DCB
*                                  INITIALIZATION SUBROUTINE
*
*        CHECK IF USER EXIT E39 IS ACTIVE
*
APKRTRN3 PPITEST  PPIME39          EXIT E39 ACTIVE ?
         BO    APKGOUSR            YES, BRANCH
APKMVOUT L     R1,WDCBTAB          START OF DCB ADDR TABLE
         L     R2,WPARLST          NEXT USABLE SLOT IN OPEN LIST
         L     R4,WDCBADR          NEXT USABLE ACTUAL DCB ADDR
         LR    R3,R4
         LA    R5,SORTOUT          R5 -> SORTOUT DCB
         MVC   0(SORTOUTL,R4),0(R5)  MOVE DCB INTO ALLOCATED CORE
*
*        STORE DCB ADDR INTO PROPER LISTS AND UPDATE PARAMETER
*
         ST    R3,0(,R1)           STORE DCB ADDR IN DCB ADDR TABLE
         ST    R3,0(,R2)           STORE DCB ADDR IN OPEN LIST
         LA    R2,4(,R2)           UPDATE OPEN LIST POINTER
         ST    R2,WPARLST
         LA    R4,SORTOUTL(,R4)    UPDATE DCB ACTUAL ADDR
         ICM   R6,B'1111',PPIRCDCT  R6 = RECORD COUNT, ZERO ?
         BZ    APK09               ZERO, BYPASS THE INPUT
*                                  DCB GENERATION ROUTINE
*
*        GENERATE THE SORTWK DATA CONTROL BLOCKS
*
         MVI   WINDIC,X'01'        SET INDICATOR FOR INPUT DCBS
         B     APKINITL            GO OUT AND RETURN FROM THE DCB
*                                  INITIALIZATION SUBROUTINE
*
*        CHECK USER EXIT E38 IS ACTIVE
*
APKRTRN1 PPITEST  PPIME38          EXIT E38 ACTIVE ?
         BO    APKGOUSR            YES, BRANCH
*
*        SET UP PARAMETERS, ASSIGN PROPER SORTWK IDENTITIES AND
*        MOVE SORTWK DCBS AND IOBS INTO ALLOCATED STORAGE
*
APKMVIN  L     R6,WTABLE           TAPE TABLE ADDR
         LA    R8,KTABLE           IDENTITY TABLE ADDR
         L     R10,WTBLENT         NO OF ENTRIES IN TAPE TABLE
         L     R2,WPARLST          OPEN LIST POINTER
         LA    R5,SORTWK           R5 -> SORTWK DCB
         LR    R3,R4
*
*        START ASSIGNING DCB DDNAMES AND DCB GENERATION
*
APK05    TM    0(R6),X'40'         OPEN BIT SET ?
         BO    APK06               YES , BRANCH
*                                  NO
         BCT   R10,APK08           GOTO UPDATE TAPE TABLE PTR
         B     APK09               SET UP LINKAGE TO NEXT MODULE
*
*        GET INCREMENT FROM TAPE TABLE AND CONVERT TO DDNAME NUMBER
*
APK06    MVC   WFULL01+3(1),1(R6)  MOVE IN INCREMENT
         L     R9,WFULL01
         SRL   R9,1
         AR    R9,R8
         MVC   DCBDDNAM+6(2),0(R9)
*
*        SET UP IOB MODEL AND SET IOB POINTER IN DCB
*
         ST    R3,MODIOB+IOBDCBPT-IERIOB  ADDR OF ASSOCIATED DCB
         L     R9,WIOBADR
         ST    R9,MODIOB+IOBECBPT-IERIOB  ADDR OF ASSOCIATED ECB
         LA    R9,8(,R9)           INCR PAST IOB PREFIX
         ST    R9,DCBIOBAD         IOB ADDR INTO DCB
         MVC   0(SORTWKL,R4),0(R5)   MOVE DCB INTO STORAGE
         L     R9,WIOBADR          START OF PREFIXED IOB AREA
         MVC   0(MODIOBL,R9),MODIOB  MOVE PREFIXED IOB MODEL INTO CORE
         LA    R9,MODIOBL(,R9)     UPDATE IOB POINTER
         ST    R9,WIOBADR
*
*        STORE DCB ADDR AND UPDATE POINTERS
*
         L     R9,WFULL01
         AR    R9,R1               DCBTAB ENTRY SLOT
         ST    R3,0(,R9)           STORE ADDR IN DCBTAB
         ST    R3,0(,R2)           STORE ADDR IN OPEN LIST
         BCT   R10,APK07
         B     APK09               SET UP LINKAGE TO NEXT MODULE
*
APK07    LA    R2,4(,R2)           UPDATE OPEN LIST POINTER
         LA    R4,SORTWKL(,R4)     UPDATE ACTUAL DCB ADDR
         LA    R3,SORTWKL(,R3)     UPDATE THEORETIC DCB ADDR
APK08    LA    R6,2(,R6)           UPDATE TAPE TABLE POINTER
         B     APK05               CONTINUE DCB GENERATION
*
*        SET UP LINKAGE TO NEXT MODULE
*
APK09    LM    R12,R14,WREGSV3     RESTORE ORIGINAL REGS
         BR    R14                 RETURN TO IERRC9
*
*        DCB INITIALIZATION SUBROUTINE
*
*        USED FOR BOTH INPUT AND OUTPUT DCBS
*
APKINITL STM   R1,R10,WREGSAVE     SAVE REGS
         TM    WINDIC,X'01'        INPUT DCB ?
         BO    APKINT05            YES, BRANCH
*
*        OUTPUT DCB INITIALIZATION SUBROUTINE
*
         LA    R12,SORTOUT         QSAM SORTOUT DCB MODEL
         MVC   DCBDDNAM(8),KOUTID  SORTOUT
         MVC   DCBBUFNO,PPILAB07   NO OF OUTPUT BUFFERS
         MVC   DCBSYNAD,ADCON6X    MOVE SYNAD ADDR INTO DCB
         MVC   DCBBUFCA,PPILAB06+1  8 BYTE CONTROL BUFFER ADDR
         MVC   DCBBUFL,PPILAB07+2   L'OUTPUT BUFFER
         MVI   DCBEROPT,DCBERABE    ABNORMAL END OF TASK
*
*        SET UP BFTEK, BFALN AND MACRF FIELDS
*
         OI    DCBBFTEK,DCBBFTS    SIMPLE BUFFERING
         PPITEST  PPIMVSO          VBS OUTPUT ?
         BO    APKVBS              YES, GO SET MOVE MODE
         OI    DCBMACR2,DCBMRPUT+DCBMRLCP  LOCATE MODE
         B     APKINT03
*
APKVBS   OI    DCBMACR2,DCBMRPUT+DCBMRMVP  MOVE MODE FOR VBS OUTPUT
         NI    DCBMACR2,255-DCBMRLCP  LOCATE MODE
*
APKINT03 PPITEST  PPIDWA           DOUBLE WORD BUFFER ALIGNMENT ?
         BO    APKINT04            YES, GO SET DOUBLE WORD BUF ALNMENT
         OI    DCBBFALN,DCBBFAF1   NO, SINGLE WORD ALIGNMENT
         B     APKCOMM             GOTO COMM RTN
*
APKINT04 OI    DCBBFALN,DCBBFAD    DOUBLE WORD BUFFER ALIGNMENT
         B     APKCOMM             GOTO COMM RTN
*
*        SORTWK DCB INITIALIZATION SUBROUTINE
*
APKINT05 LA    R12,SORTWK          EXCP DCB MODEL
         MVC   DCBDDNAM(8),KINPID  SORTWK--
*
*        SET UP BFTEK AND BFALN FIELDS
*
         OI    DCBBFTEK,DCBBFTS    SIMPLE BUFFERING
         PPITEST  PPIDWA           DOUBLE WORD BUFFER ALIGNMENT ?
         BO    APKINT08            YES,  BRANCH
         OI    DCBBFALN,DCBBFAF1   NO, SINGLE WORD ALIGNMENT
         B     APKCOMM             GOTO COMM RTN
*
APKINT08 OI    DCBBFALN,DCBBFAD    DOUBLE WORD BUFFER ALIGNMENT
*
*        INITIALIZATION COMPLETE
*
APKCOMM  MVI   DCBIFLG,DCBIFER     USE IOS ERROR ROUTINES
         LM    R1,R10,WREGSAVE     RESTORE REGS
         TM    WINDIC,X'01'        INPUT DCB ?
         BO    APKRTRN1            YES, BRANCH
         B     APKRTRN3            NO
*
*        COMMON ROUTINE USED TO CALL THE USER AND RETURN WITH THE
*        ADDRESS OF THE USER OPTION LIST. THE MODEL DCB WILL BE
*        MODIFIED ACCORDING TO THE OPTIONS SPECIFIED ON THE LIST
*
APKGOUSR SR    R15,R15
         ST    R15,WFULL01
         STM   R1,R10,WREGSAVE
         TM    WINDIC,X'01'        INPUT DCB EXIT ?
         BO    APKUSR01            YES, BRANCH
         L     R15,PPIX39+4
         B     APKUSR02            GO SET UP RETURN FROM USER
*
APKUSR01 L     R15,PPIX38+4
APKUSR02 LA    R14,APKRTRN         SET UP RETURN FROM USER
         BR    R15                 CALL USER FOR LIST ADDR
*
*        RETURN POINT FROM THE USER MODIFICATION PROGRAM
*
APKRTRN  LR    R8,R1               R8 -> USER LIST
         L     R15,PPIOPEN+4
         TM    WINDIC,X'01'        INPUT DCB MODIFICATION ?
         BO    APKUSR03            YES, BRANCH
         LA    R5,TLDADR           NO
         LA    R7,TBRANCH
         B     APKSTMOD            GO GET WORD FROM OPTION LST
*
APKUSR03 LA    R5,TLDADR1
         LA    R7,TBRANCH1
APKSTMOD MVC   WUSRLST(4),0(R8)    GET WORD FROM OPTION LIST
         MVC   WFULL01+3(1),WUSRLST
         ICM   R4,B'1111',WFULL01
         BZ    APKUSR08            ALL OPTIONS SATISFIED ?
*                                  NO
         CL    R4,KOPTMAX          CHECK OPTION NO FOR LEGAL VALUE
         BH    APKUSR06            NOT LEGAL - OPTION NO > 3
         BE    APKUSR05            OPTION NO = 3.
APKUSR04 SLL   R4,2
         EX    0,0(R4,R5)          EXECUTE PROPER LA INSTRUCTION
         AR    R4,R7               ADD OPTION NO TO THE BRANCH TABLE
*                                  STARTING ADDR
         BR    R4                  GOTO BRANCH TABLE
*
APKUSR05 TM    WINDIC,X'01'        OPTION NO = 3, LEGAL FOR
         BO    APKUSR04            INPUT OPTIONS ONLY
*
*        ILLEGAL OPTION NUMBER SPECIFIED
*
APKUSR06 TM    WFRSTERR,X'01'      FIRST OPTION ERROR ?
         BO    APKUSR07            NO, BRANCH
         MVI   WFRSTERR,X'01'      YES, SET INDICATOR
         B     APKERR              GOTO ERROR RTN
*
APKUSR07 LA    R8,4(,R8)           UPDATE USER LIST POINTER
         B     APKSTMOD            CONTINUE MODIFICATIONS
*
*        MODIFICATIONS COMPLETE, RETURN TO MAIN PROGRAM
*
APKUSR08 LM    R1,R10,WREGSAVE     RESTORE GENERAL REGS
         MVI   WFRSTERR,X'00'      RESTORE FIRST OPTION ERROR INDIC
         TM    WINDIC,X'01'        RETURN TO INPUT ROUTINE ?
         BO    APKMVIN             YES, BRANCH
         B     APKMVOUT            NO
*
APKTRECH MVC   0(3,R6),WUSRLST+1
         B     APKUSR07            GO UPDATE USERS LIST PTR
*
APKTREB  MVC   WRDOPT+1(3),WUSRLST+1
         B     APKUSR07            GO UPDATE USERS LIST PTR
*
APKONECH MVC   WRDOPT(1),WUSRLST+3
         B     APKUSR07            GO UPDATE USERS LIST PTR
*
*        TABLE OF LOAD ADDR INSTRUCTIONS USED BY THE PROGRAM
*
TLDADR   DC    F'0'                LA TABLE
         LA    R6,DCBSYNA
         LA    R6,DCBEXLSA
         LA    R6,WUSRLST          NO EROPT FOR OUTPUT DCB
*
TLDADR1  DC    F'0'                LA TABLE
         LA    R6,WUSRLST          NO SYNAD OPTION FOR INPUT DCB
         LA    R6,DCBEXLSA
         LA    R6,WUSRLST          NO EROPT FOR INPUT DCB
*
*        BRANCH TABLES USED BY THE PROGRAM
*
TBRANCH  DC    F'0'                OUTPUT DCB BRANCH TABLE
         B     APKTRECH            SYNAD OPTION
         B     APKTRECH            EXLST OPTION
         B     APKUSR06            EROPT OPTION - ILLEGAL
*
TBRANCH1 DC    F'0'                INPUT DCB BRANCH TABLE
         B     APKTREB             SYNAD OPTION
         B     APKTRECH            EXLST OPTION
         B     APKONECH            EROPT OPTION
*
*        SET UP ERROR MESSAGE FOR PRINT MODULE
*
APKERR   STM   R0,R1,WREGSV2       SAVE REGS
         L     R14,PPIAMC+4
         LM    R0,R1,IER044        IER044I - EXIT E
         TM    WINDIC,X'01'        INPUT DCB ?
         BO    APKERR01            YES, BRANCH
         MVC   IER044B,KTAG+2
         B     APKERR02            GOTO SSC
*
APKERR01 MVC   IER044B,KTAG
APKERR02 L     R15,PPIADSSC
         BAS   R14,12(,R15)        CALL SSC
*
*        RETURN POINT FROM PRINT MODULE
*
         LM    R0,R1,WREGSV2       RESTORE REGS
         B     APKUSR07            GO UPDATE USERS LST PTR
*
*        WORK LOCATIONS
*
WFULL    DC    F'0'                WORK AREA
WFULL01  DC    F'0'                WORK AREA
WFULL02  DC    F'0'                WORK AREA
WTBLENT  DC    F'0'                NO OF ENTRIES IN TAPE TABLE
WNUMDCB  DC    F'0'                NO OF INPUT DCBS TO GENERATE
WDCBADR  DC    F'0'                STARTING ADDR OF DCB AREA
WIOBADR  DC    F'0'                STARTING ADDR OF PREFIXED IOB AREA
WDCBTAB  DC    F'0'                STARTING ADDR OF DCB ADDR TABLE
WUSRLST  DC    F'0'                TEMP STORAGE FOR USER OPTION WORD
WINDIC   DC    F'0'                INDICATOR WORD - INPUT OR OUTPUT
WTABLE   DC    F'0'                ADDR OF TAPE TABLE
WPARLST  DC    F'0'                NEXT USABLE SLOT IN OPEN LIST
WFRSTERR DC    F'0'                INDICATOR WORD - FIRST OPTION ERROR
WREGSAVE DC    11F'0'              GENERAL REGISTER SAVE AREA
WREGSV2  DC    2F'0'
WREGSV3  DC    3F'0'
APKSAV   DC    4F'0'
*
*        CONSTANTS
*
*        EXTENSION OF SORTWK DDNAME TABLE TO SUPPORT 17 - 32
*        TAPE WORK UNITS
*
KTABLE   DC    C'0001020304050607080910111213141516171819'
         DC    C'20212223242526272829303132000000'
*
KOUTID   DC    C'SORTOUT '
KINPID   DC    C'SORTWK00'
*
KTAG     DC    C'3839'
KOPTMAX  DC    F'3'
*
*        ADCONS
*
ADCON6X  DC    F'0'               SORT ERROR EXIT = SYNAD
*
APKMOVE  MVC   0(1,R4),0(R5)
*
*        MODEL IOB
*
MODIOB   DC    10F'0'              STANDARD 32 BYTE IOB PLUS 8 BYTE
*                                  S/M PREFIX
MODIOBL  EQU   *-MODIOB            L'PREFIXED IOB
         ORG   MODIOB+36           (IOBINCAM-IERIOB)
         DC    H'-1'               SET TAPE BLOCK COUNT VALUE
         ORG
*
K1       DC    H'1'                ONE
*
*        DCB MODELS USED TO GENERATE ALL REQUIRED DCBS
*
SORTOUT  DCB   MACRF=(PL),DSORG=PS,DDNAME=SORTOUT
*
SORTOUTL EQU   *-SORTOUT           L'SORTOUT DCB
*
SORTWK   DCB   MACRF=(E),DSORG=PS,DDNAME=SORTWK,REPOS=Y
*
         DC    F'0'                AREA APPENDED TO EXCP DCB
*                                  REFERENCED AS DCBOPTCD
*
SORTWKL  EQU   *-SORTWK            L'SORTWK DCB
*
*        OPEN LIST DSECT
*
OPENLST  DSECT
*
         DC    4F'0'               O   L
IERAP3A  DC    19F'0'               P   I
WRDOPT   DC    F'0'                  E   S
         DC    8F'0'                  N   T
*
*        MODULE NAME - IERAMC
*
*        MODULE CONTAINS ALL OF THE MESSAGES THAT ARE
*        REQUIRED FOR PHASE 3 ASSIGNMENT MODULES
*
DIERAMC  DSECT
*
         COPY  AMCMAIN
*
*        DCB DSECT
*
         PRINT NOGEN
*
         DCBD  DSORG=PS,DEVD=(TA)
*
         PRINT GEN
*
*        IERIOB
*
         IERIOB
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERAPL   0101-20211-20211-1200-00610-00610-00000-RELEASE 00
APL      TITLE 'IERAPL - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERAPL
*
*        MODULE FUNCTION/OPERATION -
*        LAYOUT CALCULATIONS FOR PHASE 1 AND PHASE 2 OF THE
*        OSCILLATING AND CRCX SORTS.
*        FUNCTION IS TO OBTAIN STORAGE SPACE FOR BUFFERS,
*        RSA, AND GENERATED STORAGE USING THE GETMAIN MACRO
*        INSTRUCTION AND TO PLACE THE ADDRESSES OF THESE AREAS IN
*        PPI AND/OR GENERATED STORAGE IN CASE OF VBS INPUT A
*        WORKAREA EQUAL IN LENGTH TO THE MAXIMUM RECORD LENGTH
*        WILL BE ALLOCATED
*        THE MODULE WILL ALLOCATE 1 OR 2 SORT PHASE INPUT
*        BUFFERS, 1 OR 2 OUTPUT BUFFERS, BETWEEN M AND 2M MERGE
*        PHASE INPUT BUFFERS, AND GENERATED STORAGE. RSA OCCUPIES
*        THE SAME SPACE AS MERGE PHASE INPUT BUFFERS. ADDITIONAL
*        SPACE WILL BE ALLOCATED FOR RSA IF AVAILABLE. THE
*        NUMBER OF BUFFERS ALLOCATED IS DETERMINED BY THE AMOUNT
*        OF SPACE THAT CAN BE OBTAINED BUT WILL NEVER EXCEED THE
*        MAXIMUM SPECIFIED BY B&G. B&G CALCULATIONS ARE BASED ON
*        THE AVAILABLE STORAGE VALUE
*
*        USED AS A DSECT IN - N/A
*
*        MACROS USED - SMPPI GETMAIN
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                       CALLING SEQUENCE -
*                           L    R15,ASSG
*                           BALR R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPILAB03   PPIBUF1    PPIX12
*        PPILAB07   PPIBUF23   PPIBINSZ
*        PPILAB09   PPICNTL    PPIMRGMX
*        PPITAVLC   PPIX11     PPIP1GC
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPILAB02   PPILAB10
*        PPILAB04   PPIGETMN
*        PPILAB05   PPIGETSZ
*        PPILAB06   PPICNTL
*        PPILAB98   PPISPGN1
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL -
*        RETURN TO LOAD MODULE - BR R14
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS -
*        THIS MODULE BUILDS 5 TABLES IN GENERATED STORAGE -
*        1. SORT, PHASE INPUT BUFFER ADDR TABLE
*        2. MERGE PHASE INPUT BUFFER ADDR TABLE
*        3. TABLE OF GETMAIN ADDRS
*        4. TABLE OF GETMAIN SIZES
*        5. TABLE OF ADDRS AND SIZES OF PIECES OF RSA
*
*        NOTES - THIS IS AN OSCILLATING AND CRCX MODULE
*
IERAPL   CSECT
*
         USING *,R11
         USING IERRCA,R13
*
         LR    R11,R15             SET BASE REG
         ST    R14,WREGSV          SAVE RETURN ADDR
         PPISETON PPIPH1           SET SORT PHASE INDICATOR
         PPITEST  PPIME11          E11 ACTIVE ?
         BZ    APL010              NO, BRANCH
         L     R15,PPIX11+4        YES, R15 -> USER EXIT
         BASR  R14,R15             CALL USER EXIT
APL010   PPITEST  PPIME21          E21 ACTIVE ?
         BZ    APL020              NO, BRANCH
         L     R15,PPIX21+4        YES, EXIT TO USER
         BASR  R14,R15             CALL USER EXIT
*
*        SET UP ALL POINTERS AND CONSTANTS NEEDED
*
APL020   L     R4,PPITAVLC         R4  = MAX AMT STORAGE TO BE USED FOR
*                                        BUFFERS, GEN STORAGE, RSA
         LA    R6,TRSA             R6 -> RSA TABLE
         LA    R7,TGMAD            R7 -> GETMAIN TABLE OF ADDR
         LA    R8,TGMSZ            R8 -> GETMAIN TABLE OF SIZES
         LA    R9,TP1BF            R9 -> INPUT BUFFER TABLE OF
*                                        ADDR (SORT PH)
         LA    R10,TP2BF           R10 -> INPUT BUFFER TABLE OF
*                                         ADDRS (MERGE PH)
         LH    R1,PPILAB07+2       R1 = SORTWKXX BUFFER SIZE
*
*        THE TEST BELOW WAS CODED TO SUBTRACT 8 BYTES FROM THE
*        BUFFER SIZE FOR CRCX SORTS. THIS IS INCORRECT AS EACH
*        CRCX BUFFER HAS A 20(FIXED) OR 24(VARIABLE) BYTE
*        OVERHEAD. REDUCING THE CRCX BUFFER BY 8 BYTES WILL
*        RESULT IN AN 0C4 IN SOME CONDITIONS
*
*        NOW THE 8 BYTES ARE ONLY SUBTRACTED IN AN OSC (TAPE) SORT
*
*
         PPITEST  PPI2314          CRCX TECHNIQUE ?
         BO    APL025              YES, BRANCH
         SH    R1,KH8              YES, SUBTRACT 8 FOR OSC SORT
*                                  INPUT BUFFER SIZE
         STH   R1,PPILAB07+2       ADJUST SORKWK BUFFER SIZE
APL025   SR    R1,R1
         IC    R1,PPIBUF23         R1 = NO OF PHASE 2 BUFFERS
         SR    R2,R2
         IC    R2,PPILAB09         R2 = NO OF PHASE 2 OUTPUT BUFFERS
         SR    R1,R2               SUBTRACT BUFFER COUNTS
         STH   R1,KNOIBP2          SET MAX NO INPUT BUFFERS FOR MERGE
         LH    R1,PPIMRGMX         CALC MAX NO RSA ENTRIES
         LR    R2,R1               M + M/2 + 2
         LA    R2,1(,R2)
         SRL   R2,1
         AR    R1,R2
         LA    R1,2(,R1)
         STH   R1,KMAXRSA          SET MAX NO OF RSA PIECES
*
*----------------------------------------------------------------------
*
*        GETMAIN MINIMUM STORAGE SPACE REQUIRED FOR SORT -
*        A. GENERATED STORAGE
*        B. 1 INPUT BUFFER (SORTIN)
*        C. 1 OUTPUT BUFFER (SORTWK)
*
*----------------------------------------------------------------------
*
         L     R0,PPIP1GC          R0 = GEN STORAGE SIZE
*
         GETMAIN R,LV=(0)          UNCONDITIONAL GETMAIN
*
         L     R0,PPIP1GC          REFRESH GEN STORAGE SIZE
*
         BAS   R14,APLSUB2         UPDATE TABLES AND AVAILABLE STORAGE
         AR    R1,R0               R1 -> STORAGE AREA
         ST    R1,PPISPGN1         SET PPISPGN1 TO TOP OF STORAGE AREA
*
*        OBTAIN STORAGE FOR SORTIN INPUT BUFFER POOL
*        CONTAINING 1 BUFFER
*
         LH    R0,PPILAB03+2       R0 = SORTIN BUFFER SIZE
         AH    R0,KH8              ADD 8 FOR BUFFER CONTROL BLOCK
*
         GETMAIN R,LV=(0)
*
         LH    R0,PPILAB03+2       REFRESH SORTIN BUFFER SIZE
         AH    R0,KH8              ADD 8 FOR CONTROL BUFFER
         BAS   R14,APLSUB2         UPDATE TABLES AND AVAILABLE STORAGE
         ST    R1,PPILAB06         SET ADDR OF CONTROL BUFFER FOR POOL
         ST    R1,0(,R9)           SAVE BUFF ADDR IN PH1 ADDR TABLE
         LA    R9,4(,R9)           INC TO NEXT SLOT IN TABLE
         MVI   PPILAB03,X'01'      SET NO INPUT BUFFERS TO 1
*
*        OBTAIN STORAGE FOR ONE OUTPUT BUFFER
*
         LH    R0,PPILAB07+2       R0 = SORTWK BUFFER SIZE
*
         GETMAIN R,LV=(0)
*
         LH    R0,PPILAB07+2       REFRESH SORTWK BUFFER SIZE
         BAS   R14,APLSUB2         UPDATE TABLES AND AVAILABLE STORAGE
         PPITEST  PPI2314          CRCX TECHNIQUE ?
         BZ    APL027              OSCILLATING, BRANCH
         LA    R1,8(,R1)           BYPASS FIRST EIGHT BYTES FOR CRCX
APL027   ST    R1,PPILAB04         STORE FIRST BUFFER ADDR
         MVI   PPILAB07,X'01'      SET NO BUFFERS TO 1
         PPITEST  PPIMVSI          VBS INPUT ?
         BZ    APL030              NO, BRANCH
*
*        VBS INPUT - OBTAIN SPACE FOR WORKAREA
*
         LH    R0,PPIRCDL1         R0 = MAX INPUT RECORD LENGTH
*
         GETMAIN R,LV=(0)
*
         LH    R0,PPIRCDL1         REFRESH MAX INPUT RECORD LENGTH
         BAS   R14,APLSUB2         UPDATE GETMAIN TABLE
*
*----------------------------------------------------------------------
*
*        OBTAIN STORAGE FOR M INPUT BUFFERS FOR MERGE PORTION OF PHASE
*        THIS SPACE WILL ALSO SERVE AS RSA SPACE WHEN THE SORT
*        PORTION IS BEING EXECUTED
*
*----------------------------------------------------------------------
*
*        BEGIN BUFFER GETMAIN LOOP
*
APL030   LH    R0,PPILAB07+2       R0 = SORTWK BUFFER SIZE
*
         GETMAIN R,LV=(0)          UNCONDITIONAL GETMAIN
*
         LH    R0,PPILAB07+2       REFRESH SORTWK BUFFER SIZE
         BAS   R14,APLSUB2         UPDATE TABLES AND AVAILABLE STORAGE
         ST    R1,0(,R6)           SET ADDR AND SIZE IN RSA TABLE
         ST    R0,4(,R6)
         LA    R6,8(,R6)
         ST    R1,0(,R10)          SAVE ADDR IN INPUT BUFFER TABLE PH2
         LA    R10,4(,R10)
         SR    R1,R1
         IC    R1,PPILAB08         UPDATE THE NUMBER OF ENTRIES IN
         LA    R1,1(,R1)           RSA TABLE
         STC   R1,PPILAB08
         IC    R1,PPILAB10         INCR NO OF BUFFERS OBTAINED
         LA    R1,1(,R1)
         STC   R1,PPILAB10
         CH    R1,PPIMRGMX         NO OF BUFFERS = M ?
         BL    APL030              NO, LOOP TO GETMAIN ANOTHER BUFFER
*
*----------------------------------------------------------------------
*
*        MINIMUM STORAGE REQUIREMENTS HAVE BEEN OBTAINED
*
*        TRY TO OBTAIN ADDITIONAL SPACE FOR BUFFERS AND RSA NOT
*        EXCEEDING THE MAXIMUM REQUIREMENTS SET BY B&G
*
*----------------------------------------------------------------------
*
*        ADDITIONAL SORT BUFFERS DESIRABLE ACCORDING TO B&G ?
*
         CLI   PPIBUF1+3,X'02'
         BNH   APL300              NO ADDITIONAL BUFFERS NEEDED
*
*        OBTAIN SPACE FOR THE SMALLER BUFFER FIRST
*
         CLC   PPILAB07+2(2),PPILAB03+2   L'SORTWK BUF VS L'SORTIN BUF
         BNH   APL290              GET OUTPUT BUFFER FIRST
         BAS   R3,APL260           GET SORTIN INPUT BUFFER FIRST
         CLI   PPIBUF1+3,X'03'
         BNH   APL300              NO MORE BUFFERS
         BAS   R3,APL240           GET ADDITIONAL SORTWK OUTPUT BUFFER
*
*        MORE THAN M INPUT BUFFERS DESIRABLE FOR THE MERGE PORTION ?
*
APL100   SR    R5,R5               SET CURRENT CHUNK SIZE = 0
APL105   CLC   PPILAB10(1),KNOIBP2+1  NEED MORE BUFFERS ?
         BNL   APL120              NO, BRANCH
*
*        OBTAIN SPACE FOR ADDITIONAL SORTWK MERGE BUFFERS
*
         SH    R5,PPILAB07+2       REDUCE CHUNK SIZE BY BUFFER SIZE
         BL    APL280              CURRENT CHUNK TOO SMALL GET MORE COR
APL110   ST    R3,0(,R10)          ASSIGN ANOTHER BUFFER
         LA    R10,4(,R10)         SAVE ADDR IN BUFFER TABLE
         AH    R3,PPILAB07+2
         SR    R1,R1
         IC    R1,PPILAB10         INCR NO OF BUFFERS
         LA    R1,1(,R1)
         STC   R1,PPILAB10
         B     APL105              CHECK BUFFER NEEDS
*
*        ACCESS ADDITIONAL STORAGE SPACE FOR RSA
*
APL120   CLC   PPILAB08(1),KMAXRSA+1  MORE ROOM IN RSA TABLE ?
         BNL   APL130              NO, BRANCH
         MVC   KMINL,PPIBINSZ
         C     R4,KMINL            AVAIL STORAGE = BIN SIZE ?
         BL    APL130              NO, LESS
         ST    R4,KMAXL
*
         GETMAIN VC,LA=KMINL,A=KADDRS
*
         LTR   R15,R15             REQUEST SUCCESSFUL ?
         BNZ   APL140              NO, BRANCH
         BAS   R14,APLSUB1         UPDATE TABLES AND AVAILABLE STORAGE
         MVC   0(4,R6),KADDRS      ENTER STORAGE AREA IN RSA TABLE
         MVC   4(4,R6),KSIZE
         LA    R6,8(,R6)
         SR    R1,R1
         IC    R1,PPILAB08         INCR NO OF RSA PIECES
         LA    R1,1(,R1)
         STC   R1,PPILAB08
         B     APL120              TRY FOR MORE RSA
*
*----------------------------------------------------------------------
*
*        ALL STORAGE AREAS HAVE NOW BEEN ALLOCATED
*        SET UP TABLES AND ADDRS IN GENERATED STORAGE AND PPI
*        PRINT DIAGNOSTIC MESSAGES
*
*----------------------------------------------------------------------
*
APL130   PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTICS ?
         BZ    APL140              NO, BRANCH
         L     R0,PPISPGN1         R0 -> NEXT AVAIL ADDR IN GEN STORAGE
         L     R15,PPICONV+4
         BAS   R14,4(,R15)         CALL CONVERT RTN
         USING IERAMA,R10
         L     R10,PPIAMA+4
         MVC   IER910A,2(1)        MOVE FORMATTED ADDR INTO MSG
         LM    R0,R1,IER910        IER910I GENERATED STORAGE END ADDR
         L     R15,PPIADSSC
         BAS   R14,12(,R15)        CALL PRINT MSG RTN
*
*        MOVE GETMAIN ADDRESSES AND SIZE TABLES INTO THE PPI
*
APL140   SR    R1,R1
         IC    R1,PPILAB03         R1 = NO OF SORTIN BUFFERS
         SLL   R1,2                MULT BY 4
         BCTR  R1,0                (FOR MVC INSTRUCTION)
         STC   R1,APL150+1         STORE IN MVC INSTRUCTION
         L     R4,PPISPGN1         R4 -> TOP OF GENERATED STORAGE
         LA    R1,1(,R1)           RESET TABLE SIZE
         SR    R4,R1               CALCULATE STARTING ADDR
         ST    R4,PPILAB02         SAVE ADDR OF SORTIN BUFFER ADDRS
APL150   MVC   0(1,R4),TP1BF       MOVE TABLE INTO GENERATED STORAGE
         IC    R1,PPILAB10         R1 = NO OF SORKWKXX BUFFERS
         SLL   R1,2                MULT BY 4
         BCTR  R1,0                (FOR MVC INSTRUCTION)
         STC   R1,APL160+1         STORE IN MVC INSTRUCTION
         LA    R1,1(,R1)           RESET TABLE SIZE
         SR    R4,R1               CALCULATE STARTING ADDR
         STCM  R4,B'0111',PPILAB10+1   PPILAB10 -> SORTWK BUFFER TABLE
APL160   MVC   0(1,R4),TP2BF       MOVE TABLE INTO GENERATED STORAGE
*
*        SETUP RSA TABLE
*
         PPITEST  PPIVAR           VARIABLE LENGTH RECORDS ?
         BO    APL167              VARIABLE, BRANCH
         LA    R2,TRSA             FIXED, CHECK BINSIZE VS BFR SIZE
         IC    R1,PPILAB08         NUMBER OF RSA ENTRIES IN TRSA
         SR    R7,R7
         SH    R4,KH8
APL163   L     R5,4(,R2)           GET SIZE OF THIS ENTRY
         CL    R5,PPIBINSZ         SIZE < BINSIZE ?
         BL    APL165              YES, DON'T MOVE IT TO GEN STORAGE
         MVC   0(8,R4),0(R2)       NO, PUT ENTRY IN GEN STOR RSA TABLE
         LA    R7,1(,R7)           UP ENTRIES MOVED BY ONE
         SH    R4,KH8              UPDATE GEN STORAGE FOR THIS MOVE
APL165   LA    R2,8(,R2)           POINT TO NEXT TRSA ENTRY
         BCT   R1,APL163           CONTINUE WITH ENTRYS TILL DONE
         LA    R4,8(,R4)           RESET GEN STORAGE ADDR
         ST    R4,PPILAB08         SET RSA TABLE ADDR
         STC   R7,PPILAB08         SET NUMBER OF TABLE ENTRIES
         B     APL172              BYPASS RSA TAB RESET
*
APL167   IC    R1,PPILAB08
         SLL   R1,3                MOVE TABLE OF RSA ADDRS
         BCTR  R1,0                (FOR MVC INSTRUCTION)
         STC   R1,APL170+1         INTO GENERATED STORAGE
         LA    R1,1(,R1)           RESET TABLE SIZE
         SR    R4,R1
         ST    R4,PPILAB08
         SRL   R1,3
         STC   R1,PPILAB08
APL170   MVC   0(1,R4),TRSA
APL172   IC    R1,PPIGETMN
         SLL   R1,2                MOVE GETMAIN TABLE OF ADDR
         BCTR  R1,0                (FOR MVC INSTRUCTION)
         STC   R1,APL180+1         INTO GENERATED STORAGE
         LA    R1,1(,R1)           RESET TABLE SIZE
         SR    R4,R1
         SH    R4,KH4
         ST    R4,PPIGETMN
         SRL   R1,2
         STC   R1,PPIGETMN
APL180   MVC   0(1,R4),TGMAD
         IC    R1,PPIGETSZ
         SLL   R1,2
         BCTR  R1,0                (FOR MVC INSTRUCTION)
         STC   R1,APL190+1
         LA    R1,1(,R1)           RESET TABLE SIZE
         SR    R4,R1
         SH    R4,KH4
         ST    R4,PPISPGN1
         ST    R4,PPIGETSZ
         SRL   R1,2
         STC   R1,PPIGETSZ
APL190   MVC   0(1,R4),TGMSZ
*
*        SET BIT TO INDICATE END OF GETMAIN TABLES
*
         IC    R1,PPIGETMN         GET COUNT OF NO OF ENTRIES
         SLL   R1,2                MULT BY 4
         SH    R1,KH4              OFFSET TO LAST ENTRY
         L     R2,PPIGETSZ         R2 -> TABLE OF GETMAIN SIZES
         AR    R2,R1               R2 -> LAST ENTRY
         MVI   0(R2),X'80'
         PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTICS ?
         BZ    APL200              NO, BRANCH
*
*----------------------------------------------------------------------
*
*        GENERATE DIAGNOSTICS MESSAGES
*
*----------------------------------------------------------------------
*
         L     R0,PPILAB02         R0 -> INPUT BUFFER TABLE
         L     R15,PPICONV+4
         BAS   R14,4(,R15)         CALL CONVERSION RTN
         L     R10,PPIAMA+4
         MVC   IER901A,2(R1)       MOVE FORMATTED ADDR INTO MSG
         LM    R0,R1,IER901        IER901I INPUT BUFFER TABLE ADDR
         L     R15,PPIADSSC
         BAS   R14,12(,R15)        CALL PRINT MSG RTN
         SR    R0,R0
         ICM   R0,B'0111',PPILAB10+1
         L     R15,PPICONV+4
         BAS   R14,4(,R15)         CALL CONVERSION RTN
         MVC   IER921A,2(R1)       MOVE FORMATTED ADDR INTO MSG
         LM    R0,R1,IER921        IER921I INPUT BUFFFR TABLE ADDR
*                                  FOR MERGE PHASE
         L     R15,PPIADSSC
         BAS   R14,12(,R15)        CALL PRINT MSG RTN
         SR    R0,R0
         ICM   R0,B'0111',PPILAB08+1
         L     R15,PPICONV+4
         BAS   R14,4(,R15)         CALL CONVERSION RTN
         MVC   IER903A,2(R1)       MOVE FORMATTED ADDR INTO MSG
         LM    R0,R1,IER903        IER903I RSA TABLE ADDR
         L     R15,PPIADSSC
         BAS   R14,12(,R15)        CALL PRINT MSG RTN
*
*----------------------------------------------------------------------
*
*        DETERMINE AND SET G IN PPISRTG
*        SUM UP THE NUMBER OF BINS IN EACH PIECE OF RSA
*
*----------------------------------------------------------------------
*
APL200   PPITEST  PPIVAR           VARIABLE LENGTH RECORDS ?
         BO    APL220              VARIABLE, BRANCH
         SR    R1,R1               FIXED, CALCULATE G
         SR    R2,R2
         IC    R1,PPILAB08         NO RSA ENTRIES
         L     R6,PPILAB08
         L     R7,PPIBINSZ
APL210   L     R5,4(,R6)           ACCESS SIZE OF RSA PIECE
         SR    R4,R4
         DR    R4,R7               DIVIDE BY BIN SIZE
         AR    R2,R5               ACCUMULATE NUMBER OF BINS
         LA    R6,8(,R6)
         BCT   R1,APL210           DO NEXT ENTRY
         BCTR  R2,0                NEED G+1 BINS
         C     R2,PPISRTG          NEW G SMALLER ?
         BNL   APL220              KEEP OLD G
         ST    R2,PPISRTG
APL220   L     R14,WREGSV
         BR    R14                 RETURN TO CALLER
*
*----------------------------------------------------------------------
*
*        ISSUE GETMAIN TO OBTAIN STORAGE FOR A SECOND SORTWK BUFFER
*
*----------------------------------------------------------------------
*
APL240   CH    R4,PPILAB07+2       AMOUNT OF AVAIL STORAGE PERMIT ?
         BL    APL120              NO, TOO SMALL
         MVC   KSIZE+2(2),PPILAB07+2   YES, SET UP GETMAIN PARAMETERS
         MVC   APL250+6(2),PPILAB07+2
*
APL250   GETMAIN EC,LV=80,A=KADDRS
*
         LTR   R15,R15             GETMAIN SUCCESSFUL ?
         BNZ   APL255              NO, STORAGE NOT AVAILABLE
         BAS   R14,APLSUB1         UPDATE TABLES AND AVAILABLE STORAGE
         L     R2,KADDRS           R2 -> GETMAINED STORAGE
         PPITEST  PPI2314          CRCX TECHNIQUE ?
         BZ    APL252              NO, OSCILLATING
         LA    R2,8(,R2)           BYPASS FIRST EIGHT BYTES FOR CRCX
APL252   ST    R2,PPILAB05         STORE SECOND BUFFER ADDR IN PPI
         MVI   PPILAB07,X'02'      SET NO OF OUTPUT BUFFERS = 2
         MVI   PPILAB04,X'80'      SET SECOND BUFFER GETMAINED SWITCH
         BR    R3                  RETURN TO MAINLINE
*
APL255   SH    R4,PPILAB07+2       REDUCE AVAILABLE STORAGE IN CASE
         B     APL120              BUFFER IS OBTAINED LATER
*
*----------------------------------------------------------------------
*
*        ISSUE GETMAIN TO OBTAIN STORAGE FOR SECOND SORTIN BUFFER
*
*----------------------------------------------------------------------
*
APL260   CH    R4,PPILAB03+2       STORAGE SIZE PERMIT SECOND BUFFER ?
         BL    APL275              NO, BRANCH
         MVC   KSIZE+2(2),PPILAB03+2  YES, SET UP GETMAIN PARAMETERS
         MVC   APL270+6(2),PPILAB03+2      MOVE SIZE INTO GETMAIN PARM
*
APL270   GETMAIN EC,LV=80,A=KADDRS
*
         LTR   R15,R15             GETMAIN SUCCESSFUL ?
         BNZ   APL275              NO, STORAGE NOT AVAILABLE
         BAS   R14,APLSUB1         UPDATE TABLES AND AVAILABLE STORAGE
         MVI   PPILAB03,2          SET NO BUFFERS = 2
         L     R2,KADDRS
         ST    R2,0(,R9)           SAVE ADDR IN BUFFER TABLE
         LA    R9,4(,R9)
         BR    R3                  RETURN TO MAINLINE
*
APL275   CLI   PPIBUF1+3,X'03'     SHOULD THERE BE 2 OUTPUT BUFFERS ?
         BH    APL100              YES, BRANCH
         OI    PPILAB04,X'80'      SET SW = DO NOT GET 2ND OUTPUT BUFF
         B     APL100              CHECK INPUT BUFFERS
*
*----------------------------------------------------------------------
*
*        ISSUE GETMAIN TO ACCESS SPACE FOR MORE MERGE INPUT BUFFERS
*
*----------------------------------------------------------------------
*
APL280   CH    R4,PPILAB07+2       STORAGE PERMIT MORE BUFFERS ?
         BL    APL120              NO, BRANCH
         MVC   KMINL+2(2),PPILAB07+2   YES, SET UP PARMS AND GETMAIN
         ST    R4,KMAXL            MORE STORAGE
*
         GETMAIN VC,LA=KMINL,A=KADDRS
*
         LTR   R15,R15             GETMAIN SUCCESSFUL ?
         BNZ   APL120              NO, STORAGE NOT AVAILABLE
         BAS   R14,APLSUB1         UPDATE TABLES AND AVAILABLE STORAGE
         L     R5,KSIZE            SET CURRENT CHUNK SIZE AND ADDR
         L     R3,KADDRS
         ST    R3,0(,R6)           SAVE IN RSA TABLE
         ST    R5,4(,R6)
         LA    R6,8(,R6)
         SR    R1,R1               INCR NUMBER OF RSA ENTRIES
         IC    R1,PPILAB08
         LA    R1,1(,R1)
         STC   R1,PPILAB08
         SH    R5,PPILAB07+2
         B     APL110              ALLOCATE EXTRA BUFFERS
*
APL290   BAS   R3,APL240           GET OUTPUT BUFFER
         CLI   PPIBUF1+3,X'03'
         BNH   APL100              NO MORE SORT BUFFERS
         BAS   R3,APL260           GET ADDITIONAL INPUT BUFFER
         B     APL100              CHECK INPUT BFR NEED
*
APL300   OI    PPILAB04,X'80'      SET NO SECOND BUFFER SWITCH
         B     APL100              CHECK INPUT BUFFER NEED
*
*----------------------------------------------------------------------
*
*        APLSUB1/APLSUB2
*
*----------------------------------------------------------------------
*
*        STORE THE ADDRESS AND SIZE OF ALL STORAGE OBTAINED IN
*        THE GETMAIN TABLE OF ADDRESSES AND GETMAIN TABLE OF
*        SIZES RESPECTIVELY
*        KEEP TRACK OF THE MAXIMUM AMOUNT OF STORAGE WHICH THE
*        SORT IS ALLOWED TO USE AND DECREMENTS IT EACH TIME
*        STORAGE IS OBTAINED
*        STORAGE AREA OBTAINED -> R1 OR KADDRS
*        STORAGE AREA OBTAINED LEN = R0 OR KSIZE
*
APLSUB1  MVI   KSIZE,X'00'         ENTRY POINT WHEN DATA IS IN
         L     R0,KSIZE            KADDRS AND KSIZE
         L     R1,KADDRS
*
APLSUB2  ST    R1,0(,R7)           STORE ADDR
*                                  INTO GETMAIN TABLE OF ADDR
         LA    R7,4(,R7)           INCR PTR
         ST    R0,0(,R8)           STORE LENGTH
*                                  INTO GETMAIN TABLE OF SIZES
         LA    R8,4(,R8)           INCR PTR
         SR    R4,R0               SUBTRACT SIZE FROM MAX AVAILABLE
         SR    R2,R2
         IC    R2,PPIGETMN         INCR COUNT OF ENTRIES IN TABLE
         LA    R2,1(,R2)
         STC   R2,PPIGETMN         STORE IN HI-ORDER BYTE OF TABLE PTR
         STC   R2,PPIGETSZ
         BR    R14                 RETURN TO CALLER
*
*        ORDER OF THE FOLLOWING 4 VARIABLES MUST BE MAINTAINED
*
KADDRS   DC    A(0)             *  PARAMETERS
KSIZE    DC    A(0)             |  FOR
KMINL    DC    A(0)             |  GETMAIN MACRO
KMAXL    DC    A(0)             V  INSTRUCTIONS
*
KMAXRSA  DC    H'0'                MAX NO OF RSA PIECES
KNOIBP2  DC    H'0'                MAX NO INPUT BUFFERS FOR MERGE
*
KH4      DC    H'4'
KH8      DC    H'8'
*
*        TABLES
*
TRSA     DC    26D'0'              RSA TABLE ADDR AND SIZE OF EACH
*                                  PIECE OF RSA
TGMAD    DC    40F'0'              GETMAIN TABLE OF ADDRS
TGMSZ    DC    40F'0'              GETMAIN TABLE OF SIZES
TP1BF    DC    2F'0'               PH1 TABLE OF INPUT BUFFER ADDRS
TP2BF    DC    32F'0'              PH3 TABLE OF INPUT BUFFER ADDRS
*
*        WORK AREAS
*
WREGSV   DC    F'0'                REGISTER SAVE AREA
*
*        IERAMA
*
IERAMA   DSECT
*
         COPY  AMAMAIN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERAPN   0101-20211-20211-1200-00233-00233-00000-RELEASE 00
APN      TITLE 'IERAPN - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERAPN - NOT SUPPORTED - 2301
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 1 ASSIGNMENT MODULE - DRUM OPERATION
*        THE FUNCTION OF THIS MODULE IS TO GENERATE CHANNEL
*        COMMAND WORDS FOR WRITING DRUM. IT ALSO INITIALIZES THE
*        O/P BUFFERS
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACROS USED BY MODULE -
*        SMPPI
*
*        ENTRY POINTS - ENTRY FROM
*                       CALLING SEQUENCE -
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPISTIOB   PPILAB07   PPILAB04
*        PPILAB05   PPIFIL5Z   PPISRTBL
*        ADDRESSES OF O/P BUFFERS ARE USED FOR INITIALIZATION
*        FILE SIZE IS TESTED TO SEE IF USER HAS ENTERED THIS
*        PARAMETER
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPISPGN1   PPICNTL
*        GENERATED CORE IS REDUCED WHEN CREATING CCW'S THE
*        ESTIMATED SWITCH IS TURNED ON IF NO FILE SIZE IS GIVEN
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS -
*
*        EXITS - NORMAL -
*        APNEXIT - IERMDA - NEXT SEQUENTIAL MODULE
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS -
*        MODEL OF CHANNEL COMMAND WORD LIST
*
*        NOTES -
*        THIS MODULE IS RESTRICTED TO 2301 DRUM OPERATIONS ONLY
*
IERAPN   CSECT
*
         USING *,R11               PROGRAM BASE
         USING DIERRPN,R10         RUNNING PROGRAM BASE
         USING APNAP1,R12          TEMP BASE FOR DCB OPEN LIST
         USING IHADCB,R3           DCB BASE REG
         USING IERRCA,R13          PPI BASE
         USING APNAMA,R4
*
IERMPA   LR    R11,R15             SET ADDRESSABILITY
         STM   R0,R15,APNWREG      SAVE REGISTERS
         L     R10,PPIWRT+4        SET BASE FOR IERRPN
         L     R12,PPIOPEN+4       SET BASE
         L     R9,AP1WRT           GET USER MOD ADDR
         ST    R9,RPNUSERX         SET IN RUNNING PROG
         MVI   RPNUSERX,X'00'      TURN OFF OPTION
         DROP  R12
         USING IERIOB,R12
         LA    R5,8
         L     R12,PPISTIOB        SET IOB BASE REG
         SR    R12,R5              R12 -> IERIOB WITH ECB, CCW PREFIX
         MVC   RPNDBSW(1),PPILAB07 SET DBL BUFF SW IN IERRPN
         MVC   WTRKSW(1),PPILAB04  SET BUILD SW IN IERRPN
         L     R5,PPISPGN1         GET GEN CORE ADDR
         N     R5,APNMASK          ALIGN TO DBL BOUNDRY
         LA    R15,24
         SR    R5,R15
         ST    R5,HOLDPR
         ST    R5,IOBSTART
         LA    R6,IOBCC            GET CCHHR ADDR (IOB)
         ST    R6,APNIDCCW         SET IN SEARCH CCW
         ST    R6,RPNIDCCW         SET IN DIR CCW
         MVI   RPNIDCCW,SEARIDEQ
         MVI   APNIDCCW,SEARIDEQ   SET OP CODE
         LA    R6,PPIWKARE         GET DIR BUFFER ADDR
         ST    R6,RPNCCW2          SET DIR BUFF ADDR
         MVI   RPNCCW2,WRITECKD
         L     R6,PPILAB04         GET FIRST BUFFER ADDR
         LA    R7,RPNBUF1
         LA    R9,8
         LA    R8,2                SET LOOP COUNTER
APNCHNLP SR    R6,R9               CALC BUFFER WRITE ADDR
         ST    R6,APNCCW2          SET BUFFER ADDR IN CCW
         PPITEST  PPIVAR           VARIABLE LENGTH RECORDS ?
         BO    APNVAR              YES, BRANCH
         LA    R6,12(,R6)          SET FIXED BUFFER ADDR
         B     APNSETBF            GO AND STORE BUFFER ADDR
*
APNVAR   LA    R6,16(,R6)          SET VARIABLE BUFFER ADDR
APNSETBF ST    R6,0(,R7)           SET ADDR IN IERRPN
         MVI   APNCCW2,WRITECKD    SET OP CODE
         LH    R7,PPISRTBL         GET BLOCKING FACTOR
         LA    R7,8(,R7)           CALC DATA LENGTH
         STH   R7,APNBYTES         SET CCW DATA LENGTH
         ST    R5,APNCTCCW         SET TIC CCW
         MVI   APNCTCCW,TIC        SET OP CODE
         MVC   0(24,R5),APNIDCCW   PUT CHAN PROG IN GEN CORE
         BCT   R8,APNNXTBF         SECOND BUFFER ALLOCATION ?
         B     APNGENSV            BRANCH IF TWO CCW'S MADE
*
APNNXTBF L     R6,PPILAB05         LOAD ADDR OF NEXT BUFFER
         LA    R7,RPNBUF2
         SR    R5,R15
         ST    R5,IERALTCW         SET ALT CCW IN IOB
         B     APNCHNLP            GOTO CREATE SECOND BUFFER
*
APNGENSV ST    R5,PPISPGN1         SET NEW GEN CORE ADDR
         LH    R8,PPINDSKA         NUMBER OF AREAS
         BCTR  R8,0                OPEN (N-1) UNITS
         SR    R5,R5               CLEAR REGS
         SR    R7,R7
         LA    R6,PPISTAR+1        GET PPISTAR POINTER
APNDCB   L     R3,PPISTDCB         GET DCB POINTER
         IC    R7,PPISTAR(R5)      GET INCREMENT
         L     R3,0(R7,R3)         SET DCB BASE REG
         MVC   DCBFDAD+1(7),0(R6)  SET ADDR IN DCB
         LA    R6,8(,R6)           INCREMENT PPISTAR POINTER
         LA    R5,8(,R5)           SET FOR NEXT PPISTAR
         BCT   R8,APNDCB           LIST END ?
         L     R7,PPIFILSZ         GET USER COUNT
         LTR   R7,R7               ZERO ?
         BZ    APNESTM             YES, BRANCH
*
*        DIAGNOSTC MESSAGES
*
BUFRMSGE PPITEST  PPIDIAG          DIAGNOSTCS ?
         BZ    APNENDAG            NO, BRANCH
         L     R4,PPIAMA+4         LOAD MESSAGE MODULE BASE REGISTER
         L     R0,PPILAB04         LOAD ADDR OF BUFFER1
         L     R15,PPICONV+4       LOAD ADDR OF CONVERT ROUTINE
         BAS   R14,4(,R15)         CALL CONVERT ROUTNE
         MVC   IER902A,2(R1)       MOVE FORMATTED ADDR INTO MSG
         L     R0,PPILAB05         LOAD ADDR OF BUFFER2
         L     R15,PPICONV+4       LOAD ADDR OF CONVERT ROUTINE
         BAS   R14,4(,R15)         CALL CONVERT ROUTINE
         MVC   IER902B,2(R1)
         LM    R0,R1,IER902        IER902I OUTPUT BUFFER ADDR
         L     R15,PPIADSSC        LOAD ADDR OF PRINT MSG RTN
         BAS   R14,12(,R15)        CALL PRINT MSG RTN
*
*        CCW ADDRESS
*
         L     R0,IOBSTART         LOAD ADDR OF CCW
         L     R15,PPICONV+4       ADDR OF CONVERT ROUTINE
         BAS   R14,4(,R15)         CALL CONVERT ROUTINE
         MVC   IER907A,2(R1)       MOVE CONVERTED DATA TO MSG AREA
         LM    R0,R1,IER907        IER907I OUTPUT CCW ADDR
         L     R15,PPIADSSC        LOAD ADDR OF MSG PRINT RTN
         BAS   R14,12(0,R15)       CALL MSG PRINT RTN
*
*        IOB ADDR
*
         L     R0,PPISTIOB         LOAD ADDR OF IOB
         L     R15,PPICONV+4       ADDR OF CONVERT ROUTINE
         BAS   R14,4(,R15)         CALL CONVERT RTN
         MVC   IER908A,2(R1)       MOVE FORMATTED ADDR INTO MSG
         LM    R0,R1,IER908        IER908I OUTPUT IOB ADDR
         L     R15,PPIADSSC        LOAD ADDR OF MSG RTN
         BAS   R14,12(,R15)        CALL PRINT MSG RTN
APNENDAG LM    R0,R15,APNWREG      RESTORE REGS
         BR    R14                 EXIT FROM MODULE
*
APNESTM  PPISETON PPIFSZE          TURN ON ESTIMATED BIT
         B     BUFRMSGE            GOTO TEST IF MESSAGES IS REQUESTED
*
*        CONSTANTS
*
APNIDCCW CCW   0,0,CC+SLI,05       START OF WRITE CCW
APNCTCCW CCW   0,0,CC+SLI,0        TIC CCW
APNCCW2  CCW   0,0,SLI,0           WRITE CCW
         ORG   APNCCW2+6
APNBYTES DC    X'0000'
         ORG   ,
APNWREG  DC    11F'0'              SAVEAREA FOR REGISTERS
APNWR11  DC    5F'0'               SAVEAREA FOR REGISTERS
APNMASK  DC    X'FFFF'             MASK FOR ALIGNMENT TO
         DC    X'FFF8'
APNWK    DC    X'00'
*
*        AMAMAIN
*
APNAMA   DSECT
*
         COPY  AMAMAIN
*
*        WRITE OPTION MODULE
*
APNAP1   DSECT
         DC    19F'0'              DCB ADDR
AP1RD2   DC    F'0'
AP1WRT   DC    X'20000000'
         DC    10F'0'              USER SYNAD - WRITE PH1, PH2
*
*        IERRPN
*
DIERRPN  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRPN SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRPNI
*
         PRINT NOGEN
*
         DCBD  DSORG=(PS)
*
         PRINT GEN
*
*        CCW EQUATES
*
         IERCCWEQ
*
*        IOB
*
         IERIOB
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERAPO   0101-20211-20211-1200-00227-00227-00000-RELEASE 00
APO      TITLE 'IERAPO - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERAPO - NOT SUPPORTED - 2301
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 2 ASSIGNMENT MODULE - DRUM OPERATION
*        THE FUNCTION OF THIS MODULE IS TO GENERATE CHANNEL
*        COMMAND WORDS FOR WRITING DRUM. IT ALSO INITIALIZES THE
*        O/P BUFFERS
*
*        MODULES IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACROS USED BY MODULE - SMPPI
*
*        ENTRY POINTS - ENTRY IERMPD
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPISTIOB   PPILAB07   PPILAB04
*        PPILAB05   PPIFIL5Z   PPISRTBL
*        ADDRESSES OF O/P BUFFERS ARE USED FOR INITIALIZING THEM
*        FILE SIZE IS TESTED TO SEE IF USER HAS ENTERED THIS
*        PARAMETER
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPISPGN1   PPICNTL
*        GENERATED CORE IS REDUCED WHEN CREATING CCW'S THE
*        ESTIMATED SWITCH IS TURNED ON IF NO FILE SIZE IS GIVEN
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL -
*        APOEXIT IERM01 - NEXT SEQUENTIAL MODULE
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS -
*        MODEL OF CHANNEL COMMAND WORD LIST
*
*        NOTES -
*        THIS MODULE IS RESTRICTED TO 2301 DRUM OPERATIONS ONLY
*
IERAPO   CSECT
*
         USING *,R11
         USING DIERRPO,R10
         USING DIERAP2,R12
         USING IERRCA,R13
         USING IHADCB,R3           DCB BASE REG
         USING IERAMB,R4
*
IERMPD   LR    11,15
         STM   R0,R15,APOWREG      SAVE REGS
         L     R10,PPIWRT+4        SET BASE
         L     R12,PPIOPEN+4       SET BASE REGISTER
         L     R9,AP2WRT           GET USER EXIT ADDR
         ST    R9,RPOUSERX         STOW IN IERRPO
         MVI   RPOUSERX,X'00'      TURN OFF OPTION
         DROP  R12
         USING IERIOB,R12          USING FOR S/M PREFIXED IOB
         L     R12,PPISTIOB        SET IOB BASE REG
         L     R12,0(,R12)
         LA    R5,8                SUBTRACT 8 TO SET IERIOB ADDR
         SR    R12,R5
         ST    R12,IOBECBPT        STORE ECB ADDR IN IOB
         MVC   WSWTRK(1),PPILAB04  SET BUILD SW IN RNG PROG
         MVC   RPODBSW(1),PPILAB07 SET DBL BUFF SW IN RNNG PROG
         L     R5,PPISPGN1         GET GEN CORE ADDR
         N     R5,APOMASK          ALIGN TO DBL WORD
         LA    R15,24
         SR    R5,R15
         ST    R5,IOBSTART         SET PRIME CCW IN IOB
         ST    R5,HOLDPCW          STORE PRIME BFR IN RPO
         LA    R6,IOBCC            GET IOB ID ADDR
         ST    R6,APOIDCCW         SET IN SEARCH CCW
         ST    R6,RPOSKID          SET IN DIR CCW
         MVI   RPOSKID,SEARIDEQ
         LA    R6,PPIWKARE         GET DIR BUFFER ADDR
         ST    R6,RPOBUFAD         SET DIR IN BUFF ADDR
         MVI   RPOBUFAD,WRITECKD
         MVI   APOIDCCW,SEARIDEQ   SET CCW OP CODE
         L     R6,PPILAB04         GET FIRST BUFFER ADDR
         LA    R7,RPOBUF1
         LA    R9,8
         LA    R8,2                SET LOOP COUNTER
APOCHNLP SR    R6,R9               CALC BUFFER WRITE ADDR
         ST    R6,APOCCW2          SET BUFFER ADDR IN CCW
         PPITEST  PPIVAR           VARIABLE LENGTH RECORDS ?
         BO    APOVAR              YES, BRANCH
         LA    R6,12(,R6)          CALC FIXED BUFFER ADDR
         B     APOSETBF
*
APOVAR   LA    R6,16(,R6)          CALC VARIABLE BUFFER ADDR
APOSETBF ST    R6,0(R7)            SET ADDR IN IERRPO
         MVI   APOCCW2,WRITECKD    SET CCW OP CODE
         LH    R7,PPISRTBL         GET BLOCKING FACTOR
         LA    R7,8(,R7)           CALC DATA LENGTH
         STH   R7,APOBYTES         SET CCW DATA LENGTH
         ST    R5,APOCTCCW         SET TIC CCW
         MVI   APOCTCCW,TIC        SET CCW OP CODE
         MVC   0(24,R5),APOIDCCW   PUT CHAN PROG IN GEN CORE
         BCT   R8,APONXTBF         TEST FOR SECOND BUFFER ALLOCATION
         B     APOGENSV            BRANCH IF TWO CCW'S MADE
*
APONXTBF L     R6,PPILAB05         LOAD ADDR OF NEXT BUFFER
         LA    R7,RPOBUF2
         SR    R5,R15
         ST    R5,IERALTCW         SET ALT CCW IN IERIOB
         B     APOCHNLP            GOTO CREATE SECOND BUFFER
*
APOGENSV ST    R5,PPISPGN1         SET NEW GEN CORE ADDR
         LH    R8,PPINDSKA         NUMBER OF AREAS
         LA    R5,0                SET DISPL REG
         SR    R7,R7
         LA    R6,PPISTAR+1        GET PPISTAR POINTER
APODCB   L     R3,PPISTDCB         GET DCB POINTER
         IC    R7,PPISTAR(R5)      GET INCREMENT
         L     R3,0(R7,R3)         SET DCB BASE REG
         MVC   DCBFDAD+1(7),0(R6)  SET ADDRESS IN DCB
         LA    R6,8(,R6)           INCREMENT PPISTAR POINTER
         LA    R5,8(,R5)           SET FOR NEXT PPISTAR
         BCT   R8,APODCB           TEST FOR LIST END
*
*        GENERATE OPTIONAL DIAGNOSTIC MESSAGES
*
*        BUFFER ADDRESS
*
         PPITEST  PPIDIAG          DIAGNOSTICS ?
         BZ    APOENDNG            NO, BRANCH
         L     R4,PPIAMB+4
         L     R0,PPILAB04         LOAD ADDR OF BUFFER1
         L     R15,PPICONV+4       LOAD ADDR OF CONVERT ROUTINE
         BAS   R14,4(,R15)         CALL CONVERT ROUTINE
         MVC   IER922A,2(R1)       MOVE CONVERTED DATA TO MSG AREA
         L     R0,PPILAB05         LOAD ADDR OF BUFFER2
         L     R15,PPICONV+4       LOAD ADDR OF CONVERT ROUTINE
         BAS   R14,4(,R15)         CALL CONVERT ROUTINE
         MVC   IER922B,2(R1)       MOVE CONVERTED DATA TO MSG AREA
         LM    R0,R1,IER922        IER922I OUTPUT BUFFER ADDR
         L     R15,PPIADSSC        R15 -> PPIADSSC
         BAS   R14,12(,R15)        CALL MSG PRINT RTN
*
*        CCW ADDR
*
         L     R0,IOBSTART         LOAD ADDR OF CCW
         L     R15,PPICONV+4       ADDR OF CONVERT ROUTINE
         BAS   R14,4(,R15)
         MVC   IER925A,2(R1)       MOVE CONVERTED DATA TO MSG AREA
         LM    R0,R1,IER925        IER925I OUTPUT CCW ADDR
         L     R15,PPIADSSC        R15 -> MSG PRINT RTN
         BAS   R14,12(,R15)        CALL MSG PRINT RTN
*
*        IOB ADDR
*
         L     R0,PPISTIOB         LOAD ADDR OF IOB
         L     R15,PPICONV+4       ADDR OF CONVERSION ROUTINE
         BAS   R14,4(,R15)         CALL CONVERT ROUTINE
         MVC   IER926A,2(R1)       MOVE CONVERTED DATA TO MSG AREA
         LM    R0,R1,IER926        IER926I IOB TABLE ADDR
         L     R15,PPIADSSC        R15 -> PRINT MSG RTN
         BAS   R14,12(,R15)        CALL PRINT MSG RTN
*
*        RETURN TO MAINLINE
*
APOENDNG LM    R0,R15,APOWREG      RESTORE REG
         BR    R14                 EXIT FROM MODULE
*
*        CONSTANTS
*
APOWREG  DC    11F'0'
APOWR11  DC    5F'0'
APOMASK  DC    X'FFFF'
         DC    X'FFF8'
APOWK    DC    X'00'
*
APOIDCCW CCW   0,0,CC+SLI,5        START OF WRITE CCW CHAIN
APOCTCCW CCW   0,0,CC+SLI,0        TIC CCW
APOCCW2  CCW   0,0,SLI,0           WRITE CCW
         ORG   APOCCW2+6
APOBYTES DC    H'0'                LENGTH
*
*        IERIOB
*
         IERIOB
*
*        CCW EQUATES
*
         IERCCWEQ
*
IERAMB   DSECT
*
         COPY  AMBMAIN
*
*        IERAP2
*
DIERAP2  DSECT
*
         DC    34F'0'
AP2WRT   DC    X'20000000'
         DC    10F'0'
*
DIERRPO  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRPO SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRPOI
*
         PRINT NOGEN
*
         DCBD  DSORG=(PS)
*
         PRINT GEN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERAP1   0101-20211-20211-1200-00043-00043-00000-RELEASE 00
AP1      TITLE 'IERAP1 - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERAP1
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 1 ASSIGNMENT MODULE
*        OPEN LIST - CONTAINS THE ADDRESSES OF ALL DCBS TO BE
*        OPENED FOR PHASE 1. THE FIRST ENTRY OF THE LIST IS THE
*        TOTAL NUMBER OF ENTRIES TO BE OPENED
*
*        USED AS A DSECT IN - N/A
*
*        MACROS USED - N/A
*
*        ENTRY POINTS -
*
*        INPUT PPI FIELDS REFERENCED - N/A
*
*        OUTPUT PPI FIELDS INITIALIZED OR ALTERED - N/A
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS NORMAL - N/A
*
*        EXITS-ERROR - N/A
*
*        TABLES/WORK AREAS - N/A
*
*        NOTES - NONE
*
IERAP1   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERAP1 SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERAP1I
*
         END
./ ADD NAME=IERAP1I  0101-20211-20211-1200-00015-00015-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERAP1 SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERAP1I
*
         DC    F'0'                NUMBER OF DCB ENTRIES TO OPEN
         DC    18F'0'              DCB ADDR TABLE
AP1RD2   DC    X'20000000'         USER SYNAD AND EROPT, READ - PH2
AP1WRT1  DC    F'0'                USER SYNAD - WRITE PH1
AP1WRT2  DC    F'0'                USER SYNAD - WRITE PH2
*
./ ADD NAME=IERAP2   0101-20211-20211-1200-00071-00071-00000-RELEASE 00
AP2      TITLE 'IERAP2 - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERAP2
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 2 ASSIGNMENT MODULE
*
*        OPEN LIST -
*        CONTAINS THE ADDRESSES OF ALL DATA CONTROL BLOCKS TO BE
*        OPENED FOR PHASE 2. THE FIRST ENTRY OF THE LIST IS THE
*        TOTAL NUMBER OF ENTRIES TO BE OPENED
*
*        USED AS A DSECT IN - N/A
*
*        ENTRY POINTS - N/A
*
*        INPUT PPI FIELDS REFERENCED - N/A
*
*        OUTPUT PPI FIELDS INITIALIZED OR ALTERED - N/A
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL - N/A
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS - N/A
*
*        NOTES - NONE
*
IERAP2   CSECT
*
         DC    F'0'                NUMBER OF LIST ENTRIES TO OPEN
         DC    F'0'                DCB ADDR
         DC    F'0'                DCB ADDR
         DC    F'0'                DCB ADDR
         DC    F'0'                DCB ADDR
         DC    F'0'                DCB ADDR
         DC    F'0'                DCB ADDR
         DC    F'0'                DCB ADDR
         DC    F'0'                DCB ADDR
         DC    F'0'                DCB ADDR
         DC    F'0'                DCB ADDR
         DC    F'0'                DCB ADDR
         DC    F'0'                DCB ADDR
         DC    F'0'                DCB ADDR
         DC    F'0'                DCB ADDR
         DC    F'0'                DCB ADDR
         DC    F'0'                DCB ADDR
         DC    F'0'                DCB ADDR
         DC    F'0'                DCB ADDR
         DC    F'0'                DCB ADDR
         DC    F'0'                DCB ADDR
         DC    F'0'                DCB ADDR
         DC    F'0'                DCB ADDR
         DC    F'0'                DCB ADDR
         DC    F'0'                DCB ADDR
         DC    F'0'                DCB ADDR
         DC    F'0'                DCB ADDR
         DC    F'0'                DCB ADDR
         DC    F'0'                DCB ADDR
         DC    F'0'                DCB ADDR
         DC    F'0'                DCB ADDR
         DC    F'0'                DCB ADDR
         DC    F'0'                DCB ADDR
AP2READ  DC    X'20000000'         USER SYNAD AND EROPT (READ)
AP2WRT   DC    X'20000000'         USER SYNAD AND EROPT (WRITE)
*
         END
./ ADD NAME=IERAP3   0101-20211-20211-1200-00063-00063-00000-RELEASE 00
AP3      TITLE 'IERAP3 - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERAP3
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 3 ASSIGNMENT MODULE
*
*        OPEN LIST -
*        CONTAINS THE ADDRESSES OF ALL DCBS TO BE OPENED FOR
*        PHASE 3
*        THE FIRST ENTRY OF THE LIST IS THE TOTAL NUMBER OF
*        ENTRIES TO BE OPENED
*
*        USED AS A DSECT IN - N/A
*
*        MACROS USED - N/A
*
*        ENTRY POINTS - N/A
*
*        INPUT - N/A
*
*        OUTPUT - N/A
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS -
*
*        EXITS - NORMAL - N/A
*
*        EXITS ERROR - N/A
*
*        TABLES/WORK AREAS - N/A
*
*        NOTES - NONE
*
IERAP3   CSECT
*
         DC    F'0'
         DC    F'0'
         DC    F'0'
         DC    F'0'
IERAP3A  DC    F'0'                NUMBER OF LIST ENTRIES TO OPEN
         DC    F'0'                DCB ADDR
         DC    F'0'                DCB ADDR
         DC    F'0'                DCB ADDR
         DC    F'0'                DCB ADDR
         DC    F'0'                DCB ADDR
         DC    F'0'                DCB ADDR
         DC    F'0'                DCB ADDR
         DC    F'0'                DCB ADDR
         DC    F'0'                DCB ADDR
         DC    F'0'                DCB ADDR
         DC    F'0'                DCB ADDR
         DC    F'0'                DCB ADDR
         DC    F'0'                DCB ADDR
         DC    F'0'                DCB ADDR
         DC    F'0'                DCB ADDR
         DC    F'0'                DCB ADDR
         DC    F'0'                DCB ADDR
         DC    F'0'
AP3READ  DC    X'20000000'         USER SYNAD AND EROPT (READ)
*
         END
./ ADD NAME=IERBGA   0101-20211-20211-1200-00110-00110-00000-RELEASE 00
BGA      TITLE 'IERBGA - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE FUNCTION
*
*        IERBGA IS THE THIRD OF THREE GENERAL ASSIGNMENT MODULES
*        IN TAPE B&G. THE FUNCTION OF IERBGA IS TO PRINT THE
*        MESSAGES AND STORE THE CALCULATED VALUES IN CPI. IT
*        CONTAINS ALL CONSTANTS, WORK AREAS, AND SUBROUTINES USED
*        BY IERRCS AND IERRCR
*
*        MODULES IN WHICH THIS MODULE APPEARS AS A DSECT -
*        IERRCS
*        IERRCR
*
*        MACROS USED -
*        SMCPI
*
*        ENTRY POINTS -
*        CSECT NAME IERRCR ENTER FROM IERRCR VIA
*        UNCONDITIONAL BRANCH
*
*        INPUT- CPI FIELDS REFRENCED -
*        CPIBINSZ   CPIFILSZ   CPILAB07
*        CPIEXTSZ   CPIIPBLK   CPILAB09
*        CPINWKU    CPIOPBLK   CPIP1RSZ
*        CPIP2RSZ   CPIP3RSZ   CPIRCDL1
*        CPIRCDL2   CPIRCDL3   CPIRCDL5
*        CPISRTBL   CPICNTL    CPITAVLC
*
*        OUTPUT - CPI FIELDS INITIALIZED OR ALTERED -
*        CPIBUF1    CPIBUF23   CPILAB03
*        CPIMRGAL   CPIMRGMX   CPINMAX
*        CPIP1GC    CPIP2GC    CPIP3GC
*        CPISRTBL   CPISRTG    CPICNTL
*
*        EXTERNAL ROUTINES -
*        IERRCU - DIAGNOSTIC AND ERROR MESSAGES
*
*        EXTERNAL PARAMETERS -
*        IERRCU MESSAGES
*
*        EXITS - NORMAL - IERRCM - RETURN TO IERRCM VIA
*                                  LA R15,0
*                                  BR R14
*
*        EXITS - ERROR - IERRCM - RETURN TO IERRCM VIA
*                                 LA R15,4
*                                 BR R14
*
*        TABLES/WORK AREAS -
*        WORK  - WORK9
*        WFULL - WFULL4
*
*        NOTES -
*        THIS IS RESTRICTED TO TAPE OPERATION ONLY. IT CONTAINS
*        A DSECT OF IERRCS, IERRCR, AND IERRCU
*
IERBGA   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERBGA SOURCE
*
*----------------------------------------------------------------------
*
         COPY IERBGAI
*
*        MODULE NAME - IERRCS
*
IERRCS   DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRCS SOURCE
*
*----------------------------------------------------------------------
*
         COPY IERRCSI
*
*        MODULE NAME - IERRCR
*
IERRCR   DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRCR SOURCE
*
*----------------------------------------------------------------------
*
         COPY IERRCRI
*
DIERRCU  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRCU SOURCE
*
*----------------------------------------------------------------------
*
         COPY IERRCUI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMCPI
*
         END
./ ADD NAME=IERBGAI  0101-20211-20211-1200-01349-01349-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERBGA SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER -  IERBGAI
*
         USING *,R7                BASE REG FOR BGA
         USING IERRCS,R11          BASE REG FOR RCS
         USING IERRCR,R12          BASE REG FOR RCR
         USING IERRC5,R13          BASE REG FOR CPI
         USING DIERRCU,R9          BASE REG FOR RCU
*
         IERENTRY 'IERBGA &SYSDATE &SYSTIME',REG=R7
*
*
*        RCRSCNGN SUBROUTINE
*
*        USED TO CALCULATE TECHNIQUE SELECTION SELECTION COMPARE
*        NUMBERS (SCN'S)
*
*        REGISTERS ENTERING SUBROUTINE -
*
*        R0 = TOTAL NUMBER OF PHASE 1 BUFFERS
*        R1 = TOTAL NUMBER OF PHASE 2 BUFFERS
*        R2 = TOTAL NUMBER OF PHASE 3 BUFFERS
*        R3 = SORT BUFFER LENGTH (BSL OR OBSL)
*        R4 = NUMBER OF PASSES
*        R6 = RETURN REGISTER
*
*        REGISTERS LEAVING SUBROUTINE -
*
*        R0 = SELECTION COMPARE NUMBER (SCN)
*
RCRSCNGN STM   R0,R4,WSCNNB1       SAVE PARAMETERS
         L     R3,WSCNNB3          LOAD PHASE 3 NO OF BUFS
         LH    R4,WBALMRMX(R10)    LOAD MERGE ORDER
*
         B     RCRSC01(R14)        GOTO CORRECT CHAN STATUS
RCRSC01  B     RCRSC02             +00 1 MULTIPLEX CHANNEL
         B     RCRSC03             +04 1 SELECTOR CHANNEL
*
*        2 SELECTOR CHANNELS
*
         SLL   R4,1                2 * M
         LA    R4,2(,R4)           (2*M)+2 = Y
         B     RCRSC04             CONTINUE CALCULATION
*
*        1 MULTIPLEX
*
RCRSC02  LA    R4,1(,R4)           (M+1) = Y
         B     RCRSC04             CONTINUE CALCULATION
*
*        1 SELECTOR
*
RCRSC03  LA    R4,2(,R4)           (M+2) = Y
*
*        CONTINUE CALCULATION
*
RCRSC04  MH    R3,K100             NB3*100
         SR    R2,R2
         DR    R2,R4               (NB3*100)/Y
         LR    R5,R3               SAVE VALUE
         L     R3,WSCNNB2          LOAD NB2
         L     R1,WSCNP            NUMBER OF PASSES
         SH    R1,K200             ( P - 2 )
         BZ    RCRSC04A            TERM= ZERO
         SR    R2,R2
         MR    R2,R1               (P-2)(NB2)
         SR    R2,R2
         DR    R2,R4               (NB2)(P-2)/Y
         AR    R5,R3               ADD PHASE 2 TO PHASE 3 VALUES
RCRSC04A L     R3,WSCNNB1          LOAD NB1
         MH    R3,K100             NB1*100
         EX    0,RCRSC05(R14)
         B     RCRSC06             SKIP EXECUTED INSTRUCTION
*
RCRSC05  LA    R4,2                1 MULTIPLEX - X CONSTANT
         LA    R4,3                1 SELECTOR - X CONSTANT
         LA    R4,4                2 SELECTOR - X CONSTANT
*
RCRSC06  LA    R2,0
         DR    R2,R4               (NB1*100)/X CONSTANT
         AR    R5,R3               ADD PHASE 1 VALUE TO PHASE 2+3
         L     R3,WSCNP            LOAD # OF PASSES
         MH    R3,K10              P*10
         LR    R4,R5
         SR    R2,R2
         DR    R2,R4
*
*        (P*10)/(NB1*100/X) + ((P-200)(NB2)/Y) + (NB3*100/Y)
*
         ST    R3,WRCRSCOL         SAVE OL FACTOR
         L     R3,WSCNBSL          LOAD BLOCK SIZE
         LR    R4,R3               LOAD BLOCK SIZE
         MH    R3,K1000            BSL* 1000
         AH    R4,WIRGTAPE         ADD IRG FACTOR
         SR    R2,R2
         DR    R2,R4               BLK SZ/BLK SZ + IRG
         LR    R4,R3               R3 = BE
         L     R3,K100000          LOAD SCALING FACTOR
         SR    R2,R2
         DR    R2,R4               100000/BE = BLK E FACTOR
         ST    R3,WRCRSCBE         SAVE BE
         SR    R2,R2
         M     R2,WSCNP            BE*P
         SR    R2,R2
         M     R2,WRCRSCOL         BE*P*OL = T
         ST    R3,WRCRSCT          SAVE T
         LR    R0,R3               PASS RESULTS
         BR    R6                  RETURN
*
*        RCSCAP SUBROUTINE
*
*        USED TO CALCULATE THE MAXIMUM NUMBER OF RECORDS THAT
*        CAN BE HANDLED BY SPECIFIED TECHNIQUE
*
*        NMAX = (2300' * 12'' * DENSITY * BS * REELS)
*               -------------------------------------
*                  (RECORD LENGTH * BS) + IRG
*
*        REGISTERS ENTERING SUBROUTINE -
*
*        R0 = BS (SORT BLOCKING)
*        R1 = BSL (SORT BUFFER LENGTH)
*        R2 = NO REELS CAPACITY
*        R6 = RETURN REG
*
*        REGISTERS LEAVING SUBROUTINE -
*
*        R3 = TECHNIQUE NMAX VALUE
*
RCSCAP   STM   R0,R2,RCSBS         SAVE PARAMETERS
         B     RCS100(R9)          GOTO PROPER RCD FORMAT RTN
*
RCS100   B     RCS101              VARIABLE LENGTH RCDS INDICATED.
*
*        FIXED LENGTH RECORDS INDICATED
*
         LH    R3,RCSBS+2          TECH BLOCKING FACTOR
         B     RCS102              START CALCULATIONS
*
*        VARIABLE LENGTH RECORDS INDICATED
*
RCS101   LH    R3,RCSBSL+2         VARIABLE LENGTH RCDS BUF SIZE
         LH    R4,CPIRCDL2         VAR - MAX RECORD LENGTH
         SR    R2,R2
         DR    R2,R4               BSL/L1 = VARIABLE BS
RCS102   L     R4,WDENTAPE         (2300'*12''*DENSITY)
         SR    R2,R2
         MR    R2,R4               (2300'*12''*DENSITY*BS)
         LH    R4,RCSREELS+2       TECH MAX REELS OF INPUT
         SR    R2,R2
         MR    R2,R4               (2300'*12''*DENSITY*BS*REELS)
         LH    R4,RCSBSL+2         RCD LENGTH*BS
         SH    R4,WRECIND          SUBTRACT RECORD INCREMENT FROM BSL
         AH    R4,WIRGTAPE         (RCD LENGTH*BS) + IRG
         CR    R3,R4               NUMERATOR LESS THAN DENOMINATOR ?
         BL    RCS103              YES
         SR    R2,R2
         DR    R2,R4               (2300'*12''*DENSITY*BS*REELS)
*                                  --------------------------------
*                                    (RCD LENGTH * BS) + IRG
*
         LA    R4,1000             DENSITY SCALING FACTOR
         SR    R2,R2
         MR    R2,R4               R3 = TECH NMAX
         B     RCS104              CONTINUE
*
RCS103   LA    R4,1000             DENSITY SCALING FACTOR
         SR    R2,R2
         MR    R2,R4               (2300'*12''*DENSITY*BS*REELS)
*
         LH    R4,RCSBSL+2         RCD LENGTH * BS
         SH    R4,WRECIND          SUBTRACT RECORD INCREMENT FROM BSL
         AH    R4,WIRGTAPE         (RCD LENGTH * BS) + IRG
         SR    R2,R2
         DR    R2,R4               (2300'*12''*DENSITY*BS*REELS)
*                                  - - - - - - - - - - - - - -
*                                  (RCD LENGTH*BS) + IRG
RCS104   ST    R3,RCSNMAX          STORE NMAX IN SAVE LOCATION
         BR    R6                  RETURN  TO CALLER
*
RCSNMAX  DC    F'0'                TEMP STORAGE FOR NMAX
RCSBS    DC    F'0'                TEMP STORAGE FOR BS
RCSBSL   DC    F'0'                TEMP STORAGE FOR BSL
RCSREELS DC    F'0'                TEMP STORAGE FOR NO REELS
*
*        SUBROUTINES TO UPDATE TOTALS AND RETURN TO MAIN
*        PROGRAM
*
RCSADD1  AR    R2,R5
RCSADD2  AR    R0,R3
         AR    R1,R4
         BR    R14                 RETURN  TO MAIN ROUTINE
*
*        RCRPASS SUBROUTINE -
*
*        USED BY BALANCED AND OSCILLATING TECHS TO CALCULATE
*        NUMBER OF PASSES REQUIRED AND A NEW G REQUIRED TO SAVE
*        ONE (1) PASS OF DATA
*
*        REGISTERS ENTERING SUBROUTINE -
*
*        R0 = NUMBER OF STRINGS
*        R1 = MERGE MAX
*        R2 = MERGE ALT - IF BALANCED TECH
*        R3 = NUMBER OF RECORDS (BAL) OR RMAX IF OSC
*        R6 = RETURN REGISTER
*
*        REGISTERS LEAVING SUBROUTINE -
*
*        R0 = NUMBER OF STRINGS TO CUT TO SAVE ONE (1) PASS
*        R1 = NUMBER OF PASSES (USING ORIGINAL STRING COUNT)
*        R2 = NEW G REQUIRED TO SAVE ONE (1) PASS
*        R3 = NEW TREE SIZE FOR NEW G VALUE
*        R4 = NEW PHASE 1 CORE REQUIRED FOR NEW G VALUE
*
RCRPASS  OI    RCRSW,X'01'         ENTRY FROM BALANCED TECHNIQUE
         STM   R0,R3,RCRSAVE       SAVE PARAMETER REGISTERS
         B     RCRPASS4            BEGIN CALCULATING
*
RCRPASS1 OI    RCRSW,X'01'         ENTRY FROM OSC TECH - 1ST PASS LOOP
         B     RCRPASS3            BEGIN CALCULATING
*
RCRPASS2 NI    RCRSW,X'FE'         ENTRY FROM OSC TECH - 2ND PASS LOOP
RCRPASS3 STM   R0,R3,RCRSAVE       SAVE PARAMETER REGISTERS
         ST    R1,RCRMRGAL         MRG ALT = MRG MAX
         ST    R0,WSTRORIG         ORIGINAL STRING COUNT
RCRPASS4 LA    R1,1                SET PCTR=1 (TOTAL PASS COUNT)
         L     R3,RCRMRGMX         SET SQCTR = MRG MAX
RCRP01   CR    R0,R3               NO, STRINGS EQUAL/LESS THAN SQCTR ?
         BNH   RCRP03              YES
         ST    R3,WSQCTRSV         NO - SAVE LAST SEQUENCE COUNT
         LA    R1,1(,R1)           PCTR = PCTR + 1
         STC   R1,RCRIND           SAVE PASS COUNT
         TM    RCRIND,X'01'        PCTR ODD NUMBER ?
         BO    RCRP02              YES, MULTIPLY BY MRG MAX
         L     R4,RCRMRGAL         NO, MULTIPLY BY MRG ALT
         B     RCRP02A             SKIP MRG MAX LOAD
*
RCRP02   L     R4,RCRMRGMX
RCRP02A  SR    R2,R2
         MR    R2,R4
         B     RCRP01              COMPARE RESULTS TO ORIGINAL STRING
*                                  COUNT
RCRP03   CH    R1,K01              PCTR GREATER THAN 1 ?
         BH    RCRP04              YES, MORE THAN 1 PASS REQUIRED
         SR    R0,R0               NO, INDICATE TO CALLING ROUTINE
         SR    R2,R2               NO PASSES CAN BE SAVED
         SR    R3,R3
         SR    R4,R4
         BR    R6                  RETURN TO CALLING ROUTINE
*
RCRP04   L     R2,WSQCTRSV         LAST COUNT LOWER THAN STRING NO
         LR    R4,R2               STRING COUNT NEEDED TO SAVE 1 PASS
         SR    R0,R2               ORIG STRING COUNT LESS NEW STRING
*                                  COUNT = DIFFERENCE
         STM   R0,R1,RCRSAVE       SAVE DIFFERENCE AND NO PASSES
         TM    RCRSW,X'01'         BAL TECH OR OSC TECH 1ST PASS ?
         BZ    RCRP10              NO
         B     RCRP04A(R15)        YES, GOTO PROPER TECH ROUTINE
*
RCRP04A  B     RCRP06              BALANCED TECH INDICATED
         B     RCRP11              POLYPHASE TECHNIQUE INDICATED
*
*        OSCILLATING TECHNIQUE
*
*        CALCULATE NEW G NEEDED TO SUPPLY NEW STRING COUNT
*
*        NEW G = (ORIGINAL STR. COUNT) * (ORIGINAL G)
*                  ----------------------------------
*                        (NEW STRING COUNT)
*
RCRP05   L     R3,WSTRORIG         ORIGINAL STRING COUNT
         L     R4,WBALG(R15)       ORIGINAL G
         SR    R2,R2
         MR    R2,R4               R3 = ORIG  STR COUNT * ORIG G
         L     R4,WSQCTRSV         NEW STRING COUNT TO SAVE PASS
         SR    R2,R2
         DR    R2,R4               R3 = NEW G
         B     RCRP06B             ROUND UPWARD
*
*        BALANCED TECHNIQUE
*
*        CALCULATE NEW G NEEDED TO SUPPLY NEW STRING COUNT
*
*        NEW G = USER FILE SIZE
*                ---------------
*                2(NEW STRING CT)
*
RCRP06   LR    R4,R2               NEW STRING COUNT
         SLL   R4,1                2(NEW STRING COUNT)
RCRP06A  L     R3,WFILSZ           USER FILE SIZE
         SR    R2,R2
         DR    R2,R4               R3 = NEW G
RCRP06B  LTR   R2,R2               CHECK FOR REMAINDER
         BZ    RCRP06C             NONE PRESENT
         LA    R3,1(,R3)           ADD 1 TO G VALUE
RCRP06C  ST    R3,RCRMRGAL         SAVE NEW G VALUE
*
*        BALANCED OR OSCILLATING TECHNIQUES
*
*        CALCULATE PHASE 1 CORE REQUIRED FOR NEW G AND NEW TREE
*
RCRP07   B     RCRP07A(R9)         GOTO PROPER RCD FORMAT RTN
*
RCRP07A  B     RCRP09              VARIABLE LENGTH RECORDS INDICATED
*
*        FIXED LENGTH RECORDS
*
*        PHASE 1 CORE REQUIRED = (3BINSZ + 20) * (NEW G + 1)
*                                ---------------------------
*                                             3
RCRP08   LH    R3,CPIBINSZ
         LA    R4,3
         SR    R2,R2
         MR    R2,R4               (3BINSZ)
         LA    R3,20(R3)           (3BINSZ + 20)
         L     R4,RCRMRGAL         NEW G VALUE
         LA    R4,1(,R4)           NEW G + 1
         SR    R2,R2
         MR    R2,R4               (3BINSZ+20)(NEWG+1)
         LA    R4,3
         SR    R2,R2
         DR    R2,R4               (3BINSZ+20)(NEWG+1)/3
         ST    R3,RCRCORRQ         SAVE PHASE 1 CORE REQUIRED
*
*        FIXED LENGTH RECORDS
*
*        CALCULATE TREE SIZE FOR NEW G
*
*        NEW TREE = (NEW G - 1)   * 20
*                   ------------
*                        3
*
         L     R3,RCRMRGAL         NEW G VALUE
         SH    R3,K01              (NEW G - 1)
         LA    R4,3
         SR    R2,R2
         DR    R2,R4               (NEW G - 1)/3
         LTR   R2,R2               THERE A REMAINDER ?
         BZ    RCRP08A             NO
         LA    R3,1(,R3)
RCRP08A  LA    R4,20
         SR    R2,R2
         MR    R2,R4               (NEW G -1)/3 * 20
RCRP08B  ST    R3,RCRNRCDS         SAVE NEW TREE VALUE
         B     RCRP11              RETURN
*
*        VARIABLE LENGTH RECORDS INDICATED
*
*        CALCULATE PHASE 1 CORE REQUIRED FOR NEW G
*
*        PHASE 1 CORE REQ = ((36+(K(3BINSZ))NEW G)+(K(3BINSZ))-36)
*                           --------------------------------------
*                                             3
*
RCRP09   LH    R3,CPIBINSZ
         LA    R4,3
         SR    R2,R2
         MR    R2,R4               (3BINSZ)
         MH    R3,WBALK(R10)       (3BINSZ) * K
         LR    R0,R3               R0 = (3BINSZ)K
         LA    R3,36(,R3)          (36+(K(3BINSZ)))
         L     R4,RCRMRGAL         NEW G
         SR    R2,R2
         MR    R2,R4               ((36+K(3BINSZ))NEW G)
         AR    R3,R0               ((36+K(3BINSZ))NEW G)+(K(3BINSZ))
         LA    R1,36
         SR    R3,R1               ((36+K(3BINSZ))NEW G)+(K(3BINSZ)-36)
         SR    R2,R2
         LA    R4,3
         DR    R2,R4               ((36+K(3BINSZ))NEW G)+(K(3BINSZ)-36)
*                                  ------------------------------------
*                                                  3
         ST    R3,RCRCORRQ         SAVE PHASE 1 CORE REQUIRED
*
*        VARIABLE LENGTH RECORDS
*
*        CALCULATE NEW TREE SIZE FOR NEW G
*
*        NEW TREE = (NEW G - 1) * 12
*
         L     R3,RCRMRGAL         NEW G VALUE
         SH    R3,K01              (NEW G - 1)
         LA    R4,12
         SR    R2,R2
         MR    R2,R4               (NEW G - 1) * 12
         CH    R3,K40              IS TREE LESS THAN 40
         BNL   RCRP09A             NO
         LA    R3,36               LOAD MINIMUM TREE VALUE
RCRP09A  ST    R3,RCRNRCDS         SAVE NEW TREE VALUE
         B     RCRP11              RETURN
*
*        RETURN TO CALLING ROUTINE WITH DESIRED PARAMETERS
*
*        BALANCED TECH   - RETURN ALL PARAMETERS
*        OSC FIRST PASS  - RETURN ALL PARAMETERS
*        OSC SECOND PASS - RETURN ONLY DIFFERENCE AND
*                          SUB-PASS CT
*
RCRP10   LM    R0,R1,RCRSAVE       DIFF AND PASS COUNT
         BR    R6                  RETURN TO CALLING ROUTINE
*
RCRP11   LM    R0,R4,RCRSAVE       LOAD ALL PARAMETER REGISTERS
         BR    R6                  RETURN TO CALLING ROUTINE
*
*        RCRFIBX SUBROUTINE -
*
*        USED TO GENERATE FIBONACCI NUMBERS NECESSARY TO
*        CALCULATE THE NUMBER OF STRINGS REQUIRED TO SORT AN
*        INPUT FILE. THE SUBROUTINE WILL ALSO CALCULATE THE NEW
*        NUMBER OF STRINGS NECESSARY IN ORDER TO OPTIMIZE ONE (1)
*        LEVEL OF THE FIBONACCI SERIES
*
*        REGISTERS ENTERING SUBROUTINE -
*
*        R0 = MERGE ORDER
*        R1 = NUMBER OF STRINGS IN FILE
*        R6 = RETURN REG
*
*        REGISTERS LEAVING SUBROUTINE -
*
*        R0 = NUMBER OF PASSES BEFORE OPTIMIZATION
*        R1 = NUMBER OF PASSES AFTER OPTIMIZATION
*        R2 = NEW NUMBER OF SEQUENCES NEEDED FOR OPTIMIZATION
*
RCRFIBX  STM   R0,R1,WFIBSAVE      SAVE PARAMETERS
         LR    R5,R0               M
         SLL   R5,1                2*M
         SH    R5,K02              (2 * M) - 2
         SR    R0,R0
         SR    R4,R4
         LA    R2,1
         STH   R2,WFIBWRK1         STORE ONES IN WORK AREA
         MVC   WFIBWRK1+2(30),WFIBWRK1  SET WORK AREA TO ALL ONES
RCRFIB   SR    R2,R2
         SR    R3,R3
         AH    R0,K01              ADD ONE TO LEVEL COUNTER
         LR    R1,R5               LOAD INDEX REG
RCRFIB1  AH    R2,WFIBWRK1(R1)     ADD FIB # TO ACCUM
         SH    R1,K02              STEP DOWN THE INDEX REG
*                                  ALL FIBS IN LEVEL BEEN ADDED ?
         BM    RCRFIB1A            YES
         B     RCRFIB1             NO, CONTINUE
*
RCRFIB1A STH   R2,WFIBWRK2(R4)     SAVE STRINGS AT FIB LEVEL
         LH    R3,WFIBWRK1         LOAD FIB LEVEL FIRST ELEMENT
         STH   R3,WFIBWRK4(R4)     SAVE ELEMENT
         LA    R4,2(,R4)           INCREASE INDEX REG
         C     R2,WFIBSAVE+4       NO OF STRINGS AT FIB LEVEL
*                                  GREATER OR EQUAL THAN ACTUAL NO ?
         BNL   RCRFIB3B            YES
RCRFIB2  SR    R1,R1
         LH    R2,WFIBWRK1(R5)     LOAD MTH FIB NO
         LH    R3,WFIBWRK1         FIRST ELEMENT OF LEVEL
         STH   R2,WFIBWRK3         STORE NEW FIB LEVEL
RCRFIB3  CR    R1,R5               LEVEL DONE ?
         BNL   RCRFIB3A            YES
         LR    R3,R2               FIRST ELEMENT
         AH    R3,WFIBWRK1(R1)     ADD NEXT FIB # TO NEW FIB #
         LA    R1,2(,R1)           INCREASE INDEX REG
         STH   R3,WFIBWRK3(R1)     STORE NEW FIB NUMBER
         B     RCRFIB3             LOOP
*
RCRFIB3A MVC   WFIBWRK1(32),WFIBWRK3   MOVE IN NEW FIB LEVEL
         B     RCRFIB              DO NEXT LEVEL
*
RCRFIB3B STH   R2,WOLDSTRF         NO OF STRINGS AT UN-OPT LEVEL
*
RCRFIB4  LR    R3,R0               LEVEL
         L     R2,WFIBSAVE         M
         LA    R2,1(,R2)           M+1
RCRFIB4A SR    R3,R2               LEVEL-(M+1)
         BNM   RCRFIB4A            LEVEL -(M+1) NEG ?
         AH    R3,WFIBSAVE+2       YES - ADD M
*                                  FIB LEVEL ODD ?
         BZ    RCRFIB3             YES
RCRFIB5  STH   R0,WOLDLEV          SAVE OLD FIB LEVEL
         LR    R5,R0               LEVEL
RCRFIB5A SR    R1,R1
         SR    R2,R2
         SR    R0,R0
         SLL   R5,1                2*LEVEL
         SH    R5,K02              2*LEVEL-2
RCRFIB6  LH    R3,WFIBWRK2(R1)     LOAD FIB TOTALS
         LH    R4,WFIBWRK4(R5)     FIRST FIB ELEMENT
         SR    R2,R2
         MR    R2,R4               LOW FIB TOTAL*HIGH FIB LEVEL
*                                  FIRST ELEMENT
         AR    R0,R3               ADD FOR TOTAL # STR
         LA    R1,2(,R1)           INCREASE INDEX REG
         SH    R5,K02              DECREMENT INDEX REG
*                                  HAVE ALL LEVELS BEEN MULT ?
         BNM   RCRFIB6             NO
*
*        OPTIMIZATION FOR FIB NUMBERS
*
         TM    WCSSWB+1,X'01'      OPT SWITCH SET ?
         BO    RCRFIB9             YES
         STH   R0,WOLDTSTR         SAVE TOTAL # OF STR AT OLD LEVEL
         LH    R4,WOLDLEV          LOAD OLD LEVEL
RCRFIB6A BCT   R4,RCRFIB7          FIBLEVEL-1 = NEW FIB LEVEL
         CH    R4,K01              LEVEL THE FIRST LEVEL ?
         BE    RCRFIB8             YES
RCRFIB7  LR    R3,R4               FIB LEVEL
         L     R2,WFIBSAVE         M
         LA    R2,1(,R2)           M+1
RCRFIB7A SR    R3,R2               LEVEL-(M+1)
         BNM   RCRFIB7A            LEVEL-(M+1) NEG ?
         AH    R3,WFIBSAVE+2       YES, ADD M
*                                  LEVEL ALL ODD ?
         BZ    RCRFIB6A            YES
RCRFIB8  STH   R4,WNEWLEV          NEW FIB LEVEL
         LR    R5,R4               LEVEL
         OI    WCSSWB+1,X'01'      SET SWITCH FOR OPT
*
*        BIT FOR OPTIMIZATION IS THE 16TH BIT OF SWITCH B
*
         B     RCRFIB5A            CALC  NEW  LEV
*
RCRFIB9  STH   R0,WNEWTSTR         SAVE NEW TOTAL # OF STRINGS
         SH    R1,K02              DECREMENT INDEX REG
         LH    R3,WFIBWRK2(R1)     LOAD NEW FIB STRING NO
         STH   R3,WNEWSTRF         SAVE NEW NO OF STR
         LH    R4,WOLDSTRF         ORIG NO OF STRINGS AT OLD LEVEL
         LH    R3,WOLDTSTR         LOAD UN OPT WORK FUNCTION
         MH    R3,K100             MULT BY SCALING FACTOR
         SR    R2,R2
         DR    R2,R4               WORK FUNCTION/NO. OF STRINGS =
*                                  NO OF PASSES
         LTR   R2,R2               A REMAINDER ?
         BZ    RCRFIB9A            NO
         LA    R3,1(,R3)           ADD ONE TO PASSES
RCRFIB9A LR    R0,R3               R0 = UN-OPT NO OF PASSES
         LH    R3,WNEWTSTR         OPTIMIZED WORK FUNCTION
         MH    R3,K100             MULT BY SCALING FACTOR
         SR    R2,R2
         LH    R4,WNEWSTRF         OPT NO OF STRINGS
         DR    R2,R4               WORK FUNCTION/NO OF STRINGS =
*                                  NO OF PASSES
         LTR   R2,R2               A REMAINDER ?
         BZ    RCRFIB9B            NO
         LA    R3,1(,R3)           ADD 1 TO NO OF PASSES
RCRFIB9B LR    R1,R3               R1 = OPT NO OF PASSES
         LR    R2,R4               R2 = OPT NO OF STRINGS
         BR    R6                  RETURN TO CALLER
*
*        STORE CALCULATED RESULTS IN CPI FOR THE SELECTED TECH
*
RCRCPI   L     R3,WTAVLC           LOAD CORE VALUE
         EX    0,RCRCPI01(R15)     TAVLC-RUNNING CORE
         B     RCRCPI02            BYPASS EXECUTED INSTRUCTION
*
         DC    0F'0'
RCRCPI01 S     R3,WP1BALCR         SUBTRACT BAL RUNNING CORE
         S     R3,WP1POLCR         SUBTRACT POL RUNNING CORE
         S     R3,WP12OSCR         SUBTRACT OSC RUNNING CORE
*
RCRCPI02 STCM  R3,B'0111',CPITAVLC  STORE CORE VALUE INTO CPI
         LH    R1,WBALBS(R10)      BS
         STH   R1,CPISRTBL         STORE BS INTO CPI
         L     R1,WBALNMAX(R15)    LOAD NMAX
         STCM  R1,B'0111',CPINMAX  STORE NMAX VALUE INTO CPI
         L     R1,WP1IPBFR         LOAD INPUT BFR SIZE
         STH   R1,CPILAB03         STORE SIZE OF INPUT BUFS IN CPI
         L     R1,WP3OPBFR         LOAD OUTPUT BFR
         STH   R1,CPILAB09+2       STORE SIZE OF OUTPUT BUFS IN CPI
         L     R1,WBALG(R15)       LOAD G
         STCM  R1,B'0111',CPISRTG  STORE SORT G INTO CPI
         LH    R1,WBSLBAL(R10)     LOAD BSL
         STH   R1,CPILAB07         STORE BSL SIZE IN CPI
         LH    R1,WBALNB1(R10)     P1 TOTAL NO BFRS
         STC   R1,CPIBUF1          STORE P1 TOTAL NO BFRS IN CPI
         LH    R1,WBALNB2(R10)     P2 TOTAL NO BFRS
         STC   R1,CPIBUF23         STORE P2 TOTAL NO BFRS IN CPI
         LH    R1,WBALNB3(R10)     P3 TOTAL NO BFRS
         STC   R1,CPIBUF23+1       STORE P3 TOTAL NO BFRS IN CPI
         LH    R1,WBALOUT2(R10)    NO P2 OUTPUT BFRS
         STC   R1,CPILAB09         STORE P2 OUTPUT BFRS IN CPI
         LH    R1,WBALOUT3(R10)    NO P3 OUTPUT BFRS
         STC   R1,CPILAB09+1       STORE NO P3 OUTPUT BFRS IN CPI
         L     R1,WBALP1GC(R15)    P1 GEN CORE
         A     R1,WBALTREE(R15)    GC+TREE
         SRL   R1,3
         SLL   R1,3                ROUND GEN CORE TO DOUBLE WORD
         STCM  R1,B'0111',CPIP1GC  STORE P1 GEN CORE VALUE INTO CPI
         L     R1,WBALP3GC(R15)    LOAD P3 GEN CORE
         SRL   R1,3                ROUND TO DOUBLE WORD BOUNDARY
         SLL   R1,3
         STCM  R1,B'0111',CPIP3GC  STORE P3 GEN CORE VALUE INTO CPI
         B     RCRCPI03(R15)       GOTO PROPER TECHNIQUE
RCRCPI03 B     RCRCPI04            +00 BAL TECH
         B     RCRCPI04            +04 POL TECH
         B     RCRCPI05            +08 OSC TECH
*
RCRCPI04 L     R1,WBALP2GC(R15)    P2 GEN CORE
         SRL   R1,3
         SLL   R1,3                ROUND GEN CORE TO DOUBLE WORD
         STCM  R1,B'0111',CPIP2GC  STORE P2 GEN CORE VALUE INTO CPI
RCRCPI05 LH    R1,WBALMRMX(R10)    MERGE MAX
         STC   R1,CPIMRGMX         STORE MERGE ORDER IN CPI
         LA    R1,1
         STC   R1,CPIMRGAL         MERGE ALT = 1
         B     RCRCPI06(R15)       GOTO PROPER TECHNIQUE
RCRCPI06 B     RCRCPI07            +00 BAL
         B     RCRCPI08(R15)       +04 POL
         B     RCRCPI08(R15)       +08 OSC
*
RCRCPI07 LH    R1,WBALMRAL         BAL ALT MERGE ORDER
         STC   R1,CPIMRGAL         STORE ALT MERGE ORDER IN CPI
*
         B     RCRCPI08(R15)       GOTO PROPER TECHNIQUE
RCRCPI08 B     RCRCPI09            +00 BAL TECH
         B     RCRCPI10            +04 POL TECH
*
*        OSCL
*
         CPISETON CPIOSC           SPECIFY OSC TECH SELECTED
         CPISETOF CPIBALN-CPIPOLY  TURN OFF ANY FORCED BITS
         TM    WCSSWC,X'20'        OSC 8 WAY ?
         BO    RCRCPI11            YES
         B     RCRCPI12            NO
*
*        BALN
*
RCRCPI09 CPISETON CPIBALN          SPECIFY BAL TECH SELECTED
         CPISETOF CPIPOLY-CPIOSC   TURN OFF ANY FORCED BITS
         TM    WCSSWC,X'40'        BAL 8 WAY ?
         BO    RCRCPI11            YES
         B     RCRCPI12            NO
*
*        POLY
*
RCRCPI10 CPISETON CPIPOLY          SPECIFY POL TECH SELECTED
         CPISETOF CPIBALN-CPIOSC   TURN OFF ANY FORCED BITS
         TM    WCSSWC,X'80'        POL 8 WAY ?
         BO    RCRCPI11            YES
         B     RCRCPI12            NO
*
RCRCPI11 CPISETON CPI8WAY          INDICATE 8 WAY NETWORK
         B     RCRMSG              GOTO PRINT B AND G MSGS
*
RCRCPI12 CPISETON CPI16WAY         INDICATE 16 WAY NETWORK
*
*        MESSAGE GENERATION
*
RCRMSG   LR    R5,R10              SAVE INDEX REGS FOR MESSAGE ROUTINE
         LR    R6,R15
         L     R15,VGAPRT          R15 -> IERGAPRT
         L     R9,VIERRCU          R9 -> IERRCU
         LH    R0,WBALBS(R5)       LOAD B
         CPITEST  CPIFIX           FIXED LENGTH RECORDS ?
         BO    RCRMSGA             YES
         SH    R0,WRECINCR         BS-8
RCRMSGA  BAS   R14,RCRCONV         CALL CONVERT ROUTINE
         MVC   IER036A,WM4TEMP+2   MOVE IN B
         LM    R0,R1,IER036        IER036I BLOCKING = NNNNN
         BASR  R14,R15             CALL PRINT ROUTINE
         L     R0,WBALG(R6)        LOAD G
         BAS   R14,RCRCONV         CALL CONVERT ROUTINE
         MVC   IER037A,WM4TEMP+2   MOVE IN G
         LM    R0,R1,IER037        IER037I RECORDS IN RSA = NNNNN
         BASR  R14,R15             CALL PRINT ROUTINE
         L     R0,WBALNMAX(R6)     LOAD NMAX
         CVD   R0,WM4DEWK
         ED    IER038A,WM4DEWK+3
         LM    R0,R1,IER038        IER038I ESTIMATED MAXIMUM RECORDS
         BASR  R14,R15             CALL PRINT ROUTINE
         CPITEST  CPIDIAG+CPIDSIM  DIAGNOSTICS ?
         BZ    RCRDONE             NO, BYPASS DIAG PRINT
*
*        DIAGNOSTIC MESSAGE FOR THE TECHNIQUE SPECIFIED
*
         L     R0,WBALN(R6)        LOAD NAME INDEXED BY R6 INTO R0
         STCM  R0,B'1111',IER961A  STORE INTO MESSAGE
         LM    R0,R1,IER961        IER961I SORT TECHNIQUE -
         BASR  R14,R15             CALL PRINT ROUTINE
*
*        MESSAGE FOR NO/SIZE OF BFRS BY PHASE - PHASE 1
*
         MVI   IER962A,C'1'        MOVE PHASE NO INTO MESSAGE
         LH    R0,WBALNB1(R5)      LOAD P1 NO BFRS
         BAS   R14,RCRCONV         CALL CONVERT ROUTINE
         MVC   IER962B,WM4TEMP+4   MOVE NO BFRS INTO MSG
         LH    R0,WBSLBAL(R5)      LOAD BSL
         SH    R0,WRECINCR         BSL - 4 OR 8
         BAS   R14,RCRCONV         CALL CONVERT ROUTINE
         MVC   IER962C,WM4TEMP     MOVE BSL INTO MESSAGE
         LM    R0,R1,IER962        IER962I - NO/SIZE OF BFRS, PH
         BASR  R14,R15             CALL PRINT ROUTINE
*
*        PHASE 2
*
         B     RCRMSG01(R6)        GOTO PROPER TECHNIQUE
RCRMSG01 B     RCRMSG02            +00 BAL TECH
         B     RCRMSG02            +04 POL TECH
         B     RCRMSG03            +08 OSC TECH
*
*        BAL OR POL TECH
*
RCRMSG02 MVI   IER962A,C'2'        MOVE PHASE NO INTO MESSAGE
         LH    R0,WBALNB2(R5)      LOAD PH2 NO BFRS
         BAS   R14,RCRCONV         GO TO CONVERT ROUTINE
         MVC   IER962B,WM4TEMP+4   MOVE NO BFRS INTO MESSAGE
         LM    R0,R1,IER962        IER962I - NO/SIZE OF BFRS, PH
         BASR  R14,R15             CALL PRINT ROUTINE
*
*        PHASE 3
*
RCRMSG03 MVI   IER962A,C'3'        MOVE PH NO INTO MESSAGE
         LH    R0,WBALNB3(R5)      LOAD NO PH3 BFRS
         BAS   R14,RCRCONV         GOTO CONVERT ROUTINE
         MVC   IER962B,WM4TEMP+4   MOVE NO PH3 BFRS INTO MESSAGE
         LM    R0,R1,IER962        IER962I - NO/SIZE OF BFRS, PH
         BASR  R14,R15             CALL PRINT ROUTINE
*
*        GENERATE STORAGE ASSIGNED TO SORT/MERGE MSG
*
         L     R0,WTAVLC           LOAD ASSIGNED STORAGE VALUE
         BAS   R14,RCRCONV         CALL CONVERT ROUTINE
         MVC   IER963A,WM4TEMP     MOVE STORAGE VALUE INTO MESSAGE
         LM    R0,R1,IER963        IER963I STORAGE =
         BASR  R14,R15             CALL PRINT ROUTINE
*
*        CALCULATE STORAGE BY PHASE - PHASE 1
*
         MVI   IER964A,C'1'        MOVE PHASE NO INTO MESSAGE
         EX    0,RCRMSG04(R6)      LOAD RUNNING PROGRAMS
         B     RCRMSG05            JUMP OVER EXECUTED CODE
*
RCRMSG04 L     R0,WP1BALCR         BAL RUNNING PROG   *** EXE CODE ***
         L     R0,WP1POLCR         POL RUNNING PROG   *** EXE CODE ***
         L     R0,WP12OSCR         OSC RUNNING PROG   *** EXE CODE ***
*
RCRMSG05 A     R0,WBALP1GC(R6)     ADD GEN CORE
         A     R0,WBALTREE(R6)     ADD TREE SIZE
         L     R3,WP1IPBFR         LOAD BI SIZE
         MH    R3,WBALINP1(R5)     BI*INP1
         AR    R0,R3               ADD VALUE TO RUNNING PROGRAM SIZE
         LH    R3,WBSLBAL(R5)      LOAD BSL
         LH    R4,WBALNB1(R5)      LOAD NB1
         SH    R4,WBALINP1(R5)     NB1-IND1
         SR    R2,R2
         MR    R2,R4               BSL*OUT1
         AR    R0,R3               ADD VALUE TO RUNNING PROGRAM SIZE
         L     R3,WBALG(R6)        LOAD G
         SR    R2,R2
         MH    R3,CPIBINSZ         G*BINSZ
         AR    R0,R3               ADD RSA VALUE TO TOTAL
         BAS   R14,RCRCONV         GOTO CONVERT ROUTINE
         MVC   IER964B,WM4TEMP     MOVE STORAGE VALUE INTO MESSAGE
         LM    R0,R1,IER964        IER964I PHASE 1 STORAGE =
         BASR  R14,R15             CALL PRINT ROUTINE
*
*        PHASE 2
*
         B     RCRMSG06(R6)        GOTO PROPER TECHNIQUE
RCRMSG06 B     RCRMSG07            +00 BAL
         B     RCRMSG07            +04 POL
         B     RCRMSG10            +08 OSC - NO PHASE 2
*
*        BAL OR POL TECH
*
RCRMSG07 MVI   IER964A,C'2'        MOVE PH NO INTO MESSAGE
         EX    0,RCRMSG08(R6)
         B     RCRMSG09            BYPASS EXECUTED CODE
*
RCRMSG08 L     R0,WP2BALCR         LOAD BAL RUNNING PROG  ** EX CODE **
         L     R0,WP2POLCR         LOAD POL RUNNING PROG  ** EX CODE **
         B     RCRMSG10            SHOULD NEVER GET HERE  ** EX CODE **
*
RCRMSG09 A     R0,WBALP2GC(R6)     ADD GEN CORE
         LH    R3,WBSLBAL(R5)      BSL
         LA    R2,0
         MH    R3,WBALNB2(R5)      NB2*BSL
         AR    R0,R3               ADD VALUE TO TOTAL
         BAS   R14,RCRCONV         GO TO CONVERT ROUTINE
         MVC   IER964B,WM4TEMP     MOVE STORAGE VALUE INTO MESSAGE
         LM    R0,R1,IER964        IER964I PHASE 2 STORAGE =
         BASR  R14,R15             CALL PRINT ROUTINE
*
*        PHASE 3 - BAL-POL-OSC
*
RCRMSG10 MVI   IER964A,C'3'        MOVE PHASE NO INTO MESSAGE
         EX    0,RCRMSG11(R6)
         B     RCRMSG12            BYPASS EXECUTED CODE
*
RCRMSG11 L     R0,WP3BALCR         BAL TECH   *** EX CODE ***
         L     R0,WP3POLCR         POL TECH   *** EX CODE ***
         L     R0,WP3OSCR          OSC TECH   *** EX CODE ***
*
RCRMSG12 A     R0,WBALP3GC(R6)     ADD GEN CORE
         L     R3,WP3OPBFR         LOAD OUTBFR
         MH    R3,WBALOUT3(R5)     BO*OUT3
         AR    R0,R3               ADD VALUE TO TOTAL
         LH    R3,WBALNB3(R5)      NB3
         SH    R3,WBALOUT3(R5)     NB3-OUT3
         MH    R3,WBSLBAL(R5)      (NB3-OUT3)*BSL
         AR    R0,R3               ADD VALUE TO TOTAL
         BAS   R14,RCRCONV         GO TO CONVERT ROUTINE
         MVC   IER964B,WM4TEMP     MOVE STORAGE VALUE INTO MESSAGE
         LM    R0,R1,IER964        IER964I PHASE 3 STORAGE =
         BASR  R14,R15             CALL PRINT ROUTINE
*
*        MERGE ORDER MESSAGE
*
         LH    R0,WBALMRMX(R5)     LOAD MERGE ORDER
         BAS   R14,RCRCONV         GOTO CONVERT ROUTINE
         MVC   IER965A,WM4TEMP+4   MOVE MERGE ORDER INTO MESSAGE
         LM    R0,R1,IER965        IER965I - MERGE ORDER
         BASR  R14,R15             CALL PRINT ROUTINE
         B     RCRDONE             USELESS INSTRUCTION
*
RCRDONE  LM    R0,R15,WREGSV1      RESTORE REGISTERS
         LA    R15,0
         BR    R14                 RETURN TO IERRCM
*
*        CONVERSION ROUTINE FOR MESSAGE DATA
*
RCRCONV  CVD   R0,WM4DEWK
         MVC   WM4TEMP,EPATTERN    MOVE IN ED PATTERN
         ED    WM4TEMP,WM4DEWK+4   FORMAT DATA WITH ZERO SUPPRESS
         BR    R14                 RETURN TO CALLER
*
WM4TEMP  DC    D'0'                WORK
WM4DEWK  DC    D'0'                AREA
EPATTERN DC    XL8'4020202020202020'   ZERO SUPPRESS ED PATTERN
*
WBALN    DC    CL4'BALN'        *  SORT TYPES
WPOLY    DC    CL4'POLY'        |  FOR
WOSCL    DC    CL4'OSCL'        V  MESSAGES
*
RCRMSGA2 L     R15,VGAPRT          R15 -> IERGAPRT
         L     R9,VIERRCU          R9 -> IERRCU
         LM    R0,R1,IER039        IER039A - INSUFFICIENT STORAGE
         BASR  R14,R15             CALL PRINT ROUTINE
         B     RCRABEND            ABEND
*
RCRMSGA1 L     R15,VGAPRT          R15 -> IERGAPRT
         L     R9,VIERRCU          R9 -> IERRCU
         L     R0,ABRTNMAX         LOAD NMAX
         BAS   R14,RCRCONV         CALL CONVERT ROUTINE
         MVC   IER038A,WM4TEMP     MOVE NMAX
         LM    R0,R1,IER038        IER038I ESTIMATED MAXIMUM RECORDS
         BASR  R14,R15             CALL PRINT RTN
         LM    R0,R1,IER041        IER041A SIZE GREATER THAN EST MAX
         BASR  R14,R15             CALL PRINT RTN
RCRABEND LM    R0,R15,WREGSV1      RESTORE REG
         LA    R15,4               LOAD ABEND CODE
         BR    R14                 RETURN TO RCM
*
*        THIS CODE COULD NOT FIT IN RCS. THEREFORE BRANCH TO IT
*        FROM RCS VIA A BAL INSTRUCTION AND RETURN IMMEDIATELY
*
*        CHECK FOR VBS RECORDS
*
RCS0204A CPITEST  CPIMVSI          VBS INPUT ?
         BZ    RCS0220             NO
         AH    R0,CPIRCDL1         ADD SIZE OF MAX RECORD LENGTH
RCS0220  CPITEST  CPIMVSO          VBS OUTPUT
         BZ    RCS0221             NO
         AH    R2,CPIRCDL2         ADD SIZE OF MAX SORT RECORD LENGTH
*
*        CHECK FOR CHECKPOINT/RESTART
*
RCS0221  CPITEST  CPICHKPT         CHECKPOINT INDICATED ?
         BZ    RCS0222             NO
         AH    R0,KCHK             ADD SIZE OF MODULE TO PHASE 1
         AH    R1,KCHK             ADD SIZE OF MODULE TO PHASE 2
         AH    R2,KCHK             ADD SIZE OF MODULE TO PHASE 3
RCS0222  BR    R14                 RETURN TO MAIN LINE IN RCS
*
*        CHECK FOR VBS RECORDS
*
RCS0402  CPITEST  CPIMVSI          VBS INPUT ?
         BZ    RCS0402A            NO
         AH    R0,CPIRCDL1         ADD SIZE OF MAX RECORD LENGTH
RCS0402A CPITEST  CPIMVSO          VBS OUTPUT ?
         BZ    RCS0402B            NO
         AH    R2,CPIRCDL2         ADD SIZE OF MAX SORT RECORD LENGTH
*
*        CHECK FOR CHECKPOINT/RESTART
*
RCS0402B CPITEST  CPICHKPT         CHECKPOINT INDICATED ?
         BZ    RCS0402C            NO
         AH    R0,KCHK             ADD SIZE OF MODULE TO PHASE 1/2
         AH    R1,KCHK             ADD SIZE OF MODULE TO PHASE 3
RCS0402C BR    R14                 RETURN TO MAIN LINE CODE IN RCS
*
*        CHECK FOR VBS RECORDS
*
RCS0807A CPITEST  CPIMVSI          VBS INPUT ?
         BZ    RCS0807B            NO
         AH    R0,K08              ADD 8 BYTES FOR GETMAIN LIST
RCS0807B B     0(R15,R14)          RETURN TO MAIN LINE CODE GOTO
*                                  PROPER TECH
*
*        CHECK FOR VBS RECORDS
*
RCS1006A CPITEST  CPIMVSO          VBS OUTPUT ?
         BZ    RCS1006B            NO
         AH    R0,K08              ADD 8 BYTES FOR GETMAIN LIST
RCS1006B BR    R14                 RETURN TO MAIN LINE CODE IN RCS
*
*        CONSTANTS
*
*
*        TAPE CAPACITY
*
*        (2300 FT * 12 INCHES) * (DENSITY) / 1000 SCALING FACTOR
*
KBITSMAX DC    F'44160'            9 TRK - 1600 BPI CAPACITY
KIRG     DC    H'1280'             9 TRK - 1600 BPI IRG CHARACTERS

*
K01      DC    H'1'                CONSTANT
K02      DC    H'2'                CONSTANT
K03      DC    H'3'                CONSTANT
K04      DC    H'4'                CONSTANT
K06      DC    H'6'                CONSTANT
K08      DC    H'8'                CONSTANT
K09      DC    H'9'                CONSTANT
K10      DC    H'10'               CONSTANT
K12      DC    H'12'               CONSTANT
K16      DC    H'16'               CONSTANT
K17      DC    H'17'               CONSTANT
K32      DC    H'32'               CONSTANT
K40      DC    H'40'               CONSTANT
K52      DC    H'52'               CONSTANT
K100     DC    H'100'              CONSTANT
K200     DC    H'200'              CONSTANT
K256     DC    H'256'              CONSTANT
K720     DC    H'720'              CONSTANT
K725     DC    H'725'              CONSTANT
K740     DC    H'740'              CONSTANT
K956     DC    H'956'              CONSTANT
K975     DC    H'975'              CONSTANT
K1000    DC    H'1000'             CONSTANT
K1035    DC    H'1035'             CONSTANT
K1670    DC    H'1670'             CONSTANT
K2585    DC    H'2585'             CONSTANT
K10000   DC    H'10000'            CONSTANT
K100000  DC    F'100000'           CONSTANT
KVALUE   DC    F'7200'             PHASE 1 - BAL AND POL
         DC    F'6745'             PHASE 2 - BAL AND POL
         DC    F'7805'             PHASE 3 - BAL AND POL
KVALUE1  DC    F'10790'            PHASE 1 - OSCL
         DC    F'7805'             PHASE 3 - OSCL
KSINGCF  DC    F'0'                PHASE 1 - BAL - POL
         DC    F'80'               PHASE 2 - BAL - POL
         DC    F'80'               PHASE 3 - BAL - POL
KFIXLEN  DC    F'1210'             PHASE 1 - BAL& POL
         DC    F'275'              PHASE 2 - BAL & POL
         DC    F'175'              PHASE 3 - BAL AND POL
KFIXLEN1 DC    F'1660'             PHASE 1 - OSCL
         DC    F'170'              PHASE 3 - OSCL
KVARLEN  DC    F'1025'             PHASE 1 - BAL & POL
         DC    F'375'              PHASE 2 - BAL AND POL
         DC    F'245'              PHASE 3 - BAL AND POL
KVARLEN1 DC    F'1650'             PHASE 1 - OXCL
         DC    F'245'              PHASE 3 - OSCL
KTAPE    DC    F'1240'             PHASE 1 - BAL & POL
         DC    F'2260'             PHASE 2 - BAL & POL
KMODS    DC    F'510'              PHASE 1 - BAL & POL
         DC    F'240'              PHASE 2 - BAL & POL
         DC    F'385'              PHASE 3 - BAL & POL
KMODS1   DC    F'780'              PHASE 1 - OXCL
         DC    F'385'              PHASE 3 - OSCL
*
KGFACTOR DC    H'0'                FILLER
         DC    H'0'                FILLER
         DC    H'150'              MERGE ORDER = 2
         DC    H'166'              MERGE ORDER = 3
         DC    H'175'              MERGE ORDER = 4
         DC    H'180'              MERGE ORDER = 5
         DC    H'183'              MERGE ORDER = 6
         DC    H'183'              MERGE ORDER = 7
         DC    H'187'              MERGE ORDER = 8
         DC    H'187'              MERGE ORDER = 9
         DC    H'190'              MERGE ORDER = 10
         DC    H'190'              MERGE ORDER = 11
         DC    H'191'              MERGE ORDER = 12
         DC    H'192'              MERGE ORDER = 13
         DC    H'192'              MERGE ORDER = 14
KPOLGF   DC    H'193'              DUMMY POLY GFACTOR
         DC    H'193'              MERGE ORDER = 16
         DC    H'160'              BEGINNING OF POLY GFACTORS
         DC    H'175'              MERGE ORDER = 3
         DC    H'180'              MERGE ORDER = 4
         DC    H'185'              MERGE ORDER = 5
         DC    H'190'              MERGE ORDER = 6
         DC    H'195'              MERGE ORDER = 7
*
*        WORK LOCATIONS USED BY THE MODULE
*
ABRTNMAX DC    F'0'                TOP NMAX
WORK     DC    F'0'                W         A
WORK1    DC    F'0'                 O         R
WORK2    DC    F'0'                  R         E
WORK3    DC    F'0'                   K         A
WORK4    DC    F'0'                W
WORK5    DC    F'0'                 O
WORK6    DC    F'0'                  R    A
WORK7    DC    F'0'                   K   R
WORK8    DC    F'0'                       E
WORK9    DC    F'0'                       A
WFULL    DC    F'0'                WORK LOCATION
WFULL1   DC    F'0'                WORK LOC
WFULL2   DC    F'0'                WORK LOC
WFULL3   DC    F'0'                WORK LOC
WFULL4   DC    F'0'                WORK LOC
*
WP1IPBFR DC    F'0'                PHASE 1 INPUT BUFFER SIZE
WP3OPBFR DC    F'0'                PHASE 3 OUTPUT BUFFER SIZE
*
WP1BALCR DC    F'0'                PHASE 1 - BAL - RUNNING CORE
WP2BALCR DC    F'0'                PHASE 2 - BAL - RUNNING CORE
WP3BALCR DC    F'0'                PHASE 3 - BAL - RUNNING CORE
WP1POLCR DC    F'0'                PHASE 1 - POL - RUNNING CORE
WP2POLCR DC    F'0'                PHASE 2 - POL - RUNNING CORE
WP3POLCR DC    F'0'                PHASE 3 - POL - RUNNING CORE
WP12OSCR DC    F'0'                PHASE 12 - OSC - RUNNING CORE
WP3OSCR  DC    F'0'                PHASE 3  - OSC - RUNNING CORE
WP2OSCR  DC    F'0'                PHASE 2 - OSC - CALCULATED VALUE
*
WBALP1GC DC    F'0'                PHASE 1 - BAL - GEN CORE SIZE
WPOLP1GC DC    F'0'                PHASE 1 - POL - GEN CORE SIZE
WOSCP1GC DC    F'0'                PHASE 1 - OSC - GEN CORE SIZE
WBALP2GC DC    F'0'                PHASE 2 - BAL - GEN CORE SIZE
WPOLP2GC DC    F'0'                PHASE 2 - POL - GEN CORE SIZE
WBALP3GC DC    F'0'                PHASE 3 - BAL - GEN CORE SIZE
WPOLP3GC DC    F'0'                PHASE 3 - POL - GEN CORE SIZE
WOSCP3GC DC    F'0'                PHASE 3 - OSC - GEN CORE SIZE
*
WBAL1COR DC    F'0'                BAL - PHASE 1 AVAILABLE CORE
WBAL2COR DC    F'0'                BAL - PHASE 2 AVAILABLE CORE
WBAL3COR DC    F'0'                BAL - PHASE 3 AVAILABLE CORE
WPOL1COR DC    F'0'                POL - PHASE 1 AVAILABLE CORE
WPOL2COR DC    F'0'                POL - PHASE 2 AVAILABLE CORE
WPOL3COR DC    F'0'                POL - PHASE 3 AVAILABLE CORE
WOSC1COR DC    F'0'                OSC - PHASE 12 AVAILABLE CORE
WOSC3COR DC    F'0'                OSC - PHASE 3 AVAILABLE CORE
*
WBAL1AVP DC    F'0'                BAL - P1 AVAIL CORE LESS INP BFRS
WPOL1AVP DC    F'0'                POL - P1 AVAIL CORE LESS INP BFRS
WOSC1AVP DC    F'0'                OSC - P1 AVAIL CORE LESS INP BFRS
WBAL3AVP DC    F'0'                BAL - P3 AVAIL CORE LESS OUT BFRS
WPOL3AVP DC    F'0'                POL - P3 AVAIL CORE LESS OUT BFRS
WOSC3AVP DC    F'0'                OSC - P3 AVAIL CORE LESS OUT BFRS
*
WP2UPDAV DC    F'0'                BAL - UPDATED AVAILABLE CORE
         DC    F'0'                POL - UPDATED AVAILABLE CORE
         DC    F'0'                OSC - UPDATED AVAILABLE CORE
*
WBALNMAX DC    F'0'                BAL - CALCULATED NMAX FOR TECH
WPOLNMAX DC    F'0'                POL - CALCULATED NMAX FOR TECH
WOSCNMAX DC    F'0'                OSC - CALCULATED NMAX FOR TECH
*
WBALGCOR DC    F'0'                BAL - P1 CORE AVAILABLE TO G
WPOLGCOR DC    F'0'                POL - P1 CORE AVAILABLE TO G
WOSCGCOR DC    F'0'                OSC - P1 CORE AVAILABLE TO G
*
WCSPOLS1 DC    F'0'                POL - P1 TOTAL STRINGS - ORIG
WCSPOLS2 DC    F'0'                POL - P1 TOTAL STRINGS - NEW
WEXTRSZ  DC    F'0'                EXTRACT ROUTINE SIZE
WTAVLC   DC    F'0'                TOTAL CORE AVAILABLE TO SORT
WDENTAPE DC    F'0'                MINIMUM WORK TAPE DENSITY
WOSC2AVP DC    F'0'                OSC PHASE 2 AVAIL
WGPRIMEF DC    F'0'                OSC-G PRIME FIXED LENGTH RCDS
WGPRIMEV DC    F'0'                OSC-G PRIME VAR LENGTH RCDS
*
*        HALF WORD LOCATIONS USED BY THE MODULE FOR WORK AREAS
*
WTQIND   DC    H'0'                TECH INDICATOR - PRESENT TECH BEING
*                                  CALCULATED
*                                  0 = BAL, 4 = POL, 8 = OSC
WTQIND1  DC    H'0'                TECH HALF-WORD POINTER
*                                  0 = BAL, 2 = POL, 4 = OSC
WTQCTR   DC    H'0'                NO OF TECHNIQUES TO CALCULATE FOR
*
WNOTECH  DC    H'0'                NO OF TECHNIQUES FOR OPTIMIZATION
W1STTECH DC    H'0'                1ST TECH TO OPTIMIZE FOR
WABRTCTR DC    H'0'                COUNT OF TERMINATED TECHNIQUES
WABRTIND DC    XL1'0'              TERMINATED TECH INDICATORS
*                                  BIT 1 - BAL TECH TERMINATED
*                                  BIT 2 - POL TECH TERMINATED
*                                  BIT 3 - OSC TECH TERMINATED
*                                  BIT 4 - BAL NMAX EXCEEDED
*                                  BIT 5 - POL NMAX EXCEEDED
*                                  BIT 6 - OSC NMAX EXCEEDED
*                                  BIT 7 -
*                                  BIT 8 -
WOPTTECH DC    XL1'0'              TECH TO OPTIMIZE FOR INDICATORS
*                                  BIT 1 - BAL TECHNIQUE
*                                  BIT 2 - POL TECHNIQUE
*                                  BIT 3 - OSC TECHNIQUE
*                                  BITS 4 - 7  -
*
WRECIND  DC    H'0'                RECORD FORMAT INDIC (0=VAR, 4= FIX)
WCHNIND  DC    H'0'                CHANNEL CONFIGURATION INDIC
WCHNIND1 DC    H'0'                CHANNEL STATUS - PHASE 1
WCHNIND2 DC    H'0'                CHANNEL STATUS - PHASE 2
WCHNIND3 DC    H'0'                CHANNEL STATUS - PHAS3 2
*
WBALBS   DC    H'0'                BAL - SORT BLOCKING (BS)
WPOLBS   DC    H'0'                POL - SORT BLOCKING (BS)
WOSCBS   DC    H'0'                OSC - SORT BLOCKING (BS)
*
WBALG    DC    F'0'                BAL - TECHNIQUE G VALUE
WPOLG    DC    F'0'                POL - TECHNIQUE G VALUE
WOSCG    DC    F'0'                OSC - TECHNIQUE G VALUE
*
WBSLBAL  DC    H'0'                BAL - SORT PHASE BUFFER SIZE (BSL)
WBSLPOL  DC    H'0'                POL - SORT PHASE BUFFER SIZE (BSL)
WBSLOSC  DC    H'0'                OSC - SORT PHASE BUFFER SIZE (BSL)
*
WBALMRMX DC    H'0'                BAL - MERGE MAX
WPOLMRMX DC    H'0'                POL - MERGE MAX
WOSCMRMX DC    H'0'                OSC - MERGE MAX
WBALMRAL DC    H'0'                BAL - MERGE ALTERNATE
*
WBALNB1  DC    H'0'                BAL - TOTAL PHASE 1 BUFFERS IN/OUT
WPOLNB1  DC    H'0'                POL - TOTAL PHASE 1 BUFFERS IN/OUT
WOSCNB1  DC    H'0'                OSC - TOTAL PHASE 1 BUFFERS IN/OUT
*
WBALINP1 DC    H'0'                BAL - NO PHASE 1 INPUT BUFFERS
WPOLINP1 DC    H'0'                POL - NO PHASE 1 INPUT BUFFERS
WOSCINP1 DC    H'0'                OSC - NO PHASE 1 INPUT BUFFERS
*
WBALNB2  DC    H'0'                BAL - TOTAL NO PHASE 2 BFRS (I/O)
WPOLNB2  DC    H'0'                POL - TOTAL NO PHASE 2 BFRS (I/O)
WOSCNB2  DC    H'0'                OSC - TOTAL NO PHASE 2 BFRS (I/O)
*
WBALOUT2 DC    H'0'                BAL - NO PHASE 2 OUTPUT BUFFERS
WPOLOUT2 DC    H'0'                POL - NO PHASE 2 OUTPUT BUFFERS
WOSCOUT2 DC    H'0'                OSC - NO PHASE 2 OUTPUT BUFFERS
*
WBALNB3  DC    H'0'                BAL - TOTAL PHASE 3 BUFFERS IN/OUT
WPOLNB3  DC    H'0'                POL - TOTAL PHASE 3 BUFFERS IN/OUT
WOSCNB3  DC    H'0'                OSC - TOTAL PHASE 3 BUFFERS IN/OUT
*
WBALOUT3 DC    H'0'                BAL - NO PHASE 3 OUTPUT BUFFERS
WPOLOUT3 DC    H'0'                POL - NO PHASE 3 OUTPUT BUFFERS
WOSCOUT3 DC    H'0'                OSC - NO PHASE 3 OUTPUT BUFFERS
*
WBALIOB1 DC    H'0'                BAL - P1 IOB STORAGE
WPOLIOB1 DC    H'0'                POL - P1 IOB STORAGE
WOSCIOB1 DC    H'0'                OSC - P1 IOB STORAGE
*
WBALDCB1 DC    H'0'                BAL - P1 DCB STORAGE
WPOLDCB1 DC    H'0'                POL - P1 DCB STORAGE
WOSCDCB1 DC    H'0'                OSC - P1 DCB STORAGE
*
WBALIOB2 DC    H'0'                BAL - P2 IOB STORAGE
WPOLIOB2 DC    H'0'                POL - P2 IOB STORAGE
WOSCIOB2 DC    H'0'                OSC - P2 IOB STORAGE
*
WBALDCB2 DC    H'0'                BAL - P2 DCB STORAGE
WPOLDCB2 DC    H'0'                POL - P2 DCB STORAGE
WOSCDCB2 DC    H'0'                OSC - P2 DCB STORAGE
*
WBALIOB3 DC    H'0'                BAL - P3 IOB STORAGE
WPOLIOB3 DC    H'0'                POL - P3 IOB STORAGE
WOSCIOB3 DC    H'0'                OSC - P3 IOB STORAGE
*
WBALDCB3 DC    H'0'                BAL - P3 DCB STORAGE
WPOLDCB3 DC    H'0'                POL - P3 DCB STORAGE
WOSCDCB3 DC    H'0'                OSC - P3 DCB STORAGE
*
WBREELS  DC    H'0'                BAL - MAX REELS OF INPUT
WPREELS  DC    H'0'                POL - MAX REELS OF INPUT
WOREELS  DC    H'0'                OSC - MAX REELS OF INPUT
*
WCSSWA   DC    XL2'0'              SWITCH A
*                                    BIT 1 - SW 1
*                                    BIT 2 - SW 2
*                                    BIT 3 - SW 3
*                                    BIT 4 - SW 4
*                                    BIT 5 - SW 5
*                                    BIT 6 - SW 6
*                                    BIT 7 - SW 7
*                                    BIT 8 - SW 8
*
WCSSWB   DC    XL2'0'              SWITCH B
*                                    BIT 1 - SW 9
*                                    BIT 2 - SW 10 - TECH FORCED
*                                    BIT 3 - SW 11 - FILE GIVEN/EST
*                                    BIT 4 - SW 12 - FILE ESTIMATED
*                                    BIT 5 - SW 13 - FILE EXACT
*                                    BIT 6 - SW 14 - PHASE 1 - OSC-E25
*                                    BIT 7 - SW 15 - INPUT & WORK
*                                              NOT SAME CHANNEL
*                                    BIT 8 - SW 15 - OUTPUT AND WORK
*                                              NOT SAME CHANNEL
*
WCSSWC   DC    XL2'0'              SWITCH C
*                                    BIT 1 - SW 17 - POL 8 WAY NETWORK
*                                    BIT 2 - SW 18 - BAL 8 WAY NETWORK
*                                    BIT 3 - SW 19 - OSC 8 WAY NETWORK
*                                    BIT 4 - SW 20
*                                    BIT 5 - SW 21
*                                    BIT 6 - SW 22 - OSC TECH FORCED
*                                    BIT 7 - SW 23 - BAL TECH FORCED
*                                    BIT 8 - SW 24 - POL TECH FORCED
*
WBALEXT1 DC    H'0'                BAL - SIZE OF EXT FIELD
WPOLEXT1 DC    H'0'                POL - SIZE OF EXT FIELD
WOSCEXT1 DC    H'0'                OSC - SIZE OF EXT FIELD
WBALEXT3 DC    H'0'                BAL - SIZE OF EXT FIELD
WPOLEXT3 DC    H'0'                POL - SIZE OF EXT FIELD
WOSCEXT3 DC    H'0'                OSC - SIZE OF EXT FIELD
WBALEXT  DC    H'0'                BAL - SIZE OF EXTRACT ROUTINE
WPOLEXT  DC    H'0'                POL - SIZE OF EXTRACT ROUTINE
WOSCEXT  DC    H'0'                OSC - SIZE OF EXTRACT ROUTINE
WMVRTSZ1 DC    H'0'                PHASE 1 MOVE ROUTINE SIZE
WMVRTSZ3 DC    H'0'                PHASE 3 MOVE ROUTINE SIZE
*
WDIFFCTR DC    H'0'                OSC - NO OF ENTRIES IN DIFF TABLE
WIRGTAPE DC    H'0'                MINIMUM DENSITY IRG NO CHARACTERS
*
RCRSW    DC    H'0'                BAL TECHNIQUE SWITCH
RCRIND   DC    H'0'                ODD/EVEN PASS INDICATOR
RCRSAVE  DC    F'0'                STORAGE FOR NO STRINGS IN
RCRMRGMX DC    F'0'                STORAGE FOR MRG MAX
RCRMRGAL DC    F'0'                STORAGE FOR MRG ALT
RCRNRCDS DC    F'0'                STORAGE FOR NO RECORDS IN
RCRCORRQ DC    F'0'                CORE REQUIRED FOR NEW G AND TREE
WSTRORIG DC    F'0'                ORIGINAL STR COUNT - UNOPTIMIZED
WSQCTRSV DC    F'0'                STORAGE FOR LAST LOWER SEQ COUNT
WTPRIMEV DC    F'0'                TREE PRIME VAR LENGTH RECORDS
WTPRIMEF DC    F'0'                TREE PRIME FIXED LENGTH RECORDS
WBALTREE DC    F'0'                BAL TECH ACTUAL TREE VALUE
WPOLTREE DC    F'0'                POL TECH ACTUAL TREE VALUE
WOSCTREE DC    F'0'                OSC TECH ACTUAL TREE VALUE
WSCNNB1  DC    F'0'                NUMBER OF NB1
WSCNNB2  DC    F'0'                NB2 VALUE
WSCNNB3  DC    F'0'                PHASE 3 # OF BUFS
WSCNBSL  DC    F'0'                BLOCK SIZE
WSCNP    DC    F'0'                NUMBER OF PASSES
WADRKP   DC    F'0'                SAVE LOCATION FOR RETURN ADDR
WTEMPSV  DC    3F'0'               REG SAVE AREA
WRCRSCOL DC    F'0'                OL FACTOR
WRCRSCBE DC    F'0'                BE FACTOR
WRCRSCT  DC    F'0'                T CALCULATION
WOSCSCN  DC    F'0'                SCN VALUE - FINAL
WOSCSCN1 DC    F'0'                SCN VALUE - UNOPTIMIZED
WOSCSCN2 DC    F'0'                SCN VALUE - OPTIMIZED
WBALSCN  DC    F'0'                SCN VALUE - FINAL
WPOLSCN  DC    F'0'                SCN VALUE - FINAL
WBALSCN1 DC    F'0'                SCN VALUE - UNOPTIMIZED
WPOLSCN1 DC    F'0'                SCN VALUE - UNOPTIMIZED
WBALSCN2 DC    F'0'                SCN VALUE - OPTIMIZED
WPOLSCN2 DC    F'0'                SCN VALUE - OPTIMIZED
WBALP1   DC    F'0'                BAL NO PASSES UN-OPTIMIZED
WPOLP1   DC    F'0'                POLY ORIG PASSES
WOSCP1   DC    F'0'                OSC NO PASSES UN-OPTIMIZED
WBALP2   DC    F'0'                OPT BAL NO OF PASSES
WPOLP2   DC    F'0'                OPT POLY NO OF PASSES
WOSCP2   DC    F'0'                NO PASSES - OPTIMIZED
WBALS1   DC    F'0'                STRINGCOUNT
WPOLS1   DC    F'0'                ORIG POLY STRING COUNT
WPOLS2   DC    F'0'                OPT POLY STRING COUNT
WNEWGCOR DC    F'0'                GCOR FOR OPTIMIZED B & G
WBAOBS   DC    H'0'                OPTIMIZED BS
WRECINCR DC    H'0'                RECORD INCREMENT ( FIXED = +4,
*                                  VARIABLE = +8)
WBALK    DC    H'0'                BAL - TECH K FACTOR
WPOLK    DC    H'0'                POL - TECH K FACTOR
WOSCK    DC    H'0'                OSC - TECH K FACTOR - VARIABLE RCDS
WBALNWKU DC    H'0'                BAL - NO OF WORK UNITS AVAILABLE
WPOLNWKU DC    H'0'                POL - NO OF WORK UNITS AVAILABLE
WOSCNWKU DC    H'0'                OSC - NO OF WORK UNITS AVAILABLE
KCHK     DC    H'200'              SIZE OF CHECKPOINT MODULE
WBAONB1  DC    H'0'                OPTIMISED TOTAL NO OF BFFRS
WSCNINP1 DC    F'0'                SELECTION INPUT BFRS
WBAOINP1 DC    F'0'                OPTIMIZED INPUT BUFFERS
WOBTREE  DC    F'0'                OPTIMIZED TREE
WNEWOBSL DC    F'0'                NEW OPT TEEE
WNEWBS   DC    F'0'                NEW OPTIMIZED BS
WNEWG    DC    F'0'                NEW OPTIMIZED G
WNEWSTRA DC    F'0'                DIFFERENCE TABLE - 1ST ADDR
WNEWSTRB DC    F'0'                DIFFERENCE TABLE - 2ND ADDR
WNEWG1A  DC    F'0'                NEW G TABLE - 1ST ADDR
WNEWG1B  DC    F'0'                NEW G TABLE - 2ND ADDR
WNEWT1A  DC    F'0'                NEW TREE TABLE - 1ST ADDR
WNEWT1B  DC    F'0'                NEW TREE TABLE - 2ND ADDR
WNP1CRQA DC    F'0'                NEW REQ PHASE 1 CORE TABLE - 1ST
*                                  ADDR
WNP1CRQB DC    F'0'                NEW REQ PHASE 1 CORE TABLE - 2ND
*                                  ADDR
WMRGMXA  DC    F'0'                MERGE MAX TABLE - 1ST ADDR
WMRGMXB  DC    F'0'                MERGE MAX TABLE - 2ND ADDR
WLOOPCT  DC    F'0'                LOOP COUNT SAVE LOCATION
WMRGMX   DC    16F'0'              OSC MERGE MAX TABLE AREA
WSTR1    DC    16F'0'              UN-OPTIMIZED STRING COUNT AREA
WSTR2    DC    16F'0'              OPTIMIZED STRING COUNT AREA
WNEWSTR  DC    16F'0'              NEW STRING COUNT TO SAVE PASS
WSUBP1   DC    16F'0'              UN/OPTIMIZED SUB-PASS COUNT AREA
WSUBP2   DC    16F'0'              OPTIMIZED SUB-PASS COUNT AREA
WNEWG1   DC    16F'0'              NEW G NEEDED TO SAVE PASS
WNEWT1   DC    16F'0'              NEW TREE SIZE FOR NEW G
WNP1CRQ  DC    16F'0'              PHASE 1 CORE REQUIRED FOR NEW G
WSUBTOT  DC    F'0'                SUB-PASS TOTAL COUNT
WGCAL    DC    F'0'                NEW CALCULATED G
WNMXCAL  DC    F'0'                NEW CALCULATED NMAX
WNEWCOR  DC    F'0'                NEW CORE AVAILABLE TO OPTIMIZATION
WRMAX    DC    F'0'                NEW CALCULATED RMAX
WRMAX1   DC    F'0'                OLD CALCULATED RMAX
WRMAX2   DC    F'0'                UPDATED PRESENT RMAX
WMRMXKP  DC    F'0'                MERGE MAX SAVE LOCATION
WOSCRMAX DC    F'0'                FINAL TECH RMAX
WFILSZ   DC    F'0'                USER FILE SIZE
WREM     DC    F'0'                PARTIAL REEL REMAINDER
WREM1    DC    F'0'                PARTIAL REEL REMAINDER
WREM2    DC    F'0'                PARTIAL REEL REMAINDER
WGAAA    DC    F'0'                RMAX - WORK AREA
WONB1    DC    F'0'                OPTIMIZED TOTAL NO PHASE 1 BFRS
WONB2    DC    F'0'                OPTIMIZED TOTAL NO PHASE 2 BFRS
WONB3    DC    F'0'                OPTIMIZED TOTAL NO PHASE 3 BFRS
WOBSL    DC    F'0'                SIZE OF OPTIMIZED SORL BUFFER
WOPASS   DC    F'0'                ACTUAL FULL PASSES OF FILE
WOBS     DC    F'0'                SIZE OF OPTIMIZED SORT BLOCKING
WOINP1   DC    F'0'                OPTIMIZED NO PHASE 1 INPUT BFRS
WOOUT2   DC    F'0'                OPTIMIZED NO PHASE 2 OUTPUT BFRS
WOOUT3   DC    F'0'                OPTIMIZED NO PHASE 3 OUTPUT BFRS
WOTREE   DC    F'0'                OPTIMIZED TREE VALUE
WDIFFSV  DC    H'0'                SAVE LOCATION FOR UPDATED DIFFCTR
WPTRSV   DC    H'0'                SAVE LOCATION FOR UPDATED TABLE PTR
WRCDPLUS DC    F'0'                SIZE OF 1 RCD PLUS INCREMENT
WOLDLEV  DC    H'0'                OLD FIB LEVEL
WNEWLEV  DC    H'0'                NEW FIB LEV
WOLDTSTR DC    H'0'                OLD TOTAL # OF STRINGS PASSES
WNEWTSTR DC    H'0'                NEW TOTAL # OF STRINGS PASSES
WNEWSTRF DC    H'0'                POLY NEW NO OF STRINGS
WOLDSTRF DC    H'0'                ORIG NO OF STRINGS AT FIB LEVEL
WFIBSAVE DC    2F'0'               M AND # STRINGS
WFIBWRK1 DC    16H'0'              WORK AREAS
WFIBWRK2 DC    16H'0'              FOR
WFIBWRK3 DC    16H'0'              FIBONACCI
WFIBWRK4 DC    16H'0'              CALCULATIONS
WNOTERM  DC    H'0'                NUMBER TECHS ELIMINATED
*
VGAPRT   DC    V(IERGAPRT)         PRINT ROUTINE
VIERRCU  DC    V(IERRCU)           MESSAGE MODULE
*
./ ADD NAME=IERBGB   0101-20211-20211-1200-01107-01107-00000-RELEASE 00
BGB      TITLE 'IERBGB - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERBGB
*
*        MODULE FUNCTION/OPERATION -
*        CRCX SORT TECHNIQUE -
*        CALCULATE SORT BLOCKING FACTOR, B
*        THE NUMBER OF RECORDS, G, CONTAINED IN THE RECORD STORAGE
*        AREA, RSA
*        FOR VBS RECORDS AN INPUT SPACE FOR A WORKAREA IS
*        CONSIDERED
*
*        MACROS USED - SMCPI
*
*        ENTRY POINTS - IERBGB - FROM IERRCM
*                       CALLING SEQUENCE -
*                       BAL R14,V(IERBGB)
*
*        CPI FIELDS REFERENCED AS INPUT -
*        CPILAB07 - LENGTH OF EXTRACTED CONTROL FIELD FROM IERRC2
*        CPIEXTSZ - EXTRACT ROUTINE SIZE
*        CPICNTL  - MODS OR NO MODS
*                 - VBS INPUT OR FIXED
*        CPIRCDL1 - RECORD LENGTH
*        CPIRCDL2 -
*        CPIRCDL3 -
*        CPIRCDL4 -
*        CPIRCDL5 -
*        CPITAVLC - TOTAL AVAILABLE STORAGE FOR S/M
*        CPINWKU  - NUMBER OF WORK UNITS
*        CPIP1RSZ - SIZE OF PHASE 1 USER MODS
*        CPIP2RSZ - SIZE OF PHASE 2 USER MODS
*        CPIP3RSZ - SIZE OF PHASE 3 USER MODS
*        CPIIPBLK - INPUT BLOCKING - PHASE 1
*        CPIOPBLK - OUTPUT BLOCKING - PHASE 2
*        CPIBINSZ - BIN SIZE CALCULATION
*
*        CPICNTL - 1. FIXED OR VARIABLE
*                - 2. CRCX TECHNIQUE
*                - 3. EQUALS OR EXTRACT ROUTINE
*                - 4. CHANNEL ENVIRONMENT
*                - 5. WORD ALIGNMENT
*                - 6. LRECL LE OR GT 256
*
*        CPI FIELDS REFERENCED AS OUTPUT -
*        CPISRTBL - B  CALCULATED
*        CPISRTG  - G  CALCULATED
*        CPILAB03 - PHASE 1 INPUT BUFFER SIZE AND NUMBER OF INPUTS
*        CPILAB07 - PHASE 2 BUFFER SIZE AND NUMBER OF OUTPUT BUFFERS
*        CPILAB09 - PHASE 3 OUTPUT BUFFER SIZE AND NUMBER OF OUTPUTS
*        CPIBUF23 - PHASE 2 AND 3 TOTAL BUFFERS
*        CPIMRGMX - MAXIMUM MERGE ORDER
*        CPIMRGAL - ALTERNATE MERGE ORDER
*        CPICNTL  - 1 - 8 OR 8 - 16 WAY NETWORK
*        CPIBUF1  - TOTAL BUFFERS PHASE 1
*        CPIP1GC  - SIZE OF PHASE 1 GENERATED STORAGE
*        CPIP2GC  - SIZE OF PHASE 2 GENERATED STORAGE
*        CPIP3GC  - SIZE OF PHASE 3 GENERATED STORAGE
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL - EXIT TO IERRCM
*                         LA  15,0
*                         BR  14
*
*        EXITS - ERROR - FOR INSUFFICIENT STORAGE AVAILABLE
*                        EXIT TO IERRCM WITH RETURN CODE OF 4
*                        LA  15,4
*                        BR  14
*
*        TABLES / WORK AREAS -
*        TABCONT TABLE OF CONSTANTS USED
*
IERBGB   CSECT
*
         USING *,R15
*
         USING IERRC5,R13          CPI MODULE BASE REG
*
         IERENTRY 'IERBGB &SYSDATE &SYSTIME'
*
         STM   R14,R12,12(R12)     USE SAVE AREA PROVIDED BY IERRCM
         DROP  R15                 FREE R15
         LR    R11,R15
         USING IERBGB,R11          BASE REGISTER = R11
         ST    R12,SAVER12         SAVE SAVEAREA ADDR
         CPISETOF CPIBALN-CPIPOLY-CPIOSC  ALL TECHNIQUE FLAGS
*                                  OTHER THAN CRCX ARE TURNED OFF
         LH    R15,CPILAB07        L'EXTRACTED CONTROL FIELD
         LA    R15,8(,R15)         + 8  FOR GENERATED STORAGE
         STH   R15,KLCF            STORE AND SAVE NEW LENGTH
*
*        INITIALIZE REGISTERS
*
BGBINIT  LA    R15,4               FIXED LENGTH RECORDS R15 = 4
         CPITEST  CPIFIX           RECFM=F ?
         BO    BGBINITA            YES, BRANCH
         AR    R15,R15             VARIABLE RECORDS     R15 = 8
BGBINITA LH    R14,CPINWKU         NUMBER OF WORK UNITS
         BCTR  R14,0               -1 TO SET MERGE ORDER
         STC   R14,CPIMRGMX        STORE MERGE MAXIMUM
         STC   R14,CPIMRGAL        STORE ALTERNATE MERGE ORDER
         STH   R14,WMERGE          STORE WORKING MERGE COUNT
*
*        C A L C U L A T I O N    O F    R U N N I N G
*
*                P R O G R A M    S I Z E S
*
*                                              PHASES 1/2   PHASE 3
*        FIXED VALUE                             10,000      6,000
*        FIXED LENGTH RECORDS                       900        175
*        VARIABLE LENGTH RECORDS                  1,700        250
*        SINGLE CONTROL FIELD WITH
*                FIXED LENGTH RECORDS             1,775
*                VARIABLE LENGTH RECORDS            950
*                8-WAY NETWORK                    1,100      1,100
*                16-WAY NETWORK                   1,750      1,750
*        MULTIPLE CONTROL FIELDS WITH
*                FIXED LENGTH RECORDS             1,825
*                VARIABLE LENGTH RECORDS          1,050
*                8-WAY NETWORK                    1,000      1,000
*                16-WAY NETWORK                   1,700      1,700
*        USER EXITS INCLUDED                      1,100        425
*
*
         LH    R1,KVALUE12         R1 = PHASES 1/2 STORAGE REQUIREMENTS
         LH    R2,KVALUE3          R2 = PHASE 3 STORAGE REQUIREMENTS
         SR    R0,R0
         ICM   R0,B'0111',CPIP1RSZ    PHASE 1 USER WRITTEN MODS
         AR    R1,R0                  ADD USER MODE SIZE TO TOTAL
         ICM   R0,B'0111',CPIP2RSZ    PHASE 2 USER WRITTEN MODS
         AR    R1,R0                  ADD USER MODE SIZE TO TOTAL
         ICM   R0,B'0111',CPIP3RSZ    PHASE 3 USER WRITTEN MODS
         AR    R2,R0                  ADD USER MODE SIZE TO TOTAL
         CPITEST  CPISCF           SINGLE CONTROL FIELD ?
         BZ    BGBMULTF            NO, BRANCH
         CH    R15,KH4             FIXED LENGTH RECORDS ?
         BNE   BGBVARS             NO, BRANCH
*
*        SINGLE CONTROL FIELD/FIXED LENGTH
*
         AH    R1,KSINFIX
         AH    R1,KFIXED12         FIXED LENGTH RECORDS, PHASES 1/I
         AH    R2,KFIXED3          FIXED LENGTH RECORDS, PHASE 3
         B     BGBNETWK            DETERMINE NETWORK
*
*        SINGLE CONTROL FIELD/VARIABLE LENGTH
*
BGBVARS  AH    R1,KSINVAR
         AH    R1,KVARY12          VARIABLE LENGTH RECORDS/PHASES 1/2
         AH    R2,KVARY3           VARIABLE LENGTH RECORDS/PHASE 3
*
*        DETERMINE NETWORK
*
BGBNETWK CH    R14,KH8             MERGE ORDER VS 8
         BH    BGB16WAS            MERGE ORDER GREATER THAN 8 CHOSE 16
         AH    R1,K8WAYSIN         8 WAY NETWORK/SINGLE CONTROL FIELD
         AH    R2,K8WAYSIN
         B     BGB8WAY             MERGE ORDER LESS THAN OR EQUAL TO 8
*
BGB16WAS AH    R1,K16WAYS          16 WAY NETWORK/SINGLE CONTROL FIELD
         AH    R2,K16WAYS
         B     BGB16WAY            TURN ON 16 WAY SWITCH
*
*        MULTI FIELD
*
BGBMULTF CH    R15,KH4             FIXED LENGTH RECORDS ?
         BNE   BGBVARM             NO, BRANCH
         AH    R1,KMULFIX          MULTIPLE CONTROL FIELDS/FIXED
         AH    R1,KFIXED12         FIXED LENGTH RECORDS, PHASES1/2
         AH    R2,KFIXED3          FIXED LENGTH RECORDS, PHASE 3
         B     BGBNTWRK            CHECK ORDER OF MERGE
*
*        MULTIPLE CONTROL FIELDS/VARIABLE
*
BGBVARM  AH    R1,KMULVAR
         AH    R1,KVARY12          VARIABLE LENGTH RECORDS, PHASES 1/2
         AH    R2,KVARY3           VARIABLE LENGTH RECORDS, PHASE 3
*
BGBNTWRK CH    R14,KH8             MERGE ORDER VS 8
         BH    BGB16WAM            CHOOSE 16 WAY MERGE
         AH    R1,K8WAYMUL         8-WAY NETWORK/MULTIPLE CONTROL FIELD
         AH    R2,K8WAYMUL
BGB8WAY  CPISETOF CPI16WAY         TURN OFF 16 WAY NETWORK BIT
         CPISETON CPI8WAY          SET 8 WAY NETWORK BIT
         B     BGBUSMOD            CHECK MODS
*
*        16-WAY NETWORK/MULT CONTROL FIELDS
*
BGB16WAM AH    R1,K16WAYM
         AH    R2,K16WAYM
BGB16WAY CPISETOF CPI8WAY          TURN OFF 8-WAY NETWORK BIT
         CPISETON CPI16WAY         SET 16-WAY NETWORK BIT
*
*        PHASE 3 USER MODIFICATIONS ACTIVATED ?
*
BGBUSMOD CPITEST  CPIME31+CPIME35+CPIME37+CPIME38+CPIME61
         BNZ   BGBUSMO1            YES, BRANCH
         CPITEST  CPIME39          PH 3 USER MODIFICATIONS ACTIVATED ?
         BZ    BGBUSMO2            NO, BRANCH
BGBUSMO1 AH    R2,KMODS3           PHASE 3 MODS
*
*        PHASE 1/2 USER MODS ACTIVATED ?
*
BGBUSMO2 CPITEST  CPIME11+CPIME15+CPIME16+CPIME17+CPIME18+CPIME21+00000C
               +CPIME25+CPIME27
         BNZ   BGBUSMO3            YES, BRANCH
*                                  PHASE 1/2  USER MODS ACTIVATED ?
         CPITEST  CPIME28+CPIME61+CPIME19+CPIME29
         BZ    BGBUSMO4            NO
BGBUSMO3 AH    R1,KMODS12          PHASE 1/2 MODS
BGBUSMO4 CPITEST  CPIEQUAL         EQUALS ROUTINE ?
         BZ    BGBUSMO5            NO, BRANCH
         AH    R1,KEQUALS          YES, EQUALS ROUTINE
         AH    R2,KEQUALS
         B     BGBMOVE
*
BGBUSMO5 CPITEST  CPIEXTRT         EXTRACT ROUTINE ?
         BZ    BGBMOVE             NO, NOT EXTRACT
         AH    R1,CPIEXTSZ         EXTRACT ROUTINE
         AH    R2,CPIEXTSZ
BGBMOVE  CPITEST  CPICHKPT         CHECKPOINT REQUESTED ?
         BZ    BGBNOCHK            NO CHECKPOINT
         A     R1,KCHK             ADD SIZE OF CHECKPOINT ROUTINE
         A     R2,KCHK             ADD SIZE OF CHECKPOINT ROUTINE
BGBNOCHK CPITEST  CPIMVSI          VARIABLE BLOCKED SPANNED INPUT ?
         BZ    BGBNVBS1            NO, NOT VBS
         AH    R1,CPIRCDL1
BGBNVBS1 LA    R1,7(,R1)           ALIGN RUNNING PROGRAMS TO DOUBLE WRD
         N     R1,KEIGHT
         ST    R1,WRUNING1         SAVE RUNNING PROGRAM SIZE OF PHASE 1
         MVC   WTAVLC+1(3),CPITAVLC    SAVE STORAGE AVAILABLE VALUE
         MVC   WPH1AVIL+1(3),CPITAVLC  TOTAL STORAGE AVAILABLE TO S/M
         L     R8,WPH1AVIL         CALC STORAGE AVAILABLE TO PHASE 1
         SR    R8,R1               SUBTRACT TOTAL RUNNING PROGRAMS
         ST    R8,WPH1AVIL         REQUIREMENT
         LA    R2,7(,R2)
         N     R2,KEIGHT           ROUND TO DOUBLE WORD
         CPITEST  CPIMVSO          VARIABLE BLOCKED SPANNED OUTPUT ?
         BZ    BGBNVBS2            NO VBS, BRANCH
         AH    R2,CPIRCDL2         SIZE OF WORKAREA FOR VBS
BGBNVBS2 ST    R2,WRUNING3         RUNNING PROGRAM OF PHASE 3
*
*        CALCULATION OF GENERATED STORAGE
*
*        CALCULATE SIZES OF MOVE ROUTINE
*
         SR    R1,R1               CLEAR
         SR    R2,R2               CLEAR
         CPITEST  CPIVAR           RECFM=V ?
         BO    BGBRUNIN            YES, BRANCH
         LA    R3,4                TO ALLOW FOR 3 PHASE CALCULATIONS
BGBMUV1  SR    R4,R4               INITIALIZE TO 0
         EX    0,*+4(R3)        *  ANY USER MODS ?
         B     BGBMUVA          |  BRANCH TABLE FOR PHASE CAL
         CPITEST  CPIME15       |  PHASE 1 - E15 ACTIVATED ?
         CPITEST  CPIME25       |  PHASE 2 - E25 ACTIVATED ?
         CPITEST  CPIME35       |  PHASE 3 - E35 ACTIVATED ?
BGBMUVA  BO    BGBMUV2          V  YES, AN EXIT IS ACTIVATED
         CPITEST  CPILE256         RECORDS <= 256 ?
         BO    BGBNOMUV            YES, BRANCH
BGBMUV2  EX    0,*+4(R3)        *  GET PROPER PHASE RECORD LENGTH
         B     BGBMUV3          |  BR TABLE FOR PHASE CAL
         LH    R4,CPIRCDL2      |  PHASE 1 RECORD LENGTH
         LH    R4,CPIRCDL2      |  PHASE 2
         LH    R4,CPIRCDL3      V  PHASE 3
BGBMUV3  LA    R4,255(,R4)         FOR THE ROUNDERS
         SRL   R4,8                DIVIDE BY 256
         LR    R6,R4               SAVE FOR FUTURE CALCULATION
         MH    R4,KH6              6 BYTES FOR A MVC INSTRUCTION
         LA    R4,2(,R4)           2 BYTES FOR SPECIAL INSTRUCTION
         CH    R6,KH16             NUMBER VS 16
         BNH   BGBNOMUV            BRANCH LE
         SRL   R6,4                DIVIDE BY 16
         MH    R6,KH12             X 12
         AR    R4,R6               TOTAL TABLE SIZE
BGBNOMUV EX    0,*+4(R3)           ADD TO PHASE TOTALS
         B     BGBMUV4     R3 = 0  BR TABLE FOR PHASE CAL
         AR    R1,R4       R3 = 4  PHASE 1  MOVE ROUTINE
         NOPR  0                   ALIGNMENT
         AR    R1,R4       R3 = 8  PHASE 2  MOVE ROUTINE
         NOPR  0                   ALIGNMENT
         B     BGBMUV4A    R3 = 12 BRANCH TO ADD PH3 MOVE AND EXIT LOOP
BGBMUV4  LA    R3,4(,R3)           INCR PHASE SELECTOR
         B     BGBMUV1             CALL NEXT PH1
BGBMUV4A AR    R2,R4               ADD PHASE 3 MOVE ROUTINE
*
*                         PHASE 1 / 2                  PHASE 3
*
* GETMAIN ADDR TABLE     (2M + M/2 + 5)*4              '2M + 3)*4
* GETMAIN SIZE TABLE     (2M + M/2 + 5)*4              '2M + 3)*4
* GETMAIN ADDR AND SIZE TABLES INCREASED WITH 4 BYTES EACH
*                                  IN PHASE 1     IF VBS INPUT
*                                  IN PHASE 3     IF VBS OUTPUT
* INPUT BUFFER TABLE      4 PER / BUFFER                4 PER / BUFFER
* DEBLOCK BUFF TABLE     (CPINWKU + 1)*4                SAME
* DCB ADDR     TABLE     (CPINWKU + 1)*4                SAME
* BLOCK COUNT  TABLE     (CPINWKU + 1)*4                SAME
* SEQUENCE DIS TABLE     (CPINWKU + 1)*48               N/A
* RSA          TABLE     (M +(M+1)/2 + 2)*8             N/A
* FREE TRACK   TABLE     (CPINWKU)*80                   N/A
* UNIT COUNT TABLE       (CPINWKU + 1)*4               N/A
* EXTRACTED CONTROL      (FIELD + 8)CPINWKU             SAME
* TREE                 **SEE FORMULA**                  N/A
* MOVE ROUTINES        ** SEE FORMULA **               SAME
* QSAM DCB                CPIQDCBL                     CPIQDCBL
* IN OUT DCB              CPIQDCBL                     CPIQDCBL
* EXCP DCB               (CPINWKU)*CPIEDCBL          (CPINWKU)*CPIEDCBL
* IOB / ECB              (CPINWKU)*CPIIOBL           (CPINWKU)*CPIIOBL
* CCW  READ               M* 48                        M * 48
* CCW WRITE                  48                        N/A
* IOB ADDR TABLE            N/A                       CPINWKU*4
* MERGE BUFFER TABLE     4 PER BUFFER                  N/A
*
*        CALCULATE STORAGE TOTAL FOR PHASES 1/2 EXCEPT FOR IO AREAS
*
BGBRUNIN SR    R3,R3               CLEAR FOR MULTIPLICATION
         LH    R4,KH32             FOR 2 GETMAIN AND RSA TABLE
         AH    R4,KCCW             ADD MERGE INPUT CCW AMOUNT
         MH    R4,WMERGE           * MERGE ORDER (NO OF WORKAREAS - 1)
         AH    R4,KEXTRA           3*20 FOR GET AND RSA TABLES-8 BUILD
         LH    R6,KLCF             LENGTH OF EXTRACTED CONTROL FIELD
         LA    R6,CPIEDCBL(,R6)    ADD L'DCB FOR EXCP
         LA    R6,CPIIOBL(,R6)     ADD L'IOB FOR PHASE 2
         AH    R6,KFREETRK         ADD FREE TRACK LIST STORAGE AMOUNT
         AH    R6,KSEQU            ADD SEQUENCE DISTRIBUTION
         AH    R6,KTABLE12         ADD FOR 4 TABLES
         MH    R6,CPINWKU          * WORK AREAS
         LA    R6,CPIQDCBL(,R6)    ADD L'SORTIN DCB
         AH    R6,KSEQU            1 EXTRA FOR DISTRIBUTION
         AH    R6,KTABLE12         EXTRAS FOR TABLES
         AH    R6,KRITECCW         FOR 2 WRITE CCW'S
         AR    R4,R6               TOTALS FOR PHASES 1/2  EXCEPT FOR IO
*                                  AND WORKAREA IF VBS
*
*        CALCULATE STORAGE TOTAL FOR PHASE 3 EXCEPT FOR IO AREAS
*
         LH    R6,KLCF             LENGTH OF EXTRACTED CONTROL FIELDS
         LA    R6,CPIEDCBL(,R6)    DCB  FOR EXCP IN PHASE 3
         LA    R6,CPIIOBL(,R6)     IOB + IOB TABLE
         AH    R6,KTABLE12         FOR 4 TABLES IN PHASE 3
         MH    R6,CPINWKU          * WORK AREAS
         AH    R6,KTABLE3          EXTRA FOR TABLES
         LA    R6,24(,R6)          EXTRA FOR GETMAINS
         LA    R6,CPIQDCBL(,R6)    ADD L'DCB SORTOUT
         LH    R8,KGETMAN3         GET MAINS FOR PHASE 3
         AH    R8,KCCW             FOR CCW'S
         MH    R8,WMERGE           * MERGE ORDER (NO OF WORKAREAS - 1)
         AR    R6,R8               TOTAL PHASE 3 GENERATED STORAGE
*                                  EXCEPT FOR IO AND WORKAREA IF VBS
*
*        ALLOW FOR VBS SORTIN/SORTOUT
*
         CPITEST  CPIMVSI          VBS INPUT ?
         BZ    BGBNVBS3            INCREASE GETMAIN ADDR AND SIZE
         LA    R4,8(,R4)           TABLES WITH 4 BYTES EACH
BGBNVBS3 CPITEST  CPIMVSO          VBS OUTPUT ?
         BZ    BGBNVBS4            NO, BRANCH
         LA    R6,8(,R6)
*
*        SAVE GENERATE STORAGE AMOUNTS TO BE UPDATED WITH AMOUNTS
*        FOR THE TREE, BUFFER ADDITIONS AND BUFFER TABLE OF ADDR
*
BGBNVBS4 AR    R4,R1               ADD ACCUM STORE REQUIRED PHASE 1/2
         AR    R6,R2               ADD ACCUM STORE REQUIRED PHASE 3
         ST    R4,WGEN12           TOTAL GENERATED STORAGE - PHASE 1/2
         ST    R6,WGEN3            TOTAL GENERATED STORAGE - PHASE 3
         L     R1,WRUNING1
         AR    R1,R4               RUNNING + GEN STORAGE PHASE 1/2
         L     R2,WRUNING3
         AR    R2,R6               RUNNING + GEN STORAGE PHASE 3
         MVC   WPH3AVIL+1(3),CPITAVLC  GET TOTAL AVAIL STORAGE FOR S/M
         L     R3,WPH3AVIL
         S     R3,WRUNING1         SUBTRACT RUNNING PROGRAM SIZE
         ST    R3,WPH1AVIL
         MVC   CPITAVLC,WPH1AVIL+1  ADJUST TOTAL AVAILABLE STORAGE
         L     R3,WPH3AVIL
         SR    R3,R1               SUBTRACT PHASE 1 RUNNING+GENERA
         ST    R3,WPH1AVIL         SAVE PHASE1 AVAILABLE STORAGE
         ST    R3,WPH2AVIL         SAVE PHASE2 AVAILABLE STORAGE
         L     R3,WPH3AVIL         GET TOTAL AVAILABLE AGAIN
         SR    R3,R2               SUBTRACT PHASE 2 AMOUNTS
         ST    R3,WPH3AVIL         SAVE PHASE 3 AVAILABLE STORAGE
         LH    R4,CPILAB03         INPUT BUFFER LENGTH
         LH    R5,CPILAB09+2       OUTPUT BUFFER LENGTH
*        R15 HAS A VALUE OF 4 FOR FIXED LENGTH RECORDS
*                           8 FOR VARIABLE LENGTH RECORDS
         LA    R12,CPIBLKTB        R12 -> DASD BLKSIZE TABLE
*                                  THIS HAS BEEN CALCULATED FOR THE
*                                  SPECIFIC DASD TYPE SPECIFIED FOR
*                                  THIS SORT EXECUTION. IT IS THE
*                                  MAXIMUM DASD RECORD SIZE FOR THE
*                                  NUMBER OF BLOCKS PER TRACK
BGBAGAIN SR    R6,R6               CLEAR FOR DIVISION
         SR    R7,R7
         ICM   R7,B'0011',0(R12)   GET SORTWK BLOCKSIZE TABLE ENTRY
*                                  END OF TABLE ?
         BZ    BGERROR             YES, INSUFFICIENT STORAGE FOR SORT
*                                  AS NO TABLE ENTRY WAS SMALL ENOUGH
*                                  GIVEN THE STORAGE AVAILABLE
*
*        REDUCE THE MAX DASD RECORD SIZE TO ALLOW FOR THE SORT
*        PER BLOCK OVERHEAD AND ROUNDING TO DOUBLE WORD BOUNDARY
*
         EX    0,*+4(R15)   R15    RECFM=F OR RECFM=V ?
         B     BGBCALCA
*
         S     R7,KF28      EX 4 * FIXED- 8/DISK AD, 8/WRITE RTN, 4/EOS
         S     R7,KF32      EX 8 V VAR- 8/DISK, 8/WRITE, 4/EOS, 4/CC
BGBCALCA CH    R7,CPIRCDL2         DASD RECORD LENGTH < SORT LRECL ?
         BL    BGERROR             YES, BRANCH, SORT RECORD CANNOT
*                                  FIT IN DASD RECORD

         LH    R1,CPIRCDL2         RECORD LENGTH FOR SORT/MERGE PHASE
         B     *(R15)       R15    FIXED OR VARIABLE LENGTH RECORDS
         DR    R6,R1          4    DIVIDE TRACK BLOCK SIZE BY LRECL
*
         NOPR  0              8    DUMMY
         B     *(R15)       R15    RECFM=F OR RECFM=V ?
*
*        SET SORT BLOCKING FACTOR FOR FIXED LENGTH RECORDS
*
         STH   R7,CPISRTBL    4    STORE B FOR FIXED
         B     *(R15)       R15 8  RECFM=F OR RECFM=V ?
         SR    R6,R6          4    FIXED -  CLEAR FOR MULTIPLICATION
*
*        CALCULATE NUMBER OF DATA BYTES IN DASD RECORD
*
         MR    R6,R1          8    B * RECORD LENGTH
         EX    0,*+4(R15)   R15    RECFM=F OR RECFM=V ?
         B     BGBAGCB             UNCONDITIONAL AFTER EXECUTE
*
*        ADD BACK SORT BLOCK DASD OVERHEAD
*
         LA    R7,20(,R7)   EX 4   FIXED- 8/DISK AD, 8/WRITE RTN, 4/EOS
         LA    R7,24(,R7)   EX 8   VAR- 8/DISK, 8/WRITE, 4/EOS, 4/CC
*
*        ALIGN SORT BLOCK LENGTH TO DOUBLE WORD BOUNDARY
*
BGBAGCB  LA    R7,7(,R7)
         N     R7,KEIGHT
*
*        SET SORT BLOCKSIZE
*
         STH   R7,CPILAB07
         EX    0,*(R15)     R15    RECFM=F OR RECFM=V ?
         B     *+8            4    FIXED
         STH   R7,CPISRTBL    8    VARIABLE - SORT B STORED
*
*        ALWAYS TRY FIRST FOR TWO INPUT AND TWO OUTPUT BUFFERS
*        IF THERE IS NOT ENOUGH STORAGE NEXT TRY FOR TWO OF THE
*        SMALLER AND ONE OF THE LARGER BUFFERS. IF STORAGE IS
*        STILL TOO SMALL, NEXT TRY FOR ONE AND ONE
*
*        R4    CPILAB03            INPUT BUFFER LENGTH
*        R7    CPISRTBL            SORT BLOCKSIZE
*
         LA    R10,12        R10   INITIAL VALUE
BGBREDUC LA    R1,0(R4,R7)         INITIALIZE TO 1 INPUT + 1 OUTPUT BUF
         EX    0,*(R10)       0    TO FIND NUMBER OF BUFFERS - PHASE 1
         B     BGBRED00       4    1 INPUT + 1 OUTPUT BUFFERS
         LA    R1,0(R7,R1)    8    1 INPUT + 2 OUTPUT BUFFERS
         LA    R1,0(R1,R1)    12   2 INPUT + 2 OUTPUT BUFFERS
         LA    R1,0(R1,R1)    16   2 INPUT + 2 OUTPUT BUFFERS
         LA    R1,0(R4,R1)    20   2 INPUT + 1 OUTPUT BUFFERS
*
BGBRED00 EX    0,*+4(R10)          TO FIND EXTRAS FOR GENERATED STOR1/2
         B     BGBRED01       0    UNCONDITIONAL
         LA    R5,4           4    4 FOR ONE INPUT BUFFER
         LA    R5,4           8
         LA    R5,8           12   8 FOR TWO INPUT BUFFERS
         LA    R5,8           16
         LA    R5,8           20
BGBRED01 ST    R5,WGENEX12         SAVE EXTRA GENERATED STOR FOR 1/2PHS
         AR    R5,R4               ASSUME 1 INPUT BUFFER IN PHASE 1
*
         EX    0,*(R10)       0    TO FIND NO OF INPUTS(PH1)IN PHASE 2
         B     BGBRED02       4    UNCONDITIONAL
         B     BGBRED02       8    ONLY 1 INPUT BUFFER
         LA    R5,0(R4,R5)    12   2 INPUTS IN PHASE 1
         LA    R5,0(R4,R5)    16   2 INPUTS IN PHASE 1
         LA    R5,0(R4,R5)    20   2 INPUTS IN PHASE 1
*
BGBRED02 ST    R5,WGEXEX02         EXTRAS FOR PHASE 2 ONLY
*
         EX    0,*+4(R10)          TO SAVE TOTAL NUMBER BUFFERS - PHAS1
         B     BGBRED03       0    BR DET BY NO OF BUFFERS
         MVI   CPIBUF1,2      4    2 BUFFER TOTAL
         MVI   CPIBUF1,3      8    3 BUFFER TOTAL
         MVI   CPIBUF1,4      12   4 BUFFER TOTAL
         MVI   CPIBUF1,4      16   4 BUFFER TOTAL
         MVI   CPIBUF1,3      20   3 BUFFER TOTAL
*
*        ROUTINE CALCULATES A 'G' AND STORE IT
*        IT WILL ALSO CALCULATE A TREE SIZE TO BE ADDED TO
*        GENERATED STORAGE, AND THE NUMBER OF BINS PER RECORD IF NOT
*        FIXED LENGTH RECORDS
*
BGBRED03 MVI   WBINS+1,1           ASSUME 1 BIN PER RECORD - FIXED RECD
         L     R8,WPH1AVIL         RUNNING PROGRAMS + GENERATED -PHASE1
         S     R8,WGENEX12         TO FIND AVAILABLE STORAGE PHASE 1
         SR    R8,R1               SUBTRACT STORAGE ALLOCATED FOR
*                                  BUFFERS TO CALC STORAGE AVAILABLE
*                                  FOR RDA AND TREE
         BM    BGBBAD1             INSUFFICIENT STORAGE, ERROR
         LA    R3,8                ASSUME 4* 2M INPUT BUFFERS IN PH 2
         MH    R3,WMERGE           * MERGE ORDER
*                                  = INPUT BUFFER TABLE
         SR    R8,R3               SUBTRACT BUFFER TABLE FROM PH 1 ONLY
         BM    BGBBAD1             INSUFFICIENT STORAGE, ERROR
*                                  COPY RECFM = F OR RECFM=V INDICATOR
         LR    R6,R15              TO ENABLE A DOUBLE CHECK VARIABLE G
*
BGBMODGG SR    R2,R2               INITIALIZE FOR DIVISION
         LR    R3,R8               AMOUNT AVAILABLE TO RSA+ TREE
         MH    R3,KH3              * 3 TO GET RID OF DENOMINATOR OF 3
         LH    R1,CPIBINSZ         BINSIZE
         B     *(R15)              RECFM=F OR RECFM=V ?
         B     BGBRED04        +04 RECFM=F
         BAS   R7,BGBVARYG     +08 BRANCH TO FIND NUMBER OF BINS/RECORD
BGBRED04 MH    R1,KH3              BINSIZE *  3
         SR    R3,R1               G+1 RECORDS IN RSA
         BM    BGBBAD1             INSUFFICIENT STORAGE, ERROR
*
         EX    0,*+4(R15)          FIXED OR VARIABLE
         B     BGBRED05            UNCONDITIONAL
         LA    R3,20(,R3)          20 EXTRA BYTES FOR TREE - FIXED
         LA    R3,36(,R3)          36 EXTRA BYTES FOR TREE - VARIABLE
*
BGBRED05 EX    0,*+4(R15)   R15    FIXED OR VARIABLE
         B     BGBRED06            UNCONDITIONAL
         LA    R1,20(,R1)   4      20 FOR FIXED
         LA    R1,36(,R1)   8      36 FOR VARIABLE
BGBRED06 DR    R2,R1               AVAIL / BINSIZE = G
*
*        CALCULATE ACTUAL TREE SIZE AS PART OF GENERATED STORAGE IN
*        PHASES 1/2. IT IS THEN STORED
*
BGBTREE  B     *(R6)               FIXED OR VAR
         B     BGBRED07        +04 FIXED, CONTINUE
         B     BGBCOMP         +08 VARIABLE, SKIP FIRST TIME THRU
BGBRED07 LR    R0,R3               SAVE G
         CH    R15,KH4             FIXED (R15=4) OR VARIABLE
         BNE   BGBVTREE            BRANCH FOR VARIABLE (R15=8)
         LA    R3,1(,R3)           FORM G+1
         LA    R4,3                TO DIVIDE BY 3
         SR    R2,R2               CLEAR FOR DIVISION
         DR    R2,R4               FORM (G+1)/3 TO ELIMINATE
*                                  ROUNDING. TREE IS (G-1)/3
*                                  ROUNDED UP.
         MH    R3,KH20             MULTIPLY BY 20 GIVES BYTES
         B     BGBST
*
BGBVTREE BCTR  R3,0                FORM G-1
*                                  TREE HAS G-1 NODES
         MH    R3,KH12             MULTIPLY BY 12 GIVES BYTES
         C     R3,KF36             TREE AT LEAST 36 BYTES ?
         BNL   BGBST               IF SO STORE VALUE
BGBTEST  LA    R3,36               LOAD MIN VAR TREE SIZE
         LR    R2,R0               LOAD G
         LA    R2,1(,R2)           G + 1
         MH    R2,WBINS            * NUMBER OF BINS PER RECORD
         MH    R2,CPIBINSZ         FIND SIZE OF RSA
         AR    R2,R3               RSA + TREE SIZE
         LR    R4,R8               AMOUNT AVAILABLE TO RSA + TREE
         SR    R4,R2               NEW TREE SIZE FIT ?
         BNM   BGBST               YES, BRANCH
         BCTR  R0,0                OTHERWISE, DECREMENT G BY ONE
         CH    R0,KH2              NEW G VS. 2
         BL    BGBBAD1             BRANCH IF LOW TO RECALCULATE
         B     BGBTEST             RECALCULATE TO SEE IF IT FITS
*
BGBST    ST    R3,WTREE            STORE TREE SIZE
         LR    R3,R0
BGBCOMP  ST    R3,WSAVG            STORE G
         STCM  R3,B'0111',CPISRTG  G IN CPI
         CH    R3,KH2              G VS 2
         BNL   BGBCHECK            HIGH OR EQUAL ? BRANCH
*
*        THERE IS NOT ENOUGH STORAGE ALLOCATED TO THE SORT
*
BGBBAD1  B     BGERROR             BARNCH TO GENERATE ERROR MESSAGE
*GBBAD1  LH    R4,CPILAB03         RESTORE PH1 INPUT BLOCKING
*        LH    R5,CPILAB09+2       RESTORE PH3 OUTPUT BLOCKING
*        LH    R7,CPILAB07         RESTORE SORT BLOCK SIZE
*        B     *(R10)        R10   BR DET BY CH CONF
*        B     BGBMULT       4     +04 1 MULTIPLEXOR CHANNEL
*        B     BGBSEL1       8     +08 1 SELECTOR
*        B     BGBSEL2       12    +12 2 SELECTOR
*        B     BGBSEL12      20    +16 1 SELECTO4 - 4 BUFFERS
*        B     BGBSEL1       24    +20 1 SELECTOR, OUTPUT > INPUT BUFF
*
BGBMULT  LA    R12,4(,R12)         REDUCES TRACK BLOCKING, INCR TO NEXT
*                                  LOWER VALUE ENTRY IN CPIBLKTB
         LA    R10,12              RESTORE ORIGINAL OVERLAP
         B     BGBAGAIN            RETRY
*
BGBSEL1  LA    R10,4               REDUCES BUFFERS TO 1 AND 1
         B     BGBREDUC            RETRY
*
BGBSEL2  CLR   R4,R7               INPUT BLOCKING VS SORT BLOCKING
         BL    BGB2INP             TRY FOR 2 AND 1
         LA    R10,8               IF OUTPUT < INPUT, TRY FOR 1 AND 2
         B     BGBREDUC            RETRY
*
BGB2INP  LA    R10,20              IF INPUT < OUTPUT, TRY FOR 2 AND 1
         B     BGBREDUC            RETRY
*
BGBSEL12 LA    R10,20              REDUCES BUFFERS TO 2 AND 1
         B     BGBREDUC            RETRY
*
*        CHECK TO SEE THAT B IS NOT LARGER THAN G
*
BGBVARYG SR    R4,R4               CLEAR FOR  DIVISION
         EX    0,*+4(R6)           1ST TIME OR 2ND TIME THROUGH
         B     *+12                UNCONDITIONAL
         LH    R5,CPIRCDL5         2ND TIME - MODAL RECORD LENGTH
         LH    R5,CPIRCDL2         1ST TIME - MAXIMUM RECORD LENGTH
         AH    R5,KH3              + 3
         AH    R5,KLCF             LENGTH OF EXTRACTED CONTROL FIELDS
         SH    R1,KH4              BINSIZE - 4
         DR    R4,R1               (L+3+EXTRACT) / (BINSIZE -4) = BINS
         LA    R5,1(,R5)           FOR THE ROUNDERS
         STH   R5,WBINS            SAVE NO OF BINS/RECORD
         LA    R1,4(,R1)           BINSIZE
         MH    R1,WBINS            FOR VARIABLE LENGTH RECORDS
         B     *(R15)        R15   CONTINUE
         BR    R7            4     RETURN
         NOPR  0                   ALIGNMENT
         STH   R5,WBINSMAX   8     ON FIRST TIME THRU FOR VARIABLE,
         BR    R7                  SAVE G BASED ON MAX RECORD LENGTH
*
*        IF VARIABLE LENGTH RECORDS - G MUST BE LARGE ENOUGH FOR
*        2 MAXIMUM SIZE RECORDS - AND IS CALCULATED FOR MODAL
*        RECORD LENGTH
*
BGBCHECK B     *(R6)               FIXED OR VARIABLE LENGTH RECORDS
         B     BGBCOMBG        +04 FIXED
         LA    R6,4            +08 VARIABLE, TO ALLOW FOR 2 CHECKS
         B     BGBMODGG            GET G FOR VARIABLE MODAL RECORD LGTH
*
BGBCOMBG CH    R10,KH4             1 INPUT AND 1 OUTPUT BUFFER ?
         BE    BGBPH2              YES, BRANCH
         SR    R6,R6               CLEAR FOR DIVISION
         LH    R7,CPISRTBL         R7 = SORT BLOCKING FACTOR
         B     *(R15)              FIXED OR VARIABLE
         B     BGBRED08        +04 FIXED
         LH    R5,CPIRCDL5     +08 MODAL RECORD LENGTH
         SH    R7,KH24             VARIABLE - 24 BYTES FOR EXTRAS
         DR    R6,R5               VARIABLE BLOCK / MODAL REC =  B APX
BGBRED08 CLR   R7,R3               B VS G
         BH    BGBBAD2             B GREATER THAN G - TRY ALL OVER
         LH    R7,CPIIPBLK         TEST INPUT BLOCKING VS G
         SR    R6,R6               CLEAR FOR POSSIBLE DIVISION
         B     *(R15)              FIXED OR VARIABLE
         B     BGBRED09            FIXED
         DR    R6,R5               INPUT BLOCK / MODAL REC = VARY IN B
BGBRED09 CLR   R7,R3               INPUT B VS G
         BNH   BGBPH2              INPUT EQUAL OR LESS THAN G - YES
BGBBAD2  B     *(R10)        R10   CHECK OVERLAP
         B     BGBPH2        4     +04 CANNOT CHANGE OVERLAP
         B     BGBBAD1       8     +08 GET RID OF AN OUTPUT BUFFER
         B     BGBBAD1       12    +12 GET RID OF AN INPUT BUFFER
         B     BGBBAD1       16    +16 GET RID OF AN INPUT BUFFER
         B     BGBBAD1       20    +20 GET RID OF AN OUTPUT BUFFER
*
*        CALCULATE THE TOTAL NUMBER OF SORT BUFFERS AND THE
*        NUMBER OF OUTPUT BUFFERS
*
BGBPH2   L     R3,WTREE            LOAD TREE SIZE
         L     R9,WPH2AVIL         RUNNING PROGRAMS + GENERAL STOR-PH2
         S     R9,WGEXEX02         EXTRA GENERATED STORAGE FOR PHASE 2
         SR    R9,R3               SUBTRACT TREE SIZE TO CALCULATE
*                                  TOTAL BUFFER AREA
         SR    R8,R8               CLEAR FOR DIVISION
         LH    R7,CPILAB07         R7 = SORT BLOCKING ON INPUT SIDE
         LR    R6,R7               FOR OUTPUT BUFFERS
         LA    R7,4(,R7)           4 BYTES FOR ADDRESS OF INPUT BUFFER
         MVI   CPILAB09,1          SET 1 OUTPUT BUFFER PHASE 2
         LA    R5,1                1 OUTPUT BUFFER - SORT PHASE
         LA    R2,4
         CR    R10,R2              TO FIND BYTES FOR OUTPUT BUFFERS
         BE    BGBSUB              IF EQUAL, ONLY ONE OUTPUT BUFFER
         CH    R10,KH20
         BE    BGBSUB              IF EQUAL, ONLY ONE OUTPUT BUFFER
         AR    R6,R6               2 OUTPUT BUFFERS
         MVI   CPILAB09,2          SET NUMBER OF OUTPUT BUFFERS TO 2
         LA    R5,2                2 OUTPUT BUFFER FOR SORT PHASE
BGBSUB   SR    R9,R6               SUBTRACT FROM AVAILABLE STORAGE
         BM    BGBBAD1             MINUS, YES. INSUFFICIENT STOR -REDO
         DR    R8,R7               AVAILABLE / BLOCKING  = NO OF INPUTS
         CLR   R9,R14              NO OF BUFFERS  VS M (MERGE ORDER)
         BL    BGBBAD1             LESS, BRANCH TO TRY NEW ARRANGE
         AR    R14,R14             2 * M
         CLR   R9,R14              NO OF BUFFERS VS 2*M
         BNH   BGBSUB1             LESS  OR EQUAL, BRANCH
         LR    R9,R14              MAXIMUM BUFFERS = 2*M
BGBSUB1  LA    R5,0(R5,R9)         CALC NUMBER OF PHASE 2 BUFFERS
         STC   R5,CPIBUF23         SAVE NUMBER OF PHASE 2 BUFFERS
         LA    R1,4                FOUR PER INPUT BUFFER
         MR    R0,R9               TIMES NUMBER MERGE INPUT BUFFERS
         A     R1,WGENEX12         ADD TO EXTRA GENERATED STORAGE
         ST    R1,WGENEX12
         LH    R2,CPIBINSZ         BIN SIZE
         LH    R1,CPILAB07         SORT BLOCKING
         SH    R1,KH8              - 8
         SR    R0,R0
         DR    R0,R2               BINS WHICH CAN FIT IN A BUFFER
         LH    R14,WMERGE
         MR    R0,R14              TIMES MERGE NUMBER OF BUFFERS
         SR    R9,R14              BUFFERS OVER MERGE ORDER
         MH    R9,CPILAB07         TIMES SIZE OF EACH BUFFER
         AR    R9,R8               ADD REMAINING STORAGE
         SR    R8,R8
         DR    R8,R2               BINS WHICH WILL FIT IN REMAINING COR
         AR    R1,R9               TOTAL BINS WHICH WILL FIT
         B     *(R15)              FIXED OR VARIABLE ?
         B     BGBCOMPA            +04 FIXED
         LH    R2,WBINSMAX         +08 LOAD BINS PER MAX RECORD LENGTH
         DR    R0,R2               G BASED ON MAXIMUM RECORD LENGTH
BGBCOMPA CH    R1,KH3              G+1 STILL > 3?
         BNM   BGBPH3-4            EVERYTHING OK
         CH    R10,KH4             DOWN TO 1 AND 1 LEVEL ?
         BH    BGBBAD1             RECALCULATE USING FEWER BUFFERS
         B     BGERROR             INSUFFICIENT STORAGE
*
*        THE FOLLOWING SECTION ASSURES THAT THE SORT/MERGE IS
*        CAPABLE OF COMPLETING THE FINAL MERGE PHASE. THIS IS
*        POSSIBLE IF M+1 BUFFERS WILL FIT IN PHASE 3
*
         LA    R10,12              SET CHANNEL CONFIGURATION
BGBPH3   L     R9,WPH3AVIL         PHASE 3 AVAILABLE STORAGE
         SR    R8,R8               CLEAR FOR DIVISION
         LA    R5,1                R5 = NO OF OUTPUT BUFFERS, PHASE 3
         LA    R4,4                1 CHANNEL NUMBER
         CLR   R10,R4              1 CHANNEL ?
         BE    BGBPH3              YES
         LA    R5,2                NO
BGBPH3A  STC   R5,CPILAB09+1       SET NO OF OUTPUT BUFFERS, PHASE 3
         LH    R7,CPILAB09+2       R7 = PHASE 3 OUTPUT BUFFER SIZE
BGBPH3B  EX    0,BGBPH3B(R10)  R10 CALC OUTPUT BUFFER STORAGE
         B     BGBPH3C         04  1 OUTPUT BUFFER
         LA    R7,0(R7,R7)     08  L'2 OUTPUT BUFFERS
         LA    R7,0(R7,R7)     0C  L'2 OUTPUT BUFFERS
BGBPH3C  SR    R9,R7               CALC AVAILABLE STORAGE AFTER
*                                  ALLOCATIING THE OUTPUT BUFFERS
         BM    BGBMIN03            NOT ENOUGH STORAGE, BRANCH
         LH    R14,WMERGE          R14 = MAXIMUM MERGE ORDER
         LH    R6,CPILAB07         R6 = SORTWKXX BLOCK SIZE
         LA    R6,4(,R6)           4 BYTES FOR INPUT BUFFER TABLE
         DR    R8,R6               AVAILABLE / BUFFER SIZE  = NO OF INP
         CLR   R9,R14              NO OF INPUT BUFFERS VS M
         BL    BGBMIN03            BRANCH LESS THAN
         LA    R14,0(R14,R14)      2 * M
         CLR   R9,R14              COMPARE NO OF BUFFERS VS 2*M
         BNH   BGBPH3D             MORE BUFFERS THAN 2*M, BRANCH
         LR    R9,R14              EXCHANGE TO 2*M + NO OF OUTPUTS
BGBPH3D  LA    R9,0(R9,R5)
         STC   R9,CPIBUF23+1       STORE TOTAL BUFFERS IN PHASE 3
         MR    R8,R4               FOUR PER INPUT BUFFER
         A     R9,WGEN3            ADD TO TOTAL PHASE 3 GENERATED STOR
         ST    R9,WGEN3
         B     BGBCALCU            CALCULATE TOTAL STORAGE
*
BGBMIN03 EX    0,*+4(R10)
         B     BGBPH3              CAL PH3
         B     BGBBAD1             CANNOT GET M INPUT BUFFERS IN PH 3
         LA    R10,4               SET FOR MINIMUM CONDITION
         LA    R10,4               SET MINIMUM OF M+1 TOTAL BUFFERS
*
*        THIS ROUTINE IS EXTRA AND CALCULATES THE TOTAL AMOUNT
*        OF STORAGE USED IN THE THREE PHASES
*
BGBCALCU L     R1,WGEN12           GENERATED STORAGE, PHASES 1/2
         L     R2,WGEN12
         L     R3,WGEN3            GENERATED STORAGE, PHASE 3
         A     R1,WGENEX12         = 24/OUTPUT CCW, 4/PH1 INPUT BUFFER
         A     R2,WGEXEX02         = WGENEX12 + TOTAL SIZE PH1 INP BUFS
         A     R1,WTREE            SIZE OF TREE
         A     R2,WTREE
         LA    R1,7(,R1)
         N     R1,KEIGHT           ALIGN TO DOUBLE WORD BOUNDARY
         LA    R3,7(,R3)
         N     R3,KEIGHT           ALIGN TO DOUBLE WORD BOUNDARY
         ST    R1,KEIGHT
         MVC   CPIP1GC(3),KEIGHT+1   INITIALIZE PARAMETERS FOR APL, THE
         MVC   CPIP2GC(3),KEIGHT+1   ROUTINE WHICH WILL ISSUE THE
         ST    R3,KEIGHT             GETMAINS
         MVC   CPIP3GC(3),KEIGHT+1
         A     R1,WRUNING1         SIZE OF RUNNING PROGS, PHASES 1/2
         A     R2,WRUNING1
         A     R3,WRUNING3         SIZE OF RUNNING PROGS, PHASE 3
         L     R4,WSAVG            G
         LA    R4,1(,R4)
         MH    R4,WBINS            NUMBER OF BINS PER RECORD
         MH    R4,CPIBINSZ         SIZE OF EACH BIN
         AR    R1,R4
         SR    R5,R5
         IC    R5,CPILAB09         NUMBER OF OUTPUT BUFFERS, PHASES 1/2
         SR    R4,R4
         IC    R4,CPIBUF1          TOTAL NUMBER OF BUFFERS, PHASE 1
         SR    R6,R6
         IC    R6,CPIBUF23         TOTAL BUMBERS OF BUFFERS, PHASE 2
         SR    R4,R5               SUBTRACT NUMBER OF PHASE 1 OUTPUT
*                                  BUFFERS FROM TOAL PH1 BUFFERS
         SR    R6,R5               SUBTRACT NUMBER OF PHASE 2 OUTPUT
*                                  BUFFERS FROM TOTAL PH2 BUFFERS
         MH    R5,CPILAB07         SIZE OF PHASE 1 OUTPUT BUFFERS
         AR    R1,R5
         AR    R2,R5
         MH    R4,CPILAB03         SIZE OF PHASE 1 INPUT BUFFERS
         AR    R1,R4
         MH    R6,CPILAB07         SIZE OF PHASE 2 INPUT BUFFERS
         AR    R2,R6
         SR    R7,R7
         SR    R8,R8
         IC    R7,CPIBUF23+1       TOTAL NUMBER OF PHASE 3 BUFFERS
         IC    R8,CPILAB09+1       NUMBER OF OUTPUT BUFFERS, PHASE 3
         SR    R7,R8               SUBTRACT NUMBER OF PHASE 3 OUTPUT
*                                  BUFFERS FROM TOTAL PH3 BUFFERS
         LR    R9,R7
         SLL   R9,2                FOUR BYTES FOR EACH PH3 INPUT BUF
         AR    R3,R9
         MH    R7,CPILAB07         MULTIPLY BY PH3 INPUT BUFFER SIZE
         MH    R8,CPILAB09+2       MULTIPLY BY PH3 OUTPUT BUFFER SIZE
         AR    R3,R7
         AR    R3,R8
         ST    R1,W1STOR
         ST    R2,W2STOR
         ST    R3,W3STOR
*
*        PRINT  MESSAGES AND VALUES
*
BGBMSG   L     R3,VIERRCU          R3 -> IERRCU MSG TEXT
         USING DIERRCU,R3
*
*        GENERATE IER036I BLOCKING = NNNNN
*
         LH    R1,CPISRTBL         GET BLOCKING FACTOR
         CVD   R1,KCONVERT
         MVC   IER036A,EPATTERN    MOVE IN EDIT PATTERN
         ED    IER036A,KCONVERT+5
         LM    R0,R1,IER036        IER036I BLOCKING
         L     R15,VGAPRT          MESSAGE WRITER ADDR
         BASR  R14,R15             CALL MSG WRITER
*
*        GENERATE IER037I RECORDS IN RSA = NNNNN
*
         SR    R1,R1
         ICM   R1,B'0111',CPISRTG
         CVD   R1,KCONVERT
         MVC   IER037A,EPATTERN    MOVE IN EDIT PATTERN
         ED    IER037A,KCONVERT+5
         LM    R0,R1,IER037        IER037I RECORDS IN RSA
         L     R15,VGAPRT          MESSAGE WRITER ADDR
         BASR  R14,R15             CALL MSG WRITER
*
*        OPTIONALLY GENERATE DIAGNOSTIC MESSAGES
*
         CPITEST  CPIDIAG+CPIDSIM  DIAGNOSTICS ?
         BZ    BGBRET              NO, BRANCH
*
*        GENERATE IER961I SORT TECHNIQUE - XXXX
*
         MVC   IER961A,KCRCX       SET TECHNIQUE
         LM    R0,R1,IER961        IER961I SORT TECHNIQUE - CRCX
         L     R15,VGAPRT          MESSAGE WRITER ADDR
         BASR  R14,R15             CALL MSG WRITER
*
*        GENERATE IER962I PHASE 1 NUMBER OF BUFFERS, BUFFER SIZE
*
         MVI   IER962A,C'1'        SET FOR PHASE 1
         SR    R1,R1
         IC    R1,CPIBUF1          NUMBER OF BUFFERS
         CVD   R1,KCONVERT
         MVC   IER962B,EPATTERN
         ED    IER962B,KCONVERT+6
         LH    R1,CPILAB07         BUFFER SIZE
         CVD   R1,KCONVERT
         MVC   IER962C,EPATTERN
         ED    IER962C,KCONVERT+5
         LM    R0,R1,IER962        IER962I PHASE 1 NUMBER OF BUFFERS
         L     R15,VGAPRT          MESSAGE WRITER ADDR
         BASR  R14,R15             CALL MSG WRITER
*
*        GENERATE IER962I PHASE 2 NUMBER OF BUFFERS, BUFFER SIZE
*
         MVI   IER962A,C'2'        SET FOR PHASE 2
         SR    R1,R1
         IC    R1,CPIBUF23         NUMBER OF PHASE 2 BUFFERS
         CVD   R1,KCONVERT
         MVC   IER962B,EPATTERN
         ED    IER962B,KCONVERT+6
         LH    R1,CPILAB07         BUFFER SIZE
         CVD   R1,KCONVERT
         MVC   IER962C,EPATTERN
         ED    IER962C,KCONVERT+5
         LM    R0,R1,IER962        IER962I PHASE 2 NUMBER OF BUFFERS
         L     R15,VGAPRT          MESSAGE WRITER ADDR
         BASR  R14,R15             CALL MSG WRITER
*
*        GENERATE IER962I PHASE 3 NUMBER OF BUFFERS, BUFFER SIZE
*
         MVI   IER962A,C'3'        SET FOR PHASE 3
         SR    R1,R1
         IC    R1,CPIBUF23+1       NUMBER OF PHASE 3 BUFFERS
         CVD   R1,KCONVERT
         MVC   IER962B,EPATTERN
         ED    IER962B,KCONVERT+6
         LH    R1,CPILAB07         BUFFER SIZE
         CVD   R1,KCONVERT
         MVC   IER962C,EPATTERN
         ED    IER962C,KCONVERT+5
         LM    R0,R1,IER962        IER962I PHASE 3 NUMBER OF BUFFERS
         L     R15,VGAPRT          MESSAGE WRITER ADDR
         BASR  R14,R15             CALL MSG WRITER
*
*        GENERATE IER963 STORAGE = NNNNNNN
*
         L     R1,WTAVLC           AVAILABLE STORAGE (WAS CPITAVLC)
         CVD   R1,KCONVERT
         MVC   IER963A,EPATTERN
         ED    IER963A,KCONVERT+4
         LM    R0,R1,IER963        IER963I STORAGE =
         L     R15,VGAPRT          MESSAGE WRITER ADDR
         BASR  R14,R15             CALL MSG WRITER
*
*        GENERATE IER964 PHASE 1 STORAGE = NNNNNNNN
*
         MVI   IER964A,C'1'        SET FOR PHASE 1
         L     R1,W1STOR           GET ASSIGNED STORAGE
         CVD   R1,KCONVERT
         MVC   IER964B,EPATTERN
         ED    IER964B,KCONVERT+4
         LM    R0,R1,IER964        PHASE 1 STORAGE = NNNNNNNN
         L     R15,VGAPRT          MESSAGE WRITER ADDR
         BASR  R14,R15             CALL MSG WRITER
*
*        GENERATE IER964 PHASE 2 STORAGE = NNNNNNNN
*
         MVI   IER964A,C'2'        SET FOR PHASE 2
         L     R1,W2STOR           GET ASSIGNED STORAGE
         CVD   R1,KCONVERT
         MVC   IER964B,EPATTERN
         ED    IER964B,KCONVERT+4
         LM    R0,R1,IER964        PHASE 2 STORAGE = NNNNNNNN
         L     R15,VGAPRT          MESSAGE WRITER ADDR
         BASR  R14,R15             CALL MSG WRITER
*
*        GENERATE IER964 PHASE 3 STORAGE = NNNNNNNN
*
         MVI   IER964A,C'3'        SET FOR PHASE 3
         L     R1,W3STOR           GET ASSIGNED STORAGE
         CVD   R1,KCONVERT
         MVC   IER964B,EPATTERN
         ED    IER964B,KCONVERT+4
         LM    R0,R1,IER964        PHASE 3 STORAGE = NNNNNNNN
         L     R15,VGAPRT          MESSAGE WRITER ADDR
         BASR  R14,R15             CALL MSG WRITER
*
*        GENERATE IER965 MERGE ORDER = NNNNN
*
         LH    R1,WMERGE           GET MERGE ORDER
         CVD   R1,KCONVERT
         MVC   IER965A,EPATTERN
         ED    IER965A,KCONVERT+6
         LM    R0,R1,IER965        IER965 MERGE ORDER = NNNNN
         L     R15,VGAPRT          MESSAGE WRITER ADDR
         BASR  R14,R15             CALL MSG WRITER
*
         DROP  R3
*
*        R E T U R N   R O U T I N E
*
BGBRET   SR    R15,R15             SAFE RETURN CODE
BGBRETE  L     R12,SAVER12         RESTORE R12
         L     R14,12(,R12)
         LM    R0,R11,20(R12)      RESTORE REGS
         BR    R14                 RETURN WITH RC IN R15
*
*        E R R O R   A N D   M E S S A G E   R O U T I N E
*
BGERROR  L     R3,VIERRCU          R3 -> MESSAGE MODULE CSECT
         USING DIERRCU,R3
         L     R1,IER039
         MVC   CPIABMNO,3(R1)      MOVE MSG NO INTO ABEND CODE
         LM    R0,R1,IER039        IER039A INSUFFICIENT STORAGE
         L     R15,VGAPRT          MESSAGE WRITER ADDR
         BASR  R14,R15             LINK TO WRITER
         LA    R15,4               ERROR CODE
         B     BGBRETE
*
*        W O R K    A R E A S
*
SAVER12  DC    F'0'                -> SAVEAREA IN IERRCM
WTAVLC   DC    F'0'                SAVE CPITAVLC FOR LATER MSG
WPH1AVIL DC    F'0'                PHASE 1  RUNNING AND GENERATED STOR
WPH2AVIL DC    F'0'                PHASE 2
WPH3AVIL DC    F'0'                PHASE 3
WRUNING1 DC    F'0'                PHASES 1/2 RUNNING PROGRAMS
WRUNING3 DC    F'0'                PHASE   3  RUNNING PROGRAMS
WGEN12   DC    F'0'                PHASES 1/2 GENERATED STORAGE
WGEN3    DC    F'0'                PHASE   3  GENERATED STORAGE
WSAVG    DC    F'0'                FOR SAVING G
WGEXEX02 DC    F'0'                SAVE GENERATED STOR + INPUT BUFF-PH2
WGENEX12 DC    F'0'                SAVE GENERATED STOR EXTRAS PHASE 1/2
W1STOR   DC    F'0'                CORE USED PH1
W2STOR   DC    F'0'                CORE USED PH2
W3STOR   DC    F'0'                CORE USED PH3
WTREE    DC    F'0'                FOR VALUE OF TREE
WBINS    DC    H'0'                NUMBER OF BINS PER RECORD
WBINSMAX DC    H'0'                NO BINS/MAX VARIABLE RECORD
WMERGE   DC    H'0'                SAVE MERGE ORDER FOR CALCULATIONS
*
*        C O N S T A N T S   U S E D   I N   R U N N I N G
*
*        P R O G R A M S
*
KVALUE12 DC    H'14385'            SIZE OF CRISS-CROSS TECHNIQUE
KVALUE3  DC    H'8880'             SIZE OF PHASE 3
K8WAYSIN DC    H'1035'             8-WAY NETWORK/SINGLE CONTROL FIELD
K8WAYMUL DC    H'960'              8-WAY NETWORK/MULTIPLE CONTROL FIELD
K16WAYS  DC    H'1670'             16-WAY NETWORK/SINGLE CONTROL FIELD
K16WAYM  DC    H'1620'             16-WAY NETWORK/MULT CONTROL FIELDS
KFIXED12 DC    H'860'              FIXED-LENGTH RECORDS, PHASES1/2
KFIXED3  DC    H'170'              FIXED-LENGTH RECORDS, PHASE 3
KVARY12  DC    H'1650'             VARIABLE-LENGTH RECORDS, PHASES 1/2
KVARY3   DC    H'170'              VARIABLE-LENGTH RECORDS, PHASE 3
KMODS12  DC    H'780'              USER EXITS INCLUDED, PHASES 1/2P
KMODS3   DC    H'385'              USER EXITS INCLUDED, PHASE 3
KSINFIX  DC    H'1585'             SINGLE CONTROL FIELD/FIXED-LENGTH
KSINVAR  DC    H'885'              SINGLE CONTROL FIELD/FIXED-LENGTH
KMULFIX  DC    H'1740'             MULTIPLE CONTROL FIELD/FIXED
KMULVAR  DC    H'970'              MULTIPLE CONTROL FIELD/VARIABLE
KEQUALS  DC    H'86'               EQUALS ROUTINE
KCHK     DC    F'200'              SIZE OF CHECKPOINT MODULE
*
*        C O N S T A N T S   U S E D   I N   G E N E R A T E D
*
*        S T O R A G E
*
KH32     DC    H'32'    GETMAIN ADDRESS+SIZE+RSA TABLES= 32*M + 60
KGETMAN3 DC    H'16'    GETMAIN ADDRESS+SIZE     TABLES= 16*M + 24
KEXTRA   DC    H'60'               60 FROM GETMAIN
KTABLE12 DC    H'16'    4 TABLES - DEBLOCK,DCB,BLOCK,UNIT - PHASE 1/2
KTABLE3  DC    H'20'               3 PHASE 3 TABLES + ROUNDING FACTOR
KLCF     DC    H'0'                LENGTH OF EXTRACTED CF AREA
KCCW     DC    H'48'               CCW SIZE FOR DIRECT ACCESS
KFREETRK DC    H'84'               FREE TRACK LIST
KSEQU    DC    H'48'               SEQUENCE DISTRIBUTION TABLE
KRITECCW DC    H'64'               2 WRITE CCW'S + 2 ROUNDING FACTORS
         DC    0F'0'
KEIGHT   DC    X'FFFFFFF8'         ROUND DOWN TO 8 FOR ALIGNMENT
*
*
*        C O N S T A N T S   U S E D   I N   M O V E   R O U T I N E
*
*
KH8      DC    H'8'                VS MERGE ORDER FOR NETWORK
KH6      DC    H'6'                6 BYTES PER MOVE INSTRUCTION
KH16     DC    H'16'               USED AS MULTIPLIER
KH12     DC    H'12'               USED AS MULTIPLIER
*
*        CONSTANTS USED IN THE CALCULATIONS OF 'G' AND BUFFERS
*
KH3      DC    H'3'                FOR TREE - 3
KH2      DC    H'2'                FOR COMPARING  G VS 2
KH4      DC    H'4'                4 - TO HELP CALCULATE BINS FOR VARY
KH24     DC    H'24'               24 BYTE - DISK & CHAIN ADS, EOS, CCT
KH20     DC    H'20'               FOR FIXED     TREE
KF100    DC    F'100'              MINIMUM FIXED TREE LENGTH
KF28     DC    F'28'
KF32     DC    F'32'
KF36     DC    F'36'               MINIMUM VARIABLE TREE LENGTH
*
*        CONSTANTS FOR MESSAGE MODULE
*
KCONVERT DC    D'0'                FOR CVD INSTRUCTION
KCRCX    DC    C'CRCX'             CRISSCROSS TECHNIQUE USED
EPATTERN DC    XL8'4020202020202020'  PATTERN FOR DATA FORMATTING
*
VIERRCU  DC    V(IERRCU)           MSG CSECT
VGAPRT   DC    V(IERGAPRT)         MSG WRITER
*
*        MESSAGE DSECT
*
DIERRCU  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRCU SOURCE
*
*----------------------------------------------------------------------
*
         COPY IERRCUI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMCPI
*
         END
./ ADD NAME=IERCHK   0101-20211-20211-1200-00081-00081-00000-RELEASE 00
CHK      TITLE 'IERCHK - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERCHK
*
*        MODULE FUNCTION/OPERATION -
*        CHECKPOINT MODULE, USED BY PHASES 1, 2, AND 3. THE
*        FUNCTION OF THIS MODULE IS TO ACT AS THE INTERFACE
*        BETWEEN THE SORT/MERGE PROGRAM AND THE
*        CHECKPOINT/RESTART FACILITY OF THE OPERATING SYSTEM.
*        THE MODULE IS LOADED ONLY WHEN THE USER HAS SPECIFIED
*        CHECKPOINT AND PERFORMS THE FOLLOWING FUNCTIONS -
*        1 - ISSUES ALL THE CHECKPOINT MACROS FOR THE SORT/MERGE
*            PROGRAM
*        2 - CONTAINS THE DCB FOR THE CHECKPOINT DATA SET
*
*        USED AS A DSECT IN - N/A
*
*        MACROS USED -
*        SMPPI
*        DCB
*        DCBD
*        CHKPT
*
*        ENTRY POINTS - CHKISSU - ENTRY TO ISSUE CHKPT
*                                 CALLING SEQUENCE
*                                 L   R15,PPICHKAD
*                                 BAL R14,0(,R15)
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIBDSVA PPITPTBL PPISTDCB
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED - NONE
*
*        EXTERNAL ROUTINES - NONE
*
*        EXTERNAL PARAMETERS - NONE
*
*        EXITS - NORMAL - BRANCH R14 RETURN TO CALLING MODULE
*
*        EXITS - ERROR NONE
*
*        TABLES/WORK AREAS -
*        CHKRGSAV - SAVE AREA FOR REGISTERS
*
*        NOTES - N/A
*
IERCHK   CSECT
*
         USING *,R11               MODULE BASE REGISTER
         USING IERRCA,R13          PPI COMMON MODULE BASE REGISTER
         LR    R0,R11              SAVE USER BASE REGISTER
         LR    R11,R15             LOAD BASE REGISTER
         STM   R0,R14,CHKRGSAV     SAVE REGISTERS 0 - 14
*
         CHKPT SORTCKPT            ISSUE CHECKPOINT
*
         LM    R0,R14,CHKRGSAV     RESTORE REGISTERS 0 - 14
         LR    R11,R0              RESTORE USER BASE REGISTER
         BR    R14                 RETURN TO CALLER
*
*        SAVE AREA
*
CHKRGSAV DC    15F'0'              SAVE AREA FOR REGISTERS 0-14
*
*        DCB FOR THE CHECKPOINT DATA SET
*
         PRINT NOGEN
*
SORTCKPT DCB   MACRF=(W),DSORG=PS,DDNAME=SORTCKPT
*
         PRINT GEN
*
*        REGISTERA AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERDM4   0101-20211-20211-1200-00094-00094-00000-RELEASE 00
DM4      TITLE 'IERDM4 - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERDM4
*
*        MODULE FUNCTION/OPERATION -
*        CONVERSION ROUTINE TO CONVERT MACHINE LANGUAGE
*        ADDRESSES TO EITHER HEX OR DECIMAL FORMATS FOR PRINTING
*        DIAGNOSTIC MESSAGES. A BRANCH LIST IS USED TO DETERMINE
*        IF A HEX OR A DECIMAL CONVERSION IS PERFORMED
*
*        THE CALLING MODULE SHOULD INCLUDE THE FOLLOWING CODE -
*
*        L     R0,NO TO BE CONVERTED
*        L     R15,PPICONV+4 ADDR OF CONVERSION ROUTINE
*
*        THEN ONE OF THE FOLLOWING BRANCH STATEMENTS -
*        B     0(,R15) FOR DECIMAL CONVERSION
*        B     4(,R15) FOR HEX CONVERSION
*
*        THE ADDR CONTAINING THE CONVERTED NUMBER WILL BE
*        RETURNED IN R1. THE NUMBER WILL BE A DOUBLE WORD
*
*        MODULES IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        LIST OF MACROS USED BY MODULE - N/A
*
*        ENTRY POINTS - CALLING SEQUENCE
*                              L  R0,NO TO BE CONVERTED
*                              L  R15,PPICONV+4  ADDR OF CONV ROUTINE
*                       EITHER B  0(,R15) FOR DECIMAL CONVERSION
*                         OR   B  4(,R15) FOR HEX CONVERSION
*
*        INPUT - PPI FIELDS REFERENCED - N/A
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED - N/A
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS -
*        R0 - THE NUMBER OR ADDR TO BE CONVERTED
*        R1 - RETURNED ADDR OF DOUBLE WORD WITH CONVERTED ADDR OR
*             NUMBER
*
*        EXITS - NORMAL -
*        STANDARD RETURN TO CALLING ROUTINE VIA R14
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS - N/A
*
*        NOTES -
*        THIS MODULE IS LOADED INTO STORAGE WHEN THE GENERAL
*        DIAGNOSTIC SWITCH IS SET
*
IERDM4   CSECT
*
         USING *,R15               R15 USED AS BASE REG
         B     DM4DEC00            +00 BRANCH TO DECIMAL CONVERT
*
*        HEX CONVERSION ROUTINE TO RETURN ADDR IN PRINTABLE CHARS
*
*                                  +04 HEX CONVERSION ROUTINE
         ST    R0,DM4HEX           STORE NUMBER TO BE CONVERTED
         UNPK  DM4TEMP(9),DM4HEX(5)      UNPACK NUMBER
         NC    DM4TEMP(8),DM4MASK        ZERO HIGH ORDER NIBBLE
         TR    DM4TEMP(8),DM4HTBL        CONVERT TO HEX CHAR
         LA    R1,DM4TEMP          R1 -> FORMATTED DATA FOR CALLER
         BR    R14                 RETURN TO CALLING ROUTINE
*
*        DECIMAL CONVERSION ROUTINE TO RETURN VALUE AS 8 DIGITS
*
DM4DEC00 CVD   R0,DM4DEWK          CONVERT NUMBER TO PACKED DECIMAL
         UNPK  DM4TEMP(8),DM4DEWK+3(5)       UNPACK NUMBER
         OI    DM4TEMP+7,X'F0'     SET SIGN POSITIVE
DM4RTN   LA    R1,DM4TEMP          R1 -> FORMATTED DATA FOR CALLER
         BR    R14                 RETURN TO CALLING ROUTINE
*
*        WORK AREAS
*
DM4TEMP  DC    D'0'                STORAGE FOR CONVERTED NUMBER
DM4DEWK  DC    D'0'                WORK AREA FOR DECIMAL CONVERSION
DM4HTBL  DC    C'0123456789ABCDEF'      TRANSLATE TABLE FOR HEX CONVERT
DM4HEX   DC    F'0'                WORK AREA FOR HEX CONVERSION
         DC    0D'0'
DM4MASK  DC    X'0F0F0F0F0F0F0F0F'
BLANKS   DC    C'  '
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         END
./ ADD NAME=IERDTE   0101-20211-20211-1200-00987-00987-00000-RELEASE 00
DTE      TITLE 'IERDTE - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERDTE
*
*        MODULE FUNCTION/OPERATION -
*        1. TRACE EXCP I/O REQUESTS
*        2. TRACE COMPLETION OF EXCP I/O REQUESTS AT COMPLETION OF WAIT
*
*        CHANGE LOG -
*        CORRECT PRINTING OF HEX DATA WHEN LESS               REL 1.1
*        THAN 4 BYTES OF DATA ARE BEING FORMATTED
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        ENTRY POINTS - CALLING SEQUENCE FOR TRACING EXCP REQUESTS
*                              BAL R1,PPITXEP      FROM CALLING MODULE
*
*                      PPITXEP STM R0,R15,PPITSAV  IN PPI
*                              L   R15,PPITDTE     ADDR OF IERDTE
*                              BR  R15
*
*                     - CALLING SEQUENCE FOR TRACING WAIT COMPLETION
*                              BAL R1,PPITXEP      FROM CALLING MODULE
*
*                      PPITWAI STM R0,R15,PPITSAV  IN PPI
*                              LCR R1,R1           COMPLEMENT R1
*                              L   R15,PPITDTE     ADDR OF IERDTE
*                              BR  R15
*
*        INPUT - PPI FIELDS REFERENCED - N/A
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED - N/A
*
*        EXTERNAL ROUTINES -
*        IERDM4   - CONVERSION ROUTINE VIA PPICONV+4
*        IERGAPRT - MESSAGE WRITER
*
*        EXTERNAL PARAMETERS - EXCP ENTRY
*
*        R1 -> RETURN ADDR
*              R1 - 8
*              BITS 00 - 11 X'470' NOP
*                   12 - 15 REGISTER USED TO PASS THE ADDR OF IOB
*                   16 - 19 ENCODED 4TH BYTE OF THE MODULE NAME
*                   20 - 25 ENCODED 5TH BYTE OF THE MODULE NAME
*                   26 - 31 ENCODED 6TH BYTE OF THE MODULE NAME
*
*        EXITS - NORMAL -
*        RETURN TO CALLING ROUTINE VIA R1
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS - N/A
*
*        NOTES -
*        THIS MODULE IS LOADED INTO STORAGE WHEN EXCP TRACING
*        IS REQUESTED AS A DIAGNOSTIC OPTION.
*        A HARD CODED DDT BREAKPOINT MAY BE USED TO TRIGGER DDT WHEN
*        A RECORD COMPARISON PROCESS HAS FOUND THE REQUIRED RECORD
*        FOR EXCP WRITE OPERATIONS AND WAIT ON EXCP READ OPERATIONS
*        THE FIRST 256 BYTES OF THE RECORD ARE FORMATTED INTO THE
*        TRACE. THIS SETTING MAY BE ZAPPED TO ENSURE THE ENTIRE
*        RECORD IS FORMATTED
*
IERDTE   CSECT
*
         USING *,R15               ENTER VIA R15
         USING IERIOB,R9           SORT/MERGE IOB
         USING IERRCA,R13          PPI
*
         IERENTRY 'IERDTE &SYSDATE &SYSTIME'
*
         DROP  R15
         LR    R10,R15
         USING IERDTE,R10          MODULE BASE REGISTER
         XC    DATA,DATA           CLEAR DATA AREA
         LTR   R8,R1               EXCP OR WAIT ENTRY ?
         BP    IERDTEE             EXCP ENTRY, BRANCH
*
*        WAIT ENTRY
*
         MVI   CNTLFLAG,WAITENT    SET WAIT ENTRY
         LCR   R1,R1               WAIT ENTRY, RECOMPLEMENT RET ADDR
         ST    R1,PPITSAV+4        RESET COMPLEMENTED R1 TO RET ADDR
         LA    R0,6
         SR    R1,R0               R1 -> WAIT SVC
         BAS   R12,MODID           DETERMINE MODULE AND OFFSET
         MVC   IER984M,0(R1)       MOVE MODULE NAME INTO MSG
         L     R15,PPICONV+4
         BAS   R14,4(,R15)         CONVERT OFFSET TO PRINTABLE
         MVC   IER984O,4(R1)       MOVE ADDR INTO MSG
         LM    R0,R1,IER984        IER983I WAIT ISSUED AT
         BAS   R12,WRITERA         CALL MSG WRITER SPECIAL ENTRY
         L     R9,PPITECB          R9 -> IERIOB
         B     IERDTEW
*
*        EXCP ENTRY
*
IERDTEE  MVI   CNTLFLAG,EXCPENT
         LA    R0,8
         SR    R8,R0               R8 -> NOP PARAMETER INSTRUCTION
         CLI   0(R8),X'47'         CHECK THAT IT IS A BRANCH INST ?
         BNE   IERDTEX             NO, EXIT THE TRACE MODULE
*
*        GET ADDR OF IOB AND CALLING MODULE NAME
*
         SR    R9,R9
         IC    R9,1(,R8)           GET SECOND BYTE OF NOP
         SLL   R9,2                CONVERT REG NO TO OFFSET IN PPITSAV
         L     R9,PPITSAV(R9)      R9 -> IOB
         SR    R9,R0               R9 -> IERIOB (IOB - 8 BYTE PREFIX)
         LA    R1,2(,R1)           R1 -> SVC 0
         BAS   R12,MODID           CALL MODULE INDENTIFICATION RTN
         MVC   IER983M,0(R1)       MOVE MODULE NAME OR N/A INTO MSG
         L     R15,PPICONV+4
         BAS   R14,4(,R15)         CONVERT OFFSET TO PRINTABLE
         MVC   IER983O,4(R1)       MOVE INTO MSG
         LM    R0,R1,IER983        IER983I EXCP ISSUED AT
         BAS   R12,WRITERA         CALL MSG WRITER SPECIAL ENTRY
*
*        FORMAT IOB AND IOB PREFIX
*
IERDTEW  MVC   IER983P(3),=CL3'IOB'
         LA    R0,8(,R9)            R0 -> STANDARD IOB ADDR
         L     R15,PPICONV+4
         BAS   R14,4(,R15)          CONVERT IOB ADDR
         MVC   IER983P+4(6),2(R1)   MOVE FORMATTED ADDR INTO MSG
         BAS   R12,WRITER
         MVC   IER983P(L'CPREFIX),CPREFIX  MOVE IOB PREFIX TEXT MSG
         L     R0,IERECB            GET IERECB
         L     R15,PPICONV+4
         BAS   R14,4(,R15)          CONVERT IERECB CONTENTS
         MVC   IER983P+17(8),0(R1)  MOVE FORMATTED ECB INTO MSG
         L     R0,IERALTCW          GET IERALTCW
         L     R15,PPICONV+4
         BAS   R14,4(,R15)          CONVERT IERALTCW ADDR
         MVC   IER983P+42(8),0(R1)  MOVE FORMATTED IERALTCW INTO MSG
         BAS   R12,WRITER           WRITE THE LINE
*
*        FORMAT IOBFLAG1, IOBFLAG2, IOBSENS0 AND IOBSENS1 BYTES
*
         MVC   IER983P(L'CFLAG1),CFLAG1
         IC    R0,IOBFLAG1
         L     R15,PPICONV+4
         BAS   R14,4(,R15)          CONVERT IOBFLAG1 CONTENTS
         MVC   IER983P+17(2),6(R1)  MOVE IOBFLAG1 CONTENTS INTO MSG
         LA    R2,IER983P+20
         LR    R3,R2                TAKE A COPY OF START ADDR
         TM    IOBFLAG1,IOBDATCH    DATA CHAINING FLAG ON ?
         BZ    FLAGS1               NO, BRANCH
         MVC   0(L'KDATCH,R2),KDATCH  MOVE IN IOBDATCH
         LA    R2,L'KDATCH(,R2)     INCR R2 TO NEXT LOCATION
FLAGS1   TM    IOBFLAG1,IOBCMDCH    COMMAND CHAINING FLAG ON ?
         BZ    FLAGS3               NO, BRANCH
         CR    R2,R3                FIRST FLAG ?
         BE    FLAGS2               YES, BRANCH
         MVI   0(R2),C'+'
         LA    R2,1(,R2)            INCR LOCATION
FLAGS2   MVC   0(L'KCMDCH,R2),KCMDCH   MOVE IN IOBCMDCH
FLAGS3   IC    R0,IOBFLAG2
         L     R15,PPICONV+4
         BAS   R14,4(,R15)          CONVERT IOBFLAG2 CONTENTS
         MVC   IER983P+55(2),6(R1)  MOVE FORMATTED CONTENTS INTO MSG
         IC    R0,IOBSENS0
         L     R15,PPICONV+4
         BAS   R14,4(,R15)          CONVERT IOBSENS0 CONTENTS
         MVC   IER983P+71(2),6(R1)  MOVE FORMATTED IOBSENS0 INTO MSG
         IC    R0,IOBSENS1
         L     R15,PPICONV+4
         BAS   R14,4(,R15)          CONVERT IOBSENS1 CONTENTS
         MVC   IER983P+87(2),6(R1)  MOVE FORMATTED IOBSENS1 INTO MSG
         BAS   R12,WRITER
*
*        FORMAT IOBECB, IOBFLAG3 AND IOBCMDA FIELDS
*
         MVC   IER983P(L'CECBDATA),CECBDATA
         L     R0,IOBECBPT
         L     R15,PPICONV+4
         BAS   R14,4(,R15)          CONVERT IOBECBCC CONTENTS
         MVC   IER983P+17(2),0(R1)  MOVE FORMATTED IOBECBCC INTO MSG
         MVC   IER983P+33(6),2(R1)  MOVE FORMATTED IOBECBPB INTO MSG
         L     R0,IOBFLAG3
         L     R15,PPICONV+4
         BAS   R14,4(,R15)          CONVERT IOBFLAG3 AND IOBCMDA DATA
         MVC   IER983P+55(2),0(R1)  MOVE FORMATTED IOBFLAG3 INTO MSG
         MVC   IER983P+71(6),2(R1)  MOVE FORMATTED IOBCMDA  INTO MSG
         BAS   R12,WRITER
*
*        FORMAT IOBCSW FIELDS
*        IOBUSTAT, IOBCSTAT AND RESIDUAL COUNT
*
         MVC   IER983P(L'CCSWS),CCSWS
         L     R0,IOBCSW+3
         L     R15,PPICONV+4
         BAS   R14,4(,R15)          CONVERT IOBCSW DATA
         MVC   IER983P+17(2),0(R1)  MOVE FORMATTED IOBUSTAT INTO MSG
         MVC   IER983P+55(2),2(R1)  MOVE FORMATTED IOBCSTAT INTO MSG
         LA    R2,IER983P+20        R2-> FORMATTED FLAGS AREA
         LR    R3,R2                TAKE A COPY OF THE START ADDR
         TM    IOBUSTAT,CUE         CONTROL UNIT END ?
         BZ    USTAT1               NO, BRANCH
         MVC   0(L'KCUE,R2),KCUE    MOVE IN CUE
         LA    R2,L'KCUE(,R2)       INCR LOCATION
USTAT1   TM    IOBUSTAT,CE          CHANNEL END ?
         BZ    USTAT3               NO, BRANCH
         CR    R2,R3                STILL AT THE START ?
         BE    USTAT2               YES, BYPASS PLUS
         MVI   0(R2),C'+'           MOVE IN PLUS
         LA    R2,1(,R2)            INCR LOCATION
USTAT2   MVC   0(L'KCE,R2),KCE      MOVE IN CHANNEL END
         LA    R2,L'KCE(,R2)        INCR LOCATION
USTAT3   TM    IOBUSTAT,DE          DEVICE END ?
         BZ    USTAT5               NO, BRANCH
         CR    R2,R3                STILL AT THE START ?
         BE    USTAT4               YES, BYPASS PLUS
         MVI   0(R2),C'+'           MOVE IN PLUS
         LA    R2,1(,R2)            INCR LOCATION
USTAT4   MVC   0(L'KDE,R2),KDE      MOVE IN DEVICE END
         LA    R2,L'KDE(,R2)        INCR LOCATION
USTAT5   TM    IOBUSTAT,UC          UNIT CHECK ?
         BZ    USTAT7               NO, BRANCH
         CR    R2,R3                STILL AT THE START ?
         BE    USTAT6               YES, BYPASS PLUS
         MVI   0(R2),C'+'           MOVE IN PLUS
         LA    R2,1(,R2)            INCR LOCATION
USTAT6   MVC   0(L'KUC,R2),KUC      MOVE IN UNIT CHECK
         LA    R2,L'KUC(,R2)        INCR LOCATION
USTAT7   TM    IOBUSTAT,UE          UNIT EXCEPTION ?
         BZ    USTAT9               NO, BRANCH
         CR    R2,R3                STILL AT START ?
         BE    USTAT8               YES, BYPASS PLUS
         MVI   0(R2),C'+'           MOVE IN PLUS
         LA    R2,1(,R2)            INCR LOCATION
USTAT8   MVC   0(L'KUE,R2),KUE      MOVE IN UNIT EXCEPTION
USTAT9   EQU   *                    END OF IOBUSTAT PROCESSING
         LA    R2,IER983P+58        START OF CSTAT AREA
         LR    R3,R2                TAKE A COPY OF THE START LOCATION
         TM    IOBCSTAT,PCI         PROGRAM CONTROLLED INTERRUPT ?
         BZ    CSTAT1               NO, BRANCH
         MVC   0(L'KPCI,R2),KPCI    MOVE IN PCI
         LA    R2,L'KPCI(,R2)       INCR LOCATION
CSTAT1   TM    IOBCSTAT,IL          INCORRECT LENGTH ?
         BZ    CSTAT3               NO, BRANCH
         CR    R2,R3                STILL AT START ?
         BE    CSTAT2               YES, BRANCH
         MVI   0(R2),C'+'           MOVE IN PLUS
         LA    R2,1(,R2)            INCR LOCATION
CSTAT2   MVC   0(L'KIL,R2),KIL      MOVE IN IL
         LA    R2,L'KIL(,R2)        INCR LOCATION
CSTAT3   TM    IOBCSTAT,PC          PROGRAM CHECK ?
         BZ    CSTAT5               NO, BRANCH
         CR    R2,R3                STILL AT START ?
         BE    CSTAT4               YES, BRANCH
         MVI   0(R2),C'+'           MOVE IN PLUS
         LA    R2,1(,R2)            INCR LOCATION
CSTAT4   MVC   0(L'KPC,R2),KPC      MOVE IN PROGRAM CHECK
         LA    R2,L'KPC(,R2)        INCR LOCATION
CSTAT5   TM    IOBCSTAT,PROTC       PROTECTION CHECK ?
         BZ    CSTAT7               NO, BRANCH
         CR    R2,R3                STILL AT START ?
         BE    CSTAT6               YES, BRANCH
         MVI   0(R2),C'+'           MOVE IN PLUS
         LA    R2,1(,R2)            INCR LOCATION
CSTAT6   MVC   0(L'KPROTC,R2),KPROTC  MOVE IN PROTECTION CHECK
         LA    R2,L'KPROTC(,R2)     INCR LOCATION
CSTAT7   TM    IOBCSTAT,CDC         CHANNEL DATA CHECK ?
         BZ    CSTAT9               NO, BRANCH
         CR    R2,R3                STILL AT START ?
         BE    CSTAT8               YES, BRANCH
         MVI   0(R2),C'+'           MOVE IN PLUS
         LA    R2,1(,R2)            INCR LOCATION
CSTAT8   MVC   0(L'KCDC,R2),KCDC    MOVE IN CHANNEL DATA CHECK
         LA    R2,L'KCDC(,R2)       INCR LOCATION
CSTAT9   TM    IOBCSTAT,CCC         CHANNEL CONTROL CHECK ?
         BZ    CSTATB               NO, BRANCH
         CR    R2,R3                STILL AT START ?
         BE    CSTATA               YES, BRANCH
         MVI   0(R2),C'+'           MOVE IN PLUS
         LA    R2,1(,R2)            INCR LOCATION
CSTATA   MVC   0(L'KCCC,R2),KCCC    MOVE IN CHANNEL CONTROL CHECK
         LA    R2,L'KCCC(,R2)       INCR LOCATION
CSTATB   TM    IOBCSTAT,ICC         INTERFACE CONTROL CHECK ?
         BZ    CSTATD               NO, BRANCH
         CR    R2,R3                STILL AT START ?
         BE    CSTATC               YES, BRANCH
         MVI   0(R2),C'+'           MOVE IN PLUS
         LA    R2,1(,R2)            INCR LOCATION
CSTATC   MVC   0(L'KICC,R2),KICC    MOVE IN INTERFACE CONTROL CHECK
         LA    R2,L'KICC(,R2)       INCR LOCATION
CSTATD   TM    IOBCSTAT,CHK         CHAINING CHECK ?
         BZ    CSTATF               NO, BRANCH
         CR    R2,R3                STILL AT START ?
         BE    CSTATE               YES, BRANCH
         MVI   0(R2),C'+'           MOVE IN PLUS
         LA    R2,1(,R2)            INCR LOCATION
CSTATE   MVC   0(L'KCHK,R2),KCHK    MOVE IN CHAINING CHECK
CSTATF   SR    R1,R1
         CLI   CNTLFLAG,EXCPENT     EXCP ENTRY ?
         BE    CSTATG               YES, RESIDUAL NOT VALID
         ICM   R1,B'0011',IOBCSW+5  GET RESIDUAL COUNT
CSTATG   CVD   R1,WORKD
         MVC   IER983P+90(6),EPATTN6Z  MOVE EDIT PATTERN INTO MSG
         ED    IER983P+90(6),WORKD+5   FORMAT RESIDUAL BYTE COUNT
         BAS   R12,WRITER
*
*        FORMAT IOBSTART, IOBFLAG4 AND IOBDCBPB DATA
*
         MVC   IER983P(L'CSTART),CSTART
         L     R0,IOBSIOCC          GET IOBSIOCC AND IOBSTRTB DATA
         L     R15,PPICONV+4
         BAS   R14,4(,R15)          CONVERT IOBSIOCC AND IOBSTRTB DATA
         MVC   IER983P+17(2),0(R1)  MOVE FORMATTED IOBSIOCC INTO MSG
         MVC   IER983P+33(6),2(R1)  MOVE FORMATTED IOBSTRTB INTO MSG
         L     R0,IOBFLAG4          GET IOBFLAG4 AND IOBDCBPB DATA
         L     R15,PPICONV+4
         BAS   R14,4(,R15)          CONVERT IOBFLAG4 AND IOBDCBPB DATA
         MVC   IER983P+55(2),0(R1)  MOVE FORMATTED IOBFLAG4 INTO MSG
         MVC   IER983P+71(6),2(R1)  MOVE FORMATTED IOBDCBPB INTO MSG
         L     R2,IOBDCBPT          R2 -> DCB
         USING IHADCB,R2
         LH    R2,DCBTIOT           GET TIOT OFFSET IN R2
         DROP  R2
         L     R1,CVTPTR            R1 -> CVT
         USING CVT,R1
         L     R1,CVTTCBP
         DROP  R1
         L     R1,4(,R1)            R1 -> TCB
         USING TCB,R1
         L     R1,TCBTIO            R1 -> TIOT
         DROP  R1
         AR    R2,R1                R2 -> TIOT ENTRY
         USING TIOENTRY,R2
         MVC   IER983P+88(8),TIOEDDNM  MOVE TIOEDDNM INTO MSG
         MVC   DATADCB,TIOEDDNM     MOVE DCB DDNAME INTO DATA AREA
         DROP  R2
         BAS   R12,WRITER
*
*        FORMAT IOBRESTART AND OPTIONAL TAPE FIELDS
*
         PPITEST  PPITAPE           TAPE SORT ?
         BNO   CRESTD1              NO, BRANCH
         MVC   IER983P(L'CRESTT),CRESTT  TAPE IOB FORMATTING
         L     R0,IOBINCAM          GET IOBINCAM AND IOBERRCT
         L     R15,PPICONV+4
         BAS   R14,4(,R15)          CONVERT IOBINCAM AND IOBERRCT DATA
         MVC   IER983P+47(4),0(R1)  MOVE FORMATTED IOBINCAM INTO MSG
         MVC   IER983P+64(4),4(R1)  MOVE FORMATTED IOBERRCT INTO MSG
         B     CRESTD2
*
CRESTD1  MVC   IER983P(L'CRESTD),CRESTD
CRESTD2  L     R0,IOBRESTR          GET IOBRESTR
         L     R15,PPICONV+4
         BAS   R14,4(,R15)          CONVERT IOBRESTR DATA
         MVC   IER983P+17(8),0(R1)  MOVE FORMATTED IOBRESTR INTO MSG
         BAS   R12,WRITER
         PPITEST  PPITAPE           TAPE SORT ?
         BO    CRESTX               YES, BRANCH OVER IOBSEEK FORMATTING
*
*        FORMAT IOBSEEK FIELDS
*
         MVC   IER983P(L'CSEEK),CSEEK
         SR    R1,R1
         ICM   R1,B'0011',IOBCC       GET CYL ADDR
         CVD   R1,WORKD
         MVC   IER983P+26(6),EPATTN6  MOVE EDIT PATTERN INTO MSG
         ED    IER983P+26(6),WORKD+5  FORMAT CYL ADDR
         ICM   R1,B'0011',IOBHH       GET HEAD NUMBER
         CVD   R1,WORKD
         MVC   WORKD(4),EPATTN4       MOVE EDIT PATTERN INTO WORKD
         ED    WORKD(4),WORKD+6       FORMAT HH NUMBER
         MVC   IER983P+44(2),WORKD+2  MOVE HH INTO MSG
         SR    R1,R1
         IC    R1,IOBR
         CVD   R1,WORKD
         MVC   IER983P+59(4),EPATTN4  MOVE EDIT PATTERN INTO MSG
         ED    IER983P+59(4),WORKD+6  FORMAT R NUMBER
         BAS   R12,WRITER
CRESTX   EQU   *
*
*        FORMAT THE CCWS
*
         L     R4,IOBSTART          R4 -> CCW CHAIN
FMTCCW   MVC   IER983P(L'CCCW),CCCW
         LR    R0,R4                R0 -> CCW
         L     R15,PPICONV+4
         BAS   R14,4(,R15)          CONVERT CCW DATA ADDR
         MVC   IER983P+4(6),2(R1)   MOVE FORMATTED DATA ADDR INTO MSG
         L     R0,0(,R4)            R0 = CCW COMMAND AND DATA
         L     R15,PPICONV+4
         BAS   R14,4(,R15)          CONVERT CCW COMMAND AND DATA
         MVC   IER983P+16(2),0(R1)  MOVE IN FORMATTED CCW COMMAND
         MVC   IER983P+44(6),2(R1)  MOVE IN FORMATTED DATA ADDR
         MVC   WORKD(1),0(R4)       GET CCW COMMAND
         TR    WORKD(1),CMDLOOKU    CONVERT TO OFFSET
         SR    R1,R1
         IC    R1,WORKD             GET OFFSET
         LA    R1,CMDTAB(R1)        R1 -> COMMAND NAME
         MVC   IER983P+19(8),0(R1)  MOVE COMMAND NAME INTO MSG
         L     R0,4(,R4)            GET CCW FLAGS
         L     R15,PPICONV+4
         BAS   R14,4(,R15)          CONVERT CCW FLAGS AND BYTE COUNT
         MVC   IER983P+61(2),0(R1)  MOVE FORMATTED FLAGS INTO MSG
         SR    R1,R1
         ICM   R1,B'0011',6(R4)     GET CCW BYTE COUNT
         CVD   R1,WORKD
         MVC   IER983P+88(6),EPATTN6Z  MOVE EDIT PATTERN INTO MSG
         ED    IER983P+88(6),WORKD+5   FORMAT CCW BYTE COUNT INTO MSG
         LA    R2,IER983P+64        R2 -> START FORMATTED CCW FLAGS
         LR    R3,R2                TAKE A COPY OF THE START LOCATION
         TM    4(R4),CD             DATA CHAINING ON ?
         BZ    FMTCCW1              NO, BRANCH
         MVC   0(L'KCD,R2),KCD      MOVE IN DATA CHAINING
         LA    R2,L'KCD(,R2)        INCR LOCATION
FMTCCW1  TM    4(R4),CC             COMMAND CHAINING ON ?
         BZ    FMTCCW3              NO, BRANCH
         CR    R2,R3                STILL AT START ?
         BE    FMTCCW2              YES, BRANCH
         MVI   0(R2),C'+'           MOVE IN PLUS
         LA    R2,1(,R2)            INCR LOCATION
FMTCCW2  MVC   0(L'KCC,R2),KCC      MOVE IN COMMAND CHAINING
         LA    R2,L'KCC(,R2)        INCR LOCATION
FMTCCW3  TM    4(R4),SLI            SUPPRESS LENGTH INDICATOR ON ?
         BZ    FMTCCW5              NO, BRANCH
         CR    R2,R3                STILL AT START ?
         BE    FMTCCW4              YES, BRANCH
         MVI   0(R2),C'+'           MOVE IN PLUS
         LA    R2,1(,R2)            INCR LOCATION
FMTCCW4  MVC   0(L'KSLI,R2),KSLI    MOVE IN SUPPRESS LENGTH INDICATOR
         LA    R2,L'KSLI(,R2)       INCR LOCATION
FMTCCW5  TM    4(R4),SKIP           SKIP TRANSFER OF DATA ON ?
         BZ    FMTCCW7              NO, BRANCH
         CR    R2,R3                STILL AT START ?
         BE    FMTCCW6              YES, BRANCH
         MVI   0(R2),C'+'           MOVE IN PLUS
         LA    R1,1(,R2)            INCR LOCATION
FMTCCW6  MVC   0(L'KSLI,R2),KSLI    MOVE IN SKIP TRANSFER OF DATA
FMTCCW7  BAS   R12,WRITER
*
*        SEARCHID OR WRITECKD CCW COMMAND ?
*
         CLI   0(R4),SEARIDEQ       SEARCH ID EQUAL CCW COMMAND ?
         BE    FMTCCW7A             YES, BRANCH
         CLI   0(R4),WRITECKD       WRITECKD CCW COMMAND ?
         BNE   FMTCCW8              NO, BRANCH
*
*        FORMAT SEARCHID OR COUNT DATA FOR APPROPRIATE CCWS
*
*        R4 -> CCW
*        R2 -> CCW DATA
*
FMTCCW7A MVC   IER983P(L'CCWS),CCWS
         L     R2,0(,R4)              R2 -> CCHHR OR COUNT AREA
         MVC   DATASID+3(5),0(R2)     MOVE IN CCHHR
         SR    R1,R1
         ICM   R1,B'0011',0(R2)       GET CYL ADDR
         CVD   R1,WORKD
         MVC   IER983P+26(6),EPATTN6  MOVE EDIT PATTERN INTO MSG
         ED    IER983P+26(6),WORKD+5  FORMAT CYL NUMBER
         ICM   R1,B'0011',2(R2)       GET HEAD NUMBER
         CVD   R1,WORKD
         MVC   WORKD(4),EPATTN4       MOVE EDIT PATTERN INTO WORKD
         ED    WORKD(4),WORKD+6       FORMAT HH NUMBER
         MVC   IER983P+44(2),WORKD+2  MOVE HH INTO MSG
         SR    R1,R1
         IC    R1,4(,R2)              GET RECORD NUMBER
         CVD   R1,WORKD
         MVC   IER983P+59(4),EPATTN4  MOVE EDIT PATTERN INTO MSG
         ED    IER983P+59(4),WORKD+6  FORMAT RRR NUMBER
         CLI   0(R4),SEARIDEQ         SEARCH ID EQUAL CCW COMMAND ?
         BE    FMTCCW7B               YES, BRANCH
         MVC   IER983P+74(2),=C'KL'   KEYLEN CONSTANT
         IC    R1,5(,R2)              GET KEYLENGTH
         CVD   R1,WORKD
         MVC   IER983P+77(4),EPATTN4  MOVE EDIT PATTERN INTO MSG
         ED    IER983P+77(4),WORKD+6  FORMAT KL NUMBER
         MVC   IER983P+83(2),=C'DL'   DATA LENGTH CONSTANT
         ICM   R1,B'0011',6(R2)       GET DATA LENGTH FROM CCW
         CVD   R1,WORKD
         MVC   IER983P+88(6),EPATTN6Z  MOVE EDIT PATTERN INTO MSG
         ED    IER983P+88(6),WORKD+5   FORMAT DL BYTE COUNT INTO MSG
FMTCCW7B BAS   R12,WRITER
*
         CLI   0(R4),SEARIDEQ      SEARCH ID EQUAL CCW COMMAND ?
         BE    FMTCCWN             YES, NO FURTHER FORMATTING REQUIRED
         CLI   CNTLFLAG,WAITENT    WAIT ENTRY ?
         BNE   FMTCCW7C            NO, BRANCH
         TM    0(R4),X'01'         WAIT ENTRY, WRITE CCW ?
         BO    FMTCCWN             YES, NO FURTHER FORMATTING REQUIRED
*
*        EXCP ENTRY
*
FMTCCW7C SR    R7,R7
         ICM   R7,B'0011',6(R2)    R7 = DATA LENGTH FROM CKD FIELD
         LA    R5,8(,R2)           R5 -> DATA AFTER COUNT FIELD
         B     FMTCCW8C            BRANCH TO FORMAT DATA
*
FMTCCW8  CLI   0(R4),TIC           TIC CCW ?
         BE    FMTCCWN             YES, NO FURTHER FORMATTING
         TM    0(R4),X'03'         SENSE TYPE CCW ?
         BZ    FMTCCWN             YES, NO FURTHER FORMATTING
         CLI   CNTLFLAG,EXCPENT    EXCP ENTRY ?
         BNE   FMTCCW8A            NO, BRANCH TO WAIT PROCESSING
*
*        EXCP ENTRY
*
         TM    0(R4),X'02'         YES, READ OR CONTROL CCW ?
         BO    FMTCCWN             YES, NO FURTHER FORMATTING
         B     FMTCCW8B            BRANCH TO FORMAT CCW DATA
*
*        WAIT ENTRY
*
FMTCCW8A TM    0(R4),X'01'         WRITE CCW ?
         BO    FMTCCWN             YES, NO FURTHER FORMATTING
*
*        FORMAT CCW DATA
*
*        R0    WORK
*        R1    WORK
*        R2 -> OUTPUT LOCATION
*        R3    LOOP COUNTER
*        R4 -> CURRENT CCW
*        R5 -> START OF DATA
*        R6 -> CURRENT POSITION
*        R7    L'DATA
*        R8    L'THIS LINE
*
FMTCCW8B SR    R5,R5
         ICM   R5,B'0111',1(R4)    GET DATA ADDR
         SR    R7,R7
         ICM   R7,B'0011',6(R4)    GET L'DATA FROM CCW
FMTCCW8C MVC   DATAMB,0(R5)        MOVE MB TO DATA AREA
         MVC   DATARECN,12(R5)     MOVE RECORD NUMBER TO DATA AREA
         TM    0(R4),X'01'         WRITE CCW ?
         BO    FMTCCWR             YES, BRANCH
         SH    R7,IOBCSW+5         NO, READ, SUBTRACT RESIDUAL VALUE
FMTCCWR  CH    R7,=H'256'          LIMIT DATA DUMP TO 256 BYTES
         BNH   FMTCCW9             =< 256, BRANCH
*
*        NOP THIS TO FORCE FORMATTING OF ENTIRE CONTENTS OF THE RECORD
*        |
*        V
         LA    R7,256              SET MAXIMUM OF 256
*                                  START LINE
FMTCCW9  MVC   IER983P(L'CCCWD),CCCWD
         SR    R8,R8               ZERO BYTES PROCESSED THIS LINE
         LR    R6,R5               R6 -> DATA FOR THIS LINE
         LR    R0,R5               GET ADDR FOR FORMATTING
         L     R15,PPICONV+4
         BAS   R14,4(,R15)         CONVERT CCW DATA ADDR
         MVC   IER983P+4(6),2(R1)  MOVE DATA ADDR INTO MSG
         LA    R2,IER983P+11       SET TO START OF DATA IN MSG
         LA    R3,8                DUMP 4*8 BYTES PER LINE
*                                  FORMAT UP TO 4 BYTES OF DATA
FMTCCWA  CH    R7,=H'4'            GOT 4 BYTES LEFT TO PROCESS ?
         BL    FMTCCWB             NO, BRANCH
         L     R0,0(,R6)           YES, GET DATA FOR FORMATTING
         L     R15,PPICONV+4
         BAS   R14,4(,R15)         CONVERT DATA
         MVC   0(8,R2),0(R1)       MOVE CONVERTED DATA INTO MSG
         LA    R2,9(,R2)           INCR TO NEXT OUTPUT LOCATION
         LA    R6,4(,R6)           INCR ADDR POINTER
         LA    R8,4(,R8)           INCR BYTES PROCESSED THIS LINE
         SH    R7,=H'4'            DECR REMAINING BYTE COUNT
         BZ    FMTCCWC             NO MORE DATA REMAINING
         BCT   R3,FMTCCWA          PROCESS NEXT 4 BYTES
         B     FMTCCWC             GO FORMAT CHARACTER DATA FOR MSG
*
FMTCCWB  IC    R15,ICMMASK(R7)     CONVERT L'DATA TO ICM MASK
         EX    R15,ICMLOAD         GET DATA INTO R0 VIA ICM
         L     R15,PPICONV+4
         BAS   R14,4(,R15)         CONVERT DATA
         LA    R8,0(R8,R7)         INCR BYTES PROCESSED COUNT
         SLL   R7,1                DOUBLE THE BYTE COUNT
         BCTR  R7,0                DECR FOR EX
         EX    R7,MVCDATA          MOVE DATA INTO MSG
         SR    R7,R7               NO MORE DATA TO PROCESS
FMTCCWC  BCTR  R8,0                DECR BYTES PROCESSED FOR EX
         EX    R8,MVCPDATA         MOVE DATA INTO PRINT LINE
         L     R15,ATRANTAB        R15 -> TRANSLATE TABLE
         EX    R8,TRDATA           TRANSLATE UNPRINTABLES TO ~
         BAS   R12,WRITER
         LTR   R7,R7               ANY MORE DATA TO DUMP ?
         BZ    FMTCCWN             NO, BRANCH
         LA    R5,1(R8,R5)         INCR TO NEXT INPUT DATA
         B     FMTCCW9
*
FMTCCWN  TM    4(R4),CC            THIS CCW CHAINED TO NEXT ?
         BZ    FMTCCWX             NO, BRANCH
         LA    R4,8(,R4)           INCR TO NEXT CCW FOR FORMATTING
         B     FMTCCW              BRANCH TO FORMAT
*
FMTCCWX  EQU   *                   END OF CCW FORMATTING
*
*        EXIT
*
IERDTEX  MVC   DATAREQ,CNTLFLAG
         CLC   DATA,COMP           MATCHED DATA ?
         BNE   IERDTEXX            NO, EXIT
         LM    R0,R15,PPITSAV      RESTORE ALL CALLERS REGS
         NOP   0         <-------- PLACE DDT BREAKPOINT HERE
         BR    R1                  RETURN TO CALLER
*
IERDTEXX LM    R0,R15,PPITSAV      RESTORE ALL CALLERS REGS
         BR    R1                  RETURN TO CALLER
*
*        MODID
*
*        DETERMINE ISSUING LOAD MODULE AND OFFSET INTO MODULE
*
*        ON ENTRY
*        R1  -> ADDR
*        R12 =  RETURN ADDR
*
*        ON EXIT
*        R0  = OFFSET INTO MODULE
*        R1 -> MODULE NAME OR N/A
*
MODID    SR    R4,R4               ZERO WORK REG
         L     R2,CVTPTR           R2 -> CVT
         USING CVT,R2
         L     R2,CVTTCBP          R2 -> ADDR CURRENT TCB ADDR
         L     R2,4(,R2)           R2 -> CURRENT TCB ADDR
         DROP  R2
         USING TCB,R2
MODIDT   ICM   R5,B'0111',TCBJPQ+1   R5 -> CDE ENTRY
         BZ    MODIDN              NO JPQ, NOT THE CORRECT TCB
         USING CDENTRY,R5
         USING XTLST,R3
MODIDA   L     R3,CDXLMJP          R3 -> EXTENT LIST ENTRY FOR CDE
         C     R1,XTLMSBAA         ISSUING ADDR < MODULE ADDR ?
         BL    MODIDL              YES, CANNOT BE THIS MODULE
         ICM   R4,B'0111',XTLMSBLN  GET L'MODULE
         A     R4,XTLMSBAA         CALC END ADDR OF MODULE
         CR    R1,R4               WITHIN THIS LOAD MODULE ?
         BH    MODIDL              NO, BRANCH
*
*        FOUND ISSUING LOAD MODULE
*
         S     R1,XTLMSBAA         CONVERT ISSUING ADDR TO OFFSET
         LR    R0,R1               RETURN OFFSET IN R0
         LA    R1,CDNAME           R1 - > LOAD MODULE NAME
         BR    R12                 RETURN TO CALLER
*
MODIDL   ICM   R5,B'1111',CDCHAIN  R5 -> NEXT CDE ON CHAIN
         BNZ   MODIDA              BRANCH TO PROCESS THIS CDE/XL
*
*        CHAIN ENDED WITH NO MATCH
*
MODIDF   SR    R0,R0               SET OFFSET TO ZERO
         LA    R1,KNA              R1 -> N/A
         BR    R12                 RETURN TO CALLER
*
*        LOCATE NEXT TCB TO PROCESS
*
MODIDN   ICM   R6,B'0111',TCBOTC+1 TCB HAVE A MOTHER ?
         BNZ   MODIDM              YES, GO SEE IF MOTHER HAS JPQ
         ICM   R6,B'0111',TCBLTC+1 TCB  TCB HAVE A DAUGHTER ?
         BNZ   MODIDM              YES, GO PROCESS
         ICM   R6,B'0111',TCBNTC+1 TCB  TCB HAVE A SIBLING ?
         BZ    MODIDF              NO, FAILED TO FIND TCB
MODIDM   LR    R2,R6               GO TEST NEW TCB FOR JPQ
         B     MODIDT
*
         DROP  R2,R3
*
*        MESSAGE WRITER
*
WRITER   LM    R0,R1,IER983D       MESSAGE TEXT
WRITERA  L     R15,PPIADSSC        R15 -> PRINT ROUTINE
         BAS   R14,12(,R15)        CALL PRINT RTN
         MVI   IER983P,C' '
         MVC   IER983P+1(L'IER983P-1),IER983P  BLANK PRINT LINE
         BR    R12                 RETURN TO CALLER
*
*        CONSTANTS
*
ICMLOAD  ICM   R0,B'0000',0(R6)    GET REMAINING BYTES FOR FORMATTING
MVCDATA  MVC   0(0,R2),0(R1)       MOVE FORMATTED DATA INTO MSG
MVCPDATA MVC   IER983P+84(0),0(R5)   MOVE DATA FOR PRINT TRANSLATE
TRDATA   TR    IER983P+84(0),0(R15)  CONVERT ALL UNPRINTABLES TO ~
*
CNTLFLAG DC    X'00'
EXCPENT  EQU   X'01'               EXCP ENTRY POINT
WAITENT  EQU   X'02'               WAIT ENTRY POINT
*
ICMMASK  DC    XL4'00080C0E'       CONVERT NO OF BYTES TO ICM MASK
*
ATRANTAB DC    A(TRANTAB)
*                          1         2         3         4         5
*                012345678901234567890123456789012345678901234567890123
CPREFIX  DC    C'    -08 IERECB   XXXXXXXX  -04 IERALTCW   XXXXXXXX'
*                          1         2         3         4         5
*                012345678901234567890123456789012345678901234567890123
CFLAG1   DC    C'    +00 IOBFLAG1 XX                       +01 IOBFLAG2C
                XX +02 IOBSENS0 XX +03 IOBSENS1 XX'
*              45678901234567890123456789012345678901234567890123
*                    6         7         8         9
*                012345678901234567890123456789012345678901234567890123
CECBDATA DC    C'    +04 IOBECBCC XX +05 IOBECBPB XXXXXX   +08 IOBFLAG3C
                XX +09 IOBCMDA  XXXXXX'
*              45678901234567890123456789012345678901234567890123
*                          1         2         3         4         5
*                012345678901234567890123456789012345678901234567890123
CCSWS    DC    C'    +12 IOBUSTAT XX                       +13 IOBCSTATC
                XX                    +14 RESIDUAL XXXXX'
*              45678901234567890123456789012345678901234567890123
*                    6         7         8         9
*                012345678901234567890123456789012345678901234567890123
CSTART   DC    C'    +16 IOBSIOCC XX +17 IOBSTRTB XXXXXX   +20 IOBFLAG4C
                XX +21 IOBDCBPB XXXXXX    DDNAME XXXXXXXX'
*              45678901234567890123456789012345678901234567890123
*                    6         7         8         9
*                012345678901234567890123456789012345678901234567890123
CRESTD   DC    C'    +24 IOBRESTR XXXXXXXX'
CRESTT   DC    C'    +24 IOBRESTR XXXXXXXX         +28 IOBINCAM XXXX+30C
                IOBERRCT XXXX'
*              45678901234567890123456789012345678901234567890123
*                    6         7         8         9
*                012345678901234567890123456789012345678901234567890123
CSEEK    DC    C'    +32 IOBSEEK  +36 IOBCC XXXXX  +38 IOBHH XX     +40C
                IOBR XXX'
*              45678901234567890123456789012345678901234567890123
*                012345678901234567890123456789012345678901234567890123
CCCW     DC    C'CCW XXXXXX  +00 XX 12345678       +01 DATA  XXXXXX +04C
                FLAGS XX                +06 COUNT XXXXX'
*              45678901234567890123456789012345678901234567890123
*                    6         7         8         9
*                012345678901234567890123456789012345678901234567890123
CCWS     DC    C'                        CC XXXXX         HH XX        C
                   R XXX'
*              45678901234567890123456789012345678901234567890123
*                012345678901234567890123456789012345678901234567890123
CCCWD    DC    C'    XXXXXX                                            C
                                            *                          C
                     *'
*              45678901234567890123456789012345678901234567890123
*                    6         7         8         9
*
KDATCH   DC    C'IOBDATCH'
KCMDCH   DC    C'IOBCMDCH'
KCUE     DC    C'CUE'
KCE      DC    C'CE'
KDE      DC    C'DE'
KUC      DC    C'UC'
KUE      DC    C'UE'
KPCI     DC    C'PCI'
KIL      DC    C'IL'
KPC      DC    C'PC'
KPROTC   DC    C'PROTC'
KCDC     DC    C'CDC'
KCCC     DC    C'CCC'
KICC     DC    C'ICC'
KCHK     DC    C'CHK'
KCD      DC    C'CD'
KCC      DC    C'CC'
KSLI     DC    C'SLI'
KSKIP    DC    C'SKIP'
*
CMDLOOKU DC    XL128'00'
         ORG   CMDLOOKU+X'01'
         DC    AL1(CWRITET-CMDTAB)
         ORG   CMDLOOKU+X'02'
         DC    AL1(CREADFT-CMDTAB)
         ORG   CMDLOOKU+X'03'
         DC    AL1(CNOOP-CMDTAB)
         ORG   CMDLOOKU+X'05'
         DC    AL1(CWRITEDA-CMDTAB)
         ORG   CMDLOOKU+X'06'
         DC    AL1(CREADD-CMDTAB)
         ORG   CMDLOOKU+X'07'
         DC    AL1(CREWINDT-CMDTAB)
         ORG   CMDLOOKU+X'08'
         DC    AL1(CTIC-CMDTAB)
         ORG   CMDLOOKU+X'0C'
         DC    AL1(CREADBT-CMDTAB)
         ORG   CMDLOOKU+X'0D'
         DC    AL1(CWRITEKD-CMDTAB)
         ORG   CMDLOOKU+X'0E'
         DC    AL1(CREADKD-CMDTAB)
         ORG   CMDLOOKU+X'0F'
         DC    AL1(CREWINDU-CMDTAB)
         ORG   CMDLOOKU+X'12'
         DC    AL1(CREADC-CMDTAB)
         ORG   CMDLOOKU+X'16'
         DC    AL1(CREADR0-CMDTAB)
         ORG   CMDLOOKU+X'17'
         DC    AL1(CERASEG-CMDTAB)
         ORG   CMDLOOKU+X'1A'
         DC    AL1(CREAFHA-CMDTAB)
         ORG   CMDLOOKU+X'1D'
         DC    AL1(CWRITCKD-CMDTAB)
         ORG   CMDLOOKU+X'1E'
         DC    AL1(CREADCKD-CMDTAB)
         ORG   CMDLOOKU+X'1F'
         DC    AL1(CWRITETM-CMDTAB)
         ORG   CMDLOOKU+X'22'
         DC    AL1(CREADSEC-CMDTAB)
         ORG   CMDLOOKU+X'23'
         DC    AL1(CSETSECT-CMDTAB)
         ORG   CMDLOOKU+X'27'
         DC    AL1(CBSPBT-CMDTAB)
         ORG   CMDLOOKU+X'29'
         DC    AL1(CSEARKEQ-CMDTAB)
         ORG   CMDLOOKU+X'2F'
         DC    AL1(CBSPFT-CMDTAB)
         ORG   CMDLOOKU+X'31'
         DC    AL1(CSEARIDE-CMDTAB)
         ORG   CMDLOOKU+X'37'
         DC    AL1(CFSPBT-CMDTAB)
         ORG   CMDLOOKU+X'3F'
         DC    AL1(CFSPFT-CMDTAB)
         ORG   CMDLOOKU+X'69'
         DC    AL1(CSEARKHE-CMDTAB)
         ORG
CMDTAB   EQU   *                   CCW COMMAND NAME
CUNKNOWN DC    CL8'UNKNOWN'        00
CWRITET  DC    CL8'WRITET'         01
CREADFT  DC    CL8'READFT'         02
CNOOP    DC    CL8'NO-OP'          03
CWRITEDA DC    CL8'WRITEDATA'      05
CREADD   DC    CL8'READDATA'       06
CREWINDT DC    CL8'REWIND'         07
CTIC     DC    CL8'TIC'            08
CREADBT  DC    CL8'READBT'         0C
CWRITEKD DC    CL8'WRITEKD'        0D
CREADKD  DC    CL8'READKD'         0E
CREWINDU DC    CL8'REWINDU'        0F
CREADC   DC    CL8'READC'          12
CREADR0  DC    CL8'READR0'         16
CERASEG  DC    CL8'ERASEGAP'       17
CREAFHA  DC    CL8'READHA'         1A
CWRITCKD DC    CL8'WRITECKD'       1D
CREADCKD DC    CL8'READCKD'        1E
CWRITETM DC    CL8'WRITETM'        1F
CREADSEC DC    CL8'READSECT'       22
CSETSECT DC    CL8'SETSECT'        23
CBSPBT   DC    CL8'BACKSBLK'       27
CSEARKEQ DC    CL8'SEARKEQ'        29
CBSPFT   DC    CL8'BACKSFIL'       2F
CSEARIDE DC    CL8'SEARIDEQ'       31
CFSPBT   DC    CL8'FORSPBLK'       37
CFSPFT   DC    CL8'FORSPFIL'       3F
CSEARKHE DC    CL8'SEARKHE'        69
*
*        WORK AREAS
*
IER983   DC    A(IER983T)
         DC    A(IER983X-IER983T)  L'MSG TEXT
IER983T  DC    C'IER983I EXCP Issued by '
IER983M  DC    CL6' '              MODULE NAME (6 CHAR)
         DC    C'+'
IER983O  DC    CL4' '              OFFSET IN MODULE
IER983X  EQU   *
*
IER984   DC    A(IER984T)
         DC    A(IER984X-IER984T)  L'MSG TEXT
IER984T  DC    C'IER984I WAIT on EXCP Issued by '
IER984M  DC    CL6' '              MODULE NAME (6 CHAR)
         DC    C'+'
IER984O  DC    CL4' '              OFFSET IN MODULE
IER984X  EQU   *
*
IER983D  DC    A(IER983P)
         DC    A(L'IER983P)
IER983P  DC    CL120' '            GENERAL DATA LINE
*
BLANKS   DC    C'  '
WORKD    DC    D'0'                WORK AREA
*
EPATTN4  DC    XL4'40212121'
EPATTN6  DC    XL6'402021212121'
EPATTN6Z DC    XL6'402020202121'
KNA      DC    CL8'N/A'
*
*        DEBUGGING FIELDS
*
*        DATA IS EXTRACTED OUT OF THE CURRENT RECORD BEING
*        TRACED AND STORED IN THE COMPxxx FIELDS.
*        THIS IS COMPARED TO THE COMPARISON DATA AT LABEL
*        IERTDEX AND IF MATCHED A DDT BREAKPOINT IS TRIGGERED
*
         DC    0D'0'
DATA     DS    0XL27               L'FIELDS FOR COMPARE
DATADCB  DC    CL8' '              DCB DD NAME
DATAREQ  DC    X'00'               EXCP OR WAIT
DATASID  DC    XL8'0000000000000000'  MBBCCHHR OF RECORD
*
DATARECN DC    CL10'0000000000'
DATAMB   DC    XL2'0000'
*
*        DEBUGGING COMPARISON DATA
*
         DC    0D'0'
COMP     DS    0XL27
COMPDCB  DC    CL8'SORTWK00'
COMPREQ  DC    X'02'               X'01' EXCP REQUEST
*                                  X'02' WAIT ENTRY
*
*                   M B B C C H H R
COMPSID  DC    XL8'0000000000000000'
*
*                   1234567890
COMPRECN DC    CL10'0000006870'
COMPMB   DC    XL2'0000'
*
         LTORG
*
*        TRANSLATE ALL UNPRINTABLE CHARS TO HEX A1
*
TRANTAB  DC    X'A1A1A1A1A1A1A1A1'  ~~~~~~~~   00 -> 07
         DC    X'A1A1A1A1A1A1A1A1'  ~~~~~~~~   08 -> 0F
         DC    X'A1A1A1A1A1A1A1A1'  ~~~~~~~~   10 -> 17
         DC    X'A1A1A1A1A1A1A1A1'  ~~~~~~~~   18 -> 1F
         DC    X'A1A1A1A1A1A1A1A1'  ~~~~~~~~   20 -> 27
         DC    X'A1A1A1A1A1A1A1A1'  ~~~~~~~~   28 -> 2F
         DC    X'A1A1A1A1A1A1A1A1'  ~~~~~~~~   30 -> 37
         DC    X'A1A1A1A1A1A1A1A1'  ~~~~~~~~   38 -> 3F
         DC    X'40A1A1A1A1A1A1A1'  ~~~~~~~~   40 -> 47
         DC    X'A1A14A4B4C4D4E4F'  ~~ó.<(+|   48 -> 4F
         DC    X'50A1A1A1A1A1A1A1'  &~~~~~~~   50 -> 57
         DC    X'A1A15A5B5C5D5E5F'  ~~!$*);¬   58 -> 5F
         DC    X'6061A1A1A1A1A1A1'  -/~~~~~~   60 -> 67
         DC    X'A1A16A6B6C6D6E6F'  ~~ ,%_>?   68 -> 6F
         DC    X'A1A1A1A1A1A1A1A1'  ~~~~~~~~   70 -> 77
         DC    X'A1797A7B7C7D7E7F'  ~`:#@'="   78 -> 7F
         DC    X'A181828384858687'  ~ABCDEFG   80 -> 87
         DC    X'8889A1A1A1A1A1A1'  HI~~~~~~   88 -> 8F
         DC    X'A191929394959697'  ~JKLMNOP   90 -> 97
         DC    X'9899A1A1A1A1A1A1'  QR~~~~~~   98 -> 9F
         DC    X'A1A1A2A3A4A5A6A7'  ~~STUVWX   A0 -> A7
         DC    X'A8A9A1A1A1ADA1A1'  YZ~~~Ý~~   A8 -> AF
         DC    X'A1A1A1A1A1A1A1A1'  ~~~~~~~~   B0 -> B7
         DC    X'A1A1A1A1A1BDA1A1'  ~~~~~¨~~   B8 -> BF
         DC    X'C0C1C2C3C4C5C6C7'  {ABCDEFG   C0 -> C7
         DC    X'C8C9A1A1A1A1A1A1'  HI~~~~~~   C8 -> CF
         DC    X'D0D1D2D3D4D5D6D7'  }JKLMNOP   D0 -> D7
         DC    X'D8D9A1A1A1A1A1A1'  QR~~~~~~   D8 -> DF
         DC    X'E0A1E2E3E4E5E6E7'  \~STUVWX   E0 -> E7
         DC    X'E8E9A1A1A1A1A1A1'  YZ~~~~~~   E8 -> EF
         DC    X'F0F1F2F3F4F5F6F7'  01234567   F0 -> F7
         DC    X'F8F9A1A1A1A1A1A1'  89~~~~~~   F8 -> FF
*
         IERCCWEQ
*
         PRINT NOGEN
*
*        MAP IOB
*
         IERIOB
*
         PRINT NOGEN
*
*        MAP DCB
*
         DCBD DSORG=PS,DEVD=(DA,TA)
*
*        MAP CVT
*
         CVT  DSECT=YES
*
*        MAP TIOT
*
TIOT     DSECT
*
         IEFTIOT1
*
*        MAP TCB
*
         IKJTCB
*
*        MAP CDE
*
         IHACDE
*
*        MAP EXTENT LIST
*
         IHAXTLST
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IEREX1   0101-20211-20211-1200-00113-00113-00000-RELEASE 00
EX1      TITLE 'IEREX1 - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IEREX1
*
*        MODULE FUNCTION/OPERATION -
*        INSERT THE ADDRESSES OF THE USER EXIT MODULES INTO THE
*        PROPER ADDRESS LOCATIONS IN THE PPI
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACROS USED BY MODULE - SMPPI
*
*        ENTRY POINTS - N/A
*
*        INPUT - PPI FIELDS REFERENCED - N/A
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPIX11   PPIX15   PPIX17   PPIX18
*        PPIX19   PPIX61   PPIX16
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS -
*        EXTRN E1
*        EXTRN E15
*        EXTRN E17
*        EXTRN E18
*        EXTRN E19
*        EXTRN E61
*        EXTRN E16
*
*        EXITS - NORMAL - BRANCH TO IERRC9 VIA R14
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS - N/A
*
*        NOTES - N/A
*
IEREX1   CSECT
*
         EXTRN E11
*
         EXTRN E15
*
         EXTRN E17
*
         EXTRN E18
*
         EXTRN E19
*
         EXTRN E61
*
         EXTRN E16
*
         USING *,R15
*
         IERENTRY 'IEREX1 &SYSDATE &SYSTIME'
*
         STM   R0,R15,REGSAVE      SAVE REGISTERS
         LR    R11,R15             SET UP BASE REGISTER
         DROP  R15
         USING IEREX1,R11
         USING IERRCA,R13          PPI COMMON MODULE BASE REGISTER
         LA    R5,PPIX11           SET POINTER A TO PPIX11
         LA    R7,AE16             SET END POINTER TO E16
         LA    R6,AE11             SET POINTER B TO E11
         SR    R1,R1               ZERO R1
EX1NEXT  C     R1,0(,R6)           EMPTY ADCON ?
         BE    EX1LAST             YES, BRANCH
         MVC   4(4,R5),0(R6)       MOVE ADCON TO POINTER A PLUS 4
EX1LAST  TM    FINSW,X'01'         FINISH ON ?
         BO    EX1RETN             YES, BRANCH TO RETURN TO CALLER
         LA    R6,4(,R6)           INCR POINTER B
         CLR   R6,R7               LAST ADDRESS ?
         BE    EX1END              YES, BRANCH FOR LAST PASS
         LA    R5,16(,R5)          INCR POINTER A
         B     EX1NEXT             GET NEXT ADCON
*
EX1END   LA    R5,8(,R5)           INCR POINTER A
         OI    FINSW,X'01'         SET FINISH SWITCH
         B     EX1NEXT             GET LAST ADCON
*
EX1RETN  LM    R0,R15,REGSAVE      RESTORE REGISTERS
         BR    R14                 RETURN TO RC9
*
*        SAVE AREA FOR REGISTERS
*
REGSAVE  DC    16F'0'
*
*        ADDRESS CONSTANTS
*
AE11     DC    A(E11)
         DC    A(E15)
         DC    A(E17)
         DC    A(E18)
         DC    A(E19)
         DC    A(E61)
AE16     DC    A(E16)
*
*        SWITCHES
*
FINSW    DC    X'00'
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IEREX2   0101-20211-20211-1200-00104-00104-00000-RELEASE 00
EX2      TITLE 'IEREX2 - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IEREX2
*
*        MODULE FUNCTION/OPERATION -
*        INSERT THE ADDRESSES OF THE USER EXIT MODULES INTO THE
*        PROPER POINTERS IN PPI
*
*        MODULES IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACROS USED BY MODULE - SMPPI
*
*        ENTRY POINTS - N/A
*
*        INPUT - PPI FIELDS REFERENCED - N/A
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPIX21   PPIX25   PPIX27
*        PPIX28   PPIX29   PPIX61
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS -
*        E21
*        E25
*        E27
*        E28
*        E29
*        E61
*
*        EXITS - NORMAL - BRANCH TO IERRC9 VIA R14
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS - N/A
*
*        NOTES - N/A
*
IEREX2   CSECT
*
         EXTRN E21
         EXTRN E25
         EXTRN E27
         EXTRN E28
         EXTRN E29
         EXTRN E61
*
         USING *,R15
*
         IERENTRY 'IEREX2 &SYSDATE &SYSTIME'
*
         STM   R0,R15,REGSAVE      SAVE REGISTERS
         LR    R11,R15             SET UP BASE REGISTER
         DROP  R15
         USING IEREX2,R11
         USING IERRCA,R13          PPI COMMON MODULE BASE REGISTER
         LA    R5,PPIX21           SET POINTER A TO PPIX21
         LA    R7,AE61             SET END POINTER TO E61
         LA    R6,AE21             SET POINTER B TO E21
         SR    R1,R1               ZERO R1
EX2NEXT  CL    R1,0(,R6)           EMPTY ADCON ?
         BE    EX2LAST             YES, BYPASS STORE
         MVC   4(4,R5),0(R6)       MOVE ADCON TO POINTER A PLUS 4
EX2LAST  TM    FINSW,X'01'         FINISH ON ?
         BO    EX2RETN             YES, RETURN TO CALLER
         LA    R6,4(,R6)           ADD 4 TO POINTER B
         CLR   R6,R7               LAST ADDR ?
         BE    EX2END              YES, BRANCH
         LA    R5,16(,R5)          ADD 16 TO POINTER A
         B     EX2NEXT             GET NEXT ADCON
*
EX2END   LA    R5,8(,R5)           ADD 8 TO POINTER A
         OI    FINSW,X'01'         SET ON FINISH SWITCH
         B     EX2NEXT             GET LAST ADCON
*
EX2RETN  LM    R0,R15,REGSAVE      RESTORE REGISTERS
         BR    R14                 RETURN TO IERRC9
*
*        SAVE AREA FOR REGISTERS
*
REGSAVE  DC    16F'0'
*
*        ADDRESS CONSTANTS
*
AE21     DC    A(E21)
         DC    A(E25)
         DC    A(E27)
         DC    A(E28)
         DC    A(E29)
AE61     DC    A(E61)
*
*        SWITCHES
*
FINSW    DC    X'00'
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IEREX3   0101-20211-20211-1200-00111-00111-00000-RELEASE 00
EX3      TITLE 'IEREX3 - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IEREX3
*
*        MODULE FUNCTION/OPERATION -
*        INSERT THE ADDRESSES OF THE USER EXIT MODULES INTO THE
*        PROPER POINTERS IN PPI
*
*        MODULES IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        LIST OF MACROS USED BY MODULE - SMPPI
*
*        ENTRY POINTS - N/A
*
*        INPUT - PPI FIELDS REFERENCED - N/A
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPIX31   PPIX35   PPIX37
*        PPIX38   PPIX39   PPIX61
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS -
*        EXTRN E31
*        EXTRN E35
*        EXTRN E37
*        EXTRN E38
*        EXTRN E39
*        EXTRN E61
*
*        EXITS - NORMAL -
*        BRANCH TO RC9 VIA R14
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS - N/A
*
*        NOTES - N/A
*
IEREX3   CSECT
*
         EXTRN E31
         EXTRN E35
         EXTRN E37
         EXTRN E38
         EXTRN E39
         EXTRN E61
*
         USING *,R15
*
         IERENTRY 'IEREX3 &SYSDATE &SYSTIME'
*
         STM   R0,R15,REGSAVE      SAVE REGISTERS
         LR    R11,R15             SET UP BASE REGISTER
         DROP  R15
         USING IEREX3,R11
         USING IERRCA,R13          PPI COMMON MODULE BASE REGISTER
         LA    R5,PPIX31           SET POINTER A TO PPIX31
         LA    R7,AE61             SET END POINTER TO E61
         LA    R6,AE31             SET POINTER B TO E31
         SR    R1,R1               ZERO R1
EX3NEXT  CL    R1,0(,R6)           ADCON NOT RESOLVED ?
         BE    EX3LAST             YES, BYPASS STORE
         MVC   4(4,R5),0(R6)       MOVE ADCON TO POINTER A PLUS 4
EX3LAST  TM    FINSW,X'01'         TEST FINISH SWITCH
         BO    EX3RETN             IF FINSW IS SET RETURN TO CALLER
         LA    R6,4(,R6)           ADD 4 TO POINTER B
         CLR   R6,R7               LAST ADDR ?
         BE    EX3END              YES, BRANCH
         LA    R5,16(,R5)          ADD 16 TO POINTER A
         B     EX3NEXT             LOOP TO PROCESS NEXT ADCON
*
EX3END   LA    R5,8(,R5)           ADD 8 TO POINTER A
         OI    FINSW,X'01'         SET FINISH SWITCH
         B     EX3NEXT             GET LAST ADCON
*
EX3RETN  LM    R0,R15,REGSAVE      RESTORE REGISTERS
         BR    R14                 RETURN TO RC9
*
*
*        SAVE AREA FOR REGISTERS
*
REGSAVE  DC    16F'0'
*
*
*        ADDR CONSTANTS
*
AE31 DC        A(E31)
         DC    A(E35)
         DC    A(E37)
         DC    A(E38)
         DC    A(E39)
AE61     DC    A(E61)
*
*
*        SWITCHES
*
FINSW    DC    X'00'
*
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
*        DSECTS
*
         SMPPI
*
         END
./ ADD NAME=IERFMT   0101-20211-20211-1200-00291-00291-00000-RELEASE 00
FMT      TITLE 'IERFMT - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERFMT
*
*        MODULE FUNCTION/OPERATION -
*        FORMAT STORAGE FOR PRINTING FOR DIAGNOSTIC PURPOSES
*        UP TO 32 BYTES PER LINE ARE FORMATTED INTO A 120 BYTE BUFFER
*        SIMILAR TO THE OUTPUT GENERATED BY SNAP
*        NULL LINES, EXCEPT FOR THE FIRST, ARE SUPRESSED AND THE
*        RANGE SUPRESSED IS IDENTIFIED IN A MESSAGE, AGAIN SIMILAR
*        TO SNAP
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        ENTRY POINTS - IERFMT
*                       VIA BASR R14,R15
*
*        EXTERNAL PARAMETERS -
*        R1 ->
*         ______________
*        | ADDR OF      |
*        | STORAGE AREA |
*        | TO FORMAT    |
*        |______________|
*        | END ADDR OF  |
*        | STORAGE AREA |
*        | TO FORMAT    |
*        |______________|
*        | ADDR OF PRINT|
*        | ROUTINE      |
*        | CALLED TO    |
*        | PRINT EACH   |
*        | LINE         |
*        |______________|
*
*
*        EXITS - NORMAL -
*        RETURN TO CALLING ROUTINE VIA R14
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS - N/A
*
*        NOTES -
*        THIS MODULE PROVIDES A FORMATED STORAGE DUMP SIMILAR
*        TO THE FORMAT GENERATED BY SNAP
*
IERFMT   CSECT
*
         USING *,R15               ENTER VIA R15
*
         IERENTRY 'IERFMT &SYSDATE &SYSTIME'
*
         STM   R14,R12,FMTSAVE     SAVE CALLERS REGS
         DROP  R15
         LA    R12,0(,R15)
         USING IERFMT,R12          MODULE BASE REGISTER
*
         LM    R9,R11,0(R1)        R9  -> START OF DATA
*                                  R10 -> END OF DATA
*                                  R11 -> PRINT ROUTINE
         LR    R7,R10              R7 -> END OF DATA
         SR    R7,R9               SUBTRACT START OF DATA
         LA    R7,1(,R7)           R7 = L'DATA TO FORMAT
*
*        BEGIN FORMATTING A LINE
*        FIRST TEST IF THIS IS THE LAST LINE OF THE STORAGE AREA
*
BEGINLIN CH    R7,=H'32'           MORE THAN 32 BYTES REMAINING ?
         BH    FMT001              YES, BRANCH
*
*        THIS IS THE LAST LINE
*
         CLC   STRTNULL,ENDNULL    ANY SUPRESSED NULL LINES ?
         BE    FMT009              NO, BRANCH, STANDARD PROCESSING
         BAS   R14,NULLLIN         YES, CALL RTN TO PRINT RANGE
         B     FMT009              GO PRINT REMAINING BYTES
*
*        NOT LAST LINE
*
FMT001   CLC   0(32,R9),HEXNULLS   A NULL LINE ?
         BNE   FMT003              NO, BRANCH
         CLI   PRNTNULL,1          YES, A PREVIOUS NULL LINE PRINTED ?
         BE    FMT005              YES, BRANCH
         MVI   PRNTNULL,1          TURN ON PRINTING NULL LINE
         B     FMT009              STANDARD PROCESSING
*
*        A NULL LINE HAS BEEN PRINTED PREVIOUSLY AND THIS LINE IS
*        NULL
*
FMT005   CLC   STRTNULL,ENDNULL    YES, ANY PREVIOUS NULL LINES ?
         BNE   FMT004              YES, BRANCH
         ST    R9,STRTNULL         NO, STORE START ADDR
         LA    R15,31(,R9)         CALC END ADDR
         ST    R15,ENDNULL         STORE END ADDR
         B     FMTNOP              SUPRESS PRINTING
*
*        ALREADY SUPRESSED A LINE, UPDATE END ADDR ONLY
*
FMT004   L     R15,ENDNULL
         LA    R15,32(,R15)        CALC NEW END ADDR
         ST    R15,ENDNULL         STORE END ADDR
         B     FMTNOP              SUPPRESS PRINTING
*
*        NOT A NULL LINE
*
FMT003   MVI   PRNTNULL,0          TURN OFF PRINTING NULL LINE
         CLC   STRTNULL,ENDNULL    ANY PREVIOUS SUPRESSED LINES ?
         BE    FMT009              NO, GO PRINT
         BAS   R14,NULLLIN         YES, CALL RTN TO PRINT RANGE
FMT009   MVC   FMTDATA(L'BLNKLINE),BLNKLINE
         SR    R8,R8               ZERO BYTES PROCESSED THIS LINE
         LR    R6,R9               R6 -> DATA FOR THIS LINE
         LR    R0,R9               GET ADDR FOR FORMATTING
         BAS   R14,BIN2HEX         CONVERT STORAGE ADDR
         MVC   FMTDATA+4(6),2(R1)  MOVE DATA ADDR INTO MSG
         LA    R2,FMTDATA+11       R2 -> START OF DATA IN MSG
         LA    R3,8                DUMP 4*8 BYTES PER LINE
*
*        FORMAT UP TO 4 BYTES OF DATA
*
FMT4BYTE CH    R7,=H'4'            GOT 4 BYTES LEFT TO PROCESS ?
         BL    FMTLT4              NO, BRANCH
         ICM   R0,B'1111',0(R6)    YES, GET DATA FOR FORMATTING
         BAS   R14,BIN2HEX         CONVERT DATA
         MVC   0(8,R2),0(R1)       MOVE CONVERTED DATA INTO MSG
         LA    R2,9(,R2)           INCR TO NEXT OUTPUT LOCATION
         LA    R6,4(,R6)           INCR ADDR POINTER
         LA    R8,4(,R8)           INCR BYTES PROCESSED THIS LINE
         SH    R7,=H'4'            DECR REMAINING BYTE COUNT
         BZ    FMTCHAR             NO MORE DATA REMAINING
         BCT   R3,FMT4BYTE         PROCESS NEXT 4 BYTES
         B     FMTCHAR             GO FORMAT CHARACTER DATA FOR MSG
*
*        FORMAT LESS THAN 4 BYTES OF DATA
*
FMTLT4   IC    R15,ICMMASK(R7)     CONVERT L'DATA TO ICM MASK
         EX    R15,ICMLOAD         GET DATA INTO R0 VIA ICM
         BAS   R14,BIN2HEX         CONVERT DATA
         LA    R8,0(R8,R7)         INCR BYTES PROCESSED COUNT
         SLL   R7,1                DOUBLE THE BYTE COUNT
         BCTR  R7,0                DECR FOR EX
         EX    R7,MVCDATA          MOVE DATA INTO MSG
         SR    R7,R7               NO MORE DATA TO PROCESS
*
*        FORMAT CHAR DATA
*
FMTCHAR  BCTR  R8,0                DECR BYTES PROCESSED FOR EX
         EX    R8,MVCPDATA         MOVE DATA INTO PRINT LINE
         EX    R8,TRDATA           TRANSLATE UNPRINTABLES TO ~
*
*        CALL PRINT ROUTINE TO WRITE LINE
*
         LM    R0,R1,WTRPARM       MESSAGE TEXT
         LR    R15,R11             R15 -> PRINT ROUTINE
         BASR  R14,R15             CALL PRINT RTN
         LTR   R7,R7               ANY MORE DATA TO FORMAT ?
         BZ    IERFMTXX            NO, BRANCH
         LA    R9,1(R8,R9)         YES, INCR TO NEXT INPUT DATA BYTE
         B     BEGINLIN            RE-ENTER LOOP
*
*        SUPPRESS PRINTING A NULL LINE
*
FMTNOP   LA    R9,32(,R9)          INCR ADDR
         SH    R7,=H'32'           DECR COUNT OF DATA TO PRINT
         B     BEGINLIN            RE-ENTER LOOP
*
*        EXIT
*
IERFMTXX LM    R14,R12,FMTSAVE     RESTORE CALLERS REGS
         XR    R15,R15
         BR    R14                 RETURN TO CALLER
*
*        NULLLIN
*
*        PRINT MESSAGE IDENTIFYING SUPPRESSED NULL LINES RANGE
*
NULLLIN  ST    R14,NULLSAVE        SAVE THE RETURN ADDDR
         MVI   FMTDATA,C' '        BLANK PRINT LINE
         MVC   FMTDATA+1(L'FMTDATA-1),FMTDATA
         L     R0,STRTNULL         R0 = START ADDR OF SUPPRESSED NULLS
         BAS   R14,BIN2HEX         CONVERT ADDR TO PRINTABLE HEX
         MVC   FMTDATA+11(6),2(R1)  MOVE IN START ADDR
         MVI   FMTDATA+18,C'-'
         L     R0,ENDNULL          R0 = ADDR OF END OF SUPRESS NULLS
         BAS   R14,BIN2HEX
         MVC   FMTDATA+20(6),2(R1)  MOVE IN END ADDR
         MVC   FMTDATA+27(13),=C'SAME AS ABOVE'
*
*        CALL PRINT ROUTINE TO WRITE LINE
*
         LM    R0,R1,WTRPARM       MESSAGE TEXT
         LR    R15,R11             R15 -> PRINT ROUTINE
         BASR  R14,R15             CALL PRINT RTN
         XC    STRTNULL,STRTNULL   ZERO START ADDR OF SUPPRESSED NULL
         XC    ENDNULL,ENDNULL     ZERO ENDT ADDR OF SUPPRESSED NULL
         MVI   PRNTNULL,0          ZERO PRINT NULL LINE
         L     R14,NULLSAVE        R14 = RETURN ADDR
         BR    R14                 RETURN
*
*        BINARY TO PRINTABLE HEX CONVERSION ROUTINE
*
*        ON INPUT -
*        R0 = 4 BYTES OF DATA FOR CONVERSION
*        ON OUTPUT -
*        R1 -> 8 BYTES OF CONVERTED DATA
*
BIN2HEX  ST    R0,DM4HEX           STORE NUMBER TO BE CONVERTED
         UNPK  DM4TEMP(9),DM4HEX(5)      UNPACK NUMBER
         NC    DM4TEMP,DM4MASK     ZERO HIGH ORDER NIBBLE
         TR    DM4TEMP,DM4HTBL     CONVERT TO HEX CHAR
         LA    R1,DM4TEMP          R1 -> FORMATTED DATA FOR CALLER
         BR    R14                 RETURN TO CALLING ROUTINE
*
*        CONSTANTS
*
ICMLOAD  ICM   R0,B'0000',0(R6)    GET REMAINING BYTES FOR FORMATTING
MVCDATA  MVC   0(0,R2),0(R1)       MOVE FORMATTED DATA INTO MSG
MVCPDATA MVC   FMTDATA+84(0),0(R9)    MOVE DATA FOR PRINT TRANSLATE
TRDATA   TR    FMTDATA+84(0),TRANTAB  CONVERT ALL UNPRINTABLES TO ~
*
NULLSAVE DC    A(0)                R14 SAVE AREA FOR NULLLIN RTN
STRTNULL DC    A(0)
ENDNULL  DC    A(0)
PRNTNULL DC    X'00'               NON ZERO IF PREVIOUS LINE NULL
*
HEXNULLS DC    XL32'00'            TEST FOR NULL LINE
ICMMASK  DC    XL4'00080C0E'       CONVERT NO OF BYTES TO ICM MASK
*
BLNKLINE DC    C'    XXXXXX                                            C
                                            *                          C
                     *'
*
*        WORK AREAS
*
FMTSAVE  DC    18F'0'              REGISTER SAVE AREA
WTRPARM  DC    A(FMTDATA)
         DC    A(L'FMTDATA)
FMTDATA  DC    CL120' '            GENERAL DATA LINE
*
DM4TEMP  DC    D'0'                STORAGE FOR CONVERTED NUMBER
         DC    X'00'               RESERVED
DM4HTBL  DC    C'0123456789ABCDEF'   TRANSLATE TABLE FOR HEX CONVERT
DM4HEX   DC    F'0'                WORK AREA FOR HEX CONVERSION
         DC    X'00'               RESERVED
DM4MASK  DC    X'0F0F0F0F0F0F0F0F'
*
         LTORG
*
*        TRANSLATE ALL UNPRINTABLE CHARS TO HEX A1
*
TRANTAB  DC    X'A1A1A1A1A1A1A1A1'  ~~~~~~~~   00 -> 07
         DC    X'A1A1A1A1A1A1A1A1'  ~~~~~~~~   08 -> 0F
         DC    X'A1A1A1A1A1A1A1A1'  ~~~~~~~~   10 -> 17
         DC    X'A1A1A1A1A1A1A1A1'  ~~~~~~~~   18 -> 1F
         DC    X'A1A1A1A1A1A1A1A1'  ~~~~~~~~   20 -> 27
         DC    X'A1A1A1A1A1A1A1A1'  ~~~~~~~~   28 -> 2F
         DC    X'A1A1A1A1A1A1A1A1'  ~~~~~~~~   30 -> 37
         DC    X'A1A1A1A1A1A1A1A1'  ~~~~~~~~   38 -> 3F
         DC    X'40A1A1A1A1A1A1A1'  ~~~~~~~~   40 -> 47
         DC    X'A1A14A4B4C4D4E4F'  ~~ó.<(+|   48 -> 4F
         DC    X'50A1A1A1A1A1A1A1'  &~~~~~~~   50 -> 57
         DC    X'A1A15A5B5C5D5E5F'  ~~!$*);¬   58 -> 5F
         DC    X'6061A1A1A1A1A1A1'  -/~~~~~~   60 -> 67
         DC    X'A1A16A6B6C6D6E6F'  ~~ ,%_>?   68 -> 6F
         DC    X'A1A1A1A1A1A1A1A1'  ~~~~~~~~   70 -> 77
         DC    X'A1797A7B7C7D7E7F'  ~`:#@'="   78 -> 7F
         DC    X'A181828384858687'  ~ABCDEFG   80 -> 87
         DC    X'8889A1A1A1A1A1A1'  HI~~~~~~   88 -> 8F
         DC    X'A191929394959697'  ~JKLMNOP   90 -> 97
         DC    X'9899A1A1A1A1A1A1'  QR~~~~~~   98 -> 9F
         DC    X'A1A1A2A3A4A5A6A7'  ~~STUVWX   A0 -> A7
         DC    X'A8A9A1A1A1ADA1A1'  YZ~~~Ý~~   A8 -> AF
         DC    X'A1A1A1A1A1A1A1A1'  ~~~~~~~~   B0 -> B7
         DC    X'A1A1A1A1A1BDA1A1'  ~~~~~¨~~   B8 -> BF
         DC    X'C0C1C2C3C4C5C6C7'  {ABCDEFG   C0 -> C7
         DC    X'C8C9A1A1A1A1A1A1'  HI~~~~~~   C8 -> CF
         DC    X'D0D1D2D3D4D5D6D7'  }JKLMNOP   D0 -> D7
         DC    X'D8D9A1A1A1A1A1A1'  QR~~~~~~   D8 -> DF
         DC    X'E0A1E2E3E4E5E6E7'  \~STUVWX   E0 -> E7
         DC    X'E8E9A1A1A1A1A1A1'  YZ~~~~~~   E8 -> EF
         DC    X'F0F1F2F3F4F5F6F7'  01234567   F0 -> F7
         DC    X'F8F9A1A1A1A1A1A1'  89~~~~~~   F8 -> FF
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         END
./ ADD NAME=IERRBA   0101-20211-20211-1200-00133-00133-00000-RELEASE 00
RBA      TITLE 'IERRBA - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRBA
*
*        MODULE FUNCTION -
*        OSCILLATING 2314 BLOCK ROUTINE
*        THIS MODULE IS USED BY OSCILLATING OR 2314 SORT FOR
*        VARIABLE LENGTH RECORDS THE FUNCTION OF THIS MODULE IS
*        TO BLOCK VARIABLE LENGTH RECORDS IN THE OUTPUT
*        BUFFER(S). TO DO THIS IT LINKS TO THE VARIABLE MOVE
*        ROUTINE, IERRBF, WHICH MOVES THE RECORD FROM RSA(BINS)
*        TO AN OUTPUT TO THE DEBLOCK MODULE. NOW THAT THE BIN(S)
*        IN RSA HAVE BEEN FREED THIS MODULE UPDATES THE NEXT
*        AVAILABLE RSA BIN POINTER AND COUNTER LOCATED IN PPI
*
*        INFORMATION COMMUNICATED BETWEEN MODULES ARE AS FOLLOWS -
*        NETWORK TO BLOCK -
*          R3 CONTAINS WINNER ADDRESS IN RSA
*        BLOCK TO MOVE -
*          R5 HAS ADDRESS OF RCD IN RSA, R1 HAS ADDRESS IN OUTPUT
*          BUFFER TO MOVE THE RECORD, R1 HAS A 4 TO DENOTE BLOCK
*          ROUTINE
*        MOVE TO BLOCK -
*          R1 HAS NUMBER OF BINS FREED, R5 POINTS TO CHAIN ADDR OF
*          LAST BIN MOVED
*        BLOCK TO WRITE -
*          R1 HAS OUTPUT BLOCK COUNT, R2 HAS ADDR OF OUTPUT
*          BUFFER, R4 HAS 4 FOR NORMAL EOS OTHERWISE HAS A ZERO
*        WRITE TO BLOCK -
*          R2 HAS ENDING ADDRESS OF OUTPUT BLOCK+1
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - IERABA
*
*        LIST OF MACROS USED BY MODULE -
*
*        SMPPI
*
*        ENTRY POINTS - NETWORK TO BLOCK  - ENTRY FROM NETWORK
*                                           CALLING SEQUENCE -
*                                           L   R11,PPIBLK+4
*                                           B   0(,R11)     LAST RCD
*                                           B   4(,R11)     EOS
*                                           B   12(,R11)    NORMAL
*
*                     - MOVE RTN TO BLOCK - ENTRY FROM MOVE ROUTINE
*                                           CALLING SEQUENCE
*                                           BR   R14      RETURN
*
*                     - WRITE TO BLOCK    - ENTRY FROM WRITE
*                                           CALLING SEQUENCE
*                                           L   R11,PPIBLK+4
*                                           B   8(0,R11)    NORMAL
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIBDSVA   PPILEXFF
*        PPIDEB     PPIWRT
*        PPILAB07   PPIDEPHO
*        PPIUNTCT
*        INFO IS NEEDED FOR LINKAGE TO OTHER MODULES AND FOR
*        CALCULATIIONS
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED
*        PPIBDSVA
*        UNIT COUNTERS IN GENERATED CORE ARE UPDATED FOR EACH
*        RECORD BLOCKED AVAILABLE BIN POINTER WITHIN THIS AREA
*
*        EXTERNAL ROUTINES -
*
*        EXTRN IERRBF - ADDR ALSO WITHIN PPIBDSVA
*                       THIS ROUTINE MOVES THE RCD FORM RSA TO AN
*                       OUTPUT BUFFER
*
*        EXTERNAL PARAMETERS - NONE
*
*        EXITS - NORMAL - BLOCK TO WRITE    - EXIT TO WRITE
*                                             CALLING SEQUENCE
*                                             L   R11,PPIWRT+4
*                                             B   4(,R11)  ANY EOS
*                                             B   8(,R11)  NORMAL WRITE
*
*                       - BLOCK TO DEBLOCK  - EXIT TO DEBLOCK
*                                             CALLING SEQUENCE
*                                             L   R11,PPIDEB+4
*                                             B   8(,R11)
*
*                       - BLOCK TO MOVE RTN - EXIT TO IERABF
*                                             CALLING SEQUENCE
*                                             L    R15,PPIBDSVA+12
*                                             BALR R14,R15
*
*        EXITS - ERROR - NONE
*
*        TABLES/WORK AREAS -
*
*        WBLKCCNT -
*          KEEPS TRACK OF THE NUMBER OF BYTES IN AN OUTPUT BUFFER
*        WINNER -
*          ADDR OF THE NEXT RECORD IN RSA TO BE BLOCKED
*        WLSTPTR -
*          ADDR OF THE PRESENT OUTPUT BUFFER
*        WLSTPTRD -
*          ADDR OF AN AVAILABLE AREA IN THE OUTPUT BUFFER
*        WKEEPAVA -
*          STARTING ADDR OF THE WINNER'S BIN IN RSA
*        WHOLD -
*          WORK AREA
*        WLASTRCD -
*          LAST RECORD SWITCH
*
*        NOTES -
*        THIS MODULE IS USED BY THE OSCILLATING SORT FOR A
*        VARIABLE LENGTH TAPE SORT OR THE 2314 FOR A VARIABLE
*        DISK SORT
*
IERRBA   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRBA SOURCE
*
*----------------------------------------------------------------------
*
         COPY IERRBAI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERRBAI  0101-20211-20211-1200-00183-00183-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERRBA SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERRBAI
*
         USING *,R11               MODULE BASE REG LOADED EXTERNALLY
         USING IERRCA,R13          PPI COMMON MODULE BASE REGISTER
*
*        ENTRY TABLE
*
IERDB1   B     RBLSTRCD            +00 LAST RCD ENTRY FROM REPLACEMENT
         B     RBEOS               +04 EOS ENTRY FROM REPLACEMENT
         B     RBWRT               +08 WRITE ENTRY
*
*        NORMAL REPLACEMENT ENTRY -
*        INCR BLOCK CHAR CTR, CHECK IF RCD WILL FIT IN OUTPUT
*        BLOCK. IF NOT WRITE THE BUFFER BEFORE MOVING THE RCD
*
RBLDCCNT L     R6,WBLKCCNT         +12 OUTPUT BLOCK CHARACTER CTR
*                                      INITIALLY PRESET TO 8 BY IERABA
         B     RBBRANCH
*
WLSTPTR  DC    F'0'                INITIALLY LOADED BY IERABA TO OUTPUT
*                                  BLOCK ENDING ADDR + 1
WLSTPTRD DC    F'0'                OUTPUT BLOCK ENDING ADDR + 1
*
RBBRANCH AH    R6,0(,R3)           ADD LENGTH OF RECORD TO BE MOVED
         CH    R6,PPILAB07+2       > ROUNDED OUTPUT BLOCKING ?
         BH    RBWRTBLK            YES, BR TO WRITE THE BLOCK FIRST
RBSAVERD ST    R3,WINNER           SAVE ADDR OF RCD IN RSA TO BE BLOCKD
         L     R4,WLSTPTR          ADDR IN OUTPUT BLOCK TO MOVE RCD
RBTAPE   SH    R4,0(,R3)           DECR ADDR BY RCD LEN FOR TAPE SORT
*                                  RCDS FILL OUTPUT BLOCK STARTING
*                                  FROM HIGH CORE TO LOW CORE. THIS
*                                  INST WILL BE NOP BY IERABA IF DISK
*
*        CALCULATE BEGINNING ADDR OF THIS BIN
*        STORE AS NEW AVAILABLE BIN
*
         S     R3,KFOUR            SUBTR 4 BYTES FOR TREE ADDR IN RSA
         SH    R3,PPILEXFF         SUBTR LENGTH OF CONTROL FIELD
         ST    R3,WKEEPAVA         SAVE STRTG ADDR OF BIN IN WORK AREA
*
*        LOAD PARAMETERS AND BRANCH TO MOVE MODULE TO MOVE RECORD
*        FROM RSA TO THE OUTPUT BLOCK
*        TEST IF LAST RECORD SWITCH SET
*
         L     R5,WINNER           R5 -> RECORD IN RSA
         L     R1,KFOUR            A 4 DENOTES A BLOCK RTN TO MOVE MOD
         L     R15,PPIBDSVA+12     LOAD ADDR OF MOVE RTN
         LR    R8,R4               ELLIOTT I PUT THIS IN.  DLB
         BASR  R14,R15             BR TO MOVE RTN(WILL SAVE ALL REGS +
*                                  PASS = BINS VACATED IN R1, AND LINK
*                                  ADDR OF LAST BIN OF RCD IN R5)
*
         LR    R4,R8               ELLIOTT I PUT THIS IN.  DLB
         SR    R9,R9
RBINCR   IC    R9,PPIDEPHO+3       INCREMENT FOR OUTPUT UNIT
         L     R7,PPIUNTCT         LOAD ADDR OF UNIT COUNTERS
         L     R8,0(R9,R7)         LOAD COUNT FOR THIS UNIT
         LA    R8,1(,R8)           INCREMENT BY ONE
         ST    R8,0(R9,R7)         RESTORE
         CLI   WLASTRCD,X'00'      LAST RECORD SWITCH ON ?
         BNE   RBSEQSW             YES, GO SET FINAL EOS SW FOR WRITE
         L     R8,WINNER           DISK SORT ONLY - ADD RECORD LENGTH
RBDISK   AH    R4,0(,R8)           TO BLOCK PTR - NOP AH FOR TAPE
         ST    R4,WLSTPTR          SAVE UPDATED OUTPUT BLK ADDR PTR
*
*        UPDATE BIN COUNT AND PTR TO NEXT AVAILABLE AREA IN
*        RSA. UPDATE CHAIN ADDR OF LAST BIN VACATED IN RSA IF
*        BIN COUNT IS NOT ZERO
*
         L     R8,PPIBDSVA+8       LOAD BIN COUNT
         AR    R8,R1               INCR BY = OF BINS JUST VACATED
         ST    R8,PPIBDSVA+8       STORE UPDATED BIN COUNT FOR DEBLOCK
         CR    R8,R1               BIN COUNT ZERO BEFORE INCR ? (IF SO
*                                  R8 WILL NOW EQUAL R1)
         BE    RBSTOKEP            YES, BR TO UPDATE NEXT AVAILABLE BIN
*                                  PTR ONLY, BECAUSE ALL BINS ARE
*                                  LINKED TOGETHER ALREADY
         MVC   0(4,R5),PPIBDSVA+4  STORE ADDR OF NEXT AVAIL BIN IN LINK
*                                  ADDR OF LAST BIN VACATED
RBSTOKEP MVC   PPIBDSVA+4(4),WKEEPAVA  ADDR OF AVAIL BIN
         ST    R6,WBLKCCNT         SAVE CHARACTER COUNTER
*
*        INTERFACE TO DEBLOCK MODULE
*
RBOVLAY1 L     R11,PPIDEB+4        ADDR OF DEBLOCK MOD. THIS INSTR WILL
*                                  BE OVLAYED BY B RBLDLPTR ON NORMAL
*                                  EOS, THEN RESTORED FOR NEXT SEQ
         B     8(,R11)             BR TO DEBLOCK MOD
*
*        FINAL SEQUENCE ROUTINE FOR LAST RECORD
*
RBSEQSW  ST    R4,WLSTPTR          SAVE STRTG ADDR OF LAST RECORD IN
*                                  OUTPUT BLOCK
         SR    R4,R4               SET LAST SEQ SWITCH FOR WRITE MODULE
RBTAPE1  L     R7,WLSTPTR
         B     RBDCRLST            BR TO DECR OUTPUT BLOCK PTR
*
*        WRITE A BLOCK. THIS RECORD CAN'T FIT INTO THIS BLOCK
*
RBWRTBLK SH    R6,0(,R3)           SUBTRACT LENGTH OF RCD THAT CANNOT
*                                  FIT FROM OUTPUT BLOCK COUNT
RBOVLAY2 L     R2,WLSTPTR          LOAD OUTPUT BLK PTR FOR DISK,WLSTPTR
         S     R2,KEIGHT           EQUALS ADDR OF OUTPUT BLK TO WRITE
         STH   R6,WHOLD            SET ON HALF WORD BOUNDARY
         MVC   0(2,R2),WHOLD       BCC IN 1ST 2 BYTES OF OUTPUT BLK
         LR    R1,R6               ALSO, IN R1 FOR WRITE PARAM
         L     R11,PPIWRT+4        ADDR OF WRITE MODULE
         B     8(,R11)             BR TO WRITE MODULE
*
*        WRITE MODULE REENTER VIA BRANCH TABLE
*        R2 FOR TAPE HAS ADDR OF AN OUTPUT BLOCK ENDING ADDR+1
*
RBWRT    ST    R2,WLSTPTRD         SAVE AS INITIAL OUTPUT BLK POINTER
         ST    R2,WLSTPTR          STORE AS OUTPUT BLOCK WORK PTR
         L     R6,KEIGHT           REINITIALIZE BCC TO 8 OR 16
         AH    R6,0(,R3)           ADD RCD LENGTH OF RCD TO BE MOVED
*                                  TO OUTPUT BLOCK
         B     RBSAVERD
*
*        FROM REPLACEMENT
*        LAST RECORD
*
RBLSTRCD OI    WLASTRCD,X'01'      TURN ON LAST RCD SWITCH
         B     RBLDCCNT
*
*        FROM REPLACEMENT
*        NORMAL EOS
*
RBEOS    MVC   RBOVLAY1,KLDLPTR    OVLAY EXIT TO DEBLOCK FOR NORMAL EOS
         B     RBLDCCNT            BR TO MOVE LAST RCD OF THIS SEQUENCE
*
*        RETURN FROM RBOVLAY1 WHICH WAS OVERLAYED ON THIS NORMAL
*        EOS.
*
RBLDLPTR L     R7,WLSTPTR
         LA    R4,4                SET SWITCH TO NORMAL EOS FOR WRITE
RBDCRLST MVC   WLSTPTR,WLSTPTRD    RESET OUTPUT BLOCK POINTER
         MVC   RBOVLAY1,KIERDD1    RESET RBOVLAY1 TO ORIGINAL INSTR
*
*        CONTINUATION POINT FOR LAST RCD
*        R7 POINTS TO BYTE AFTER EOS ENTRY
*
         S     R7,KEIGHT           DECR OUTPUT BLK PTR BY 8 TO INSERT
*                                  BLOCK CHAR CNT IN 1ST 2 BYTES
         MVC   WBLKCCNT,KEIGHT     REINITIALIZE BLOCK CHAR CTR TO 8
         STH   R6,WHOLD            SET ON HALF WORD BOUNDARY
         MVI   WLASTRCD,X'00'      RESET LAST RECORD SWITCH TO ZERO
         MVC   0(2,R7),WHOLD       BCC IN 1ST 2 BYTES OF OUTPUT BLK
         LR    R1,R6               LOAD BLOCK CHAR CNT FOR WRITE
         LR    R2,R7               LOAD OUTPUT BLOCK PTR FOR WRITE MOD
*
*        INTERFACE TO WRITE MODULE FOR EOS
*
         L     R11,PPIWRT+4        ADDR OF WRITE MODULE
         B     4(,R11)             BR TO WRITE MODULE
*
*        LIST OF CONSTANTS USED BY THE MODULE
*
KFOUR    DC    F'4'
KEIGHT   DC    F'8'                CONSTANT =8 FOR OSCL., =16 FOR 2314
KIERDD1  L     R11,PPIDEB+4        RESTORE RBOVLAY1 AFTER NORMAL EOS.
KLDLPTR  B     RBLDLPTR            OVLAY RBOVLAY1 EVERY NORMAL EOS
*
*        LIST OF WORK AREAS USED BY THE MODULE
*
WBLKCCNT DC    F'0'                OUTPUT BLOCK CHARACTER CTR INITIALLY
*                                  PRESET TO 8 BY AP (2-BCC, 2-SYSTEM
*                                  CHECK, 4-EOS)
*                                  IF 2314, INITIALLY SET TO 16 TO
*                                  INCLUDE CHAIN DISK ADDR TOO
WINNER   DC    F'0'                ADDR OF RCD IN RSA TO BE BLOCKED
*                                  POINTS TO 2 BYTE LENGTH FIELD
WKEEPAVA DC    F'0'                STARTG ADDR OF BIN
WHOLD    DC    H'0'                HALF WORD BOUNDARY WORK AREA
WLASTRCD DC    X'00'               LAST RCD SWITCH
*
./ ADD NAME=IERRBB   0101-20211-20211-1200-00082-00082-00000-RELEASE 00
RBB      TITLE 'IERRBB - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRBB
*
*        MODULE FUNCTION/OPERATION -
*        THIS MODULE BLOCKS RECORDS FOR THE SORT PHASE. IT
*        HANDLES FIXED LENGTH RECORDS LESS THAN OR EQUAL TO 256
*        BYTES BY WAY OF THE EXCP MACRO. THE MODULE MAINTAINS THE
*        BUFFER SCHEME
*
*        APPEARS AS A DSECT IN - IERABB
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM SORT NETWORK EOF
*                       CALLING SEQUENCE -
*                         L    R11,PPIBLK+4
*                         BR   R11
*
*                       ENTRY FROM SORT NETWORK EOS
*                       CALLING SEQUENCE -
*                         L    R11,PPIBLK+4
*                         B    4(R11)
*
*                       ENTRY FROM WRITE RTN NORMAL
*                       CALLING SEQUENCE -
*                         L    R11,PPIBLK+4
*                         B    8(R11)
*
*                       ENTRY FROM SORT NETWORK NORMAL
*                       CALLING SEQUENCE -
*                         L    R11,PPIBLK+4
*                         B    12(R11)
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIRCDL2   PPIDEB
*        PPISRTBL   PPIWRT
*
*        ADDRESS OF WINNER RECORD SITTING IN RSA IS IN R3
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED - N/A
*
*        WINNER RECORD IS MOVED INTO OUTPUT BUFFER
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL -
*        PPIDEB   DSPL=8   DEBLOCK - NORMAL
*        PPIWRT   DSPL=8   WRITE - NORMAL
*        PPIWRT   DSPL=4   WRITE - EOS
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS -
*        WSAVRCD - SAVE WINNER ADDR ON EXIT TO WRITE
*
*        NOTES -
*        THIS MODULE IS USED FOR FIXED LENGTH RECORDS LESS THAN
*        OR EQUAL TO 256 BYTES
*
IERRBB   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRBB SOURCE
*
*----------------------------------------------------------------------
*
         COPY IERRBBI
*
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERRBBI  0101-20211-20211-1200-00114-00114-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERRBB SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERRBBI
*
         USING *,R11
         USING IERRCA,R13
*
*        SORT NETWORK PASSES ADDR OF RCD TO BE BLOCKED IN R3
*
IERDB1   B     RBB1110             +00 LAST RECORD EOF ENTRY
         B     RBB1080             +04 EOS ENTRY
         B     RBB1060             +08 ENTRY FROM WRITE - NORMAL
         B     RBB1010             +12 NORMAL ENTRY FROM SORT NETWORK
         B     *                   +16 DUMMY ENTRY POINT - NOT USED
*
KBLKPTR  DC    F'0'                BLOCK POINTER
KIBLKPTR DC    F'0'                INITIAL BLOCK POINTER
*                                  RESET BY WRITE RTN ON EOS
*
RBB1010  SR    R4,R4               ENTRY FROM SORT NETWORK - NORMAL
*                                  R3 CONTAINS ADDR OF WINNER RCD
         CH    R4,KBLKCNT          BLOCK COUNT = 0 ?
         BE    RBB1050             YES, BUFFER IS FULL BRANCH
         L     R2,KBLKPTR          NO, DECREMENT BLK PTR BY RCD LENGTH
*
*        THE FOLLOWING 3 INSTRUCTIONS ARE OVERLAID FOR DISK SO
*        THAT THE RECORD IS MOVED TO THE OUTPUT BUFFER AND THEN
*        THE BLOCK POINTER IS INCREMENTED
*
RBB1020  SH    R2,PPIRCDL2
         ST    R2,KBLKPTR
RBB1030  MVC   0(1,R2),0(R3)       MOVE RCD FROM RSA TO OUTPUT BUFFER
         LH    R6,KBLKCNT          DECREMENT BLOCK COUNT BY 1
         BCTR  R6,0
         STH   R6,KBLKCNT
*
*        THIS MODULE EXIT IS OVERLAID WHEN AN EOS OR EOF IS
*        INDICATED SO THAT IT BRANCHES TO EITHER THE EOS OR EOF
*        PPORTION OF THIS MODULE, IE RBB1090 OR RBB1120
*
RBB1040  L     R11,PPIDEB+4        LINK TO DEBLOCK R3 CONTAINS ADDR
         B     8(,R11)             OF WINNER RCD
*
*        BUFFER IS FULL
*        PASS BUFFER ADDR TO WRITE ROUTINE
*
RBB1050  L     R1,KBUFSIZ          R1 = NO BYTES IN BUFFER
RBB1055  L     R2,KBLKPTR          LOAD PARAMREG WITH BUFFER ADDR
*                                  FOR DISK, THE INITIAL BLK PTR IS
*                                  LOADED
         SH    R2,K4               DECREMENT BY 4 FOR EOS INDICATION
         ST    R3,WSAVRCD          SAVE ADDR OF LAST WINNER RCD
         L     R11,PPIWRT+4        LINK TO WRITE
         B     8(,R11)
*
*        RETURN FROM WRITE
*        R2 CONTAINS ADDR OF EMPTY BUFFER
*
RBB1060  MVC   KBLKCNT(2),PPISRTBL  RESET BLK CNT TO SORT BLOCKING
         ST    R2,KIBLKPTR          SAVE INITIAL POINTER
         L     R3,WSAVRCD           RESTORE ADDR OF LAST WINNER
         B     RBB1020              BLOCK NEXT RECORD
*
*        END OF SEQUENCE
*        RECORD STILL TO BE PUT IN THIS SEQUENCE
*
RBB1080  MVC   RBB1040(4),KRBBMOD1  MODIFY MODULE EXIT
         B     RBB1010              BLOCK LAST RCD OF THIS SEQUENCE
*
RBB1090  MVC   RBB1040(4),KRBBMOD2  RESET MODULE EXIT TO LINK TO DEBLK
         LA    R4,4                 SET INDICATION FOR NOT FINAL EOS
RBB1100  L     R1,KBUFSIZ           CALCULATE NO BYTES TO BE WRITTEN
         LH    R6,KBLKCNT
         MH    R6,PPIRCDL2         BUFSIZ-(BLKCNT * RCDLENGTH)
         SR    R1,R6
RBB1105  L     R2,KBLKPTR          FOR DISK, THE INITIAL BLK PTR IS
*                                  LOADED
         SH    R2,K4               SET R2 = BUFFER ADDR
         L     R5,KIBLKPTR
         ST    R5,KBLKPTR
         MVC   KBLKCNT(2),PPISRTBL  RESET BLK CNT TO SORT BLOCKING
         L     R11,PPIWRT+4         LINK TO WRITE ON EOS
         B     4(,R11)
*
*        LAST RECORD IS TO BE BLOCKED
*
RBB1110  MVC   RBB1040(4),KRBBMOD3  OVERLAY MODULE EXIT TO BRANCH TO
*                                   RBB1120
         B     RBB1010              BLOCK LAST RCD
*
*        LAST RECORD HAS BEEN BLOCKED
*
RBB1120  SR    R4,R4               SET INDICATION FOR FINAL EOS
         B     RBB1100
*
*        CONSTANTS
*
KRBBMOD1 B     RBB1090             RETURN TO EOS ROUTINE
KRBBMOD2 L     R11,PPIDEB+4        LINK TO DEBLOCK
KRBBMOD3 B     RBB1120             RETURN TO LAST RCD RTN
*
KBUFSIZ  DC    F'0'                BUFFER SIZE
KBLKCNT  DC    H'0'                BLOCK COUNT
K4       DC    X'0004'
*
*        WORK AREAS
*
WSAVRCD  DC    F'0'                SAVES WINNER ADDR OF EXIT TO WRITE
*
./ ADD NAME=IERRBC   0101-20211-20211-1200-00064-00064-00000-RELEASE 00
RBC      TITLE 'IERRBC - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRBC
*
*        MODULE FUNCTION/OPERATION -
*        THE MODULE HANDLES FIXED LENGTH RECORDS BY WAY OF THE
*        EXCP MACRO. THERE IS NO DATA CHAINING, AND THE MODULE
*        MAINTAINS THE BUFFER SCHEME. THE RECORD LENGTH IS
*        GREATER THAN 256 BYTES, SO THE MODULE LINKS TO THE
*        MULTIPLE MOVE LIST. THE MOVE LIST MOVES THE RECORD TO AN
*        OUTPUT BUFFER AND RETURNS TO THE MODULE. THE MODULE
*        THEN LINKS TO THE APPROPRIATE DEBLOCK MODULE.
*
*        MODULES IN WHICH THIS MODULE APPEARS AS A DSECT -
*        IERABC
*
*        MACROS USED BY MODULE - SMPPI
*
*        ENTRY POINTS - ENTRY IERDB1 - MODULE ENTRY POINT
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIBDSVA PPISRTBL PPIDEB PPIWRT
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED - PPIRCDL2
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL -
*        IERDD1+8   EXIT TO DEBLOCK ROUTINE
*        IERDPW1+8  EXIT TO WRITE ROUTINE
*        IERDPW1+4  EXIT TO WRITE ON EOS
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS - WSAVRCD
*
*        NOTES -
*        THE OPERATION OF THIS MODULE DOES NOT DEPEND UPON A
*        PARTICULAR INTERNAL REPRESENTATION OF THE EXTERNAL
*        CHARACTER SET
*
IERRBC   CSECT
*
         ENTRY IERDB1              MODULE ENTRY POINT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRBC SOURCE
*
*----------------------------------------------------------------------
*
         COPY IERRBCI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERRBCI  0101-20211-20211-1200-00127-00127-00000-RELEASE 00
*
*
*----------------------------------------------------------------------
*
*        IERRBC SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERRBC
*
         USING *,R11
         USING IERRCA,R13
*
*        SORT NETWORK PASSES ADDR OF RCD TO BE BLOCKED IN R3
*
IERDB1   B     RBC1080             +00 LAST RECORD EOF ENTRY
         B     RBC1060             +04 EOS ENTRY
         B     RBC1050             +08 ENTRY FROM WRITE - NORMAL
         B     RBC1010             +12 NORMAL ENTRY FROM SORT NETWORK
         B     *                   +16 DUMMY ENTRY POINT - NOT USED
*
KBLKPTR  DC    F'0'                BLOCK POINTER
KIBLKPTR DC    F'0'                INITIAL BLOCK POINTER
*                                  RESET BY WRITE RTN ON EOS
*
RBC1010  SR    R4,R4               ENTRY FROM SORT NETWORK - NORMAL
         CH    R4,KBLKCNT          BLOCK COUNT = 0 ?
         BE    RBC1040             YES, BUFFER IS FULL BRANCH
         L     R2,KBLKPTR          NO, DECREMENT BLK PTR BY RCD LENGTH
*
*        FOR DISK, THE FOLLOWING 6 INSTRUCTIONS ARE OVERLAID SO
*        THAT THE WINNER RECORD IS MOVED TO THE OUTPUT BUFFER AND
*        THEN THE BLOCK POINTER IS INCREMENTED
*
RBC1020  SH    R2,PPIRCDL2
         ST    R2,KBLKPTR
*
*        SET UP LINKAGE TO MOVE LIST
*
         LR    R4,R3               R4 -> RCD TO BE MOVED
         LR    R5,R2               R5 -> BUFFER AREA
         L     R15,PPIBDSVA+4      LINK TO MOVE RTN, MOVE RCD FROM RSA
         BASR  R14,R15             TO OUTPUT BUFFER
         LH    R6,KBLKCNT          DECREMENT BLOCK COUNT BY 1
         BCTR  R6,0
         STH   R6,KBLKCNT
*
*        THIS MODULE EXIT IS OVERLAID WHEN AN EOS OR EOF IS
*        INDICATED SO THAT IT BRANCHES TO EITHER THE EOS OR EOF
*        PORTION OF THIS MODULE, IE RBC1070 OR RBC1090
*
RBC1030  L     R11,PPIDEB+4        LINK TO DEBLOCK, R3 CONTAINS ADDR
         B     8(,R11)             OF FREE AREA IN RSA
*
*        BUFFER IS FULL
*        PASS BUFFER ADDR TO WRITE ROUTINE TO BE WRITTEN
*
RBC1040  L     R1,KBUFSIZ          R1  = NO BYTES TO BE WRITTEN
RBC1045  L     R2,KBLKPTR          R2 -> BUFFER
*                                  FOR DISK, INITIAL PTR IS LOADED
         SH    R2,K4               DECR BY 4 FOR EOS INDICATION
         ST    R3,WSAVRCD          SAVE ADDR OF LAST WINNER RCD
         L     R11,PPIWRT+4        LINK TO WRITE
         B     8(,R11)
*
*        WRITE RETURNS ADDR OF EMPTY BUFFER TO BLOCK IN R2
*
RBC1050  MVC   KBLKCNT(2),PPISRTBL  RESET BLK CTR TO SORT BLOCKING
         ST    R2,KIBLKPTR          SAVE INITIAL BLK PTR
         L     R3,WSAVRCD           RESTORE ADDR OF LAST WINNER
         B     RBC1020
*
*        END OF SEQUENCE
*        RECORD STILL TO BE PUT IN THIS SEQUENCE
*
RBC1060  MVC   RBC1030(4),KRBCMOD1  MODIFY MODULE EXIT
         B     RBC1010              PROCESS LAST RCD OF THIS SEQUENCE
*
RBC1070  MVC   RBC1030(4),KRBCMOD2  RESET MODULE EXIT TO LINK TO DEBLK
         LA    R4,4                 SET INDICATION FOR NOT FINAL EOS
RBC1075  L     R1,KBUFSIZ           CALCULATE NO OF BYTES TO BE
         LH    R6,KBLKCNT           WRITTEN
         MH    R6,PPIRCDL2
         SR    R1,R6
*
*        R1 = BUFFER SIZE WHEN FULL -
*        (REMAINING BLK CNT * RCD LENGTH)
*
RBC1078  L     R2,KBLKPTR          SET R2 = BUFFER ADDR
*                                  FOR DISK, INITIAL PTR IS LOADED
         SH    R2,K4               DECR BY 4 FOR EOS INDICATION
         L     R5,KIBLKPTR         RESET BLOCK PTR
         ST    R5,KBLKPTR
         MVC   KBLKCNT(2),PPISRTBL  RESET BLK CNT TO SORT BLOCKING
         L     R11,PPIWRT+4         LINK TO WRITE ON EOS
         B     4(,R11)
*
*        LAST RECORD IS TO BE BLOCKED, EOF
*
RBC1080  MVC   RBC1030(4),KRBCMOD3  OVERLAY MODULE EXIT TO RETURN TO
*                                  EOF, RBC1090
         B     RBC1010             PROCESS LAST RCD
*
*        LAST RECORD HAS BEEN BLOCKED
*        WRITE FINAL SEQUENCE
*
RBC1090  SR    R4,R4               SET INDICATOR FOR FINAL EOS
         B     RBC1075
*
*        CONSTANTS
*
KBUFSIZ  DC    F'0'                BUFFER SIZE
KBLKCNT  DC    H'0'                BLOCK COUNT
K4       DC    H'4'
*
*
*        INSTRUCTION CONSTANTS
*
KRBCMOD1 B     RBC1070             RETURN TO EOS ROUTINE
KRBCMOD2 L     R11,PPIDEB+4        RETURN TO EOS ROUTINE
KRBCMOD3 B     RBC1090
*
*
*        WORK AREAS
*
WSAVRCD  DC    F'0'                SAVES WINNER ADDR ON EXIT TO WRITE
*
./ ADD NAME=IERRBE   0101-20211-20211-1200-00121-00121-00000-RELEASE 00
RBE      TITLE 'IERRBE - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRBE
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 1 RUNNING MODULE. ANY VARIABLE LENGTH SORT
*        THE FUNCTION OF THIS MODULE IS TO BLOCK VARIABLE LENGTH
*        RECORDS IN THE OUTPUT BUFFER(S). TO DO THIS IT LINKS TO
*        THE VARIABLE MOVE ROUTINE IERRBF WHICH MOVES THE RECORD
*        FROM RSA (BINS) TO AN OUTPUT TO THE DEBLOCK MODULE. NOW
*        THAT THE BIN(S) IN RSA HAVE BEEN FREED THIS MODULE
*        UPDATES THE NEXT AVAILABLE RSA BIN POINTER AND COUNTER
*        LOCATED IN PPI
*
*        INFORMATION COMMUNICATED BETWEEN MODULES -
*        NETWORK TO BLOCK -
*        R3 -> WINNER ADDRESS IN RSA
*        BLOCK TO MOVE -
*        R5 -> RECORD IN RSA
*        R1 -> OUTPUT BUFFER TO MOVE THE RECORD
*        R1  = 4 TO DENOTE BLOCK RTN
*        MOVE TO BLOCK-
*        R1  = NUMBER OF BINS FREED
*        R5  -> CHAIN ADDR OF LAST BIN MOVED
*        BLOCK TO WRITE -
*        R1  = OUTPUT BLOCK COUNT
*        R2 -> OUTPUT BUFFER
*        R4  = 4 FOR NORMAL EOS ELSE ZERO
*        WRITE TO BLOCK -
*        R2 -> STARTING ADDRESS OF OUTPUT BLOCK+8 FOR DISK OR
*              ENDING ADDRESS OF OUTPUT BLOCK+1 FOR TAPE
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - IERABE
*
*        MACROS USED BY MODULE - SMPPI
*
*        ENTRY POINTS - ENTRY FROM NETWORK
*                       CALLING SEQUENCE -
*                           L   R11,PPIBLK+4
*                           B   0(,R11)      LAST RCD
*                           B   4(,R11)      EOS
*                           B   12(,R11)     NORMAL
*
*                     - ENTRY FROM MOVE RTN
*                       CALLING SEQUENCE -
*                           BR   R14         RETURN
*
*                     - ENTRY FROM WRITE
*                       CALLING SEQUENCE -
*                           L   R11,PPIBLK+4
*                           B   8(,R11)      NORMAL
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIBDSVA   PPILEXFF
*        PPIDEB     PPIWRT
*        PPILAB07
*        INFO IS NEEDED FOR LINKAGE TO OTHER MODULES AND FOR
*        CALCULATIONS
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPIBDSVA
*
*        AVAILABLE BIN POINTER WITHIN THIS AREA
*
*        EXTERNAL ROUTINES - EXTRN IERRBF
*                            ADDR ALSO WITHIN PPIBDSVA. THIS RTN
*                            MOVES THE RCD FORM RSA TO AN OUTPUT
*                            BUFFER
*
*        EXTERNAL PARAMETERS - NONE
*
*        EXITS - NORMAL - EXIT TO WRITE
*                         CALLING SEQUENCE -
*                             L    R11,PPIWRT+4
*                             B    4(,R11)      ANY EOS
*                             B    8(,R11)      NORMAL WRITE
*
*                       - EXIT TO DEBLOCK
*                         CALLING SEQUENCE -
*                             L    R11,PPIDEB+4
*                             B    8(,R11)
*                       - EXIT TO IERABF
*                         CALLING SEQUENCE -
*                             L    R15,PPIBDSVA+12
*                             BALR R14,R15
*
*        EXITS - ERROR - NONE
*
*        TABLES/WORK AREAS -
*        WBLKCCNT -  KEEPS TRACK OF THE NUMBER OF BYTES IN AN
*                    OUTPUT BUFFER
*        WINNER   -> NEXT RECORD IN RSA TO BE BLOCKED
*        WLSTPTR  -> THE PRESENT OUTPUT BUFFER
*        WLSTPTRD -> AN AVAILABLE AREA IN THE OUTPUT BUFFER
*        WKEEPAVA -  STARTING ADDR OF THE WINNER'S BIN IN RSA
*        WHOLD    -  WORK AREA
*        WLASTRCD -  LAST RECORD SWITCH
*
*        NOTES -
*        THIS MODULE IS USED FOR ANY VARIABLE LENGTH SORT
*        TAPE OR DISK
*
IERRBE   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRBE SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRBEI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERRBEI  0101-20211-20211-1200-00183-00183-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERRBE SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERRBE
*
         USING *,R11               MODULE BASE REG LOADED EXTERNALLY
         USING IERRCA,R13          PPI COMMON MODULE BASE REGISTER
*
*        ENTRY TABLE
*
IERDB1   B     RBLSTRCD            +00 LAST RCD ENTRY FROM REPLACEMENT
         B     RBEOS               +04 EOS ENTRY FROM REPLACEMENT
         B     RBWRT               +08 WRITE ENTRY
         B     RBLDCCNT            +12 NORMAL ENTRY FROM REPLACEMENT
         B     *                   +16 DUMMY ENTRY NOT USED
*
WLSTPTR  DC    F'0'                INITIALLY LOADED BY AP TO OUTPUT
*                                  BLOCK ENDING ADDR+1 FOR TAPE, OR
*                                  OUTPUT BLOCK STARTG ADDR+8 FOR A
*                                  DISK SORT
WLSTPTRD DC    F'0'                CURRENT OUTPUT BLK STRTG ADDR+8-DISK
*                                  OR OUTPUT BLK ENDG ADDR+1 TAPE
*                                  BOTH POINTERS ARE RESET BY WRITE
*                                  RTN ON EOS
*
*        NORMAL REPLACEMENT ENTRY
*        INCR BLOCK CHAR CTR CHECK IF RECORD WILL FIT IN OUTPUT BLOCK
*        IF NOT, WRITE THE BUFFER BEFORE MOVING THE RCD
*
RBLDCCNT L     R6,WBLKCCNT         OUTPUT BLOCK CHARACTER CTR INITIALLY
*                                  PRESET TO 8 BY AP
         AH    R6,0(,R3)           ADD LENGTH OF RECORD TO BE MOVED
         CH    R6,PPILAB07+2       > ROUNDED OUTPUT BLOCKING ?
         BH    RBWRTBLK            YES, BRANCH TO WRITE THE BLOCK FIRST
RBSAVERD ST    R3,WINNER           SAVE ADDR OF RCD IN RSA TO BE BLOCKD
         L     R4,WLSTPTR          ADDR IN OUTPUT BLOCK TO MOVE RCD
RBTAPE   SH    R4,0(,R3)           DECR ADDR BY RCD LNGTH FOR TAPE SORT
*                                  RCDS FILL OUTPUT BLOCK STARTING
*                                  FROM HIGH CORE TO LOW CORE. THIS
*                                  INSTR WILL BE NOP BY AP IF DISK
*
*        CALCULATE BEGINNING ADDR OF THIS BIN
*        STORE AS NEW AVAILABLE BIN
*
         S     R3,KFOUR            SUBTR 4 BYTES FOR TREE ADDR IN RSA
         SH    R3,PPILEXFF         SUBTR LENGTH OF CONTROL FIELD
         ST    R3,WKEEPAVA         SAVE STRTG ADDR OF BIN IN WORK AREA
*
*        LOAD PARAMETERS AND BRANCH TO MOVE MODULE TO MOVE
*        RECORD FROM RSA TO THE OUTPUT BLOCK.
*        TEST IF LAST RECORD SWITCH SET
*
         L     R5,WINNER           LOAD ADDR OF RCD IN RSA
         L     R1,KFOUR            A 4 DENOTES A BLOCK RTN TO MOVE MOD
         L     R15,PPIBDSVA+12     LOAD ADDR OF MOVE RTN
         LR    R8,R4               ELLIOTT I PUT THIS IN   DLB
         BASR  R14,R15             BR TO MOVE RTN (WILL SAVE ALL REGS +
*                                  PASS = BINS VACATED IN R1, AND LINK
*                                  ADDR OF LAST BIN OF RCD IN R5)
         LR    R4,R8               ELLIOTT I PUT THIS IN   DLB
         CLI   WLASTRCD,X'00'      LAST RECORD SWITCH ON ?
         BNE   RBSEQSW             YES, BR SET FINAL EOS SW FOR WRITE
         L     R8,WINNER           LOAD ADDR OF RECORD IN RSA
RBDISK   AH    R4,0(,R8)           DISK SORT ONLY INCR ADDR IN OUTPUT
*                                  BLOCK BY RECORD LENGTH. THIS INSTR
*                                  WILL BE A NOP IF TAPE SORT
         ST    R4,WLSTPTR          SAVE UPDATED OUTPUT BLK ADDR PTR
*
*        UPDATE BIN COUNT AND PTR TO NEXT AVAILABLE AREA IN RSA
*        UPDATE CHAIN ADDR OF LAST BIN VACATED IN RSA IF BIN
*        COUNT IS NOT ZERO
*
         L     R8,PPIBDSVA+8       LOAD BIN COUNT
         AR    R8,R1               INCR BY = OF BINS JUST VACATED
         ST    R8,PPIBDSVA+8       STORE UPDATED BIN COUNT FOR DEBLOCK
         CR    R8,R1               BIN COUNT ZERO BEFORE INCR ? (IF SO
*                                  R8 WILL NOW EQUAL R1)
         BE    RBSTOKEP            YES, BRANCH TO UPDATE NEXT AVAILABLE
*                                  BIN PTR ONLY, BECAUSE ALL BINS ARE
*                                  LINKED TOGETHER ALREADY
         MVC   0(4,R5),PPIBDSVA+4  STORE ADDR OF NEXT AVAIL BIN IN LINK
*                                  ADDR OF LAST BIN VACATED
RBSTOKEP MVC   PPIBDSVA+4(4),WKEEPAVA  ADDR OF AVAIL BIN
         ST    R6,WBLKCCNT         SAVE CHARACTER COUNTER
*
*        INTERFACE TO DEBLOCK MODULE
*
RBOVLAY1 L     R11,PPIDEB+4        ADDR OF DEBLOCK MOD THIS INSTR WILL
*                                  BE OVLAYED BY B RBLDLPTR ON NORMAL
*                                  EOS, THEN RESTORED FOR NEXT SEQ
         B     8(,R11)             BRANCH TO DEBLOCK MOD
*
*        FINAL SEQUENCE ROUTINE FOR LAST RECORD
*
RBSEQSW  ST    R4,WLSTPTR          SAVE STRTG ADDR OF LAST RCD IN
*                                  OUTPUT BLK FOR TAPE IGNORE FOR DISK
         SR    R4,R4               SET LAST SEQ SWITCH FOR WRITE MODULE
RBTAPE1  L     R7,WLSTPTRD         FOR DISK, LOAD OUTPUT BLK PTR FOR
*                                  TAPE AP WILL SET TO L R7,WLSTPTR
         B     RBDCRLST            BRANCH TO DECR OUTPUT BLOCK PTR
*
*        WRITE A BLOCK
*        THIS RCD CAN'T FIT INTO THIS BLOCK
*
RBWRTBLK SH    R6,0(,R3)           SUBTRACT LENGTH OF RCD THAT CANT FIT
*                                  FROM OUTPUT BLOCK COUNT
RBOVLAY2 L     R2,WLSTPTR          LOAD OUTPUT BLK PTR FOR DISK,WLSTPTR
*                                  WILL BE OVLAYED BY WLSTPTRD BY AP
         S     R2,KEIGHT           EQUALS ADDR OF OUTPUT BLK TO WRITE
         STH   R6,WHOLD            SET ON HALF WORD BOUNDARY
         MVC   0(2,R2),WHOLD       BCC IN 1ST 2 BYTES OF OUTPUT BLK
         LR    R1,R6               ALSO IN R1 FOR WRITE PARAM
         L     R11,PPIWRT+4        ADDR OF WRITE MODULE
         B     8(,R11)             BRANCH TO WRITE MODULE
*
*        WRITE MODULE REENTER VIA BRANCH TABLE
*        R2, FOR TAPE, HAS ADDR OF AN OUTPUT BLK ENDING ADDR+1
*        R2, FOR DISK, HAS OUTPUT BLK STARTING ADDR+8
*
RBWRT    ST    R2,WLSTPTRD         SAVE AS INITIAL OUTPUT BLK POINTER
         ST    R2,WLSTPTR          STORE AS OUTPUT BLOCK WORK PTR
         LA    R6,8                REINITIALIZE BLOCK CHAR CTR TO 8
         AH    R6,0(,R3)           ADD RCD LENGTH OF RCD TO BE MOVED
*                                  TO OUTPUT BLOCK
         B     RBSAVERD
*
*        FROM REPLACEMENT. LAST RECORD
*
RBLSTRCD OI    WLASTRCD,X'01'      TURN ON LAST RCD SWITCH
         B     RBLDCCNT
*
*        FROM REPLACEMENT. NORMAL EOS
*
RBEOS    MVC   RBOVLAY1,KLDLPTR    OVLAY EXIT TO DEBLOCK FOR NORMAL EOS
         B     RBLDCCNT            BR TO MOVE LAST RCD OF THIS SEQUENCE
*
*        RETURN FROM RBOVLAY1 WHICH WAS OVERLAYED ON THIS NORMAL
*        EOS
*
RBLDLPTR L     R7,WLSTPTRD         LOAD OUTPUT BLOCK PTR (DISK SORT) AP
*                                  WILL MAKE L R7,WLSTPTR (TAPE SORT)
         LA    R4,4                SET SWITCH TO NORMAL EOS FOR WRITE
         MVC   WLSTPTR,WLSTPTRD    RESET OUTPUT BLOCK POINTER
         MVC   WBLKCCNT,KEIGHT     REINITIALIZE BLOCK CHAR CTR TO 8
         MVC   RBOVLAY1,KIERDD1    RESET RBOVLAY1 TO ORIGINAL INSTR
*
*        CONTINUATION POINT FOR LAST RCD
*        R7 POINTS TO BYTE AFTER EOS ENTRY
*
RBDCRLST S     R7,KEIGHT           DECR OUTPUT BLK PTR BY 8 TO INSERT
*                                  BLOCK CHAR CNT IN 1ST 2 BYTES
         STH   R6,WHOLD            SET ON HALF WORD BOUNDARY
         MVC   0(2,R7),WHOLD       BCC IN 1ST 2 BYTES OF OUTPUT BLK
         LR    R1,R6               LOAD BLOCK CHAR CNT FOR WRITE
         LR    R2,R7               LOAD OUTPUT BLOCK PTR FOR WRITE MOD
*
*        INTERFACE TO WRITE MODULE FOR EOS
*
         L     R11,PPIWRT+4        ADDR OF WRITE MODULE
         B     4(,R11)             BRANCH TO WRITE MODULE
*
*        CONSTANTS
*
KFOUR    DC    F'4'
KEIGHT   DC    F'8'
KIERDD1  L     R11,PPIDEB+4        RESTORE RBOVLAY1 AFTER NORMAL EOS
KLDLPTR  B     RBLDLPTR            OVLAY RBOVLAY1 EVERY NORMAL EOS
*
*        WORK AREAS
*
WBLKCCNT DC    F'0'                OUTPUT BLOCK CHARACTER CTR INITIALLY
*                                  PRESET TO 8 BY AP (2-BCC, 2-SYSTEM
*                                  CHECK, 4-EOS)
WINNER   DC    F'0'                ADDR OF RCD IN RSA TO BE BLOCKED
*                                  POINTS TO 2 BYTE LENGTH FIELD
WKEEPAVA DC    F'0'                STARTINGG ADDR OF BIN
WHOLD    DC    H'0'                HALFWORD BOUNDARY WORK AREA
WLASTRCD DC    X'00'               LAST RCD SWITCH
*
./ ADD NAME=IERRBF   0101-20211-20211-1200-00060-00060-00000-RELEASE 00
RBF      TITLE 'IERRBF - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRBF
*
*        FUNCTION/OPERATION -
*        THE PURPOSE OF THIS MODULE IS TO MOVE VARIABLE LENGTH
*        RECORDS FROM THE INPUT BUFFER TO RSA ON THE DEBLOCK
*        SIDE, AND FROM RSA TO THE OUTPUT BUFFER ON THE BLOCK
*        SIDE. THERE ARE THREE VARIABLE MOVE MODULES. THE CORRECT
*        ONE IS CHOSEN BY THE ASSIGNMENT MODULE. IN ORDER TO
*        CHOOSE THE CORRECT VARIABLE MOVE MODULE THE ASSIGNMENT
*        MODULE CALCULATES THE FOLLOWING VALUES -
*
*        X = LENGTH OF EXTRACT CONTROL FIELDS + 4
*
*        Y = BINSIZE - X - 4
*
*        IF Y < 256 AND (X+Y) < 256 MODULE RBFM1 IS USED
*
*        IF Y < 256 AND (X+Y) > 256 MODULE RBFM2 IS USED
*
*        IF Y > 256 AND (X+Y) > 256 MODULE RBFM3 IS USED
*
*        MODULES IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACROS USED BY MODULE - SMPPI
*
*        ENTRY POINTS - ENTRY FROM BLOCK/DEBLOCK MODULES
*                       CALLING SEQUENCE -
*                          L    R15,PPIBDSVA+12
*                          BALR R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIBDSVA
*
*        THIS VALUE IS THE NUMBER OF AVAILABLE BINS
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED - N/A
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL -
*        BR R14 - RETURN TO CALLER
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS - N/A
*
*        NOTES-
*        THIS MODULE IS USED IN PHASE 1 OF A VARIABLE SORT
*        IERRBF HOLDS THE SELECTED CODE THAT IS MOVED INTO IT BY
*        IERABF
*
IERRBF   CSECT
*
         DC    82F'0'
*
         END
./ ADD NAME=IERRBG   0101-20211-20211-1200-00091-00091-00000-RELEASE 00
RBG      TITLE 'IERRBG - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRBG
*
*        MODULE FUNCTION/OPERATION -
*        DEBLOCKING AND BLOCKING OF FIXED LENGTH RECORDS.
*        THE MODULE MAINTAINS THE BUFFER SCHEMES. THE RECORD
*        LENGTH IS LESS THAN OR EQUAL TO 256 BYTES SO THE MODULE
*        CONTAINS AN INLINE MOVE INSTRUCTION ON THE BLOCK SIDE OF
*        THE MODULE TO MOVE THE RECORD TO AN OUTPUT BUFFER. FLOW
*        IN THE MODULE IS FROM MERGE TO BLOCK SIDE TO DEBLOCK
*        SIDE
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - IERABG
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM MERGE NETWORK EOS
*                       CALLING SEQUENCE -
*                           L   R11,PPIBLK2+4
*                           BR  R11
*
*                     - ENTRY FROM READ ROUTINE
*                       CALLING SEQUENCE -
*                           L   R11,PPIBLK2+4
*                           B   4(,R11)
*
*                     - ENTRY FROM WRITE ROUTINE
*                       CALLING SEQUENCE -
*                           L  R11,PPIBLK2+4
*                           B  8(,R11)
*
*                     - ENTRY FROM MERGE NETWORK - PRIMING
*                       CALLING SEQUENCE -
*                           L   R11,PPIBLK2+4
*                           B   12(,R11)
*
*                     - ENTRY FROM MERGE NETWORK - NORMAL
*                       CALLING SEQUENCE -
*                           L   R11,PPIBLK2+4
*                           B   16(,R11)
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIRCDL2   PPINETM    PPICOUNT
*        PPIRD      PPISBLCT   PPIWRT
*        PPIBDSVA   PPISRTBL
*
*        ADDRESS OF WINNER RECORD SITTING IN INPUT BUFFER
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED - PPICOUNT -
*        UPDATED BY 1
*        WINNER RECORD IS MOVED TO OUTPUT BUFFER
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL -
*        PPINETM - DSPL=8 - MERGE NETWORK - NORMAL
*        PPIREAD - DSPL=8 - READ - NORMAL
*        PPIWRT  - DSPL=8 - WRITE - NORMAL
*        PPIWRT  - DSPL=4 - WRITE - EOS
*
*        EXITS - ERROR N/A
*
*        TABLES/WORK AREAS -
*        BUFFER ADDRESS TABLE
*        BLOCK COUNT TABLE
*
*        NOTES -
*        THIS MODULE IS USED FOR FIXED LENGTH RECORDS <= 256 BYTES
*
IERRBG   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRBG SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRBGI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERRBGI  0101-20211-20211-1200-00128-00128-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERRBG SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERRBGI
*
         USING *,R11
         USING IERRCA,R13
*
IERDB2   B     RBG2080             +00 EOS ENTRY
         B     RBG2040             +04 READ ENTRY
         B     RBG2060             +08 WRITE ENTRY
         B     *+4                 +12 PRIMING ENTRY (REQUIRES NO
*                                      ACTION IN THIS MODULE)
*
*        NORMAL ENTRY FROM MERGE, R3 CONTAINS WINNER ADDR
*
         ICM   R4,B'1111',KOBLKCNT +16 SET R4=OUTPUT BLOCK COUNT
*
*        BLOCK WINNER RECORD
*
*                                  BLOCK COUNT = 0 ?
         BNP   RBG2050             YES, BLOCK IS FULL BRANCH
RBG2010  BCTR  R4,0                NO, DECREMENT BLK CNT BY 1
         ST    R4,KOBLKCNT
         L     R2,KBLKPTR
*
*        FOR DISK THE FOLLOWING 3 INSTRUCTIONS ARE OVERLAYED
*        RECORD IS MOVED TO THE OUTPUT BUFFER BEFORE THE BLOCK
*        POINTER IS INCREMENTED
*
RBG2020  SH    R2,PPIRCDL2         DECREMENT BLK PTR BY RCD LENGTH
         ST    R2,KBLKPTR
RBG2025  MVC   0(1,R2),0(R3)       MOVE WINNER RCD TO OUTPUT BUFFER
         L     R6,PPICOUNT
         LA    R6,1(,R6)           INCREMENT RCD COUNT
         ST    R6,PPICOUNT
*
*        DEBLOCK NEW RECORD FROM SAME FILE AS WINNER RECORD
*
         LR    R2,R3               SAVE WINNER ADDR
         SRL   R3,24               ACCESS INCREMENT
         L     R7,PPISBLCT         R7 -> BLOCK COUNT TABLE
         L     R8,0(R3,R7)         SET R8 = BLK COUNT FOR THIS BUFFER
         BCTR  R8,0                DECREMENT BLOCK COUNT
         LTR   R8,R8               THIS BLOCK COUNT = ZERO ?
         BNP   RBG2030             YES, BLOCK IS EMPTY, BRANCH
         ST    R8,0(R3,R7)         NO, STORE NEW BLOCK COUNT
         LR    R3,R2               INCREMENT WINNER BY RECORD LENGTH TO
         AH    R3,PPIRCDL2         GET NEXT RECORD
         L     R11,PPINETM+4       EXIT TO MERGE
         B     8(,R11)
*
*        INPUT BUFFER IS EMPTY - LINK TO READ ROUTINE TO REFILL
*        BUFFER
*        R2 -> EMPTY BUFFER
*        R3  = INCREMENT
*
RBG2030  L     R7,PPIBDSVA         R7 -> BUFFER TABLE
         L     R2,0(R3,R7)         ACCESS ADDR OF EMPTY BUFFER
         L     R11,PPIRD+4         EXIT TO READ RTN
         B     8(,R11)
*
*        RETURN FROM READ ROUTINE
*        R1  = BLOCK COUNT
*        R2 -> BUFFER (FOR DEBLOCKING)
*        R3  = INCREMENT
*        R4 -> BUFFER (FOR READING)
*
RBG2040  L     R7,PPIBDSVA         R7 -> BUFFER TABLE
         ST    R4,0(R3,R7)         STORE BUFF ADDR IN TABLE
         L     R5,PPISBLCT         SET R5 = START ADDRS OF BLK CNTRS
         ST    R1,0(R3,R5)         STORE BLK CNT IN BLK CNT TABLE
         SLL   R3,24               ADD INCR TO NEXT RCD
         AR    R3,R2
         L     R11,PPINETM+4       EXIT TO MERGE
         B     8(,R11)
*
*        OUTPUT BUFFER IS FULL - LINK TO WRITE RTN TO EMPTY BUFFER
*
*        R1  = NO OF BYTES TO BE WRITTEN
*        R2 -> BUFFER TO BE WRITTEN
*
RBG2050  L     R1,KBUFSIZ          SET R1 = NO BYTES IN BUFFER
RBG2053  L     R2,KBLKPTR          R2 -> BUFFER
*                                  FOR DISK, LOAD INITIAL BLK PTR
         SH    R2,K4               ADJUST BY 4 FOR EOS INDICATION
         L     R11,PPIWRT+4        EXIT TO WRITE RTN
         B     8(,R11)
*
*        RETURN FROM WRITE ROUTINE
*        R2 -> EMPTY BUFFER
*
RBG2060  LH    R4,PPISRTBL         RESET OUTPUT BLK CNT TO SORT BLKNG
         ST    R2,KIBLKPTR         SAVE INITIAL PTR
         ST    R2,KBLKPTR          SET BLK PTR
         B     RBG2010
*
*        END OF SEQUENCE - WRITE THIS BUFFER
*        RESET POINTERS TO REUSE THIS BUFFER THE NEXT TIME
*        THROUGH
*
RBG2080  LA    R3,4                SET INDICATION FOR NOT FINAL EOS
         L     R1,KBUFSIZ
         L     R4,KOBLKCNT         CALCULATE NO OF BYTES TO BE
         MH    R4,PPIRCDL2         WRITTEN
         SR    R1,R4
         LH    R4,PPISRTBL         RESET OUTPUT BLOCKING TO SORT
         ST    R4,KOBLKCNT         BLOCKING
RBG2090  L     R2,KBLKPTR          R2 -> BUFFER
*                                  FOR DISK, LOAD INITIAL BLK PTR
         SH    R2,K4
         L     R5,KIBLKPTR
         ST    R5,KBLKPTR          SET BLK PTR
         L     R11,PPIWRT+4
         B     4(,R11)
*
*        CONSTANTS
*
KBLKPTR  DC    F'0'                BLOCK POINTER
KIBLKPTR DC    F'0'                INITIAL BLOCK POINTER
KOBLKCNT DC    F'0'                OUTPUT BLOCK COUNT
KBUFSIZ  DC    F'0'                BUFFER SIZE WHEN FULL
K4       DC    X'0004'
*
./ ADD NAME=IERRBH   0101-20211-20211-1200-00091-00091-00000-RELEASE 00
RBH      TITLE 'IERRBH - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRBH
*
*        MODULE FUNCTION/OPERATION -
*        DEBLOCKING AND BLOCKING OF FIXED LENGTH RECORDS.
*        THE MODULE MAINTAINS THE BUFFER SCHEMES. THE RECORD
*        LENGTH IS GREATER THAN 256 BYTES SO THE MODULE BLOCK
*        SIDE LINKS TO THE MULTIPLE MOVE LIST. THE LIST MOVES THE
*        RECORD TO AN OUTPUT BUFFER AND RETURNS TO THE MODULE.
*        FLOW IN THE MODULE IS FROM MERGE TO BLOCK SIDE TO
*        DEBLOCK SIDE
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - IERABH
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM MERGE NETWORK- EOS
*                       CALLING SEQUENCE -
*                           L   R11,PPIBLK2+4
*                           BR  R11
*
*                     - ENTRY FROM READ ROUTINE
*                       CALLING SEQUENCE -
*                           L   R11,PPIBLK2+4
*                           B   4(,R11)
*
*                     - ENTRY FROM WRITE ROUTINE
*                       CALLING SEQUENCE -
*                           L   R11,PPIBLK2+4
*                           B   8(,R11)
*
*                     - ENTRY FROM MERGE NETWORK - PRIMING
*                       CALLING SEQUENCE -
*                           L   R11,PPIBLK2+4
*                           B   12(,R11)
*
*                     - ENTRY FROM MERGE NETWORK - NORMAL
*                       CALLING SEQUENCE -
*                           L   R11,PPIBLK2+4
*                           B   16(,R11)
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIRCDL2   PPIBDSVA   PPICOUNT   PPISBLCT
*        PPISRTBL
*
*        ADDRESS OF WINNER RECORD SITTING IN INPUT BUFFER
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPICOUNT - FIELD UPDATED BY 1
*        WINNER RECORD IS MOVED TO OUTPUT BUFFER
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL -
*        PPINETM - DSPL = 8 - MERGE NETWORK - NORMAL
*        PPIREAD - DSPL = 8 - READ - NORMAL
*        PPIWRT  - DSPL = 8 - WRITE - NORMAL
*        PPIWRT  - DSPL = 4 - WRITE - EOS
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS -
*        BUFFER ADDRESS TABLE
*        BLOCK COUNT TABLE
*
*        NOTES -
*        THIS MODULE IS USED FOR FIXED LENGTH RECORDS GREATER
*        THAN 256 BYTES LONG
*
IERRBH   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRBH SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRBHI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERRBHI  0101-20211-20211-1200-00132-00132-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERRBH SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERRBHI
*
         USING *,R11
         USING IERRCA,R13
*
IERDB2   B     RBH2080             +00 EOS ENTRY
         B     RBH2040             +04 READ ENTRY
         B     RBH2060             +08 WRITE ENTRY
         B     *+4                 +12 PRIMING ENTRY (REQUIRES NO
*                                      ACTION IN THIS MODULE)
         ICM   R4,B'1111',KOBLKCNT +16 SET R4 = OUTPUT BLOCK COUNT
*                                      NORMAL ENTRY FROM MERGE
*                                  BLOCK COUNT = ZERO ?
         BNP   RBH2050             YES, BLOCK IS FULL BRANCH
RBH2010  BCTR  R4,0                NO, DECREMENT BLK CNT BY 1
         ST    R4,KOBLKCNT
         L     R2,KBLKPTR
*
*        THE FOLLOWING 6 INSTRUCTIONS ARE OVERLAID FOR DISK SO
*        THAT THE WINNER RECORD IS MOVED TO THE OUTPUT BUFFER AND
*        THEN THE BLOCK POINTER IS INCREMENTED
*
RBH2020  SH    R2,PPIRCDL2         DECREMENT BLK PTR BY RCD LENGTH
         ST    R2,KBLKPTR
         LR    R4,R3               SET R4 = RCD ADDR FOR MOVE RTN
         LR    R5,R2               SET R2 = BUFFER ADDR
         L     R15,PPIBDSVA+8      CALL TO MOVE LIST - MOVE WINNER
         BASR  R14,R15             TO OUTPUT BUFFER
         L     R6,PPICOUNT
         LA    R6,1(,R6)           INCREMENT RCD COUNT
         ST    R6,PPICOUNT
*
*        DEBLOCK NEW RECORD FROM SAME FILE AS WINNER RECORD
*
         LR    R2,R3               SAVE WINNER ADDR
         SRL   R3,24               ACCESS INCREMENT
         L     R7,PPISBLCT         R7 -> BLOCK COUNTER TABLE
         L     R8,0(R3,R7)         SET R8 = BLK CNT FOR THIS BUFFER
         BCTR  R8,0                DECREMENT BLOCK COUNT
         LTR   R8,R8               THIS BLOCK COUNT ZERO ?
         BNP   RBH2030             YES, BLOCK IS EMPTY, BRANCH
         ST    R8,0(R3,R7)         NO, STORE NEW BLOCK COUNT
         LR    R3,R2               INCREMENT WINNER BY RECORD LENGTH
         AH    R3,PPIRCDL2         TO GET NEXT RECORD
         L     R11,PPINETM+4       EXIT TO MERGE
         B     8(,R11)
*
*        INPUT BUFFER IS EMPTY
*        CALL READ ROUTINE TO REFILL BUFFER
*        R2 -> EMPTY BUFFER
*        R3  = INCREMENT
*
RBH2030  L     R7,PPIBDSVA         R7 -> BUFFER TABLE
         L     R2,0(R3,R7)         R2 -> EMPTY BUFFER
         L     R11,PPIRD+4         EXIT TO READ RTN
         B     8(,R11)
*
*        RETURN FROM READ ROUTINE -
*        R1  = BLOCK COUNT
*        R2 -> BUFFER (FOR DEBLOCKING)
*        R3  = INCREMENT
*        R4 -> BUFFER (FOR READING)
*
RBH2040  L     R7,PPIBDSVA         R7 -> BUFFER TABLE
         ST    R4,0(R3,R7)         STORE BUFFER ADDR IN TABLE
         L     R5,PPISBLCT         R5 -> BLOCK COUNT TABLE
         ST    R1,0(R3,R5)         STORE BLK CNT IN BLK CNT TABLE
         SLL   R3,24               MOVE INCR(M) INTO NEXT RECORD ADDR
         AR    R3,R2
         L     R11,PPINETM+4       EXIT TO MERGE
         B     8(,R11)
*
*        OUTPUT BUFFER IS FULL
*        CALL WRITE RTN TO EMPTY BUFFER
*        R1  = NO OF BYTES TO BE WRITTEN
*        R2 -> BUFFER TO BE WRITTEN
*
RBH2050  L     R1,KBUFSIZ          R1 = L'BUFFER
RBH2053  L     R2,KBLKPTR          R2 -> BUFFER
*                                  FOR DISK THE INITIAL BLK PTR IS
*                                  LOADED
         SH    R2,K4               ADJUST BY 4 FOR EOS INDICATION
         L     R11,PPIWRT+4        EXIT TO WRITE
         B     8(,R11)
*
*        RETURN FROM WRITE ROUTINE
*        R2 -> EMPTY BUFFER
*
RBH2060  LH    R4,PPISRTBL         RESET OUTPUT BLK CNT TO SORT BLKNG
         ST    R2,KIBLKPTR         SAVE INITIAL POINTER
         ST    R2,KBLKPTR          SET BLK PTR
         B     RBH2010
*
*        END OF SEQUENCE - WRITE THIS BUFFER
*        RESET POINTERS TO REUSE THIS BUFFER THE NEXT TIME
*        THROUGH
*
RBH2080  LA    R3,4                SET INDICATION FOR NOT FINAL EOS
         L     R1,KBUFSIZ
         L     R4,KOBLKCNT         CALCULATE NO OF BYTES TO BE
         MH    R4,PPIRCDL2         WRITTEN
         SR    R1,R4
*
*        R1 = BUFFER SIZE WHEN FULL -
*        (REMAINING BLOCK COUNT * RCD LENGTH)
*
         LH    R4,PPISRTBL         RESET OUTPUT BLOCKING TO SORT
         ST    R4,KOBLKCNT         BLOCKING
RBH2090  L     R2,KBLKPTR          SET R2 = BUFFER ADDR
*                                  FOR DISK, THE INITIAL BLK PTR IS
*                                  LOADED
         SH    R2,K4               DECR BY 4 FOR EOS INDICATION
         L     R5,KIBLKPTR
         ST    R5,KBLKPTR          SET BLK PTR
         L     R11,PPIWRT+4        EXIT TO WRITE ON EOS
         B     4(,R11)
*
*        CONSTANTS
*
KBLKPTR  DC    F'0'                BLOCK POINTER
KIBLKPTR DC    F'0'                INITIAL BLOCK POINTER
KOBLKCNT DC    F'0'                OUTPUT BLOCK COUNT
KBUFSIZ  DC    F'0'                BUFFER SIZE WHEN FULL
K4       DC    H'4'
*
./ ADD NAME=IERRBI   0101-20211-20211-1200-00104-00104-00000-RELEASE 00
RBI      TITLE 'IERRBI - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRBI
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 2 RUNNING MODULE - VARIABLE LENGTH WITHOUT EXITS
*        THE FUNCTION OF THE MODULE IS TO HANDLE THE DEBLOCKING
*        AND BLOCKING OF VARIABLE LENGTH RECORDS. THE BUFFERS ARE
*        FILLED BY THE READ MODULE AND EMPTIED BY THE WRITE
*        MODULE. THIS MODULE MOVES THE VARIABLE LENGTH RECORD
*        FROM THE INPUT BLOCK DIRECTLY TO THE OUTPUT BLOCK
*
*        THE MERGE NETWORK INITIALLY PASSES A WINNER TO THE
*        BLOCK SIDE OF THIS MODULE. BLOCK SEES IF IT CAN FIT IN
*        THE OUTPUT BLOCK AND IF IT CAN'T, WRITES THE BLOCK THEN
*        MOVES THE RECORD. IT THEN BRANCHES TO THE DEBLOCK SIDE.
*        DEBLOCK DEBLOCKS ANOTHER RECORD FROM THE SAME FILE AS
*        THE WINNER, TESTING FIRST IF THAT BLOCK IS EMPTY. IF IT
*        IS, DEBLOCK READS ANOTHER BLOCK FROM THE SAME FILE.
*        DEBLOCK THEN PASSES THE ADDRESS OF THE NEW RECORD TO THE
*        MERGE NETWORK. THE NETWORK FINDS ANOTHER WINNER AND THE
*        PROCESS IS REPEATED
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - IERABI
*
*        MACROS USED BY THE MODULE - SMPPI
*
*        ENTRY POINTS - ENTRY FROM MERGE NETWORK
*                       CALLING SEQUENCE -
*                           L    R11,PPIBLK2+4
*                           B    0(,R11)     NORMAL EDS
*                           B    16(,R11)    NORMAL
*                     - ENTRY FROM READ
*                       CALLING SEQUENCE -
*                           L    R11,PPIBLK2+4
*                           B    4(,R11)
*                     - ENTRY FROM WRITE
*                       CALLING SEQUENCE -
*                           L    R11,PPIBLK2+4
*                           B    8(,R11)
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIBDSVA PPILAB07 PPISBLCT
*
*        VARIOUS ADDRESSES
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPICOUNT
*        UPDATE COUNTERS
*
*        EXTERNAL ROUTINES - NONE
*
*        EXTERNAL PARAMETERS - SEE REGISTERS
*
*        EXITS - NORMAL - EXIT TO READ
*                         CALLING SEQUENCE -
*                             L    R11,PPIRD+4
*                             B    8(,R11)
*
*                       - EXIT TO NETWORK
*                         CALLING SEQUENCE -
*                             L    R11,PPINETM+4
*                             B    8(,R11)
*
*                       - EXIT TO WRITE
*                         CALLING SEQUENCE -
*                             L    R11,PPIWRT+4
*                             B    4(,R11)     EOS
*                             B    8(,R11)     NORMAL
*
*        EXITS - ERROR - NONE
*
*        TABLES/WORK AREAS -
*        WBLKCCNT - OUTPUT BUFFER CHARACTER COUNTER
*        WRCDLGTH - LENGTH OF WINNER RECORD
*        WINNER   - ADDR OF THE WINNER RECORD IN THE INPUT BLOCK
*        WLSTPTR  - ADDR OF A FREE AREA IN OUTPUT BUFFER TO MOVE
*                   THE WINNER
*        WLSTPTRD - PTR TO STARTG+8 (DISK) OR ENDING+1 (TAPE) ADDR
*                   OF OUTPUT BUFFER
*
*        NOTES -
*        THIS MODULE WILL EXECUTE FOR ANY VARIABLE LENGTH SORT
*        WITHOUT USER EXITS
*
IERRBI   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRBI SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRBII
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERRBII  0101-20211-20211-1200-00187-00187-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERRBI SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERRBII
*
         USING *,R11               MODULE BASE REG LOADED EXTERNALLY
         USING IERRCA,R13          ADDR OF PPI LOADED EXTERNALLY
*
*        ENTRY TABLE
*
IERDB2   B     RBEOS               +00 FROM MERGE ON NORMAL EOS
         B     RBRDRTRN            +04 FROM READ MODULE
         B     RBWRT               +08 FROM WRITE MODULE
         NOP   RBSAVE              +12 PRIMING ENTRY
*                                      USED ONLY FOR USER MODS
*
*        NORMAL MERGE ENTRY - INCR BLOCK CHAR CTR
*        CHECK IF RCD WILL FIT IN OUTPUT BLOCK. IF NOT, WRITE
*        THE BLOCK BEFORE MOVING THE RCD
*
         L     R6,WBLKCCNT         +16 OUTPUT BLOCK CHAR CTR INITIALLY
*                                      PRESET TO 8 BY AP
         MVC   WRCDLGTH+2(2),0(R3)  MOVE RCD LENGTH TO PROPER BOUNDARY
         A     R6,WRCDLGTH         ADD RCD LENGTH TO OUTPUT BLOCK CHAR
*                                  CTR
         CH    R6,PPILAB07+2       > ROUNDED OUTPUT BLOCKING ?
         BH    RBWRTBLK            YES, BRANCH TO WRITE THE BLOCK FIRST
RBSAVE   ST    R6,WBLKCCNT         SAVE UPDATED BLOCK CHAR CTR
         ST    R3,WINNER           SAVE ADDR OF RCD IN INPUT BLOCK
         L     R5,WLSTPTR          ADDR IN OUTPUT BLOCK TO MOVE RCD
RBSUBRLT S     R5,WRCDLGTH         DECR ADDR BY RCD LGTH FOR TAPE SORT
*                                  RCDS FILL OUTPUT BLOCK STARTG FROM
*                                  HI CORE TO LOW. AP WILL NOP THIS
*                                  INSTR IF DISK
         L     R6,PPICOUNT         RECORD COUNTER
         LA    R6,1(,R6)           INCR RECORD COUNTER
         ST    R6,PPICOUNT         STORE UPDATED RECORD COUNTER
         LR    R4,R3               ADDR OF RCD IN INPUT AREA FOR MOVE
         L     R8,WRCDLGTH         LENGTH OF RCD FOR MOVE RTN
*
*        GENERALIZED MOVE RTN USED TO MOVE ANY SIZED DATA RCD
*        FROM ONE DATA AREA TO ANOTHER.
*        REGISTERS ON INPUT -
*        R4 -> DATA SOURCE
*        R5 -> DATA TARGET
*        R8 = L'DATA
*
*        IN ADDITION, THE ROUTINE USES REGISTERS R6 AND R7
*
*        THE ROUTINE DOES ALL INTERMEDIARY UPDATING OF
*        REGISTERS. UPON COMPLETION OF THE MOVE THE REGISTERS
*        CONTAIN-
*        R4 FROM ADDR UPDATED
*        R5 TO ADDR UPDATED
*        R8 REMAINING RCD LENGTH SET TO ZERO
*
         LR    R6,R5               R6 -> DATA TARGET
         LR    R5,R8               R5 = L'DATA
         LR    R7,R8               R7 = L'DATA
         MVCL  R6,R4               MOVE DATA, NO PAD
         LR    R5,R6               R5 -> TARGET+1
         SR    R8,R8               R8 = REMAINING COUNT = 0
*
*        END OF GENERALIZED MOVE ROUTINE
*
RBSUBRLD S     R5,WRCDLGTH         DECR ADDR BY RCD LGTH FOR DISK SORT
*                                  AP WILL NOP THIS INSTR
         ST    R5,WLSTPTR          SAVE UPDATED OUTPUT BLOCK RCD PTR
         B     RBDEBLCK            BRANCH TO DEBLOCK ANOTHER RCD
*
*        WRITE A BLOCK
*        THIS RCD CAN'T FIT INTO THIS BLOCK
*
RBWRTBLK S     R6,WRCDLGTH         SUBTR LENGTH OF RCD THAT CAN'T FIT
*                                  FROM OUTPUT BLOCK CHAR COUNT
RBLSTPTR L     R2,WLSTPTR          LOAD OUTPUT BLOCK RCD PTR FOR DISK,
*                                  AP WILL OVERLAY WLSTPTR WITH
*                                  WLSTPTRD
         S     R2,KEIGHT           EQUALS ADDR OF OUTPUT BLK TO WRITE
         ST    R6,WBLKCCNT         STORE BLK CHAR CTR IN 1ST 2 BYTES
         MVC   0(2,R2),WBLKCCNT+2
         LR    R1,R6               ALSO, IN R1 FOR WRITE MODULE PARAM
*
*        INTERFACE TO WRITE MODULE
*
         L     R11,PPIWRT+4        ADDR OF WRITE MODULE
         B     8(,R11)             BRANCH TO WRITE MODULE
*
*        WRITE MODULE REENTERS VIA BRANCH TABLE
*        R2 FOR TAPE, HAS AN OUTPUT BLOCK ENDING ADDR+1
*        FOR DISK, R2 HAS OUTPUT BLK STARTING ADDR+8
*
RBWRT    ST    R2,WLSTPTRD         SAVE AS CURRENT OUTPUT BLK POINTER
         ST    R2,WLSTPTR          STORE AS OUTPUT BLK WORK POINTER
         LA    R6,8                REINITIALIZE BLOCK CHAR CTR TO 8
         A     R6,WRCDLGTH         ADD LENGTH OF RCD TO BE MOVED TO
*                                  OUTPUT BLOCK
         B     RBSAVE              BRANCH TO MOVE RCD TO OUTPUT BLOCK
*
*        FROM MERGE NORMAL EOS
*        PREVIOUS RCD WAS EOS RCD AND IS IN OUTPUT BLK NO NEW
*        RECORDS PASSED TO BLOCK RTN AT THIS TIME
*
RBEOS    L     R4,WLSTPTR          FOR TAPE USE WLSTPTR FOR DISK AP
*                                  WILL OVLAY WLSTPTR WITH WLSTPTRD
         MVC   WLSTPTR,WLSTPTRD    RESET OUTPUT BLOCK POINTER
         S     R4,KEIGHT           DECR OUTPUT BLK PTR BY 8 TO INSERT
*                                  BLOCK CHAR CNT IN 1ST 2 BYTES
         MVC   0(2,R4),WBLKCCNT+2  STORE BLK CHAR CNT IN OUTPUT BLK
         L     R1,WBLKCCNT         LOAD BLOCK CHAR CNT FOR WRITE MOD
         MVC   WBLKCCNT,KEIGHT     REINITIALIZE BLOCK CHAR CTR TO 8
         LA    R3,4                SET SWITCH TO NORMAL EOS FOR WRITE
         LR    R2,R4               LOAD OUTPUT BLOCK PTR FOR WRITE
*
*        INTERFACE TO WRITE MODULE FOR NORMAL EOS
*
         L     R11,PPIWRT+4        ADDR OF WRITE MODULE
         B     4(,R11)             BRANCH TO WRITE MODULE
*
*        DEBLOCK SIDE OF PROGRAM
*
RBDEBLCK SRL   R3,24               SHIFT TO GET AT INCR OF WINNER RCD
         L     R6,PPISBLCT         R6 -> BLOCK COUNT TABLE
         L     R7,0(R3,R6)         R7 = BLK CHAR CNT OF WINNER'S BLOCK
         S     R7,WRCDLGTH         SUBTRACT RECORD LENGTH OF WINNER
*                                  BLOCK CHAR CNT ZERO ?
         BZ    RBREAD              YES, BRANCH TO READ ANOTHER BLK INTO
*                                       INPUT BLK JUST VACATED
         ST    R7,0(R3,R6)         NO, STORE UPDATED BLOCK CHAR COUNT
         L     R3,WINNER           RESTORE WINNER
         A     R3,WRCDLGTH         R3 -> NEXT RECORD FROM WINNER FILE
*
*        INTERFACE TO MERGE NETWORK
*
RBMERGE  L     R11,PPINETM+4       ADDR OF MERGE MODULE
         B     8(R11)              BR TO MERGE MODULE
*
*        FILL EMPTY INPUT BLOCK OF WINNER
*        R3 HAS INCR IN LOW ORDER BYTE
*
RBREAD   L     R6,PPIBDSVA         ADDR OF INPUT BLK ADDR TABLE
         L     R2,0(R3,R6)         ADDR OF THE WINNER'S INPUT BLOCK
*
*        INTERFACE TO READ MODULE
*
         L     R11,PPIRD+4         ADDR OF READ MODULE
         B     8(,R11)             BRANCH TO READ MODULE
*
*        READ MODULE RETURNS VIA THIS MODULE BRANCH TABLE
*        REGS CONTAIN THE FOLLOWING
*        R1 -  BLOCK CNT
*        R2 -> FIRST RECORD IN INPUT BLOCK
*        R3 -  INCR
*        R4 -  ENDING ADDR OF BLOCK FOR TAPE OR STARTING ADDR OF
*              BLOCK FOR DISK
*
RBRDRTRN L     R6,PPISBLCT         R6 -> BLOCK COUNT TABLE
         S     R1,KFOUR            EQUALS TOTAL BYTES(OF RCDS)IN BLOCK
         ST    R1,0(R3,R6)         STORE NEW BLOCK CHAR CNT IN TABLE
         L     R6,PPIBDSVA         R6 -> INPUT BLK STARTING ADDR TABLE
         ST    R4,0(R3,R6)         STORE IN INDEXED POSITION IN TABLE
         SLL   R3,24               POSITION INCR IN HI BYTE
         AR    R3,R2               INSERT STRTG ADDR OF 1ST RCD OF BLK
         B     RBMERGE             BRANCH TO MERGE
*
*        CONSTANTS
*
KFOUR    DC    F'4'                FOUR
KEIGHT   DC    F'8'                EIGHT
*
*        WORK AREAS
*
WBLKCCNT DC    F'0'                OUTPUT BLOCK CHAR CTR INITIALLY
*                                  PRESET TO 8 BY AP
WRCDLGTH DC    F'0'                L'INPUT RECORD TO BE BLOCKED
WINNER   DC    F'0'                ADDR OF WINNER RCD IN INPUT BLOCK
WLSTPTR  DC    F'0'                ADDR IN OUTPUT BLOCK TO MOVE WINNER
*                                  AP INITIALLY SETS TO OUTPUT ENDING
*                                  ADDR+1 FOR TAPE, OR OUTPUT BLK
*                                  STARTING ADDR+8 FOR DISK SORT
WLSTPTRD DC    F'0'                CURRENT OUTPUT BLK STRTG ADDR+8-DISK
*                                  OR OUTPUT BLK ENDING ADDR+1-TAPE
*
./ ADD NAME=IERRBJ   0101-20211-20211-1200-00094-00094-00000-RELEASE 00
RBJ      TITLE 'IERRBJ - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRBJ
*
*        MODULE FUNCTION/OPERATION -
*        DEBLOCKING AND BLOCKING OF FIXED LENGTH RECORDS.
*        THE MODULE MAINTAINS THE BUFFER SCHEMES. THE MODULE IS
*        USED WHENEVER USER EXIT E25 IS ACTIVATED. THE MODULE
*        BLOCK SIDE LINKS TO THE MULTIPLE MOVE LIST TO MOVE
*        RECORDS TO THE OUTPUT BUFFER. FLOW IN THE MODULE IS FROM
*        THE MERGE TO BLOCK SIDE TO DEBLOCK SIDE
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - IERABJ
*
*        MACROS USED BY MODULE - SMPPI
*
*        ENTRY POINTS - ENTRY FROM NETWORK
*                       CALLING SEQUENCE -
*                           L     R11,PPIBLK2+4
*                           B     16(,R11)   NORMAL ENTRY
*
*                           L     R11,PPIBLK2+4
*                           B     12(,R11)   PRIMING ENTRY
*
*                           L     R11,PPIBLK2+4
*                           BR    R11        EOS ENTRY
*
*                     - ENTRY FROM READ
*                       CALLING SEQUENCE -
*                           L     R11,PPIBLK2+4
*                           B     4(,R11)
*
*                     - ENTRY FROM WRITE
*                       CALLING SEQUENCE -
*                           L     R11,PPIBLK2+4
*                           B     8(,R11)
*
*                     - ENTRY FROM E25
*                       CALLING SEQUENCE -
*                           BR    R14
*
*                     - ENTRY FROM MOVE LIST
*                       CALLING SEQUENCE -
*                           BR    R14
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIRCDL2   PPIBDSVA   PPICOUNT
*        PPISBLCT   PPISRTBL   PPIDELCT
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPICOUNT   PPIDELCT
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL -
*        E25       - PHASE 2 RECORD MODIFICATION EXIT
*        MOVE LIST - TO MOVE RECORD FROM INPUT BUFFER TO OUTPUT
*                    BUFFER
*        NETWORK   - PASS ADDR OF NEXT RECORD
*        READ      - TO FILL A BUFFER
*        WRITE     - TO EMPTY A BUFFER - NORMAL
*        WRITE     - TO EMPTY A BUFFER - AT EOS
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS -
*        WORK AREA STARTING AT ADDR KPARLST CONTAINS ADDR OF
*        WINNER RECORD AND LAST RECORD BLOCKED
*
*        NOTES -
*        THIS MODULE IS USED ONLY IF THE RECORD LENGTHS ARE
*        FIXED AND E25 IS ACTIVE
*
IERRBJ   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRBJ SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRBJI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERRBJI  0101-20211-20211-1200-00161-00161-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERRBJ SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERRBJI
*
         USING *,R11
         USING IERRCA,R13
*
IERDB2   B     RBJ2080             +00 EOS ENTRY
         B     RBJ2040             +04 READ ENTRY
         B     RBJ2060             +08 WRITE ENTRY
         B     RBJ2006             +12 PRIME ENTRY TO BYPASS E25
*
*        NORMAL ENTRY FROM MERGE
*        R3 -> WINNER RCD
*
*        SET UP LINK TO USER EXIT
*
         ST    R3,KPARLST          +16 PUT WINNER ADDR IN PARM LIST
         LA    R1,KPARLST          R1 -> PARAMETER LIST
         L     R15,PPIX25+4
         BASR  R14,R15             CALL USER EXIT E25
         B     *+4(R15)            RETURN FROM USER - R15 INDICATES
*                                  PROPER BRANCH TABLE ENTRY
         B     RBJ2005             +00 DO NOTHING ENTRY - PROCEED TO
*                                      BLOCK RECORD
         B     RBJ2100             +04 DELETE ENTRY
*
*        BLOCK WINNER RECORD
*
RBJ2006  LR    R1,R3               LOAD ADDR OF RCD
RBJ2005  L     R4,KOBLKCNT         SET R4 = OUTPUT BLOCK COUNT
         LTR   R4,R4               BLOCK COUNT = 0 ?
         BNP   RBJ2050             YES, BRANCH, BLOCK IS FULL
RBJ2010  BCTR  R4,0                NO, DECREMENT BLOCK COUNT BY 1
         ST    R4,KOBLKCNT
         L     R2,KBLKPTR
*
*        FOR DISK THE FOLLOWING 6 INSTRUCTIONS ARE OVERLAID SO
*        THAT THE WINNER RECORD IS MOVED TO THE OUTPUT BUFFER AND
*        THEN THE BLOCK POINTER IS INCREMENTED
*
RBJ2020  SH    R2,PPIRCDL2         DECREMENT BLK PTR BY RCD LENGTH
         ST    R2,KPARLST+4        STORE RCD ADDR IN PARM LIST
         LR    R4,R1               SET R4 = RCD ADDR OF MOD RCD
         LR    R5,R2               SET R2 = BUFFER ADDR
         L     R15,PPIBDSVA+8      CALL MOVE LIST - MOVE WINNER TO
         BASR  R14,R15             OUTPUT BUFFER
         ST    R2,KBLKPTR
         L     R6,PPICOUNT
         LA    R6,1(,R6)           INCREMENT RCD COUNT
         ST    R6,PPICOUNT
*
*        DEBLOCK RECORD FROM SAME FILE AS WINNER RECORD
*
RBJ2027  LR    R2,R3               SAVE WINNER ADDR
         SRL   R3,24               ACCESS INCREMENT
         L     R7,PPISBLCT         R7 -> BLOCK COUNT TABLE
         L     R8,0(R3,R7)         R8 = BLOCK COUNT FOR THIS BUFFER
         BCTR  R8,0                DECREMENT BLOCK COUNT
         LTR   R8,R8               BLOCK COUNT = 0 ?
         BNP   RBJ2030             YES, BRANCH, BLOCK IS EMPTY
         ST    R8,0(R3,R7)         NO, STORE NEW BLOCK COUNT
         LR    R3,R2               INCREMENT WINNER BY RECORD LENGTH
         AH    R3,PPIRCDL2         TO GET NEXT RECORD
         L     R11,PPINETM+4       EXIT TO MERGE
         B     8(,R11)
*
*        INPUT BUFFER IS EMPTY - CALL READ ROUTINE TO REFILL BUFFER
*        R2 -> EMPTY BUFFER
*        R3  = INCREMENT
*
RBJ2030  L     R7,PPIBDSVA         R7 -> BUFFER TABLE
         L     R2,0(R3,R7)         ACCESS ADDR OF EMPTY BUFFER VIA INCR
         L     R11,PPIRD+4
         B     8(,R11)
*
*        RETURN FROM READ ROUTINE
*        R1  = BLOCK COUNT
*        R2 -> BUFFER (FOR DEBLOCKING)
*        R3  = INCREMENT
*        R4 -> BUFFER (FOR READING)
*
RBJ2040  L     R7,PPIBDSVA         R7 -> BUFFER TABLE
         ST    R4,0(R3,R7)         STORE BUFF ADDR IN TABLE
         L     R5,PPISBLCT         R5 -> BLOCK COUNTER TABLE
         ST    R1,0(R3,R5)         STORE BLOCK CNT IN BLK CNT TABLE
         SLL   R3,24               ADD INCREMENT TO NEXT RECORD
         AR    R3,R2
         L     R11,PPINETM+4       EXIT TO MERGE
         B     8(,R11)
*
*        OUTPUT BUFFER IS FULL - CALL WRITE ROUTINE TO EMPTY BUFFER
*        R1  = NO OF BYTES TO BE WRITTEN
*        R2 -> BUFFER TO BE WRITTEN
*
RBJ2050  ST    R1,WRBSAVE          STORE MOD RCD ADDR
         L     R1,KBUFSIZ          SET R1 = NO BYTES IN BUFFER
RBJ2053  L     R2,KBLKPTR          R2 -> BUFFER
*                                  FOR DISK, INITIAL PTR IS LOADED
         SH    R2,K4               DECR BY 4 FOR EOS INDICATION
         L     R11,PPIWRT+4        CALL WRITE RTN
         B     8(,R11)
*
*        RETURN FROM WRITE ROUTINE
*        R2 -> EMPTY BUFFER
*
RBJ2060  LH    R4,PPISRTBL         RESET OUTPUT BLK CNT TO SORT BLKNG
         ST    R2,KIBLKPTR         SAVE INITIAL POINTER
         ST    R2,KBLKPTR          SET BLOCK POINTER
         L     R1,WRBSAVE          RELOAD MOD RCD ADDR
         B     RBJ2010
*
*        END OF SEQUENCE - WRITE THIS BUFFER
*        RESET POINTERS TO REUSE THIS BUFFER THE NEXT TIME
*        THROUGH
*
RBJ2080  LA    R3,4                SET INDICATION FOR NOT FINAL EOS
*
*        CALCULATE NUMBER OF BYTES TO BE WRITTEN -
*        BUFFER SIZE WHEN FULL - (REMAINING BLOCK COUNT * RECORD
*        LENGTH)
*
         L     R1,KBUFSIZ
         L     R4,KOBLKCNT
         MH    R4,PPIRCDL2
         SR    R1,R4
         LH    R4,PPISRTBL         RESET OUTPUT BLOCK COUNT TO SORT
         ST    R4,KOBLKCNT         BLOCKING
RBJ2090  L     R2,KBLKPTR          R2 -> BUFFER
*                                  FOR DISK, INITIAL PTR IS LOADED
         SH    R2,K4               DECR BY 4 FOR EOS INDICATION
         L     R5,KIBLKPTR
         ST    R5,KBLKPTR          RESET BLK PTR
         L     R11,PPIWRT+4        CALL WRITE ON EOS
         B     4(,R11)
*
*        WINNER RECORD IS TO BE DELETED
*
RBJ2100  L     R7,PPIDELCT
         LA    R7,1(,R7)           INCREMENT DELETE COUNTER
         ST    R7,PPIDELCT
         B     RBJ2027             DEBLOCK ANOTHER RECORD
*
*        CONSTANTS
*        PARAMETER LIST FOR USER
*
KPARLST  DC    A(0)                ADDR OF WINNER RECORD
         DC    A(0)                ADDR OF LAST RECORD BLOCKED
*
KBLKPTR  DC    F'0'
KIBLKPTR DC    F'0'
KOBLKCNT DC    F'0'
KBUFSIZ  DC    F'0'
WRBSAVE  DC    F'0'                CURRENT MODIFIED RECORD ADDR
K4       DC    H'4'
*
./ ADD NAME=IERRBK   0101-20211-20211-1200-00128-00128-00000-RELEASE 00
RBK      TITLE 'IERRBK - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRBK
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 2 RUNNING MODULE VARIABLE LENGTH RECORDS WITH EXIT E25
*        THE FUNCTION OF THIS MODULE IS TO HANDLE THE DEBLOCKING
*        AND BLOCKING OF VARIABLE LENGTH RECORDS. THE BUFFERS ARE
*        FILLED BY THE READ MODULE AND EMPTIED BY THE WRITE
*        MODULE. THIS MODULE MOVES THE VARIABLE LENGTH RECORD
*        FROM THE INPUT BLOCK DIRECTLY TO THE OUTPUT BLOCK
*
*        THE USER EXIT E25 IS ON THE BLOCK SIDE AND IS EXECUTED
*        ONCE FOR EVERY RECORD, EXCEPT THE FIRST RECORD OF EACH
*        OUTPUT SEQUENCE. THE EXIT OCCURS AFTER THE RECORD LEAVES
*        THE MERGE AND WHILE THE PREVIOUS RECORD IS AVAILABLE IN
*        THE OUTPUT AREA. THE EXIT IS FOR SUMMARIZATION AND
*        DELETION OF RECORDS EXCEPT ON THE FIRST RECORD OF EACH
*        OUTPUT SEQUENCE
*
*        THE MERGE NETWORK INITIALLY PASSES A WINNER TO THE
*        BLOCK SIDE OF THIS MODULE. BLOCK SEES IF IT CAN FIT IN
*        THE OUTPUT BLOCK AND IF IT CAN'T, WRITES THE BLOCK THEN
*        MOVES THE RECORD. IT THEN BRANCHES TO THE DEBLOCK SIDE.
*        DEBLOCK DEBLOCKS ANOTHER RECORD FROM THE SAME FILE AS
*        THE WINNER, TESTING FIRST IF THAT BLOCK IS EMPTY. IF IT
*        IS, DEBLOCK READS ANOTHER BLOCK FROM THE SAME FILE.
*        DEBLOCK THEN PASSES THE ADDRESS OF THE NEW RECORD TO THE
*        MERGE NETWORK. THE NETWORK FINDS ANOTHER WINNER AND THE
*        PROCESS IS REPEATED
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT -
*        IERABK
*
*        MACROS USED BY THE MODULE - SMPPI
*
*        ENTRY POINTS - ENTRY FROM MERGE NETWORK
*                       CALLING SEQUENCE -
*                           L    R11,PPIBLK2+4
*                           B    0(,R11)     NORMAL EOD
*                           B    12(,R11)    PRIMING ENTRY
*                           B    16(,R11)    NORMAL
*
*                     - ENTRY FROM READ
*                       CALLING SEQUENCE -
*                           L    R11,PPIBLK2+4
*                           B    4(,R11)
*
*                     - ENTRY FROM WRITE
*                       CALLING SEQUENCE -
*                           L    R11,PPIBLK2+4
*                           B    8(,R11)
*
*                     - ENTRY FROM USER EXIT E25
*                       CALLING SEQUENCE -
*                           RETURN  RC=(15) RETURN ON R14
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIBDSVA PPILAB07 PPISBLCT
*        VARIOUS ADDRESSES
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPICOUNT   PPIDELCT
*        UPDATE COUNTERS
*
*        EXTERNAL ROUTINES - NONE
*
*        EXTERNAL PARAMETERS - SEE REGISTERS
*
*        EXITS - NORMAL - EXIT TO READ
*                         CALLING SEQUENCE -
*                             L    R11,PPIRD+4
*                             B    8(,R11)
*
*                       - EXIT TO MERGE NETWORK
*                         CALLING SEQUENCE -
*                             L    R11,PPINETM+4
*                             B    8(,R11)
*
*                       - EXIT TO WRITE
*                         CALLING SEQUENCE -
*                             L    R11,PPIWRT+4
*                             B    4(,R11)     EOD
*                             B    8(,R11)     NORMAL
*
*                       - EXIT TO USER EXIT E25
*                         CALLING SEQUENCE
*                             L    R15,PPIX25+4
*                             BALR R14,R15
*
*        EXITS - ERROR - NONE
*
*        TABLES/WORK AREAS -
*        WMRGRCD  - ADDR OF WINNER IN INPUT BUFFER
*                   PARAM 1 TO USER
*        WOUTRCD  - ADDR OF LAST RCD PUT IN OUTPUT BUFFER
*                   PARAM 2 TO USER
*        WBLKCCNT - OUTPUT BUFFER CHARACTER COUNTER
*        WRCDLGTH - LENGTH OF WINNER RECORD
*        WINNER   - ADDR OF WINNER RECORD IN INPUT BUFFER
*        WLSTPTR  - ADDR OF A FREE AREA IN OUTPUT BUFFER TO MOVE
*                   THE WINNER
*        WLSTPTRD - PTR TO STRTG+8(DISK) OR ENDING+1(TAPE) ADDR
*                   OF OUTPUT BFR
*
*        NOTES -
*        THIS MODULE EXECUTES FOR ANY VARIABLE LENGTH SORT WITH
*        USER EXIT E25 ACTIVE
*
IERRBK   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRBK SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRBKI
*
*        REGISTERS AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERRBKI  0101-20211-20211-1200-00214-00214-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERRBK SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERRBKI
*
         USING *,R11               MODULE BASE REG LOADED EXTERNALLY
         USING IERRCA,R13          ADDR OF PPI LOADED EXTERNALLY
*
*        ENTRY TABLE
*
IERDB2   B     RBEOS               +00 FROM MERGE ON NORMAL EOS
         B     RBRDRTRN            +04 FROM READ MODULE
         B     RBWRT               +08 FROM WRITE MODULE
         B     RBBPSUS1            +12 PRIME ENTRY,BYPASS EXIT RTN
*
*        NORMAL MERGE ENTRY - INCR BLOCK CHAR CTR
*        CHECK IF RCD WILL FIT IN OUTPUT BLOCK. IF NOT, WRITE
*        THE BLOCK BEFORE MOVING THE RCD
*
         ST    R3,WMRGRCD          +16 PARAM 1 TO USER ADDR OF RCD IN
*                                      INPUT BLOCK
*
*        CALL USER EXIT E25
*
         L     R15,PPIX25+4        ADDR OF USER EXIT E25
         LA    R1,WMRGRCD
         BASR  R14,R15
*
*        RETURN FROM USER
*
         B     *+4(R15)
         B     RBBPSUSR            +00 DO NOTHING
         L     R6,PPIDELCT         +04 DELETE COUNTER
         LA    R6,1(,R6)           INCR DELETE CTR BY 1
         ST    R6,PPIDELCT         SAVE UPDATED DELETE CTR
         ST    R3,WINNER           SAVE WINNER ADDR (DEBLK WILL DELETE)
         MVC   WRCDLGTH+2(2),0(R3)  MOVE RCD LENGTH TO PROPER BOUNDARY
         B     RBDEBLCK            BRANCH TO DEBLOCK ANOTHER RCD
*
RBBPSUS1 LR    R1,R3
RBBPSUSR L     R6,WBLKCCNT         OUTPUT BLOCK CHAR CTR INITIALLY
*                                  PRESET TO 8 BY AP
         MVC   WRCDLGTH+2(2),0(R1)  MOVE RCD LENGTH TO PROPER BNDRY
         A     R6,WRCDLGTH         ADD RCD LENGTH TO OUTPUT BLOCK CHAR
*                                  CTR
         CH    R6,PPILAB07+2       > ROUNDED OUTPUT BLOCKING ?
         BH    RBWRTBLK            YES, BRANCH TO WRITE THE BLOCK FIRST
RBSAVE   ST    R6,WBLKCCNT         SAVE UPDATED BLOCK CHAR CTR
         ST    R3,WINNER           SAVE ADDR OF RCD IN INPUT BLOCK
         L     R5,WLSTPTR          ADDR IN OUTPUT BLOCK TO MOVE RCD
RBSUBRLT S     R5,WRCDLGTH         DECR ADDR BY RCD LGTH FOR TAPE SORT
*                                  RCDS FILL OUTPUT BLOCK STARTG FROM
*                                  HI CORE TO LOW. AP WILL NOP THIS
*                                  INSTR IF DISK
         ST    R5,WOUTRCD          PARAM 2 TO USER ADDR OF RCD IN
*                                  OUTPUT BLOCK
         L     R6,PPICOUNT         RECORD COUNTER
         LA    R6,1(,R6)           INCR RECORD COUNTER
         ST    R6,PPICOUNT         STORE UPDATED RECORD COUNTER
         LR    R4,R1               ADDR OF RCD IN INPUT AREA
         L     R8,WRCDLGTH         LENGTH OF RCD FOR MOVE RTN
*
*        GENERALIZED MOVE RTN USED TO MOVE ANY SIZED DATA RCD
*        FROM ONE DATA AREA TO ANOTHER.
*        REGISTERS ON INPUT -
*        R4 -> DATA SOURCE
*        R5 -> DATA TARGET
*        R8 = L'DATA
*
*        IN ADDITION, THE ROUTINE USES REGISTERS R6 AND R7
*
*        THE ROUTINE DOES ALL INTERMEDIARY UPDATING OF
*        REGISTERS. UPON COMPLETION OF THE MOVE THE REGISTERS
*        CONTAIN-
*        R4 FROM ADDR UPDATED
*        R5 TO ADDR UPDATED
*        R8 REMAINING RCD LENGTH SET TO ZERO
*
         LR    R6,R5               R6 -> DATA TARGET
         LR    R5,R8               R5 = L'DATA
         LR    R7,R8               R7 = L'DATA
         MVCL  R6,R4               MOVE DATA, NO PAD
         LR    R5,R6               R5 -> TARGET+1
         SR    R8,R8               R8 = REMAINING COUNT = 0
*
*        END OF GENERALIZED MOVE ROUTINE
*
RBSUBRLD S     R5,WRCDLGTH         DECR ADDR BY RCD LGTH FOR DISK SORT
*                                  AP WILL NOP THIS INSTR
         ST    R5,WLSTPTR          SAVE UPDATED OUTPUT BLOCK RCD PTR
         B     RBDEBLCK            BRANCH TO DEBLOCK ANOTHER RCD
*
*        WRITE A BLOCK. THIS RCD CAN'T FIT INTO THIS BLOCK
*
RBWRTBLK S     R6,WRCDLGTH         SUBTR LENGTH OF RCD THAT CAN'T FIT
*                                  FROM OUTPUT BLOCK CHAR COUNT
         ST    R1,WRBSAVE          STORE MOD RCD ADDR
RBLSTPTR L     R2,WLSTPTR          LOAD OUTPUT BLOCK RCD PTR FOR DISK,
*                                  AP WILL OVERLAY WLSTPTR WITH
*                                  WLSTPTRD
         S     R2,KEIGHT           EQUALS ADDR OF OUTPUT BLK TO WRITE
         ST    R6,WBLKCCNT         ALIGN TO WD BOUNDARY
         MVC   0(2,R2),WBLKCCNT+2  STORE BLOK CHAR CTR IN 1ST 2 BYTES
         LR    R1,R6               ALSO, IN R1 FOR WRITE MODULE PARAM
*
*        INTERFACE TO WRITE MODULE
*
         L     R11,PPIWRT+4        ADDR OF WRITE MODULE
         B     8(,R11)             BRANCH TO WRITE MODULE
*
*        WRITE MODULE REENTERS VIA BRANCH TABLE
*        R2 FOR TAPE, HAS AN OUTPUT BLOCK ENDING ADDR+1
*        FOR DISK, R2 HAS OUTPUT BLK STARTING ADDR+8
*
RBWRT    ST    R2,WLSTPTRD         SAVE AS CURRENT OUTPUT BLK POINTER
         ST    R2,WLSTPTR          STORE AS OUTPUT BLK WORK POINTER
         LA    R6,8                REINITIALIZE BLOCK CHAR CTR TO 8
         A     R6,WRCDLGTH         ADD LENGTH OF RCD TO BE MOVED TO
*                                  OUTPUT BLOCK
         L     R1,WRBSAVE          RELOAD MOD RCD ADDR
         B     RBSAVE              BRANCH TO MOVE RCD TO OUTPUT BLOCK
*
*        FROM MERGE NORMAL EOS
*        PREVIOUS RCD WAS EOS RCD AND IS IN OUTPUT BLK NO NEW
*        RECORDS PASSED TO BLOCK RTN AT THIS TIME
*
RBEOS    L     R4,WLSTPTR          FOR TAPE USE WLSTPTR FOR DISK AP
*                                  WILL OVLAY WLSTPTR WITH WLSTPTRD
         MVC   WLSTPTR,WLSTPTRD    RESET OUTPUT BLOCK POINTER
         S     R4,KEIGHT           DECR OUTPUT BLK PTR BY 8 TO INSERT
*                                  BLOCK CHAR CNT IN 1ST 2 BYTES
         MVC   0(2,R4),WBLKCCNT+2  STORE BLK CHAR CNT IN OUTPUT BLK
         L     R1,WBLKCCNT         LOAD BLOCK CHAR CNT FOR WRITE MOD
         MVC   WBLKCCNT,KEIGHT     REINITIALIZE BLOCK CHAR CTR TO 8
         LA    R3,4                SET SWITCH TO NORMAL EOS FOR WRITE
         LR    R2,R4               LOAD OUTPUT BLOCK PTR FOR WRITE
*
*        INTERFACE TO WRITE MODULE FOR NORMAL EOS
*
         L     R11,PPIWRT+4
         B     4(R11)              BRANCH TO WRITE MODULE
*
*        DEBLOCK SIDE OF PROGRAM
*
RBDEBLCK SRL   R3,24               SHIFT TO GET AT INCR OF WINNER RCD
         L     R6,PPISBLCT         R6 -> BLOCK COUNT TABLE
         L     R7,0(R3,R6)         R7 = BLK CHAR CNT OF WINNER'S BLOCK
         S     R7,WRCDLGTH         SUBTRACT RECORD LENGTH OF WINNER
*                                  BLOCK CHAR COUNT ZERO ?
         BZ    RBREAD              YES, BRANCH TO READ ANOTHER BLK INTO
*                                  INPUT BLOCK JUST VACATED
         ST    R7,0(R3,R6)         NO,STORE UPDATED BLOCK CHAR CNT
         L     R3,WINNER           RESTORE WINNER
         A     R3,WRCDLGTH         ADDR OF NEXT RCD FROM WINNER FILE
*
*        INTERFACE TO MERGE NETWORK
*
RBMERGE  L     R11,PPINETM+4       ADDR OF MERGE MODULE
         B     8(,R11)             BRANCH TO MERGE MODULE
*
*        FILL EMPTY INPUT BLOCK OF WINNER
*        R3 HAS INCR IN LOW ORDER BYTE
*
RBREAD   L     R6,PPIBDSVA         R6 -> INPUT BLOCK ADDR TABLE
         L     R2,0(R3,R6)         R2 -> THE WINNER'S INPUT BLOCK
*
*        INTERFACE TO READ MODULE
*
         L     R11,PPIRD+4         READ MODULE
         B     8(,R11)             BRANCH TO READ MODULE
*
*        READ MODULE RETURNS VIA THIS MODULE BRANCH TABLE
*        THE REGS CONTAIN THE FOLLOWING -
*        R1 -  BLOCK COUNT
*        R2 -> FIRST RECORD IN INPUT BLOCK
*        R3 -  INCR
*        R4 -  ENDING ADDR OF BLOCK FOR TAPE OR STARTING ADDR OF
*              BLOCK FOR DISK
*
RBRDRTRN L     R6,PPISBLCT         R6 -> BLOCK COUNT TABLE
         S     R1,KFOUR            EQUALS TOTAL BYTES (OF RCDS) IN BLK
         ST    R1,0(R3,R6)         STORE NEW BLOCK CHAR CNT IN TABLE
         L     R6,PPIBDSVA         R6 -> TABLE OF INPUT BLK STARTING
*                                  ADDRS
         ST    R4,0(R3,R6)         STORE IN INDEXED POSITION IN TABLE
         SLL   R3,24               POSITION INCR IN HI BYTE
         AR    R3,R2               INSERT STARTG ADDR OF 1ST RCD OF BLK
         B     RBMERGE             BRANCH TO MERGE NETWORK
*
*        CONSTANTS
*
KFOUR    DC    F'4'                FOUR
KEIGHT   DC    F'8'                EIGHT
*
*        WORK AREAS
*
WMRGRCD  DC    F'0'                ADDR OF RCD IN INPUT BLK-USER PARAM1
WOUTRCD  DC    F'0'                ADDR OF RCD IN OUTPUT BLK-USR PARAM2
WBLKCCNT DC    F'0'                OUTPUT BLOCK CHAR CTR INITIALLY
*                                  PRESET TO 8 BY AP
WRCDLGTH DC    F'0'                L'INPUT RECORD TO BE BLOCKED
WINNER   DC    F'0'                ADDR OF WINNER RCD IN INPUT BLOCK
WLSTPTR  DC    F'0'                ADDR IN OUTPUT BLOCK TO MOVE WINNER
*                                  AP INITIALLY SETS TO OUTPUT ENDG
*                                  ADDR+1 FOR TAPE, OR OUTPUT BLK
*                                  STARTING ADDR+8 FOR DISK SORT
WLSTPTRD DC    F'0'                CURRENT OUTPUT BLK STRTG ADDR+8-DISK
*                                  OR OUTPUT BLK ENDG ADDR+1-TAPE
WRBSAVE  DC    F'0'                CURRENT MODIFIED RCD ADDR
*
./ ADD NAME=IERRBL   0101-20211-20211-1200-00067-00067-00000-RELEASE 00
RBL      TITLE 'IERRBL - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRBL
*
*        MODULE FUNCTION/OPERATION -
*        WRITE FIXED LENGTH RECORDS BY WAY OF THE QSAM PUT
*        MACRO. THERE ARE NO USER MODIFICATION EXITS. THE PUT
*        MACRO LOCATES WHERE THE RECORD IS TO BE MOVED IN AN
*        OUTPUT BUFFER. RECORD LENGTH IS LESS THAN OR EQUAL TO
*        256 BYTES, SO THE MODULE CONTAINS AN INLINE MOVE
*        INSTRUCTION
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - IERABL
*
*        MACROS USED BY MODULE -
*        SMPPI
*        PUT
*
*        ENTRY POINTS - ENTRY FROM MERGE NETWORK
*                       CALLING SEQUENCE -
*                           L     R11,PPIBLK+4
*                           B     4(,R11) NORMAL ENTRY
*
*                           L     R11,PPIBLK+4
*                           BR    R11     LAST RECORD ENTRY
*
*        INPUT - PPI FIELDS REFERENCED - PPICOUNT
*
*        OUTPUT - PPI FIELDS INITIALIZED OR REFERENCED -
*        PPICOUNT   PPIDOOBA
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL -
*        DEBLOCK
*        EOJ ROUTINE
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS -
*        KADCB - ADDR OF THE OUTPUT DCB
*
*        NOTES -
*        THIS MODULE IS USED IF RECORD LENGTH IS FIXED AND LESS
*        THAN 257 BYTES AND E35 HAS NOT BEEN ACTIVATED
*
IERRBL   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRBL SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRBLI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERRBLI  0101-20211-20211-1200-00038-00038-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERRBL SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERRBLI
*
         USING *,R11
         USING IERRCA,R13
*
IERDB34  B     RBL34020            +00 ENTRY FROM MERGE LAST RECORD
         L     R5,KADCB            +04 NORMAL ENTRY FROM MERGE
*                                      R5 -> DCB
*                                      R3 -> WINNER RECORD
*
         PUT   (R5)
*
*        ON RETURN R1 -> AVAILABLE BUFFER SPACE
*
         ST    R1,PPIDOOBA         PASS BUFFER AREA ADDR TO MERGE
         L     R6,PPICOUNT
         LA    R6,1(,R6)           INCREMENT RECORD COUNT
         ST    R6,PPICOUNT
RBL34010 MVC   0(1,R1),0(R3)       MOVE RECORD TO OUTPUT BUFFER
         L     R11,PPIDEB+4        LINK TO DEBLOCK
         B     4(,R11)
*
*        LAST RECORD HAS BEEN BLOCKED
*
RBL34020 L     R11,PPIWRT+4        LINK TO EOJ
         BR    R11
*
*        CONSTANTS
*
KADCB    DC    F'0'                -> OUTPUT DCB
*
./ ADD NAME=IERRBM   0101-20211-20211-1200-00136-00136-00000-RELEASE 00
RBM      TITLE 'IERRBM - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRBM
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 3 RUNNING MODULE - FIXED LENGTH RECORDS WITH E35
*        THE FUNCTION OF THIS MODULE IS TO BLOCK FIXED LENGTH
*        RECORDS. TO ACCOMPLISH THIS, IT USES A MOVE ROUTINE WITH
*        THE PUT LOCATE MACRO. THE USER ROUTINE IS EXECUTED ONCE
*        FOR EVERY RECORD LEAVING THE MERGE. THE EXIT OCCURS
*        AFTER THE RECORD TO BE PUT LEAVES THE MERGE. THE USER
*        MAY THEN DO THE FOLLOWING -
*        1. INSERT A RECORD
*        2. DELETE OR SUMMARIZE A RECORD OR
*        3. DO NOTHING, ALTER, LENGTHEN, OR SHORTEN A RECORD
*        THE USER RETURNS TO THE APPROPRIATE ROUTINE IN THIS
*        MODULE. THE MODULE LINKS TO THE PROPER DEBLOCK OR EOJ
*        MODULE WHEN NEEDED
*
*        LINKAGE FROM MODULE TO USER IS VIA A CALL.
*        LINKAGE FROM USER TO MODULE IS VIA RETURN REGISTER PLUS
*        PROPER DISPLACEMENT DEPENDING ON THE USER SELECTED RTN
*
*        TWO PARAMETERS ARE PASSED TO THE USER. THE ADDR OF THE
*        RECORD LEAVING THE MERGE, AND THE STARTING ADDRESS OF
*        THE AREA IN THE OUTPUT BUFFER INTO WHICH THE PREVIOUS
*        RECORD HAD BEEN PLACED
*
*        THE USER CAN PASS TWO PARAMETERS TO THE MODULE, THE
*        ADDRESS OF THE RECORD -
*        TO INSERT
*        DO NOTHING
*        ALTER, LENGTHEN, SHORTEN IN R1
*        AND A 4 IF THE INTEGRITY OF THE CONTROL FIELD HAS BEEN
*        CHANGED OF THE RCD COMING FROM THE MERGE OR A ZERO IF
*        NOT, IN THE THIRD PARAMETER OF THE PARAMETER LIST
*
*        THE MODULE PASSES THESE PARAMETERS TO THE MERGE FOR
*        SEQUENCE CHECKING AGAINST THE NEXT RECORD THE MERGE
*        PASSES TO THE MODULE
*
*        AT EOJ, MODULE ZEROS OUT PARM 1 OF THE PARM LIST TO
*        USER
*
*        MODULE APPEARS AS A DSECT IN - IERABM
*
*        MACROS USED BY THE MODULE -
*        SMPPI
*        PUT
*
*        ENTRY POINTS - ENTRY FROM MERGE NETWORK
*                       CALLING SEQUENCE -
*                           L    R11,PPIBLK+4
*                           B    0(,R11)     LAST RECORD
*                           B    4(,R11)     NORMAL
*
*                     - ENTRY FROM PUT
*                       CALLING SEQUENCE -
*                           BR   R14
*
*                     - ENTRY FROM IERRPG
*                       CALLING SEQUENCE -
*                           L    R11,PPIBLK+4
*                           B    0(,R11)     ZERO INPUT FILE
*
*                     - ENTRY FROM EXIT E35
*                       CALLING SEQUENCE
*                           RETURN   RC=(15)
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIBDSVA   PPIX35   PPICOUNT   PPIDEB
*        VARIOUS ADDRESSES AND COUNTERS
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPICOUNT   PPIDOOBA
*        UPDATE COUNTERS AND OUTPUT BUFFER ADDRESSES
*
*        EXTERNAL ROUTINES -
*        MOVE ROUTINE IN GENERATED CORE
*
*        EXTERNAL PARAMETERS - SEE REGISTERS
*
*        EXITS - NORMAL - EXIT TO DEBLOCK
*                         CALLING SEQUENCE -
*                             L    R11,PPIDEB+4
*                             B    4(,R11)
*
*                       - EXIT TO OS PUT LOCATE RTN
*                         CALLING SEQUENCE -
*                             L    R5,WDCB    DCB ADDR
*                             PUT  (R5)
*
*                       - EXIT TO IERRPG
*                         CALLING SEQUENCE -
*                             L    R11,PPIWRT+4
*                             BR   R11
*
*                       - EXIT TO EXIT E35
*                         CALLING SEQUENCE -
*                             L    R15,PPIX35+4
*                             BALR R14,R15
*
*        EXITS - ERROR - NONE
*
*        TABLES/WORK AREAS -
*        WMRGRCD  -> NEXT RECORD TO BE PUT (IN OUTPUT BUFFER)
*        WOPBUFAD -> LAST RECORD PUT (IN OUTPUT BUFFER)
*        WINTEGSW  - USER SEQUENCE SWITCH
*        WDCB     -> OUTPUT DCB
*        WINSRTSW  - USER INSERT SWITCH
*        WSYSEOF   - SYSTEM END OF FILE SWITCH
*        WUSREOF   - USER E35 END OF FILE SWITCH
*
*        NOTES -
*        THIS MODULE IS USED WITH ANY FIXED LENGTH SORT WITH E35
*        ACTIVE
*
IERRBM   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRBM SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRBMI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERRBMI  0101-20211-20211-1200-00130-00130-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERRBM SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERRBMI
*
         USING *,R11               MODULE BASE REG LOADED EXTERNALLY
         USING IERRCA,R13          PUT R13 IN USING TABLE WITH PPI ADDR
*
*        ENTER BRANCH TABLE FROM MERGE OR READ PRIME RTN
*
IERDB34  B     RBSETREG            +00 FROM MERGE, LAST RECORD, OR
*                                      FROM READ PRIME ZERO INPUT FILE
         LM    R6,R8,PPICOUNT      +04 RESTORE COUNTERS
RBSETPAR ST    R3,WMRGRCD          SET PARAMETER 1 OF 2 FOR CALL MACRO
*                                  ADDR OF NEXT RECORD FR MERGE TO PUT
*
*        CALL USER EXIT E35
*
RBUSREXT LA    R1,WMRGRCD          PARM LIST ADDR WILL BE OVERLAYED BY
*                                  B RBLOADRE ON USER EOF
         L     R15,PPIX35+4        IF ATTACHED, PPIX35 WILL HAVE ADDR
*                                  OF ATTACHED EXIT FROM PPI
         MVC   UEXIT,PPIUEXIT      SETUP PARAMETER LIST
         BASR  R14,R15             CALL USER EXIT E35
         MVC   PPIUEXIT,UEXIT      SAVE USER EXIT WORD FOR NEXT CALL
*
*        USER RETURNS TO MODULE VIA RETURN REG AND PROPER
*        DISPLACEMENTS
*
         B     *+4(15)         *
         B     RBALSHNO        |   +00 ALTER, LENGTHN, SHRTN, NOTHG RTN
         B     RBDELSUM        |   +04 DELETE SUMMARIZE RTN
         B     RBUSREOF        |   +08 USER END OF FILE ROUTINE
*                              |
*        INSERT A RECORD       |
*                              |
RBINSRT1 OI    WINSRTSW,X'01'  V   +12 TURN INSERT SWITCH ON
         LA    R8,1(,R8)           INCR INSERT COUNTER
         LA    R6,1(,R6)           INCR RECORD COUNTER BY ONE
RBOVLAY  B     RBLOADRE            BR TO LOAD ADDR OF RCD FOR MOVE RTN
*
*        ALTER, LENGTHEN, SHORTEN, DO NOTHING
*        TO THE INPUT RECORD FROM THE MERGE
*
RBALSHNO NOP   0
RBLOADRE LR    R4,R1               STORE ADDR OF RCD FROM THE MERGE IN
*                                  MOVE RTN REG THIS INSTR WILL BE
*                                  OVLAYD BY LR R4,R3 ON USER EOF
         L     R5,WDCB             R5 -> DCB
*
         PUT   (R5)                UPDATE ADDR IN OUTPUT AREA (R1)
*
         ST    R1,WOPBUFAD         SAVE ADDR OF RCD IN OUTPUT BFR TO
*                                  MOVE RCD (2 OF 2 PARM TO USER)
         LR    R5,R1               LOAD ADDR OF OUT AREA FOR MOVE RTN
         L     R15,PPIBDSVA+8      LOAD MOVE RTN BASE REG W/ADDR OF
*                                  MOVE RCD RTN
         BASR  R14,R15             CALL MOVE RTN MOVE RCD TO OUT AREA
         CLI   WINSRTSW,X'00'      INSERT SWITCH ON ?
         BZ    RBDOOBA             OFF, BRANCH TO STORE ADDR OF OUTPUT
*                                  RCD IN PPI
         NI    WINSRTSW,X'00'      TURN INSERT SWITCH OFF
         B     RBUSREXT            BRANCH TO USER EXIT
*
RBDOOBA  ST    R1,PPIDOOBA         ADDR OF RCD IN OUTPUT BUFFER
         LA    R6,1(,R6)           INCREMENT RECORD CTR
RBDEBLK  STM   R6,R8,PPICOUNT      SAVE COUNTERS
*
*        INTERFACE TO DEBLOCK MODULE
*        R3 HAS FILE NO OF WINNER IN 1ST BYTE
*
         L     R11,PPIDEB+4        LOAD DEBLOCK ADDR
         B     4(,R11)             BRANCH TO DEBLOCK MODULE
*
*        LAST RECORD AND ZERO INPUT FILE ROUTINE
*
RBSETREG LM    R6,R8,PPICOUNT      RESTORE COUNTERS
         SR    R3,R3               ZERO WINNER REG (PARM 1 TO USER)
         OI    WSYSEOF,X'01'       SET SYSTEM END OF FILE SWITCH
         CLI   WUSREOF,X'00'       USER END OF FILE SWITCH ON ?
         BNE   RBEOJ               ON, BRANCH TO END OF JOB MODULE
         B     RBSETPAR            OFF, BRANCH TO USER ROUTINE
*
*        USER END OF FILE ROUTINE
*
RBUSREOF OI    WUSREOF,X'01'       SET USER END OF FILE SWITCH
         MVC   RBUSREXT,RBOVLAY    OVERLAY USER EXIT(BYPASS EXIT E35)
         MVI   RBLOADRE+1,X'43'    OVERLAY INSTR(CHANGES R1 TO R3)
         CLI   WSYSEOF,X'00'       SYSTEM END OF FILE SWITCH ON ?
         BNE   RBEOJ               ON, BRANCH TO END OF JOB MODULE
         PPITEST  PPIATT           ATTACHED SORT ?
         BO    RBEOJ               YES, BRANCH TO EOJ
         B     RBLOADRE            BRANCH TO LOAD ADDR OF RECORD IN R3
*
*        LINKAGE TO END OF JOB MODULE
*
RBEOJ    STM   R6,R8,PPICOUNT      SAVE COUNTERS
         L     R11,PPIWRT+4        EOJ MODULE ADDR
         BR    R11                 EOJ EXIT TO MODULE NAMED IERRPG
*
*        DELETE OR SUMMARIZE A RECORD
*
RBDELSUM LA    R7,1(,R7)           INCR DELETE SUMMARIZE CTR BY ONE
         MVC   PPIDOOBA,WOPBUFAD   ADDR OF RCD IN OUTPUT BFR THE RCD
*                                    BEFORE THE DELETED OR SUMRZD RCD
         B     RBDEBLK             BRANCH TO DEBLOCK MODULE LINKAGE
*
*        CONSTANTS
*
KZERO    DC    F'0'                ZERO
KFOUR    DC    F'4'                FOUR
*
*        E35 PARAMETER LIST
*
WMRGRCD  DC    F'0'           *    PARM 1, -> NEXT RECORD TO BE PUT
WOPBUFAD DC    F'0'           |    PARM 2, -> LAST RECORD PUT OUTBUF
UEXIT    DC    F'0'           V    PARM 3 USER EXIT WORD
*
*        WORK AREAS AND FLAGS
*
WDCB     DC    F'0'                -> DCB FOR OUTPUT FILE
*                                  LOADED BY ASSGN RTN
WINSRTSW DC    X'00'               INSERT SWITCH
WSYSEOF  DC    X'00'               SYSTEM END OF FILE SWITCH
WUSREOF  DC    X'00'               USER END OF FILE SWITCH
*
./ ADD NAME=IERRBN   0101-20211-20211-1200-00079-00079-00000-RELEASE 00
RBN      TITLE 'IERRBN - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRBN
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 3 RUNNING MODULE - VARIABLE LENGTH RECORDS NO EXITS
*        THE FUNCTION OF THIS MODULE IS TO BLOCK VARIABLE LENGTH
*        RECORDS. THIS IS ACCOMPLISHED USING AN IN LINE MOVE
*        ROUTINE AND THE PUT MACRO IN THE LOCATE MODE. THE MOVE
*        ROUTINE MOVES THE WINNER RECORD FROM THE INPUT BUFFER TO
*        THE OUTPUT BUFFER
*
*        MODULES IN WHICH THIS MODULE APPEARS AS A DSECT -
*        IERABN
*
*        MACROS USED - SMPPI PUT
*
*        ENTRY POINTS - FROM MERGE - ENTRY FROM MERGE NTWRK
*                                      CALLING SEQUENCE -
*                                      L    R11,PPIBLK+4
*                                      B    0(R11)     LAST RECORD
*                                      B    4(R11)     NORMAL ENTRY
*
*                     - FROM PUT - ENTRY FROM PUT
*                                  CALLING SEQUENCE -
*                                  BR   R14
*
*        INPUT - PPI FIELDS REFERENCED - NONE
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPIDOOBA
*        PPICOUNT
*        ADDRESS OF WINNER IN OUTPUT BUFFER FOR MERGE SEQUENCE CHECK
*        RECORD COUNTER
*
*        EXTERNAL ROUTINES - NONE
*
*        EXTERNAL PARAMETERS - SEE REGISTERS
*
*        EXITS - NORMAL - TO DEBLOCK - EXIT TO DEBLOCK
*                                      CALLING SEQUENCE-
*                                      L    R11,PPIDEB+4
*                                      B    4(R11)
*
*                       - TO OPEN OUTPUT/EOJ - EXIT TO END OF JOB
*                                              L    R11,PPIWRT+4
*                                              BR    R11
*
*                       - TO SYSTEM PUT - EXIT TO PUT
*                                             PUT (R7)  R7 HAS DCB ADDR
*
*        EXITS ERROR - NONE
*
*        TABLE/WORK AREAS -
*        WDCB - ADDR OF OUTPUT DCB
*        WINRCDAD - ADDR OF WINNER RCD IN INPUT BUFFER
*
*        NOTES - THIS MODULE WILL EXECUTE FOR ANY VARIABLE
*        LENGTH SORT WITHOUT USER EXITS
*
IERRBN   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRBN SOURCE
*
*----------------------------------------------------------------------
*
         COPY IERRBNI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERRBNI  0101-20211-20211-1200-00087-00087-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERRBN SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERRBNI
*
         USING *,R11               MODULE BASE REG LOADED EXTERNALLY
*
         USING IERRCA,R13          ADDR OF PPI
*
         USING IHADCB,R1           DSECT FOR OUTPUT DCB
*
*        ENTRY TABLE
*
IERDB34  B     RBEOJ               FROM MERGE, LAST RECORD
*
*        NORMAL ENTRY FROM MERGE
*        R3 -> INPUT RECORD ADDR
*
         ST    R3,WINRCDAD         SAVE ADDR OF NEXT OUTPUT RECORD
         L     R1,WDCB             R7 -> DCB
         MVC   DCBLRECL,0(R3)      L'RECORD IN DCB FOR PUT MACRO
         LH    R8,DCBLRECL         SAVE L'RECORD FOR MOVE RTN
*
         PUT   (1)                 OUTPUT RECORD IN LOCATE MODE
*
         LA    R4,0(,R3)           R4 -> INPUT RECORD
         LR    R5,R1               R5 -> RECORD AREA IN OUTPUT BUFFER
         ST    R1,PPIDOOBA         ADDR OF RECORD IN OUTPUT BLK FOR
*                                  MERGE SEQUENCE CHECK
*        GENERALIZED MOVE RTN USED TO MOVE ANY SIZED DATA RECORD
*        FROM ONE DATA AREA TO ANOTHER
*        REGISTERS ON INPUT -
*        R4 -> DATA SOURCE
*        R5 -> DATA TARGET
*        R8 = L'DATA
*
*        IN ADDITION, THE ROUTINE USES REGISTERS R6 AND R7
*
*        THE ROUTINE DOES ALL INTERMEDIARY UPDATING OF
*        REGISTERS. UPON COMPLETION OF THE MOVE THE REGISTERS
*        CONTAIN-
*        R4 FROM ADDR UPDATED
*        R5 TO ADDR UPDATED
*        R8 REMAINING RECORD LENGTH SET TO ZERO
*
         LR    R6,R5               R6 -> DATA TARGET
         LR    R5,R8               R5 = L'DATA
         LR    R7,R8               R7 = L'DATA
         MVCL  R6,R4               MOVE DATA, NO PAD
         LR    R5,R6               R5 -> TARGET+1
         SR    R8,R8               R8 = REMAINING COUNT = 0
*
*        END OF GENERALIZED MOVE ROUTINE
*
         L     R6,PPICOUNT         LOAD RECORD COUNTER
         LA    R6,1(,R6)           INCR RECORD
         ST    R6,PPICOUNT         SAVE RECORD COUNTER
*
*        INTERFACE TO DEBLOCK MODULE
*        R3 HAS INPUT RECORD ADDR OF WINNER
*        FILE NO IN HI ORDER BYTE
*
         L     R11,PPIDEB+4        ADDR OF DEBLOCK MODULE
         B     4(,R11)             BRANCH TO DEBLOCK MODULE
*
*        LAST RECORD WAS PUT
*        INTERFACE TO END OF JOB MODULE
*
RBEOJ    L     R11,PPIWRT+4        ADDR OF END OF JOB MODULE
         BR    R11                 BRANCH TO END OF JOB MODULE
*
*        WORK AREAS USED BY THE MODULE
*
WDCB     DC    F'0'                -> DCB FOR OUTPUT FILE LOADED
*                                     BY IERABN
WINRCDAD DC    F'0'                -> NEXT OUTPUT RECORD
*
         PRINT NOGEN
*
         DCBD  DSORG=PS,DEVD=(DA,TA)
*
         PRINT GEN
*
./ ADD NAME=IERRBO   0101-20211-20211-1200-00147-00147-00000-RELEASE 00
RBO      TITLE 'IERRBO - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRBO
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 3 RUNNING MODULE - VARIABLE LENGTH RECORDS WITH E35
*        THE FUNCTION OF THIS MODULE IS TO BLOCK VARIABLE LENGTH
*        RECORDS. TO ACCOMPLISH THIS IT USES A MOVE ROUTINE WITH
*        THE PUT LOCATE MACRO. THE USER ROUTINE IS EXECUTED ONCE
*        FOR EVERY RECORD LEAVING THE MERGE. THE EXIT OCCURS
*        AFTER THE RECORD TO BE PUT LEAVES THE MERGE. THE USER
*        MAY THEN DO THE FOLLOWING -
*        1. INSERT A RECORD
*        2. DELETE OR SUMMARIZE A RECORD OR
*        3. DO NOTHING, ALTER, LENGTHEN, OR SHORTEN A RECORD
*        THE USER RETURNS TO THE APPROPRIATE ROUTINE IN THIS
*        MODULE. THE MODULE LINKS TO THE PROPER DEBLOCK OR EOJ
*        MODULE WHEN NEEDED
*
*        LINKAGE FROM MODULE TO USER IS VIA A CALL.
*        LINKAGE FROM USER TO MODULE IS VIA RETURN REGISTER PLUS
*        PROPER DISPLACEMENT DEPENDING ON WHAT ROUTINE THE USER
*        WISHES TO RETURN TO
*
*        TWO PARAMETERS ARE PASSED TO THE USER. THE ADDRESS OF
*        THE RECORD LEAVING THE MERGE, AND THE STARTING ADDRESS
*        OF THE AREA IN THE OUTPUT BUFFER INTO WHICH THE PREVIOUS
*        RECORD HAD BEEN PLACED
*
*        THE USER CAN PASS TWO PARAMETERS TO THE MODULE, THE
*        ADDRESS OF THE RECORD HE WISHES TO INSERT, DO NOTHING,
*        ALTER, LENGTHEN, SHORTEN IN R1, AND A 4 IF HE HAS
*        CHANGED THE INTEGRITY OF THE CONTROL FIELD OF THE RCD
*        COMING FROM THE MERGE OR A ZERO IF NOT CHANGED, IN THE
*        THIRD PARAMETER OF THE PARAMETER LIST
*
*        THE MODULE PASSES THESE PARAMETERS TO THE MERGE FOR
*        SEQUENCE CHECKING AGAINST THE NEXT RECORD THE MERGE
*        PASSES TO THE MODULE
*
*        AT EOJ, MODULE ZEROS OUT PARAM 1 OF THE PARAM LIST TO
*        USER
*
*        THE OPERATION OF THIS MODULE DOES NOT DEPEND UPON A
*        PARTICULAR REPRESENTATION OF THE EXTERNAL CHARACTER SET
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - IERABO
*
*        MACROS USED BY THE MODULE -
*        SMPPI
*        PUT
*
*        ENTRY POINTS - ENTRY FROM MERGE NETWORK
*                       CALLING SEQUENCE -
*                           L    R11,PPIBLK+4
*                           B    0(,R11)     LAST RECORD
*                           B    4(,R11)     NORMAL
*
*                     - ENTRY FROM PUT
*                       CALLING SEQUENCE -
*                           BR   R14
*
*                     - ENTRY FROM IERRPG
*                       CALLING SEQUENCE-
*                           L    R11,PPIBLK+4
*                           B    0(,R11)     ZERO INPUT FILE
*
*                       ENTRY FROM EXIT E35
*                       CALLING SEQUENCE -
*                       RETURN  RC=(15) R14 = RETURN REG
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPICOUNT   PPIX35   PPIDOOBA   PPIDEB
*        VARIOUS ADDRESSES AND COUNTERS
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPICOUNT   PPIDOOBA
*        UPDATE COUNTERS AND OUTPUT BUFFER ADDRESSES
*
*        EXTERNAL ROUTINES - NONE
*
*        EXTERNAL PARAMETERS - SEE REGISTERS
*
*        EXITS - NORMAL - EXIT TO DEBLOCK
*                         CALLING SEQUENCE -
*                             L    R11,PPIDEB+4
*                             B    4(,R11)
*
*                       - EXIT TO OS PUT LOCATE DATA MANAGEMENT
*                         CALLING SEQUENCE -
*                             L    R5,WDCB    DCB ADDR
*                             PUT  (R5)
*
*                       - EXIT TO IERRPG
*                         CALLING SEQUENCE -
*                             L    R11,PPIWRT+4
*                             BR   R11
*
*                       - EXIT TO EXIT E35
*                         CALLING SEQUENCE -
*                             L    R15,PPIX35+4
*                             BALR R14,R15
*
*        EXITS - ERROR NONE
*
*        TABLES/WORK AREAS -
*        WRCDLGTH - L'RECORD TO MOVE TO OUTPUT BUFFER
*        WMRGRCD  - ADDR OF WINNER RECORD IN INPUT BUFFER
*        WOPBUFAD - ADDR OF WINNER RECORD IN OUTPUT BUFFER
*        WINTEGSW - SEQUENCE CHECK SWITCH SET BY USER
*        WDCB     - OUTPUT DCB ADDR
*        WINSRTSW - INSERT SWITCH IS TURNED ON FOR INSERTING
*                   RECORDS
*        WSYSEOF  - SYSTEM END OF FILE SW TURNED ON WHEN INPUT
*                   EOF IS REACHED
*        WUSREOF  - USER END OF FILE SWITCH IS TURNED ON AFTER
*                   USER REACHES EOF
*
*        NOTES -
*        THIS MODULE WILL EXECUTE FOR ANY VARIABLE LENGTH SORT
*        WITH USER EXIT E35
*
IERRBO   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRBO SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRBOI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         PRINT NOGEN
*
         DCBD  DSORG=PS,DEVD=(DA,TA)
*
         PRINT GEN
*
         END
./ ADD NAME=IERRBOI  0101-20211-20211-1200-00161-00161-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERRBO SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERRBOI
*
         USING *,R11               MODULE BASE REG LOADED EXTERNALLY
         USING IERRCA,R13          PUT R13 IN USING TABLE WITH PPI ADDR
         USING IHADCB,R5
*
*        ENTER BRANCH TABLE FROM MERGE OR READ PRIME RTN
*
IERDB34  B     RBSETREG            +00 FROM MERGE, LAST RECORD, OR
*                                      FROM READ PRIME ZERO INPUT FILE
         LM    R6,R8,PPICOUNT      +04 RESTORE COUNTERS
RBSETPAR ST    R3,WMRGRCD              SET PARAMETER 1 OF 2 FOR CALL
*                                       ADDR NEXT RCD FR MERGE TO PUT
*
*        CALL USER EXIT E35
*
RBUSREXT LA    R1,WMRGRCD          PARAM LIST ADDR WILL BE OVLAYED BY
*                                  B RBLOADRE ON USER EOF
         L     R15,PPIX35+4        IF ATTACHED, PPIX35 WILL HAVE ADDR
*                                  OF ATTACHED EXIT FROM PPI
         MVC   UEXIT,PPIUEXIT      SETUP PARAMETER LIST
         BASR  R14,R15             CALL USER EXIT E35
         MVC   PPIUEXIT,UEXIT      SAVE USER EXIT WORK FOR NEXT CALL
*
*        USER RETURNS TO MODULE VIA RETURN REG AND PROPER
*        DISPLACEMENTS
*
         B     *+4(15)
         B     RBALSHNO            +00 ALTER, LENGTHN, SHRTN, NOTHG RTN
         B     RBDELSUM            +04 DELETE - SUMMARIZE RTN
         B     RBUSREOF            +08 USER END OF FILE ROUTINE
*
*        INSERT A RECORD
*
RBINSRT1 OI    WINSRTSW,X'01'      TURN INSERT SWITCH ON
         LA    R8,1(,R8)           INCR INSERT CTR
         LA    R6,1(,R6)           INCR RCD COUNTER
RBOVLAY  B     RBLOADRE            BR TO LOAD ADDR OF RCD FOR MOVE RTN
*
*        ALTER, LENGTHEN, SHORTEN, DO NOTHING TO
*        THE INPUT RECORD FROM THE MERGE
*
RBALSHNO NOP   0
RBLOADRE MVC   WRCDLGTH+2(2),0(R1)  MOVE RCD LENGTH TO A BOUNDARY. R1
*                                   WILL BE OVLAYD BY R3 ON USER EOF
RBOVLAY1 LR    R4,R1               STORE ADDR OF RCD FROM THE MERGE IN
*                                  MOVE RTN REG. THIS INSTR WILL BE
*                                  OVLAYD BY LR R4,R3 ON USER EOF
         L     R5,WDCB             R5 -> DCB
         MVC   DCBLRECL,WRCDLGTH+2  SET LRECL
*
         PUT   (R5)                UPDATE ADDR IN OUTPUT AREA (R1)
*
         ST    R1,WOPBUFAD         SAVE ADDR OF RCD IN OUTPUT BFR TO
*                                  MOVE RCD (2 OF 2 PARAM TO USER)
         LR    R5,R1               LOAD ADDR OF OUT AREA FOR MOVE RTN
         STM   R6,R8,PPICOUNT      SAVE COUNTERS
         L     R8,WRCDLGTH         LENGTH OF RCD FOR MOVE RTN
*
*        GENERALIZED MOVE RTN USED TO MOVE ANY SIZED DATA RECORD
*        FROM ONE DATA AREA TO ANOTHER
*        REGISTERS ON INPUT -
*        R4 -> DATA SOURCE
*        R5 -> DATA TARGET
*        R8 = L'DATA
*
*        IN ADDITION, THE ROUTINE USES REGISTERS R6 AND R7
*
*        THE ROUTINE DOES ALL INTERMEDIARY UPDATING OF
*        REGISTERS. UPON COMPLETION OF THE MOVE THE REGISTERS
*        CONTAIN-
*        R4 FROM ADDR UPDATED
*        R5 TO ADDR UPDATED
*        R8 REMAINING RECORD LENGTH SET TO ZERO
*
         LR    R6,R5               R6 -> DATA TARGET
         LR    R5,R8               R5 = L'DATA
         LR    R7,R8               R7 = L'DATA
         MVCL  R6,R4               MOVE DATA, NO PAD
         LR    R5,R6               R5 -> TARGET+1
         SR    R8,R8               R8 = REMAINING COUNT = 0
*
*        END OF GENERALIZED MOVE ROUTINE
*
         LM    R6,R8,PPICOUNT      RESTORE REGISTERS
         CLI   WINSRTSW,X'00'      INSERT SWITCH SET ?
         BZ    RBDOOBA             OFF, BRANCH TO STORE ADDR OF OUTPUT
*                                  RCD IN PPI
         NI    WINSRTSW,X'00'      TURN INSERT SWITCH OFF
         B     RBUSREXT            BRANCH TO USER EXIT
*
RBDOOBA  ST    R1,PPIDOOBA         ADDR OF RCD IN OUTPUT BUFFER
         LA    R6,1(,R6)           INCREMENT RECORD COUNTER
RBDEBLK  STM   R6,R8,PPICOUNT      SAVE COUNTERS
*
*        INTERFACE TO DEBLOCK MODULE
*        R3 HAS FILE NO OF WINNER IN 1ST BYTE
*
         L     R11,PPIDEB+4        DEBLOCK ADDR
         B     4(0,R11)            BRANCH TO DEBLOCK MODULE
*
*        LAST RECORD AND ZERO INPUT FILE ROUTINE
*
RBSETREG LM    R6,R8,PPICOUNT      RESTORE COUNTERS
         SR    R3,R3               ZERO WINNER REG (PARAM 1 TO USER)
         OI    WSYSEOF,X'01'       SET SYSTEM END OF FILE SWITCH
         CLI   WUSREOF,X'00'       USER END OF FILE SWITCH ON ?
         BNE   RBEOJ               ON, BRANCH TO END OF JOB MODULE
         B     RBSETPAR            OFF, BRANCH TO USER ROUTINE
*
*        USER END OF FILE ROUTINE
*
RBUSREOF OI    WUSREOF,X'01'       SET USER END OF FILE SWITCH
         MVC   RBUSREXT,RBOVLAY    OVERLAY USER EXIT(BYPASS EXIT E35)
         MVI   RBLOADRE+4,X'30'    OVERLAY INSTR (CHANGES R1 TO R3)
         MVI   RBOVLAY1+1,X'43'    OVERLAY INSTR (CHANGES R1 TO R3)
         CLI   WSYSEOF,X'00'       SYSTEM END OF FILE SWITCH ON ?
         BNE   RBEOJ               ON, BRANCH TO END OF JOB MODULE
         PPITEST  PPIATT           ATTACHED SORT ?
         BO    RBEOJ               YES, BR TO EOJ
         B     RBLOADRE            BRANCH TO LOAD ADDR OF RCD IN R3
*
*        LINKAGE TO END OF JOB MODULE
*
RBEOJ    L     R11,PPIWRT+4        END OF JOB ADDRESS
         BR    R11                 EOJ EXIT TO MODULE NAMED IERRPG
*
*        DELETE OR SUMMARIZE A RECORD
*
RBDELSUM LA    R7,1(,R7)           INCR DELETE SUMMARIZE CTR
         MVC   PPIDOOBA,WOPBUFAD   ADDR OF RCD IN OUTPUT BFR (THE RCD
*                                  BEFORE THE DELETED OR SUMRZD RCD)
         B     RBDEBLK             BRANCH TO DEBLOCK MODULE LINKAGE
*
*        CONSTANTS
*
KZERO    DC    F'0'                ZERO
KFOUR    DC    F'4'                FOUR
*
*        E35 EXIT PARAMETER LIST
*
WMRGRCD  DC    F'0'           *    PARM 1, -> NEXT RECORD TO BE PUT
WOPBUFAD DC    F'0'           |    PARM 2, -> LAST RECORD PUT (OUTBUF)
UEXIT    DC    F'0'           V    PARM 3, USER EXIT WORD
*
*        WORK AREAS
*
WRCDLGTH DC    F'0'                RECORD LENGTH
WDCB     DC    F'0'                -> DCB FOR OUTPUT FILE
*                                     SET BY IERABO
WINSRTSW DC    X'00'               INSERT SWITCH
WSYSEOF  DC    X'00'               SYSTEM END OF FILE SWITCH
WUSREOF  DC    X'00'               USER END OF FILE SWITCH
*
./ ADD NAME=IERRBP   0101-20211-20211-1200-00068-00068-00000-RELEASE 00
RBP      TITLE 'IERRBP - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRBP
*
*        MODULE FUNCTION/OPERATION -
*        THE MODULE HANDLES FIXED LENGTH RECORDS BY WAY OF THE
*        QSAM PUT MACRO. THERE ARE NO USER MODIFICATION EXITS. THE
*        PUT MACRO LOCATES WHERE THE RECORD IS TO BE MOVED IN AN
*        OUTPUT BUFFER. RECORD LENGTH IS GREATER THAN 256 BYTES,
*        SO THE MODULE LINKS TO THE MOVE LIST
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - IERABP
*
*        MACROS USED BY MODULE -
*        SMPPI
*        PUT
*
*        ENTRY POINTS - ENTRY FROM MERGE
*                       CALLING SEQUENCE -
*                           L     R11,PPIBLK+4
*                           B     4(,R11) NORMAL ENTRY
*
*                           L     R11,PPIBLK+4
*                           BR    R11     ENTRY ON LAST RCD
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPICOUNT   PPIBDSVA
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPICOUNT   PPIDOOBA
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL -
*        DEBLOCK ROUTINE
*        EOJ ROUTINE
*
*        EXITS - ERROR - N/A
*
*        TABLE/WORK AREAS -
*        WORK AREA AT KADCB -> OUTPUT DCB
*
*        NOTES -
*        THIS MODULE IS ONLY USED IF THE RECORD LENGTHS ARE
*        FIXED AND LONGER THAN 256 BYTES. E35 MUST NOT BE
*        ACTIVE
*
IERRBP   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRBP SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRBPI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERRBPI  0101-20211-20211-1200-00042-00042-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERRBP SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERRBPI
*
         USING *,R11
         USING IERRCA,R13
*
IERDB34  B     RBP010              +00 ENTRY POINT FROM MERGE
*                                      LAST RECORD
         LR    R4,R3               +04 NORMAL ENTRY POINT FROM MERGE
*                                      SAVES WINNER TEMPORARILY
         L     R5,KADCB            R5 -> DCB
*
         PUT   (R5)                REQUEST BUFFER ADDR
*
*        ON RETURN R1 -> AVAILABLE SPACE IN BUFFER AREA
*
         ST    R1,PPIDOOBA         PASS BUFFER AREA ADDR TO MERGE
         L     R6,PPICOUNT
         LA    R6,1(,R6)           INCREMENT RECORD COUNT
         ST    R6,PPICOUNT
         LR    R5,R1               R5 -> BUFFER AREA
         LR    R3,R4               RESTORE WINNER FOR DEBLOCK
         L     R15,PPIBDSVA+8      CALL MOVE LIST, MOVE RECORD FROM
         BASR  R14,R15             INPUT BUFFER TO OUTPUT BUFFER
         L     R11,PPIDEB+4        CALL DEBLOCK
         B     4(,R11)
*
*        LAST RECORD HAS BEEN BLOCKED
*
RBP010   L     R11,PPIWRT+4        LINK TO EOJ
         BR    R11
*
*        CONSTANTS
*
KADCB    DC    A(0)                ADDR OF OUTPUT DCB
*
./ ADD NAME=IERRBT   0101-20211-20211-1200-00095-00095-00000-RELEASE 00
RBT      TITLE 'IERRBT - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRBT
*
*        MODULE FUNCTION -
*        OSCL/CRCX SORT/MERGE PHASE BLOCK/DEBLOCK
*        THE MODULE HANDLES THE DEBLOCKING AND BLOCKING OF FIXED
*        LENGTH RECORDS. THE MODULE MAINTAINS THE BUFFER
*        SCHEMES. THE RECORD LENGTH IS LESS THAN OR EQUAL TO 256
*        BYTES SO THE MODULE CONTAINS AN INLINE MOVE INSTRUCTION
*        ON THE BLOCK SIDE OF THE MODULE TO MOVE THE RECORD TO
*        AN OUTPUT BUFFER. FLOW IN THE MODULE IS FROM MERGE TO
*        BLOCK SIDE TO DEBLOCK SIDE
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - IERABT
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM MERGE NETWORK EOS
*                       CALLING SEQUENCE -
*                           L   R11,PPIBLK2+4
*                           BR  R11
*
*                     - ENTRY FROM READ ROUTINE
*                       CALLING SEQUENCE -
*                           L   R11,PPIBLK2+4
*                           B   4(,R11)
*
*                     - ENTRY FROM WRITE ROUTINE
*                       CALLING SEQUENCE -
*                           L  R11,PPIBLK2+4
*                           B  8(,R11)
*
*                     - ENTRY FROM MERGE NETWORK - PRIMING
*                       CALLING SEQUENCE -
*                           L   R11,PPIBLK2+4
*                           B   12(,R11)
*
*                     - ENTRY FROM MERGE NETWORK - NORMAL
*                       CALLING SEQUENCE -
*                           L   R11,PPIBLK2+4
*                           B   16(,R11)
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIRCDL2   PPINETM
*        PPIUNTCT   PPIRD
*        PPISBLCT   PPIWRT
*        PPIBDSVA   PPIDEPHO
*        PPISRTBL
*        ADDR OF WINNER RECORD SITTING IN INPUT BUFFER
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        APPROPRIATE TAPE UNIT COUNTERS IN GENERATED CORE ARE
*        UPDATED BY ONE AND MINUS ONE
*        WINNER RECORD IS MOVED TO OUTPUT BUFFER
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL -
*        PPINETM - DSPL=8 - MERGE NETWORK - NORMAL
*        PPIREAD - DSPL=8 - READ - NORMAL
*        PPIWRT  - DSPL=8 - WRITE - NORMAL
*        PPIWRT  - DSPL=4 - WRITE - EOS
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS -
*        BUFFER ADDR TABLE
*        BLOCK COUNT TABLE
*
*        NOTES -
*        THIS MODULE IS USED TO MERGE FIXED LENGTH RECORDS LESS
*        THAN OR EQUAL TO 256 BYTES LONG
*
IERRBT   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRBT SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRBTI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERRBTI  0101-20211-20211-1200-00130-00130-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERRBT SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERRBTI
*
         USING *,R11
         USING IERRCA,R13
*
IERDB2   B     RBT2080             +00 EOS ENTRY
         B     RBT2040             +04 READ ENTRY
         B     RBT2060             +08 WRITE ENTRY
         B     *+4                 +12 PRIMING ENTRY (REQUIRES
*                                      NO ACTION IN THIS MODULE)
         B     RBBRANCH            +16
*
KBLKPTR  DC    F'0'                BLOCK POINTER
KIBLKPTR DC    F'0'                INITIAL BLOCK POINTER
*
*        NORMAL ENTRY FROM MERGE
*        R3 CONTAINS WINNER ADDR
*
RBBRANCH L     R4,KOBLKCNT         SET R4=OUTPUT BLOCK COUNT
*
*        BLOCK WINNER RECORD
*
         LTR   R4,R4               BLOCK COUNT = 0 ?
         BNP   RBT2050             YES, BRANCH, BLOCK IS FULL
RBT2010  BCTR  R4,0                NO, DECREMENT BLK CNT BY 1
         ST    R4,KOBLKCNT
         L     R2,KBLKPTR
RBT2020  SH    R2,PPIRCDL2         DECREMENT BLK PTR BY RCD LENGTH
         ST    R2,KBLKPTR
RBT2025  MVC   0(1,R2),0(R3)       MOVE WINNER RCD TO OUTPUT BUFFER
         SR    R6,R6
RBINCR   IC    R6,PPIDEPHO+3       INCREMENT FOR OUTPUT UNIT COUNT
         L     R7,PPIUNTCT         LOAD ADDR OF UNIT COUNTERS
         L     R8,0(R6,R7)         LOAD COUNT FOR THIS UNIT
         LA    R8,1(,R8)           INCREMENT IT BY ONE
         ST    R8,0(R6,R7)         RESTORE
*
*        DEBLOCK NEW RECORD FROM SAME FILE AS WINNER RCD
*
         LR    R2,R3               SAVE WINNER ADDR
         SRL   R3,24               ACCESS INCREMENT
         L     R7,PPIUNTCT         LOAD ADDR OF UNIT COUNTERS
         L     R5,0(R3,R7)         LOAD COUNT FOR THIS UNIT
         BCTR  R5,0                DECREMENT IT BY ONE
         ST    R5,0(R3,R7)         RESTORE
         L     R7,PPISBLCT         R7 -> BLOCK COUNT TABLE
         L     R8,0(R3,R7)         R8 = BLPCK COUNT FOR THIS BUFFER
         BCTR  R8,0                DECREMENT BLOCK COUNT
         LTR   R8,R8               THIS BLOCK COUNT = ZERO ?
         BNP   RBT2030             YES, BRANCH, BLOCK IS EMPTY
         ST    R8,0(R3,R7)         NO, STORE NEW BLOCK COUNT
         LR    R3,R2               INCREMENT WINNER BY RCD LENGTH TO
         AH    R3,PPIRCDL2         GET NEXT RECORD
         L     R11,PPINETM+4       EXIT TO MERGE
         B     8(,R11)
*
*        INPUT BUFFER IS EMPTY - CALL READ ROUTINE TO REFILL
*        BUFFER
*        R2 -> EMPTY BUFFER
*        R3  = INCREMENT
*
RBT2030  L     R7,PPIBDSVA         R7 -> BUFFER TABLE
         L     R2,0(R3,R7)         R2 -> EMPTY BUFFER
         L     R11,PPIRD+4         EXIT TO READ RTN
         B     8(,R11)
*
*        RETURN FROM READ ROUTINE
*        R1  = BLOCK COUNT
*        R2 -> BUFFER (FOR DEBLOCKING)
*        R3  = INCREMENT
*        R4 -> BUFFER (FOR READING)
*
RBT2040  L     R7,PPIBDSVA         R7 -> BUFFER TABLE
         ST    R4,0(R3,R7)         STORE BUFF ADDR IN TABLE
         L     R5,PPISBLCT         R5 -> BLOCK COUNT TABLE
         ST    R1,0(R3,R5)         STORE BLOCK COUNT IN BLK CNT TABLE
         SLL   R3,24               ADD INCR TO NEXT RECORD
         AR    R3,R2
         L     R11,PPINETM+4       EXIT TO MERGE
         B     8(,R11)
*
*        OUTPUT BUFFER IS FULL - CALL WRITE RTN TO EMPTY BUFFER
*        R1  = NO OF BYTES TO BE WRITTEN
*        R2 -> BUFFER TO BE WRITTEN
*
RBT2050  L     R1,KBUFSIZ          SET R1=NO BYTES IN BUFFER
RBT2053  L     R2,KBLKPTR          SET R2=BUFFER ADDR
         SH    R2,K4               ADJUST BY 4 FOR EOS INDICATION
         L     R11,PPIWRT+4        EXIT TO WRITE RTN
         B     8(,R11)
*
*        RETURN FROM WRITE ROUTINE
*        R2 -> EMPTY BUFFER
*
RBT2060  LH    R4,PPISRTBL         RESET OUTPUT BLK CNT TO SORT BLKNG
         ST    R2,KIBLKPTR         SAVE INITIAL PTR
         ST    R2,KBLKPTR          SET BLK PTR
         B     RBT2010
*
*        END OF SEQUENCE - WRITE THIS BUFFER
*        RESET POINTERS TO REUSE THIS BUFFER THE NEXT TIME
*        THROUGH
*
RBT2080  L     R1,KBUFSIZ
         L     R4,KOBLKCNT         CALCULATE NO OF BYTES TO BE
         MH    R4,PPIRCDL2         WRITTEN
         SR    R1,R4
         LH    R4,PPISRTBL         RESET OUTPUT BLOCKING TO SORT
         ST    R4,KOBLKCNT         BLOCKING
RBT2090  L     R2,KBLKPTR          SET R2 = BUFFER ADDR
         SH    R2,K4
         L     R5,KIBLKPTR
         ST    R5,KBLKPTR          SET BLK PTR
         LA    R4,4                SET INDICATION FOR NON - FINAL EOS
         L     R11,PPIWRT+4
         B     4(,R11)
*
*        CONSTANTS
*
KOBLKCNT DC    F'0'                OUTPUT BLOCK COUNT
KBUFSIZ  DC    F'0'                BUFFER SIZE WHEN FULL
K4       DC    H'4'                CONSTANT =4 FOR OSCL, =12 FOR 2314
*
./ ADD NAME=IERRBU   0101-20211-20211-1200-00092-00092-00000-RELEASE 00
RBU      TITLE 'IERRBU - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRBU
*
*        MODULE FUNCTION -
*        OSCL/CRCX SORT/MERGE PHASE BLOCK/DEBLOCK
*        THE MODULE HANDLES THE DEBLOCKING AND BLOCKING OF FIXED
*        LENGTH RECORDS. THE MODULE MAINTAINS THE BUFFER
*        SCHEMES. THE RECORD LENGTH IS GREATER THAN 256 BYTES, SO
*        THE MODULE BLOCK SIDE LINKS TO THE MULTIPLE MOVE LIST.
*        THE LIST MOVES THE RECORD TO AN OUTPUT BUFFER AND
*        RETURNS TO THE MODULE. FLOW IN THE MODULE IS FROM MERGE
*        TO BLOCK SIDE TO DEBLOCK SIDE
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - IERABU
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM MERGE NETWORK - EOS
*                       CALLING SEQUENCE -
*                           L   R11,PPIBLK2+4
*                           BR  R11
*
*                     - ENTRY FROM READ ROUTINE
*                       CALLING SEQUENCE -
*                           L   R11,PPIBLK2+4
*                           B   4(,R11)
*
*                     - ENTRY FROM WRITE ROUTINE
*                       CALLING SEQUENCE -
*                           L   R11,PPIBLK2+4
*                           B   8(,R11)
*
*                     - ENTRY FROM MERGE NETWORK - PRIMING
*                       CALLING SEQUENCE -
*                           L   R11,PPIBLK2+4
*                           B   12(,R11)
*
*                     - ENTRY FROM MERGE NETWORK - NORMAL
*                       CALLING SEQUENCE-
*                           L   R11,PPIBLK2+4
*                           B   16(,R11)
*
*        INPUT - PPI FIELDS REFERENCED - PPIRCDL2 PPIBDSVA
*        PPIUNTCT   PPISBLCT
*        PPISRTBL   PPIDEPHO
*        ADDR OF WINNER RECORD SITTING IN INPUT BUFFER
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        APPROPRIATE TAPE UNIT COUNTERS IN GENERATED CORE ARE
*        UPDATED BY ONE AND MINUS ONE
*        WINNER RECORD IS MOVED TO OUTPUT BUFFER
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL -
*        PPINETM - DSPL=8 - MERGE NETWORK - NORMAL
*        PPIREAD - DSPL=8 - READ - NORMAL
*        PPIWRT  - DSPL=8 - WRITE - NORMAL
*        PPIWRT  - DSPL=4 - WRITE - EOS
*
*        EXITS ERROR - N/A
*
*        TABLES/WORK AREAS -
*        BUFFER ADDR TABLE
*        BLOCK COUNT TABLE
*
*        NOTES -
*        THIS MODULE IS USED TO MERGE FIXED LENGTH RECORDS
*        GREATER THAN 256 BYTES LONG
*
IERRBU   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRBU SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRBUI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERRBUI  0101-20211-20211-1200-00137-00137-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERRBU SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERRBUI
*
         USING *,R11
         USING IERRCA,R13
*
IERDB2   B     RBU2080          *  +00 EOS ENTRY
         B     RBU2040          |  +04 READ ENTRY
         B     RBU2060          |  +08 WRITE ENTRY
         B     *+4              |  +12 PRIMING ENTRY (REQUIRES NO
*                               |      ACTION IN THIS MODULE)
         B     RBUNORM          |  +16 ENTRY FROM MERGE - NORMAL ENTRY
*                               |
KBLKPTR  DC    F'0'             |  +20 BLOCK POINTER SET BY PPIWRT
KIBLKPTR DC    F'0'             V  +24 INITIAL BLOCK PTR SET BY PPIWRT
*
*        NORMAL ENTRY FROM MERGE
*
RBUNORM  ICM   R4,B'1111',KOBLKCNT  R4 = OUTPUT BLOCK COUNT
*                                  BLOCK COUNT = ZERO ?
         BNP   RBU2050             YES, BRANCH, BLOCK IS FULL
RBU2010  BCTR  R4,0                NO, DECREMENT BLOCK COUNT BY 1
         ST    R4,KOBLKCNT
         L     R2,KBLKPTR
*
*        INSTRUCTIONS BELOW OVERLAYED BY ASSIGNMENT MODULE IERABU
*
RBU2020  SH    R2,PPIRCDL2     *   DECREMENT BLK PTR BY RECORD LENGTH
         ST    R2,KBLKPTR      |
         LR    R4,R3           |   R4 -> RECORD
         LR    R5,R2           |   R5 -> LOCATION IN BUFFER
         L     R15,PPIBDSVA+8  |   CALL MOVE RTN TO MOVE WINNER
         BASR  R14,R15         V   TO OUTPUT BUFFER
         SR    R6,R6
RBINCR   IC    R6,PPIDEPHO+3       INCREMENT FOR OUTPUT UNIT COUNT
         L     R7,PPIUNTCT         LOAD ADDR OF UNIT COUNTERS
         L     R8,0(R6,R7)         LOAD COUNT FOR THIS UNIT
         LA    R8,1(,R8)           INCREMENT IT BY ONE
         ST    R8,0(R6,R7)         RESTORE
*
*        DEBLOCK NEW RECORD FROM SAME FILE AS WINNER RECORD
*
         LR    R2,R3               SAVE WINNER ADDR
         SRL   R3,24               ACCESS INCREMENT
         L     R7,PPIUNTCT         LOAD ADDR OF UNIT COUNTERS
         L     R5,0(R3,R7)         LOAD COUNT FOR THIS UNIT
         BCTR  R5,0                DECREMENT IT BY ONE
         ST    R5,0(R3,R7)         RESTORE
         L     R7,PPISBLCT         R7 -> BLOCK COUNT TABLE
         L     R8,0(R3,R7)         R8 -> BLK CNT FOR THIS BUFFER
         BCTR  R8,0                DECREMENT BLK CNT BY 1
         LTR   R8,R8               THIS BLK CNT = ZERO ?
         BNP   RBU2030             YES, BRANCH, BLK IS EMPTY
         ST    R8,0(R3,R7)         NO, STORE NEW BLK CNT
         LR    R3,R2               INCREMENT WINNER BY RECORD LENGTH
         AH    R3,PPIRCDL2         TO GET NEXT RECORD
         L     R11,PPINETM+4       EXIT TO MERGE
         B     8(,R11)
*
*        INPUT BUFFER IS EMPTY - CALL READ ROUTINE TO REFILL
*        BUFFER
*        R2 -> EMPTY BUFFER
*        R3  = INCREMENT M
*
RBU2030  L     R7,PPIBDSVA         R7 -> BUFFER TABLE
         L     R2,0(R3,R7)         R2 -> EMPTY BUFFER (PREVIOUS READ)
         L     R11,PPIRD+4         EXIT TO READ RTN
         B     8(,R11)
*
*        RETURN FROM READ ROUTINE -
*        R1  = BLOCK COUNT
*        R2 -> BUFFER (FOR DEBLOCKING)
*        R3  = M INCREMENT
*        R4 -> BUFFER (FOR READING)
*
RBU2040  L     R7,PPIBDSVA         R7 -> BUFFER TABLE
         ST    R4,0(R3,R7)         STORE BUFFER ADDR IN TABLE
         L     R5,PPISBLCT         R5 -> START OF BLOCK COUNTERS
         ST    R1,0(R3,R5)         STORE BLOCK COUNT IN BLK CNT TABLE
         SLL   R3,24               ADD INCR TO NEXT RECORD
         AR    R3,R2
         L     R11,PPINETM+4       EXIT TO MERGE
         B     8(,R11)
*
*        OUTPUT BUFFER IS FULL - CALL WRITE RTN TO EMPTY BUFFER
*        R1  = NO OF BYTES TO BE WRITTEN
*        R2 -> BUFFER TO BE WRITTEN
*
RBU2050  L     R1,KBUFSIZ          SET R1 = NO BYTES IN BUFFER
RBU2053  L     R2,KBLKPTR          SET R2 = BUFFER ADDR
         SH    R2,K4               ADJUST BY 4 FOR EOS INDICATION
         L     R11,PPIWRT+4        EXIT TO WRITE
         B     8(,R11)
*
*        RETURN FROM WRITE ROUTINE
*        R2 -> EMPTY BUFFER
*
RBU2060  LH    R4,PPISRTBL         RESET OUTPUT BLOCK COUNT TO
*                                  SORT RECORDS PER BLOCK
         ST    R2,KIBLKPTR         SAVE INITIAL POINTER
         ST    R2,KBLKPTR          SET BLK PTR
         B     RBU2010
*
*        END OF SEQUENCE - WRITE THIS BUFFER
*        RESET POINTERS TO REUSE THIS BUFFER THE NEXT TIME
*        THROUGH
*
RBU2080  L     R1,KBUFSIZ
         L     R4,KOBLKCNT         CALCULATE NO OF BYTES TO BE
         MH    R4,PPIRCDL2         WRITTEN
         SR    R1,R4
*
*        R1 = BUFFER SIZE WHEN FULL -
*        (REMAINING BLOCK COUNT * RCD LENGTH)
*
         LH    R4,PPISRTBL         RESET OUTPUT BLOCKING TO SORT
         ST    R4,KOBLKCNT         BLOCKING
RBU2090  L     R2,KBLKPTR          SET R2 = BUFFER ADDR
         SH    R2,K4               DECR BY 4 FOR EOS INDICATION
         L     R5,KIBLKPTR
         ST    R5,KBLKPTR          SET BLK PTR
         LA    R4,4                SET INDICATION FOR NON FINAL EOS
         L     R11,PPIWRT+4        EXIT TO WRITE ON EOS
         B     4(,R11)
*
*        CONSTANTS
*
KOBLKCNT DC    F'0'                OUTPUT BLOCK COUNT
KBUFSIZ  DC    F'0'                BUFFER SIZE WHEN FULL
K4       DC    H'4'                CONSTANT =4 FOR OSCL, =12 FOR CRCX
*
./ ADD NAME=IERRBV   0101-20211-20211-1200-00106-00106-00000-RELEASE 00
RBV      TITLE 'IERRBV - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRBV
*
*        MODULE FUNCTION -
*        OSCL/CRCX SORT/MERGE BLOCK/DEBLOCK W/O EXITS
*        HANDLE THE DEBLOCKING AND BLOCKING OF VARIABLE LENGTH RECORDS
*        THE BUFFERS ARE FILLED BY THE READ MODULE AND EMPTIED BY
*        THE WRITE MODULE. THIS MODULE MOVES THE VARIABLE LENGTH
*        RECORD FROM THE INPUT BLOCK DIRECTLY TO THE OUTPUT BLOCK
*
*        THE MERGE NETWORK INITIALLY PASSES A WINNER TO THE
*        BLOCK SIDE OF THIS MODULE. BLOCK SEES IF IT CAN FIT IN
*        THE OUTPUT BLOCK AND IF IT CAN'T, WRITES THE BLOCK THEN
*        MOVES THE RECORD. IT THEN BRANCHES TO THE DEBLOCK SIDE.
*        DEBLOCK DEBLOCKS ANOTHER RECORD FROM THE SAME FILE AS
*        THE WINNER, TESTING FIRST IF THAT BLOCK IS EMPTY. IF IT
*        IS, DEBLOCK READS ANOTHER BLOCK FROM THE SAME FILE.
*        DEBLOCK THEN PASSES THE ADDRESS OF THE NEW RECORD TO THE
*        MERGE NETWORK. THE NETWORK FINDS ANOTHER WINNER AND THE
*        PROCESS IS REPEATED
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - IERABV
*
*        MACROS USED BY THE MODULE - SMPPI
*
*        ENTRY POINTS - ENTRY FROM MERGE NETWORK
*                       CALLING SEQUENCE -
*                           L    R11,PPIBLK2+4
*                           B    0(,R11)     NORMAL EDS
*                           B    16(,R11)    NORMAL
*
*                     - ENTRY FROM READ
*                       CALLING SEQUENCE -
*                           L    R11,PPIBLK2+4
*                           B    4(,R11)
*
*                     - ENTRY FROM WRITE
*                       CALLING SEQUENCE -
*                           L    R11,PPIBLK2+4
*                           B    8(,R11)
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIBDSVA   PPILAB07   PPISBLCT   PPIDEPHO
*        PPIUNTCT
*        VARIOUS ADDRESSES
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        APPROPRIATE TAPE UNIT COUNTERS IN GENERATED CORE ARE
*        UPDATED
*        UPDATE COUNTERS
*
*        EXTERNAL ROUTINES - NONE
*
*        EXTERNAL PARAMETERS - SEE REGISTERS
*
*        EXITS - NORMAL - EXIT TO READ
*                         CALLING SEQUENCE -
*                             L    R11,PPIRD+4
*                             B    8(,R11)
*
*                       - EXIT TO NETWORK
*                         CALLING SEQUENCE -
*                             L    R11,PPINETM+4
*                             B    8(,R11)
*
*                       - EXIT TO WRITE
*                         CALLING SEQUENCE-
*                             L    R11,PPIWRT+4
*                             B    4(,R11)     EOS
*                             B    8(,R11)     NORMAL
*
*        EXITS - ERROR - NONE
*
*        TABLES/WORK AREAS -
*        WBLKCCNT - OUTPUT BUFFER CHARACTER COUNTER
*        WRCDLGTH - L'WINNER RECORD
*        WINNER   - ADDR OF THE WINNER RECORD IN THE INPUT BLOCK
*        WLSTPTR  - ADDR OF A FREE AREA IN OUTPUT BUFFER TO MOVE
*                   THE WINNER
*        WLSTPTRD - PTR TO STARTG+8 (DISK) OR ENDING+1 (TAPE) ADDR
*                   OF OUTPUT BUFFER
*
*        NOTES -
*        THIS MODULE IS USED TO MERGE VARIABLE LENGTH RECORDS
*        WITHOUT USER EXITS
*
IERRBV   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRBV SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRBVI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERRBVI  0101-20211-20211-1200-00187-00187-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERRBV SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERRBVI
*
         USING *,R11               MODULE BASE REG LOADED EXTERNALLY
         USING IERRCA,R13          ADDR OF PPI LOADED EXTERNALLY
*
*        ENTRY TABLE
*
IERDB2   B     RBEOS               +00 FROM MERGE ON NORMAL EOS
         B     RBRDRTRN            +04 FROM READ MODULE
         B     RBWRT               +08 FROM WRITE MODULE
         NOP   RBSAVE              +12 PRIMING ENTRY
*                                      ONLY FOR USER MODS MOD
         B     RBBRANCH            +16
*
WLSTPTR  DC    F'0'                INITIALLY LOADED BY AP TO OUTPUT
*                                  BLOCK ENDING ADDR + 1
WLSTPTRD DC    F'0'                OUTPUT BLOCK ENDING ADDR + 1
*
*        NORMAL MERGE ENTRY - INCR BLOCK CHAR COUNTER
*        CHECK IF RECORD WILL FIT IN OUTPUT BLOCK. IF NOT, WRITE
*        THE BLOCK BEFORE MOVING THE RECORD
*
RBBRANCH L     R6,WBLKCCNT         OUTPUT BLOCK CHAR CTR INITIALLY
*                                  PRESET TO 8 BY AP
         MVC   WRCDLGTH+2(2),0(R3)  MOVE RCD LENGTH TO PROPER BOUNDARY
         A     R6,WRCDLGTH         ADD RCD LENGTH TO OUTPUT BLOCK CHAR
*                                  CTR
         CH    R6,PPILAB07+2       > ROUNDED OUTPUT BLOCKING ?
         BH    RBWRTBLK            YES, BRANCH TO WRITE THE BLOCK FIRST
RBSAVE   ST    R6,WBLKCCNT         SAVE UPDATED BLOCK CHAR CTR
         ST    R3,WINNER           SAVE ADDR OF RCD IN INPUT BLOCK
         L     R5,WLSTPTR          ADDR IN OUTPUT BLOCK TO MOVE RCD
RBSUBRLT S     R5,WRCDLGTH         DECR ADDR BY RCD LGTH FOR TAPE SORT
*                                  RCDS FILL OUTPUT BLOCK STARTG FROM
*                                  HI CORE TO LOW
         SR    R6,R6
RBINCR   IC    R6,PPIDEPHO+3       INCREMENT FOR OUTPUT UNIT COUNT
         L     R7,PPIUNTCT         LOAD ADDR OF UNIT COUNTERS
         L     R8,0(R6,R7)         LOAD COUNT FOR THIS UNIT
         LA    R8,1(,R8)           INCREMENT
         ST    R8,0(R6,R7)         RESTORE
         LR    R4,R3               ADDR OF RCD IN INPUT AREA FOR MOVE
         L     R8,WRCDLGTH         LENGTH OF RCD FOR MOVE RTN
*
*        GENERALIZED MOVE RTN USED TO MOVE ANY SIZED DATA RCD
*        FROM ONE DATA AREA TO ANOTHER.
*        REGISTERS ON INPUT -
*        R4 -> DATA SOURCE
*        R5 -> DATA TARGET
*        R8 = L'DATA
*
*        IN ADDITION, THE ROUTINE USES REGISTERS R6 AND R7
*
*        THE ROUTINE DOES ALL INTERMEDIARY UPDATING OF
*        REGISTERS. UPON COMPLETION OF THE MOVE THE REGISTERS
*        CONTAIN-
*        R4 FROM ADDR UPDATED
*        R5 TO ADDR UPDATED
*        R8 REMAINING RCD LENGTH SET TO ZERO
*
         LR    R6,R5               R6 -> DATA TARGET
         LR    R5,R8               R5 = L'DATA
         LR    R7,R8               R7 = L'DATA
         MVCL  R6,R4               MOVE DATA, NO PAD
         LR    R5,R6               R5 -> TARGET+1
         SR    R8,R8               R8 = REMAINING COUNT = 0
*
*        END OF GENERALIZED MOVE ROUTINE
*
RBSUBRLD S     R5,WRCDLGTH         DECR ADDRESS BY RECORD LENGTH
         ST    R5,WLSTPTR          SAVE UPDATED OUTPUT BLOCK RCD PTR
         B     RBDEBLCK            BR TO DEBLOCK ANOTHER RCD
*
*        WRITE A BLOCK. THIS RCD CAN'T FIT INTO THIS BLOCK
*
RBWRTBLK S     R6,WRCDLGTH         SUBTR LENGTH OF RCD THAT CAN'T FIT
*                                  FROM OUTPUT BLOCK CHAR COUNT
RBLSTPTR L     R2,WLSTPTR          LOAD OUTPUT BLOCK RECORD POINTER
         S     R2,KEIGHT           EQUALS ADDR OF OUTPUT BLK TO WRITE
         ST    R6,WBLKCCNT         STORE BLK CHAR CTR IN 1ST 2 BYTES
         MVC   0(2,R2),WBLKCCNT+2
         LR    R1,R6               ALSO IN R1 FOR WRITE MODULE PARAM
*
*        INTERFACE TO WRITE MODULE
*
         L     R11,PPIWRT+4        ADDR OF WRITE MODULE
         B     8(,R11)             BRANCH TO WRITE MODULE
*
*        WRITE MODULE REENTERS VIA BRANCH TABLE
*        R2 FOR TAPE, HAS AN OUTPUT BLOCK ENDING ADDR+1
*
RBWRT    ST    R2,WLSTPTRD         SAVE AS CURRENT OUTPUT BLK POINTER
         ST    R2,WLSTPTR          STORE AS OUTPUT BLK WORK POINTER
         L     R6,KEIGHT           REINITIALIZE BCC TO 8 OR 16
         A     R6,WRCDLGTH         ADD LENGTH OF RCD TO BE MOVED TO
*                                  OUTPUT BLOCK
         B     RBSAVE              BRANCH TO MOVE RCD TO OUTPUT BLOCK
*
*        FROM MERGE NORMAL EOS
*        PREVIOUS RCD WAS EOS RCD AND IS IN OUTPUT BLK NO NEW
*        RECORDS PASSED TO BLOCK RTN AT THIS TIME
*
RBEOS    L     R4,WLSTPTR
         MVC   WLSTPTR,WLSTPTRD    RESET OUTPUT BLOCK POINTER
         S     R4,KEIGHT           DECR OUTPUT BLK PTR BY 8 TO INSERT
*                                    BLOCK CHAR CNT IN 1ST 2 BYTES
         MVC   0(2,R4),WBLKCCNT+2  STORE BLK CHAR CNT IN OUTPUT BLK
         L     R1,WBLKCCNT         LOAD BLOCK CHAR CNT FOR WRITE MOD
         MVC   WBLKCCNT,KEIGHT     REINITIALIZE BLOCK CHAR CTR TO 8
         LR    R2,R4               LOAD OUTPUT BLOCK PTR FOR WRITE
         LA    R4,4                SET INDICATION FOR NON FINAL EOS
*
*        INTERFACE TO WRITE MODULE FOR NORMAL EOS
*
         L     R11,PPIWRT+4        ADDR OF WRITE MODULE
         B     4(,R11)             BRANCH TO WRITE MODULE
*
*        DEBLOCK SIDE OF PROGRAM
*
RBDEBLCK SRL   R3,24               SHIFT TO GET AT INCR OF WINNER RCD
         L     R7,PPIUNTCT         LOAD ADDR OF UNIT COUNTERS
         L     R5,0(R3,R7)         LOAD COUNT FOR THIS UNIT
         BCTR  R5,0                DECREMENT BY ONE
         ST    R5,0(R3,R7)         STORE
         L     R6,PPISBLCT         LOAD ADDR OF INPT BLK CHAR CNT TABLE
         L     R7,0(R3,R6)         LOAD BLK CHAR CNT OF WINNER'S BLOCK
         S     R7,WRCDLGTH         SUBTRACT RCD LENGTH OF WINNER
*                                  BLOCK CHAR CNT = ZERO ?
         BZ    RBREAD              YES, BRANCH TO READ ANOTHER BLK INTO
*                                  INPUT BLK JUST VACATED
         ST    R7,0(R3,R6)         NO,STORE UPDATED BLOCK CHAR CNT
         L     R3,WINNER           RESTORE WINNER
         A     R3,WRCDLGTH         ADDR OF NEXT RCD FROM WINNER FILE
*
*        INTERFACE TO MERGE NETWORK
*
RBMERGE  L     R11,PPINETM+4       ADDR OF MERGE MODULE
         B     8(,R11)             BRANCH TO MERGE MODULE
*
*        FILL EMPTY INPUT BLOCK OF WINNER
*        R3 HAS INCR IN LOW ORDER BYTE
*
RBREAD   L     R6,PPIBDSVA         ADDR OF INPUT BLK ADDR TABLE
         L     R2,0(R3,R6)         ADDR OF THE WINNER'S INPUT BLOCK
*
*        INTERFACE TO READ MODULE
*
         L     R11,PPIRD+4         ADDR OF READ MODULE
         B     8(R11)              BRANCH TO READ MODULE
*
*        READ MODULE RETURNS VIA THIS MODULE BRANCH TABLE
*        THE REGS CONTAIN THE FOLLOWING
*        R1 -  BLOCK CNT
*        R2 -> FIRST RECORD IN INPUT BLOCK
*        R3 -  INCREMENT
*        R4 -  ENDING ADDR OF BLOCK
*
RBRDRTRN L     R6,PPISBLCT         LOAD ADDR OF BLOCK CNT TABLE
         S     R1,KFOUR            EQUALS TOTAL BYTES (OF RCDS)IN BLOCK
         ST    R1,0(R3,R6)         STORE NEW BLOCK CHAR CNT IN TABLE
         L     R6,PPIBDSVA         ADDR OF TABLE OF INPUT BLK STRTG
*                                  ADDRS
         ST    R4,0(R3,R6)         STORE IN INDEXED POSITION IN TABLE
         SLL   R3,24               POSITION INCR IN HI BYTE
         AR    R3,R2               INSERT STRTG ADDR OF 1ST RCD OF BLK
         B     RBMERGE             BRANCH TO MERGE
*
*        CONSTANTS
*
KZERO    DC    F'0'                ZERO
KFOUR    DC    F'4'                FOUR
KEIGHT   DC    F'8'                CONSTANT =8 FOR OSCL, 16 FOR CRCX
*
*        WORK AREAS
*
WBLKCCNT DC    F'0'                OUTPUT BLOCK CHAR CTR INITIALLY
*                                  PRESET TO 8 BY AP
WRCDLGTH DC    F'0'                LENGTH OF INPUT RECORD TO BE BLOCKED
WINNER   DC    F'0'                ADDR OF WINNER RCD IN INPUT BLOCK
*
./ ADD NAME=IERRBW   0101-20211-20211-1200-00096-00096-00000-RELEASE 00
RBW      TITLE 'IERRBW - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRBW
*
*        MODULE FUNCTION -
*        OSCL/CRCX SORT/MERGE PHASE BLOCK/DEBLOCK
*        MODULE HANDLES DEBLOCKING AND BLOCKING OF FIXED LENGTH
*        RECORDS. THE MODULE MAINTAINS THE BUFFER SCHEMES. THE
*        MODULE IS USED WHENEVER USER EXIT E25 IS ACTIVATED. THE
*        MODULE BLOCK SIDE LINKS TO THE MULTIPLE MOVE LIST TO
*        MOVE RECORDS TO THE OUTPUT BUFFER. FLOW IN THE MODULE IS
*        FROM THE MERGE TO BLOCK SIDE TO DEBLOCK SIDE
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - IERABW
*
*        MACROS USED BY MODULE - SMPPI
*
*        ENTRY POINTS - ENTRY FROM NETWORK
*                       CALLING SEQUENCE -
*                           L     R11,PPIBLK2+4
*                           B     16(,R11)   NORMAL ENTRY
*
*                           L     R11,PPIBLK2+4
*                           B     12(,R11)   PRIMING ENTRY
*
*                           L     R11,PPIBLK2+4
*                           BR    R11       EOS ENTRY
*
*                     - ENTRY FROM READ
*                       CALLING SEQUENCE -
*                           L     R11,PPIBLK2+4
*                           B     4(,R11)
*
*                     - ENTRY FROM WRITE
*                       CALLING SEQUENCE -
*                           L     R11,PPIBLK2+4
*                           B     8(,R11)
*
*                     - ENTRY FROM E25
*                       CALLING SEQUENCE -
*                           BR    R14
*
*                     - ENTRY FROM MOVE LIST
*                       CALLING SEQUENCE -
*                           BR    R14
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIRCDL2   PPIBDSVA   PPIUNTCT   PPIDEPHO
*        PPISBLCT   PPISRTBL   PPIDELCT
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPIDELCT
*        APPROPRIATE TAPE UNIT COUNTERS IN GENERATED STORAGE ARE
*        UPDATED BY ONE AND MINUS ONE
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL -
*        E25      - PHASE 2 RECORD MODIFICATION EXIT
*        MOVE LIST- MOVE RECORD FROM INPUT BUFFER TO OUTPUT BUFFER
*        NETWORK  - PASS ADDR OF NEXT RECORD
*        READ     - FILL A BUFFER
*        WRITE    - EMPTY A BUFFER - NORMAL
*        WRITE    - EMPTY A BUFFER - AT EOS
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS -
*        WORK AREA AT ADDR KPARLST CONTAINS ADDR OF WINNER
*        RECORD AND LAST RECORD BLOCKED
*
*        NOTES -
*        THIS MODULE IS USED TO MERGE FIXED LENGTH RECORDS WHEN
*        USER MODIFICATION EXIT E25 IS ACTIVE
*
IERRBW   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRBW SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRBWI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERRBWI  0101-20211-20211-1200-00163-00163-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERRBW SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERRBWI
*
         USING *,R11
         USING IERRCA,R13
*
IERDB2   B     RBW2080             +00 EOS ENTRY
         B     RBW2040             +04 READ ENTRY
         B     RBW2060             +08 WRITE ENTRY
         B     RBW2006             +12 PRIME ENTRY TO BYPASS E25
         B     RBBRANCH            +16 NORMAL ENTRY FROM MERGE
*
KBLKPTR  DC    F'0'                BLOCK POINTER
KIBLKPTR DC    F'0'                INITIAL BLOCK POINTER
*
*        NORMAL ENTRY FROM MERGE
*        R3 -> WINNER RECORD
*        SET UP LINK TO USER EXIT
*
RBBRANCH ST    R3,KPARLST          PUT WINNER ADDR IN PARAMETER LIST
         LA    R1,KPARLST          R1 -> PARAMETER LIST
         L     R15,PPIX25+4
         BASR  R14,R15             CALL USER EXIT E25
         B     *+4(R15)            RETURN FROM USER - R15 INDICATES
*                                  PROPER BRANCH TABLE ENTRY
         B     RBW2005             +00 DO NOTHING ENTRY - PROCEED TO
*                                      BLOCK RECORD
         B     RBW2100             +08 DELETE ENTRY
*
*        BLOCK WINNER RECORD
*
RBW2006  LR    R1,R3               LOAD ADDR OF RECORD
RBW2005  ICM   R4,B'1111',KOBLKCNT  SET R4 = OUTPUT BLOCK COUNT
*                                  BLOCK COUNT = 0 ?
         BNP   RBW2050             YES, BRANCH, BLOCK IS FULL
RBW2010  BCTR  R4,0                NO, DECREMENT BLOCK COUNT BY 1
         ST    R4,KOBLKCNT
         L     R2,KBLKPTR
RBW2020  SH    R2,PPIRCDL2         DECREMENT BLK PTR BY RECORD LENGTH
         ST    R2,KBLKPTR
         LR    R4,R1               SET R4 = RECORD ADDR OF MOD RECORD
         LR    R5,R2               SET R2 = BUFFER ADDR
         L     R15,PPIBDSVA+8      CALL MOVE LIST - MOVE WINNER TO
         BASR  R14,R15             OUTPUT BUFFER
         ST    R2,KPARLST+4        STORE RECORD ADDR IN PARAMETER LIST
         SR    R6,R6
RBINCR   IC    R6,PPIDEPHO+3       INCREMENT FOR OUTPUT UNIT COUNT
         L     R7,PPIUNTCT         LOAD ADDR OF UNIT COUNTERS
         L     R8,0(R6,R7)         LOAD COUNT FOR THIS UNIT
         LA    R8,1(,R8)           INCREMENT IT
         ST    R8,0(R6,R7)         RESTORE
*
*        DEBLOCK RECORD FROM SAME FILE AS WINNER RECORD
*
RBW2027  LR    R2,R3               SAVE WINNER ADDR
         SRL   R3,24               ACCESS INCREMENT
         L     R7,PPIUNTCT         LOAD ADDR OF UNIT COUNTERS
         L     R5,0(R3,R7)         LOAD COUNT FOR THIS UNIT
         BCTR  R5,0                DECREMENT
         ST    R5,0(R3,R7)         RESTORE
         L     R7,PPISBLCT         SET R7=START ADDR OF BLOCK COUNTERS
         L     R8,0(R3,R7)         SET R8 = BLK CNT FOR THIS BUFFER
         BCTR  R8,0                DECREMENT BLK CNT BY 1
         LTR   R8,R8               THIS BLK CNT = 0 ?
         BNP   RBW2030             YES, BRANCH BLK IS EMPTY
         ST    R8,0(R3,R7)         NO, STORE NEW BLK CNT
         LR    R3,R2               INCREMENT WINNER BY RECORD LENGTH TO
         AH    R3,PPIRCDL2         GET NEXT RECORD
         L     R11,PPINETM+4       EXIT TO MERGE
         B     8(,R11)
*
*        INPUT BUFFER IS EMPTY - CALL READ ROUTINE TO REFILL
*        BUFFER
*        R2 -> EMPTY BUFFER
*        R3  = INCREMENT
*
RBW2030  L     R7,PPIBDSVA         R7 -> OF BUFFER TABLE
         L     R2,0(R3,R7)         ACCESS ADDR OF EMPTY BUFFER VIA INCR
         L     R11,PPIRD+4
         B     8(,R11)
*
*        RETURN FROM READ ROUTINE
*        R1  = BLOCK COUNT
*        R2 -> BUFFER (FOR DEBLOCKING)
*        R3  = INCREMENT
*        R4 -> BUFFER (FOR READING)
*
RBW2040  L     R7,PPIBDSVA         R7 -> BUFFER TABLE
         ST    R4,0(R3,R7)         STORE BUFF ADDR IN TABLE
         L     R5,PPISBLCT         SET R5=START ADDR OF BLOCK COUNTERS
         ST    R1,0(R3,R5)         STORE BLK CNT IN BLK CNT TABLE
         SLL   R3,24               ADD INCREMENT TO NEXT RECORD
         AR    R3,R2
         L     R11,PPINETM+4       EXIT TO MERGE
         B     8(,R11)
*
*        OUTPUT BUFFER IS FULL - CALL WRITE ROUTINE TO EMPTY
*        BUFFER
*        R1  = NO OF BYTES TO BE WRITTEN
*        R2 -> BUFFER TO BE WRITTEN
*
RBW2050  ST    R1,WRBSAVE          STORE MOD RCD ADDR
         L     R1,KBUFSIZ          SET R1=NO BYTES IN BUFFER
RBW2053  L     R2,KBLKPTR          SET R2 = BUFFER ADDR
         SH    R2,K4               DECR. BY 4 FOR EOS INDICATION
         L     R11,PPIWRT+4        CALL WRITE RTN
         B     8(,R11)
*
*        RETURN FROM WRITE ROUTINE
*        R2 -> EMPTY BUFFER
*
RBW2060  LH    R4,PPISRTBL         RESET OUTPUT BLK CNT TO SORT BLKNG
         ST    R2,KIBLKPTR         SAVE INITIAL POINTER
         ST    R2,KBLKPTR          SET BLOCK POINTER
         L     R1,WRBSAVE          RELOAD MOD RCD ADDR
         B     RBW2010
*
*        END OF SEQUENCE - WRITE THIS BUFFER, RESET POINTERS TO
*        REUSE THIS BUFFER THE NEXT TIME THROUGH
*
*        CALCULATE NUMBER OF BYTES TO BE WRITTEN -
*        BUFFER SIZE WHEN FULL -
*        (REMAINING BLOCK COUNT * RECORD LENGTH)
*
RBW2080  L     R1,KBUFSIZ
         L     R4,KOBLKCNT
         MH    R4,PPIRCDL2
         SR    R1,R4
         LH    R4,PPISRTBL         RESET OUTPUT BLOCK COUNT TO SORT
         ST    R4,KOBLKCNT         BLOCKING
RBW2090  L     R2,KBLKPTR          SET R2 = BUFFER ADDR
         SH    R2,K4               DECR BY 4 FOR EOS INDICATION
         L     R5,KIBLKPTR
         ST    R5,KBLKPTR          RESET BLK PTR
         LA    R4,4                SET INDICATION FOR NON FINAL EOS
         L     R11,PPIWRT+4        CALL WRITE ON EOS
         B     4(,R11)
*
*        WINNER RECORD IS TO BE DELETED
*
RBW2100  L     R7,PPIDELCT
         LA    R7,1(,R7)           INCREMENT DELETE COUNTER
         ST    R7,PPIDELCT
         B     RBW2027             DEBLOCK ANOTHER RECORD
*
*        CONSTANTS
*
*        PARAMETER LIST FOR USER
*
KPARLST  DC    A(0)                ADDR OF WINNER RCD
         DC    A(0)                ADDR OF LAST RECORD BLOCKED
*
KOBLKCNT DC    F'0'
KBUFSIZ  DC    F'0'
WRBSAVE  DC    F'0'                CURRENT MODIFIED RCD ADDR
K4       DC    H'4'                CONSTANT =4 FOR OSCL, =12 FOR 2314
*
./ ADD NAME=IERRBX   0101-20211-20211-1200-00131-00131-00000-RELEASE 00
RBX      TITLE 'IERRBX - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRBX
*
*        MODULE FUNCTION -
*        OSCL/CRCX SORT - MERGE PHASE BLOCK/DEBLOCK - VARIABLE
*        LENGTH RECORDS WITH EXIT E25
*        THE FUNCTION OF THIS MODULE IS TO HANDLE THE DEBLOCKING
*        AND BLOCKING OF VARIABLE LENGTH RECORDS. THE BUFFERS
*        ARE FILLED BY THE READ MODULE AND EMPTIED BY THE WRITE
*        MODULE. THIS MODULE MOVES THE VARIABLE LENGTH RECORD
*        FROM THE INPUT BLOCK DIRECTLY TO THE OUTPUT BLOCK
*
*        THE USER EXIT E25 IS ON THE BLOCK SIDE AND IS EXECUTED
*        ONCE FOR EVERY RECORD, EXCEPT THE FIRST RECORD OF EACH
*        OUTPUT SEQUENCE. THE EXIT OCCURS AFTER THE RECORD LEAVES
*        THE MERGE AND WHILE THE PREVIOUS RECORD IS AVAILABLE IN
*        THE OUTPUT AREA. THE EXIT IS FOR SUMMARIZATION AND
*        DELETION OF RECORDS EXCEPT ON THE FIRST RECORD OF EACH
*        OUTPUT SEQUENCE
*
*        THE MERGE NETWORK INITIALLY PASSES A WINNER TO THE
*        BLOCK SIDE OF THIS MODULE. BLOCK SEES IF IT CAN FIT IN
*        THE OUTPUT BLOCK AND IF IT CAN'T, WRITES THE BLOCK THEN
*        MOVES THE RECORD. IT THEN BRANCHES TO THE DEBLOCK SIDE.
*        DEBLOCK DEBLOCKS ANOTHER RECORD FROM THE SAME FILE AS
*        THE WINNER, TESTING FIRST IF THAT BLOCK IS EMPTY. IF IT
*        IS, DEBLOCK READS ANOTHER BLOCK FROM THE SAME FILE.
*        DEBLOCK THEN PASSES THE ADDRESS OF THE NEW RECORD TO THE
*        MERGE NETWORK. THE NETWORK FINDS ANOTHER WINNER AND THE
*        PROCESS IS REPEATED
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - IERABX
*
*        MACROS USED BY THE MODULE - SMPPI
*
*        ENTRY POINTS - ENTRY FROM MERGE NETWORK
*                       CALLING SEQUENCE -
*                           L    R11,PPIBLK2+4
*                           B    0(,R11)     NORMAL EOD
*                           B    12(,R11)    PRIMING ENTRY
*                           B    16(,R11)    NORMAL
*
*                     - ENTRY FROM READ
*                       CALLING SEQUENCE -
*                           L    R11,PPIBLK2+4
*                           B    4(,R11)
*
*                     - ENTRY FROM WRITE
*                       CALLING SEQUENCE -
*                           L    R11,PPIBLK2+4
*                           B    8(,R11)
*
*                     - ENTRY FROM USER EXIT E25
*                       CALLING SEQUENCE
*                           RETURN  RC=(15) RETURN ON R14
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIBDSVA   PPILAB07   PPISBLCT   PPIDEPHO
*        PPIUNTCT
*        VARIOUS ADDRESSES
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPIDELCT
*        APPROPRIATE TAPE UNIT COUNTERS IN GENERATED STORAGE ARE
*        UPDATED
*        UPDATE COUNTERS
*
*        EXTERNAL ROUTINES - NONE
*
*        EXTERNAL PARAMETERS - SEE REGISTERS
*
*        EXITS - NORMAL - EXIT TO READ
*                         CALLING SEQUENCE -
*                             L    R11,PPIRD+4
*                             B    8(,R11)
*
*                       - EXIT TO MERGE NETWORK
*                         CALLING SEQUENCE -
*                             L    R11,PPINETM+4
*                             B    8(,R11)
*
*                       - EXIT TO WRITE
*                         CALLING SEQUENCE -
*                             L    R11,PPIWRT+4
*                             B    4(,R11)     EOD
*                             B    8(,R11)     NORMAL
*
*                         EXIT TO USER EXIT E25
*                         CALLING SEQUENCE -
*                             L    R15,PPIX25+4
*                             BALR R14,R15
*
*        EXITS - ERROR - NONE
*
*        TABLES/WORK AREAS -
*        WMRGRCD  - ADDR OF WINNER IN INPUT BUFFER
*                   PARM 1 TO USER
*        WOUTRCD  - ADDR OF LAST RCD PUT IN OUTPUT BUFFER
*                   PARM 2 TO USER
*        WBLKCCNT - OUTPUT BUFFER CHARACTER COUNTER
*        WRCDLGTH - L'WINNER RECORD
*        WINNER   - ADDR OF WINNER RECORD IN INPUT BUFFER
*        WLSTPTR  - ADDR OF A FREE AREA IN OUTPUT BUFFER TO MOVE
*                   THE WINNER
*        WLSTPTRD - PTR TO STRTG+8 (DISK) OR ENDING+1 (TAPE) ADDR
*                   OF OUTPUT BUFFER
*
*        NOTES -
*        THIS MODULE IS USED TO MERGE VARIABLE LENGTH RECORDS
*        WHEN USER MODIFICATION EXIT E25 IS ACTIVE
*
IERRBX   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRBX SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRBXI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERRBXI  0101-20211-20211-1200-00213-00213-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERRBX SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERRBXI
*
         USING *,R11               MODULE BASE REG LOADED EXTERNALLY
         USING IERRCA,R13          ADDR OF PPI LOADED EXTERNALLY
*
*        ENTRY TABLE
*
IERDB2   B     RBEOS               +00 FROM MERGE ON NORMAL EOS
         B     RBRDRTRN            +04 FROM READ MODULE
         B     RBWRT               +08 FROM WRITE MODULE
         B     RBBPSUS1            +12 PRIME ENTRY, BYPASS EXIT RTN
         B     RBBRANCH            +16
*
WLSTPTR  DC    F'0'                INITIALLY LOADED BY AP TO OUTPUT
*                                  BLOCK ENDING ADDR + 1
WLSTPTRD DC    F'0'                OUTPUT BLOCK ENDING ADDR + 1
*
*        NORMAL MERGE ENTRY - INCR BLOCK CHAR COUNTER
*        CHECK IF RECORD WILL FIT IN OUTPUT BLOCK. IF NOT, WRITE
*        THE BLOCK BEFORE MOVING THE RECORD
*
RBBRANCH ST    R3,WMRGRCD          PARM 1 TO USER ADDR OF RECORD IN
*                                  INPUT BLOCK
*
*        CALL USER EXIT E25
*
         L     R15,PPIX25+4        ADDR OF USER EXIT E25
         LA    R1,WMRGRCD
         BASR  R14,R15
*
*        RETURN FROM USER
*
         B     *+4(R15)
         B     RBBPSUSR            +00 DO NOTHING
         L     R6,PPIDELCT         +04 DELETE COUNTER
         LA    R6,1(,R6)           INCR DELETE CTR BY 1
         ST    R6,PPIDELCT         SAVE UPDATED DELETE CTR
         ST    R3,WINNER           SAVE WINNER ADDR (DEBLK WILL DELETE)
         MVC   WRCDLGTH+2(2),0(R3)  MOVE RCD LENGTH TO PROPER BOUNDARY
         B     RBDEBLCK            BRANCH TO DEBLOCK ANOTHER RCD
*
RBBPSUS1 LR    R1,R3
RBBPSUSR L     R6,WBLKCCNT         OUTPUT BLOCK CHAR CTR INITIALLY
*                                  PRESET TO 8 BY AP
         MVC   WRCDLGTH+2(2),0(R1) MOVE RCD LENGTH TO PROPER BNDRY
         A     R6,WRCDLGTH         ADD RCD LENGTH TO OUTPUT BLOCK CHAR
*                                  CTR
         CH    R6,PPILAB07+2       > ROUNDED OUTPUT BLOCKING ?
         BH    RBWRTBLK            YES, BRANCH TO WRITE THE BLOCK FIRST
RBSAVE   ST    R6,WBLKCCNT         SAVE UPDATED BLOCK CHAR CTR
         ST    R3,WINNER           SAVE ADDR OF RCD IN INPUT BLOCK
         L     R5,WLSTPTR          ADDR IN OUTPUT BLOCK TO MOVE RCD
RBSUBRLT S     R5,WRCDLGTH         DECR ADDR BY RCD LGTH FOR TAPE SORT
*                                  RCDS FILL OUTPUT BLOCK STARTG FROM
*                                  HI CORE TO LOW
         ST    R5,WOUTRCD          PARM 2 TO USER ADDR OF RCD IN
*                                  OUTPUT BLOCK
         SR    R6,R6
RBINCR   IC    R6,PPIDEPHO+3       INCREMENT FOR OUTPUT UNIT COUNT
         L     R7,PPIUNTCT         LOAD ADDR OF UNIT COUNTERS
         L     R8,0(R6,R7)         LOAD COUNT FOR THIS UNIT
         LA    R8,1(R8)            INCREMENT BY ONE
         ST    R8,0(R6,R7)         RESTORE
         LR    R4,R1               ADDR OF RCD IN INPUT AREA
         L     R8,WRCDLGTH         LENGTH OF RCD FOR MOVE RTN
*
*        GENERALIZED MOVE RTN USED TO MOVE ANY SIZED DATA RCD
*        FROM ONE DATA AREA TO ANOTHER
*        REGISTERS ON INPUT -
*        R4 -> DATA SOURCE
*        R5 -> DATA TARGET
*        R8 = L'DATA
*
*        THE ROUTINE USES REGS R6 AND R7
*
*        THE ROUTINE DOES ALL INTERMEDIARY UPDATING OF
*        REGISTERS. UPON COMPLETION OF THE MOVE THE REGISTERS
*        CONTAIN-
*        R4 FROM ADDR UPDATED
*        R5 TO ADDR UPDATED
*        R8 REMAINING RECORD LENGTH SET TO ZERO
*
         LR    R6,R5               R6 -> DATA TARGET
         LR    R5,R8               R5 = L'DATA
         LR    R7,R8               R7 = L'DATA
         MVCL  R6,R4               MOVE DATA, NO PAD
         LR    R5,R6               R5 -> TARGET+1
         SR    R8,R8               R8 = REMAINING COUNT = 0
*
*        END OF GENERALIZED MOVE ROUTINE
*
RBSUBRLD S     R5,WRCDLGTH         DECREMENT ADDR BY RECORD LENGTH
         ST    R5,WLSTPTR          SAVE UPDATED OUTPUT BLOCK RCD PTR
         B     RBDEBLCK            BRANCH TO DEBLOCK ANOTHER RCD
*
*        WRITE A BLOCK. THIS RECORD CAN'T FIT INTO THIS BLOCK
*
RBWRTBLK S     R6,WRCDLGTH         SUBTR LENGTH OF RCD THAT CAN'T FIT
*                                  FROM OUTPUT BLOCK CHAR COUNT
         ST    R1,WRBSAVE          STORE MOD RCD ADDR
RBLSTPTR L     R2,WLSTPTR          LOAD OUTPUT BLOCK RECORD POINTER
         S     R2,KEIGHT           EQUALS ADDR OF OUTPUT BLK TO WRITE
         ST    R6,WBLKCCNT         ALIGN TO WORD BOUNDARY
         MVC   0(2,R2),WBLKCCNT+2  STORE BLK CHAR CTR IN FIRST 2 BYTES
         LR    R1,R6               ALSO IN R1 FOR WRITE MODULE PARM
*
*        INTERFACE TO WRITE MODULE
*
         L     R11,PPIWRT+4        ADDR OF WRITE MODULE
         B     8(,R11)             BRANCH TO WRITE MODULE
*
*        WRITE MODULE REENTERS VIA BRANCH TABLE
*        R2 FOR TAPE, HAS AN OUTPUT BLOCK ENDING ADDR+1
*
RBWRT    ST    R2,WLSTPTRD         SAVE AS CURRENT OUTPUT BLK POINTER
         ST    R2,WLSTPTR          STORE AS OUTPUT BLK WORK POINTER
         L     R6,KEIGHT           REINITIALIZE BCC TO 8 OR 16
         A     R6,WRCDLGTH         ADD LENGTH OF RCD TO BE MOVED TO
*                                  OUTPUT BLOCK
         L     R1,WRBSAVE          RELOAD MOD RCD ADDR
         B     RBSAVE              BRANCH TO MOVE RCD TO OUTPUT BLOCK
*
*        FROM MERGE NORMAL EOS
*        PREVIOUS RECORD WAS EOS RECORD AND IS IN OUTPUT BLK NO NEW
*        RECORDS PASSED TO BLOCK RTN AT THIS TIME
*
RBEOS    L     R4,WLSTPTR
         MVC   WLSTPTR,WLSTPTRD    RESET OUTPUT BLOCK POINTER
         S     R4,KEIGHT           DECR OUTPUT BLK PTR BY 8 TO INSERT
*                                  BLOCK CHAR CNT IN 1ST 2 BYTES
         MVC   0(2,R4),WBLKCCNT+2  STORE BLK CHAR CNT IN OUTPUT BLK
         L     R1,WBLKCCNT         LOAD BLOCK CHAR CNT FOR WRITE MOD
         MVC   WBLKCCNT,KEIGHT     REINITIALIZE BLOCK CHAR CTR TO 8
         LR    R2,R4               LOAD OUTPUT BLOCK PTR FOR WRITE
         LA    R4,4                SET INDICATION FOR NON FINAL EOS
*
*        INTERFACE TO WRITE MODULE FOR NORMAL EOS
*
         L     R11,PPIWRT+4
         B     4(,R11)             BRANCH TO WRITE MODULE
*
*        DEBLOCK SIDE OF PROGRAM
*
RBDEBLCK SRL   R3,24               SHIFT TO GET AT INCR OF WINNER RCD
         L     R7,PPIUNTCT         LOAD ADDR OF UNIT COUNTERS
         L     R5,0(R3,R7)         LOAD COUNT FOR THIS UNIT
         BCTR  R5,0                DECREMENT BY ONE
         ST    R5,0(R3,R7)         STORE
         L     R6,PPISBLCT         LOAD ADDR OF INPT BLK CHAR CNT TABLE
         L     R7,0(R3,R6)         LOAD BLK CHAR CNT OF WINNER'S BLOCK
         S     R7,WRCDLGTH         SUBTRACT RCD LENGTH OF WINNER
*                                  BLOCK CHAR CNT = ZERO ?
         BZ    RBREAD              YES, BRANCH TO READ ANOTHER BLK
*                                       INTO INPUT BLK JUST VACATED
         ST    R7,0(R3,R6)         NO, STORE UPDATED BLOCK CHAR CNT
         L     R3,WINNER           RESTORE WINNER
         A     R3,WRCDLGTH         ADDR OF NEXT RCD FROM WINNER FILE
*
*        INTERFACE TO MERGE NETWORK
*
RBMERGE  L     R11,PPINETM+4       ADDR OF MERGE MODULE
         B     8(,R11)             BRANCH TO MERGE MODULE
*
*        FILL EMPTY INPUT BLOCK OF WINNER
*        R3 HAS INCR IN LOW ORDER BYTE
*
RBREAD   L     R6,PPIBDSVA         ADDR OF INPUT BLK ADDR TABLE
         L     R2,0(R3,R6)         ADDR OF THE WINNER'S INPUT BLOCK
*
*        INTERFACE TO READ MODULE
*
         L     R11,PPIRD+4         ADDR OF READ MODULE
         B     8(,R11)             BRANCH TO READ MODULE
*
*        READ MODULE RETURNS VIA THIS MODULE BRANCH TABLE
*        REGS CONTAIN THE FOLLOWING -
*        R1 -  BLOCK CNT
*        R2 -> FIRST RCD IN INPUT BLOCK
*        R3 -  INCREMENT
*        R4 -  ENDING ADDR OF BLOCK
*
RBRDRTRN L     R6,PPISBLCT         LOAD ADDR OF BLOCK CNT TABLE
         S     R1,KFOUR            EQUALS TOTAL BYTES (OF RCDS) IN BLK
         ST    R1,0(R3,R6)         STORE NEW BLOCK CHAR CNT IN TABLE
         L     R6,PPIBDSVA         ADDR OF TABLE OF INPUT BLK STARTING
*                                  ADDRS
         ST    R4,0(R3,R6)         STORE IN INDEXED POSITION IN TABLE
         SLL   R3,24               POSITION INCR IN HI BYTE
         AR    R3,R2               INSERT STRTG ADDR OF 1ST RCD OF BLK
         B     RBMERGE             BRANCH TO MERGE NETWORK
*
*        CONSTANTS
*
KFOUR    DC    F'4'                FOUR
KEIGHT   DC    F'8'                CONSTANT =8 FOR OSCL, = 16 FOR CRCX
*
*        WORK AREAS
*
WMRGRCD  DC    F'0'                ADDR OF RCD IN INPUT BLK USER PARM1
WOUTRCD  DC    F'0'                ADDR OF RCD IN OUTPUT BLK USER PARM2
WBLKCCNT DC    F'0'                OUTPUT BLOCK CHAR CTR INITIALLY
*                                  PRESET TO 8 BY AP
WRCDLGTH DC    F'0'                L'INPUT RECORD TO BE BLOCKED
WINNER   DC    F'0'                ADDR OF WINNER RCD IN INPUT BLOCK
WRBSAVE  DC    F'0'                CURRENT MODIFIED RCD ADDR
*
./ ADD NAME=IERRBY   0101-20211-20211-1200-00080-00080-00000-RELEASE 00
RBY      TITLE 'IERRBY - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRBY
*
*        MODULE FUNCTION -
*        OSCILLATING/CRCX SORT BLOCK ROUTINE
*        THIS MODULE BLOCKS RECORDS FOR THE SORT PHASE. IT
*        HANDLES FIXED LENGTH RECORDS LESS THAN OR EQUAL TO 256
*        BYTES. THE MODULE MAINTAINS THE BUFFER SCHEME
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - IERABY
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM SORT NETWORK - EOF
*                       CALLING SEQUENCE -
*                           L    R11,PPIBLK+4
*                           BR   R11
*
*                     - ENTRY FROM SORT NETWORK - EOS
*                       CALLING SEQUENCE -
*                           L    R11,PPIBLK+4
*                           B    4(,R11)
*
*                     - ENTRY FROM WRITE RTN - NORMAL
*                       CALLING SEQUENCE -
*                           L    R11,PPIBLK+4
*                           B    8(,R11)
*
*                     - ENTRY FROM SORT NETWORK - NORMAL
*                       CALLING SEQUENCE-
*                           L    R11,PPIBLK+4
*                           B    12(,R11)
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIRCDL2   PPIDEB
*        PPISRTBL   PPIWRT
*        PPIDEPHO   PPIUNTCT
*        ADDRESS OF WINNER RECORD SITTING IN RSA IS IN R3
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED - N/A
*        WINNER RECORD IS MOVED INTO OUTPUT BUFFER
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL -
*        PPIDEB - DSPL = 8 - DEBLOCK - NORMAL
*        PPIWRT - DSPL = 8 - WRITE - NORMAL
*        PPIWRT - DSPL = 4 - WRITE - EOS
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS -
*        WSAVRCD - SAVE WINNER ADDRESS ON EXIT TO WRITE
*
*        NOTES -
*        THIS MODULE IS USED FOR FIXED LENGTH RECORDS LESS THAN
*        OR EQUAL TO 256 BYTES
*
IERRBY   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRBY SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRBYI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERRBYI  0101-20211-20211-1200-00110-00110-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERRBY SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERRBYI
*
         USING *,R11
         USING IERRCA,R13
*
*        SORT NETWORK PASSES ADDR OF RECORD TO BE BLOCKED IN R3
*
IERDB1   B     RBY1110             +00 LAST RECORD EOF ENTRY
         B     RBY1080             +04 EOS ENTRY
         B     RBY1060             +08 ENTRY FROM WRITE - NORMAL
RBY1010  SR    R4,R4               +12 ENTRY FROM SORT NETWORK - NORMAL
*                                      R3 -> WINNER RCD
         B     RBBRANCH
*
KBLKPTR  DC    F'0'                BLOCK POINTER
KIBLKPTR DC    F'0'                INITIAL BLOCK POINTER
*
RBBRANCH CH    R4,KBLKCNT          BLOCK COUNT = 0 ?
         BE    RBY1050             YES, BUFFER IS FULL - TAKE BRANCH
         L     R2,KBLKPTR          NO, DECREMENT BLK PTR BY RCD LENGTH
RBY1020  SH    R2,PPIRCDL2
         ST    R2,KBLKPTR
RBY1030  MVC   0(1,R2),0(R3)       MOVE RCD FROM RSA TO OUTPUT BUFFER
         LH    R6,KBLKCNT          DECREMENT BLOCK COUNT BY 1
         BCTR  R6,0
         STH   R6,KBLKCNT
         SR    R6,R6
RBYINCR  IC    R6,PPIDEPHO+3       INCREMENT FOR OUTPUT UNIT
         L     R7,PPIUNTCT         LOAD ADDR OF UNIT COUNTERS
         L     R8,0(R6,R7)         LOAD COUNT FOR THIS UNIT
         LA    R8,1(,R8)           INCREMENT IT BY ONE
         ST    R8,0(R6,R7)         RESTORE
*
*        THIS MODULE EXIT IS OVERLAID WHEN AN EOS OR EOF IS
*        INDICATED SO THAT IT BRANCHES TO EITHER THE EOS OR EOF
*        PPORTION OF THIS MODULE, IE RBY1090 OR RBY1120
*
RBY1040  L     R11,PPIDEB+4        LINK TO DEBLOCK R3 -> WINNER RCD
         B     8(,R11)
*
*        BUFFER IS FULL
*        PASS BUFFER ADDR TO WRITE ROUTINE
*
RBY1050  L     R1,KBUFSIZ          SET R1 = NO BYTES IN BUFFER
RBY1055  L     R2,KBLKPTR          LOAD PARM REG WITH BUFFER ADDR
         SH    R2,K4               DECREMENT BY 4 FOR EOS INDICATION
         ST    R3,WSAVRCD          SAVE ADDR OF LAST WINNER RCD
         L     R11,PPIWRT+4        CALL WRITE
         B     8(,R11)
*
*        RETURN FROM WRITE
*        R2 -> EMPTY BUFFER
*
RBY1060  MVC   KBLKCNT(2),PPISRTBL  RESET BLK CNT TO SORT BLOCKING
         ST    R2,KIBLKPTR         SAVE INITIAL POINTER
         L     R3,WSAVRCD          RESTORE ADDR OF LAST WINNER
         B     RBY1020             BLOCK NEXT RECORD
*
*        END OF SEQUENCE
*        RECORD STILL TO BE PUT IN THIS SEQUENCE
*
RBY1080  MVC   RBY1040(4),KRBYMOD1  MODIFY MODULE EXIT
         B     RBY1010              BLOCK LAST RCD OF THIS SEQUENCE
*
RBY1090  LA    R4,4                 SET INDICATION FOR NON FINAL EOS
RBY1100  MVC   RBY1040(4),KRBYMOD2  RESET MODULE EXIT TO LINK TO DEBLCK
         L     R1,KBUFSIZ           CALCULATE NO BYTES TO BE WRITTEN
         LH    R6,KBLKCNT
         MH    R6,PPIRCDL2          BUFSIZ-(BLKCNT * RCDLENGTH)
         SR    R1,R6
RBY1105  L     R2,KBLKPTR
         SH    R2,K4                SET R2 = BUFFER ADDR
         L     R5,KIBLKPTR
         ST    R5,KBLKPTR
         MVC   KBLKCNT(2),PPISRTBL  RESET BLK CNT TO SORT BLOCKING
         L     R11,PPIWRT+4         CALL WRITE ON EOS
         B     4(,R11)
*
*        LAST RECORD IS TO BE BLOCKED
*
RBY1110  MVC   RBY1040(4),KRBYMOD3  OVERLAY MODULE EXIT TO BRANCH TO
*                                    RBY1120
         B     RBY1010             BLOCK LAST RCD
*
*        LAST RECORD HAS BEEN BLOCKED
*
RBY1120  SR    R4,R4               SET INDICATION FOR FINAL EOS
         B     RBY1100
*
*        CONSTANTS
*
KBUFSIZ  DC    F'0'                BUFFER SIZE
KBLKCNT  DC    H'0'                BLOCK COUNT
K4       DC    X'0004'             CONSTANT =4 FOR OSCL, =12 FOR 2314
*
KRBYMOD1 B     RBY1090             RETURN TO EOS ROUTINE
KRBYMOD2 L     R11,PPIDEB+4        LINK TO DEBLOCK
KRBYMOD3 B     RBY1120             RETURN TO LAST RCD RTN
*
*        WORK AREAS
*
WSAVRCD  DC    F'0'                SAVES WINNER ADDR OF EXIT TO WRITE
*
./ ADD NAME=IERRBZ   0101-20211-20211-1200-00060-00060-00000-RELEASE 00
RBZ      TITLE 'IERRBZ - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRBZ
*
*        MODULE FUNCTION -
*        OSCILLATING/CRCX BLOCK ROUTINE
*        THE MODULE MAINTAINS THE BUFFER SCHEME. THE RECORD
*        LENGTH IS GREATER THAN 256 BYTES, SO THE MODULE LINKS TO
*        THE MULTIPLE MOVE ROUTINE. THE MOVE ROUTINE MOVES THE
*        RECORD TO AN OUTPUT BUFFER AND RETURNS TO THE MODULE.
*        THE MODULE THEN CALLS THE APPROPRIATE DEBLOCK MODULE
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - IERABZ
*
*        MACROS USED BY MODULE - SMPPI
*
*        ENTRY POINTS - IERRBZ
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIBDSVA   PPISRTBL   PPIDEB    PPIWRT
*        PPIRCDL2   PPIDEPHO   PPIUNTCT
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPIRCDL2
*        UNIT COUNTERS IN GENERATED STORAGE ARE UPDATED FOR EACH
*        RECORD BLOCKED
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL -
*        IERDD1+8  - EXIT TO DEBLOCK ROUTINE
*        IERDPW1+8 - EXIT TO WRITE ROUTINE
*        IERDPW1+4 - EXIT TO WRITE ON EOS
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS -
*        WSAVRCD
*
IERRBZ   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRBZ SOURCE
*
*----------------------------------------------------------------------
*
         COPY IERRBZI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERRBZI  0101-20211-20211-1200-00126-00126-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERRBZ SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERRBZI
*
         USING *,R11
         USING IERRCA,R13
*
*        SORT NETWORK PASSES ADDR OF RECORD TO BE BLOCKED IN R3
*
IERDB1   B     RBZ1080         *   +00 LAST RECORD EOF ENTRY
         B     RBZ1060         |   +04 EOS ENTRY
         B     RBZ1050         |   +08 ENTRY FROM WRITE - NORMAL
RBZ1010  SR    R4,R4           |   +12 ENTRY FROM SORT NETWORK - NORMAL
         B     RBBRANCH        |   +14
         NOPR  0               |   +18
KBLKPTR  DC    F'0'            |   +20 BLOCK POINTER (SET BY PPIWRT)
KIBLKPTR DC    F'0'            V   +24 INIT BLOCK PTR (SET BY PPIWRT)
*
*        NORMAL ENTRY FROM SORT NETWORK
*
RBBRANCH CH    R4,KBLKCNT          BLOCK COUNT = 0 ?
         BE    RBZ1040             YES, BUFFER IS FULL, BRANCH
         L     R2,KBLKPTR          NO, DECREMENT BLK PTR BY L'RECORD
RBZ1020  SH    R2,PPIRCDL2
         ST    R2,KBLKPTR
*
*        SET UP LINKAGE TO MOVE LIST
*
         LR    R4,R3               R4 -> SOURCE RSA RECORD
         LR    R5,R2               R5 -> TARGET OUTPUT BUFFER AREA
         L     R15,PPIBDSVA+4      CALL MOVE RTN, MOVE RECORD FROM RSA
         BASR  R14,R15             TO OUTPUT BUFFER
         LH    R6,KBLKCNT          DECREMENT BLOCK COUNT BY 1
         BCTR  R6,0
         STH   R6,KBLKCNT
         SR    R6,R6
RBZINCR  IC    R6,PPIDEPHO+3       INCREMENT FOR OUTPUT UNIT
*                               Ý  UPDATED BY IERABZ ID DASD SORT TO
*        IC    R6,PPIDEPHO+1       INCR FOR OUTPUT FILE ¨
         L     R7,PPIUNTCT         R7 -> UNIT COUNTERS
         L     R8,0(R6,R7)         LOAD COUNT FOR THIS UNIT
         LA    R8,1(,R8)           INCREMENT IT BY ONE
         ST    R8,0(R6,R7)         RESTORE
*
*        THIS MODULE EXIT IS OVERLAID WHEN AN EOS OR EOF IS
*        INDICATED SO THAT IT BRANCHES TO EITHER THE EOS OR EOF
*        PORTION OF THIS MODULE, IE RBZ1070 OR RBZ1090
*
RBZ1030  L     R11,PPIDEB+4        CALL DEBLOCK, R3 -> FREE AREA IN RSA
*                                  OVERLAYED TO B RBZ1090 ON EOF
         B     8(,R11)
*
*        BUFFER IS FULL, PASS BUFFER ADDR TO WRITE ROUTINE TO BE
*        WRITTEN
*
RBZ1040  LH    R1,PPILAB07+2       R1 = NO BYTES TO BE WRITTEN
RBZ1045  L     R2,KBLKPTR          R2 -> BUFFER
         SH    R2,DECRBUFA         DECR FOR EOS FIELD
         ST    R3,WSAVRCD          SAVE ADDR OF LAST WINNER RECORD
         L     R11,PPIWRT+4        CALL WRITE
         B     8(,R11)
*
*        WRITE RETURNS ADDR OF EMPTY BUFFER TO BLOCK IN R2
*
RBZ1050  MVC   KBLKCNT,PPISRTBL    RESET BLK CTR TO SORT BLOCKING
         ST    R2,KIBLKPTR         SAVE INITIAL BLK PTR
         L     R3,WSAVRCD          RESTORE ADDR OF LAST WINNER
         B     RBZ1020
*
*        END OF SEQUENCE
*        RECORD STILL TO BE PUT IN THIS SEQUENCE
*
RBZ1060  MVC   RBZ1030(4),KRBZMOD1  MODIFY MODULE EXIT
         B     RBZ1010             PROCESS LAST RECORD OF THIS SEQUENCE
*
RBZ1070  LA    R4,4                SET INDICATION FOR NON FINAL EOS
*                                  IN IER8PA
RBZ1075  MVC   RBZ1030(4),KRBZMOD2  RESET MODULE EXIT TO LINK TO DEBLCK
         LH    R1,PPILAB07+2        CALCULATE NO OF BYTES TO BE
         LH    R6,KBLKCNT           WRITTEN
         MH    R6,PPIRCDL2
         SR    R1,R6
*
*        R1 = BUFFER SIZE WHEN FULL
*        - (REMAINING BLK CNT * RCD LENGTH)
*
RBZ1078  L     R2,KBLKPTR          R2 -> BUFFER
         SH    R2,DECRBUFA         DECR FOR EOS INDICATION
         L     R5,KIBLKPTR         RESET BLOCK PTR
         ST    R5,KBLKPTR
         MVC   KBLKCNT,PPISRTBL    RESET BLK COUNT TO SORT BLOCKING
         L     R11,PPIWRT+4        LINK TO WRITE ON EOS
         B     4(,R11)
*
*        LAST RECORD IS TO BE BLOCKED, EOF
*
RBZ1080  MVC   RBZ1030(4),KRBZMOD3  OVERLAY MODULE EXIT TO RETURN TO
*                                   EOF, RBZ1090
         B     RBZ1010             PROCESS LAST RECORD
*
*        LAST RECORD HAS BEEN BLOCKED
*        WRITE FINAL SEQUENCE
*
RBZ1090  SR    R4,R4               SET INDICATOR FOR FINAL EOS
         B     RBZ1075
*
*        CONSTANTS
*
KBLKCNT  DC    H'0'                BLOCK COUNT
DECRBUFA DC    H'4'                CONSTANT =4 FOR OSCL, =12 FOR CRCX
*
*        INSTRUCTION CONSTANTS
*
KRBZMOD1 B     RBZ1070             RETURN TO EOS ROUTINE
KRBZMOD2 L     R11,PPIDEB+4        RETURN TO EOS ROUTINE
KRBZMOD3 B     RBZ1090
*
*        WORK AREAS
*
WSAVRCD  DC    F'0'                SAVES WINNER ADDR ON EXIT TO WRITE
*
./ ADD NAME=IERRCA   0101-20211-20211-1200-00025-00025-00000-RELEASE 00
RCA      TITLE 'IERRCA - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRCA
*
*        FUNCTION/OPERATION -
*
*        PHASE TO PHASE INFORMATION AREA (PPIA)
*        THROUGH IT ARE COMMUNICATED THOSE PARAMETERS THAT ARE
*        NEEDED BY THE RUNNING PROGRAMS
*
*        THE IERRCA MODULE IS GENERATED BY THE MACRO SMPPI USING
*        THE CSECT=YES AND LIST=YES PARAMETERS
*
*        THIS MODULE IS MAPPED BY DSECT SMPPI AND REFERENCED BY
*        ALL OF THE RUNNING AND ASSIGNMENT MODULES
*
         SMPPI CSECT=YES,LIST=YES
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         END
./ ADD NAME=IERRCB   0101-20211-20211-1200-00341-00341-00000-RELEASE 00
RCB      TITLE 'IERRCB - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRCB
*
*        MODULE FUNCTION/OPERATION -
*        CONTROL THE EXECUTION OF SORT DURING THE OPTIMIZATION PHASE
*        IT LOADS IERRCV AND BRANCHES TO IT BEFORE THE START OF
*        PHASE 1 OR MERGE ONLY PHASE. IT MAINTAINS THE LINKAGE
*        WITH THE SYSTEM AND RETURNS TO IT WITH THE PROPER CODE
*        UPON NORMAL END OF JOB OR UPON AN ERROR CONDITION
*
*        CHANGE LOG -
*        DCB RECFM, BLKSIZE AND LRECL CHANGED TO FBA,0,121    REL 1.1
*        FOR SYSOUT AND SORTDIAG DCBS FOR COMPATIBILITY
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACROS USED BY THIS MODULE -
*        LINK
*        LOAD
*        OPEN
*        CLOSE
*        DCB
*        DELETE
*        SMCPI
*
*        ENTRY POINT - ENTRY FROM IERRCO - CALLING SEQUENCE
*                                          XCTL EP=IERRCB
*
*                    - ENTRY FROM IERRCZ - CALLING SEQUENCE
*                                          BR    R15
*
*                    - ENTRY FROM IERRCV - CALLING SEQUENCE
*                                          BR    R15
*
*        INPUT - PPI-CPI FIELDS REFERENCED -
*        PPISORCE   PPILINK
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPISORCE   PPISLIB
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL -
*        IERRCZ - LOAD AND BRANCH TO IT FOR OPTIMIZATION PHASE
*        IERRCV - LOAD AND BRANCH TO IT AFTER OPTIMIZATION PHASE
*        SYSTEM - RETURN CONTROL AT END OF SORT/MERGE
*
*        EXITS - ERROR -
*        SYSTEM - RETURN CONTROL WITH ERROR CODE WHENEVER AN
*        ERROR EXISTS
*
*        TABLES/WORK AREAS - N/A
*
*        NOTES-
*
*        THIS MODULE IS USED IN ALL SORT/MERGE EXECUTIONS
*
IERRCB   CSECT
*
         USING *,R8                MODULE BASE REGISTER
         USING IERRC5,R2           CPI BASE REGISTER
         USING IERRCA,R13          PPI BASE REGISTER
*
         SAVE  (14,12),,'IERRCB &SYSDATE &SYSTIME'
*
         LR    R8,R15              SET BASE ADDESSABILITY
         LR    R2,R1               R2 -> CPI
         L     R1,VIERRCA          R1 -> PPI
         ST    R1,8(,R13)          CHAIN SAVE AREAS
         ST    R13,4(,R1)
         LR    R13,R1              R13 -> PPI
         LA    R1,WTORCB           R1 -> WTO AREA
         AH    R1,WTORCB           R1 -> WTO ROUTE AND DESCR CODES
         MVC   0(4,R1),CPIWTOC     MOVE INSTALLATION CODES INTO WTO
         MVC   RCBWTOH,CPIWTOH     SAVE CPIWTOH FOR SYNAD WTO
         MVC   RCBEXTFR+2(2),CPIEXTSZ  INSERT EXTRACT ROUTINE SIZE
*
*        OPEN SYSOUT AND SORTDIAG IF REQUIRED
*
         CPITEST  CPIPALL+CPIPCRT  PRINTER USAGE REQUIRED ?
         BNZ   RCB001              YES, BRANCH TO OPEN PRINTER
         CPITEST  CPIDSIM          DIAGNOSTICS REQUESTED ON SYSOUT ?
         BZ    RCB002              NO, BRANCH
*                                  YES, SYSOUT REQUIRED FOR DIAGNOSTICS
         USING IHADCB,R5
RCB001   LA    R5,SYSOUT           R5 -> SYSOUT DCB
         MVC   DCBDDNAM,CPIMDDN    SET DDNAME TO PROVIDED VALUE
         DROP  R5
*
*        SYSOUT WILL HAVE BEEN OPENED AND CLOSED PREVIOUSLY
*        OPEN WITH EXTEND OPTION TO CONCATENATE ONTO THE END OF
*        THE PREVIOUS OUTPUT
*
         OPEN  (SYSOUT,(EXTEND))   OPEN DCB FOR SYSOUT
*
RCB002   CPITEST  CPIDIAG          DIAGNOSTICS REQUESTED ?
         BZ    RCB003              NO, BRANCH
*
*        SORTDIAG WILL HAVE BEEN OPENED AND CLOSED PREVIOUSLY
*        OPEN WITH EXTEND OPTION TO CONCATENATE ONTO THE END OF THE
*        PREVIOUS OUTPUT
*
         OPEN  (SORTDIAG,(EXTEND))  OPEN SORTDIAG DCB
*
RCB003   LOAD  EP=IERRCZ
*
         LR    R15,R0
         CNOP  0,4                 ALIGN LIST ON WORD BOUNDARY
         BAS   R1,RCB004           R1 -> PARAMETER LIST OF DCB ADDR
DCBLIST  DC    A(SYSOUT)           +00
         DC    A(SORTDIAG)         +04
         DC    A(SORTLIB)          +08
         DC    A(USERLIB)          +12
         DC    A(SYSLMOD)          +16
*
RCB004   BASR  R14,R15             BRANCH AND LINK TO IERRCZ
*
*        IERRCZ CALLS IERRC1 WHICH ESTABLISHES THE PPI AND
*        DELETES THE CPI SO NO FURTHER REFERENCES MAY BE MADE TO
*        THE CPI PAST THIS POINT
*
         DROP R2                   DROP CPI ADDRESSABILITY
*
         LR    R7,R15              SAVE R7 FOR LATER TESTING
*
         DELETE EP=IERRCZ          DELETE MODULE IERRCZ
*
         LTR   R7,R7               TEST IERRCZ RETURN CODE
         BNZ   RCBCLOSA            NOT ZERO, BRANCH
         L     R1,PPISLIB          R1 -> SORTLIB IF LIB=PRIVATE
*
         LOAD  EP=IERRCV,DCB=(1)
*
         LR    R15,R0
         LA    R3,DCBLIST          PASS SYSOUT AND SORTDIAG DCB ADDR
         BASR  R14,R15             BRANCH AND LINK TO IERRCV
         LR    R7,R15              SAVE RETCODE
*
         DELETE EP=IERRCV          DELETE MODULE IERRCV
*
*
*        CLEAN UP ANY OPEN DATA SETS
*
RCBCLOSA LA    R6,CLOSELST-4
         LR    R0,R6               TAKE A COPY FOR LATER TESTING
         USING IHADCB,R1
         LA    R1,SYSOUT
         TM    DCBOFLGS,DCBOFOPN   SYSOUT OPENED ?
         BZ    RCBCLOSB
         LA    R6,4(,R6)
         ST    R1,0(,R6)
RCBCLOSB LA    R1,SORTDIAG
         TM    DCBOFLGS,DCBOFOPN   SORTDIAG OPENED ?
         BZ    RCBCLOSC
         LA    R6,4(,R6)
         ST    R1,0(,R6)
RCBCLOSC LA    R1,SORTLIB
         TM    DCBOFLGS,DCBOFOPN   SORTLIB OPENED ?
         BZ    RCBCLOSD
         LA    R6,4(,R6)
         ST    R1,0(,R6)
RCBCLOSD LA    R1,SYSLMOD
         TM    DCBOFLGS,DCBOFOPN   SYSLMOD OPENED ?
         BZ    RCBCLOSE
         LA    R6,4(,R6)
         ST    R1,0(,R6)
RCBCLOSE LA    R1,USERLIB
         TM    DCBOFLGS,DCBOFOPN   USERLIB OPENED ?
         BZ    RCBCLOSF
         LA    R6,4(,R6)
         ST    R1,0(,R6)
RCBCLOSF CR    R0,R6               ANY DCBS FOUND OPEN ?
         BE    RCBCLOSG            NO, BRANCH AROUND CLOSE
         MVI   0(R6),X'80'         TERMINATE CLOSELST
*
         CLOSE MF=(E,CLOSELST)
*
         LTR   R15,R15             CLOSE SUCCESSFULL ?
         BZ    RCBCLOSG            YES, BRANCH
*
         DC    H'0'                CLOSE FAILED, FORCE 0C1 ABEND FOR
*                                  DIAGNOSTIC PURPOSES
*
         DROP  R1
*
RCBCLOSG PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTICS REQUESTED ?
         BZ    RCBNOM4             NO, BRANCH
*
         DELETE EP=IERDM4          DELETE CONVERT MODULE
*
RCBNOM4  PPITEST  PPITEXCP+PPITWAIT  I/O TRACING MODULE LOADED ?
         BZ    RCBNOTE             NO, BRANCH
*
         DELETE EP=IERDTE          DELETE I/O TRACING MODULE
*
RCBNOTE  PPITEST  PPIEXTRT         EXTRACT ROUTINE ?
         BO    RCBEXTFR            YES, FREE CORE
         PPITEST  PPIEQUAL         EQUALS ROUTINE ?
         BZ    RCBEXIT             NO EQUALS AND NO EXTRACT
         LA    R0,96               EQUALS ROUTINE SIZE IS 96 BYTES
         B     RCBGETAD            GO GET ADDR OF ROUTINE TO FREE
*
RCBEXTFR LA    R0,0                SET TO SIZE OF THE EXTRACT ROUTINE
RCBGETAD ICM   R1,B'1111',PPIAXERT R1 -> EQUALS OR EXTRACT RTN
         BZ    RCBEXIT             PREVIOUSLY FREED, BRANCH
*
         FREEMAIN R,LV=(0),A=(1)   FREE EQUALS OR EXTRACT ROUTINE
*
*        EXIT PROCESSING
*
RCBEXIT  SR    R15,R15             ZERO RETURN CODE REG
         LTR   R7,R7               ERRORS DETECTED IN IERRCV/IERRCZ
*                                  OR SYNAD RTN ?
         BZ    RCBEXITX            NO, EXIT CLEANLY WITH RC=0
         PPITEST PPIERET           YES, USER ABEND REQUESTED ?
         BO    RCBEXITA            YES, BRANCH
         LA    R15,16              NO, SET A RETURN CODE OF 16
         B     RCBEXITX
*
*        ABEND OPTION REQUESTED
*        DETERMINE ABEND CODE
*
RCBEXITA LH    R1,PPIABC           R1 = DEFAULT ABEND CODE
         PPITEST PPIABMSG          USE MESSAGE NO FOR ABEND CODE ?
         BZ    RCBEXITB            NO, BRANCH
*
*        MSG CODE TO BE USED AS ABEND CODE
*
         PACK  WORKD,PPIABMNO      PACK CHARACTER MSG NO
         CVB   R1,WORKD            R1 = BINARY VALUE OF MSG NO
         LTR   R1,R1               VALID ABEND CODE PROVIDED ?
         BNZ   RCBEXITB            YES, BRANCH
         LA    R1,801              NO, SET INTERNAL ERROR ABEND CODE
*
RCBEXITB ABEND (1)
*
*        NON ABEND RETURN WITH RC IN R15
*
RCBEXITX L     R13,4(,R13)         R13 -> CALLERS SAVE AREA
         LM    R2,R12,28(R13)      RESTORE R2 THROUGH R12
         L     R14,12(,R13)        RESTORE R14
         BR    R14                 RETURN TO CALLER
*
WORKD    DC    D'0'                WORKAREA FOR CVB INSTRUCTION
*
         DROP  R8
*
*---------------------------------------------------------------------
*
*        SYNAD EXIT FOR SYSOUT AND SORTDIAG
*
*---------------------------------------------------------------------
*
         USING *,R15
*
RCBSYNAD IERENTRY 'SYSOUT SYNAD &SYSDATE &SYSTIME'
*
         L     R8,AIERRCB          LOAD IERRCB ADDR
         DROP  R15
         USING IERRCB,R8
*
         SYNADAF ACSMETH=BSAM
*
         MVC   WTORCB+4(L'IER061),IER061  MOVE IN MSG HEADER
         LA    R2,WTORCB+L'IER061+4       R2 -> NEXT LOC TO MOVE TEXT
         MVC   0(L'RCBWTOH,R2),RCBWTOH    MOVE IN HEADER
         LA    R2,L'RCBWTOH(,R2)          BUMP TO NEXT AREA
         MVC   0(L'IER061C,R2),IER061C    I/O ERROR TEXT
         LA    R2,L'IER061C(,R2)          BUMP TO NEXT AREA
         MVC   0(61,R2),67(R1)     MOVE SYNAD BUILT MSG INTO WTO
*
         WTO   MF=(E,WTORCB)
*
         SYNADRLS
*
         MVC   PPIABMNO,IER061+3   MOVE MSG NO TO ABEND CODE
         LA    R7,1                SET R7 TO A NONZERO VALUE FOR ERROR
         B     RCBEXIT             BRANCH IERRCB EXIT
*
CLOSELST CLOSE (,,,,,,,,,),MF=L
*
*        DCBS
*
         PRINT NOGEN
*
*        SYSOUT DCB
*
SYSOUT   DCB   DSORG=PS,MACRF=(PM),DDNAME=SYSOUT,                      X
               RECFM=FBA,LRECL=121,SYNAD=RCBSYNAD
*
*        SORTDIAG DCB
*
SORTDIAG DCB   DSORG=PS,MACRF=(PM),DDNAME=SORTDIAG,                    X
               RECFM=FBA,LRECL=121,SYNAD=RCBSYNAD

*
SYSLMOD  DCB   DSORG=PO,MACRF=(E),DDNAME=SYSLMOD
*
USERLIB  DCB   DSORG=PO,MACRF=(E),DDNAME=USERLIB
*
SORTLIB  DCB   DSORG=PO,MACRF=(E),DDNAME=SORTLIB
*
         PRINT GEN
*
VIERRCA  DC    V(IERRCA)           ADDR OF PPI
AIERRCB  DC    A(IERRCB)           ADDR OF THIS MODULE FOR SYNAD EXIT
*
IER061   DC    C'IER061A '         MESSAGE NUMBER
IER061C  DC    C'I/O ERROR'        MESSAGE CONTINUATION
RCBWTOH  DC    CL18' '             COPY OF CPIWTOH FOR SYNAD USE
*
*        120 BYTE WTO MSG AREA
*
WTORCB   WTO   '                                                       X
                                                                       X
                        ',ROUTCDE=11,DESC=7,MF=L
*
*        MAP  DCB
*
         PRINT NOGEN
*
         DCBD  DSORG=(PS),DEVD=(DA,TA)
*
         PRINT GEN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
*        PPI
*
         SMPPI CSECT=YES
*
         SMCPI
*
         END
./ ADD NAME=IERRCC   0101-20211-20211-1200-00916-00916-00000-RELEASE 00
RCC      TITLE 'IERRCC - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRCC
*
*        MODULE FUNCTION/OPERATION -
*        OBTAIN SORT CONTROL STATEMENT INFORMATION, CHECK FOR
*        CERTAIN ERROR CONDITIONS, AND IF NONE, PASS THE
*        INFORMATION TO FOLLOWING ROUTINES VIA THE ADDRESS FIELDS
*        IN THE CPI
*        1.  READ AND STORE SORT CONTROL STATEMENTS
*            IF THE SORT HAS NOT BEEN ATTACHED THEN OPEN AND READ
*            SYSIN FOR CONTROL STATEMENTS.
*        2.  IF THE SORT HAS BEEN ATTACHED MOVE THE PROVIDED
*            ADDRESSES FROM THE ATTACH LIST TO THE
*            APPROPRIATE CPI FIELDS AND THEN OPEN AND READ
*            THE CONTROL STATEMENTS FROM SORTCNTL IF THE
*            DD STATEMENT HAS BEEN PROVIDED.
*            FINALLY FOR BOTH THE ATTACHED AND NON ATTACHED
*            ENVIRONMENT OPEN AND READ CONTROL STATEMENTS FROM
*            IERSORT DD STATEMENT IF IT HAS BEEN PROVIDED.
*        COMMENTS ON CONTINUATION RECORDS ARE REMOVED AND
*        CONTINUATION DATA IS CONCATENATED INTO A SINGLE
*        STRING FOR LATER ANALYSIS BY SUBSEQUENT MODULES.
*        COMMENT RECORDS MAY APPEAR ANYWHERE AND ARE DISCARDED
*
*        CHANGE LOG -
*        LIST ALL INPUT CONTROL STATEMENTS AS READ            REL 1.1
*        THE OPTION PARAMETER LIST/NOLIST IS NOW IMPLEMENTED
*        IN THE IERGAPRT ROUTINE IN IERRCM
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACROS USED -
*        SMCPI
*        OPEN
*        GET
*        CLOSE
*        DCB
*
*        ENTRY POINTS - ENTRY FROM - IERRCM
*                                    CALLING SEQUENCE -
*                                    L    R15,=V(IERRCC)
*                                    BALR R14,R15
*
*        INPUT - CPI FIELDS REFERENCED -
*        CPICNTL
*
*        OUTPUT - CPI FIELDS INITIALIZED OR ALTERED -
*        CPICNTL
*        SETS BITS IN CPICNTL INDICATING SORT OR MERGE ONLY AND
*        WHICH STATEMENTS ARE PRESENT
*
*        EXTERNAL ROUTINES -
*        V(IERGAPRT) - ERROR MESSAGE PRINT ROUTINE
*
*        EXITS - NORMAL
*        IERRCM - WITH ZERO RETURN CODE
*
*        EXITS - ERROR
*        IERGAPRT - MESSAGE WRITER
*        IERRCM - WITH A RETURN CODE OF 4
*
*        TABLES/WORK AREAS -
*        STMTAREA - 80 CHARACTER AREA INTO WHICH EACH STMT IS READ
*
IERRCC   CSECT
*
         ENTRY LCTOUC              LOWER -> UPPER CASE TR TABLE
*
         USING *,R11               PROGRAM BASE
         USING IERRC5,R13          CPI BASE
         USING DIERRCU,R4          MESSAGE CSECT
         USING IHADCB,R1
*
         IERENTRY 'IERRCC &SYSDATE &SYSTIME'
*
         STM   R14,R12,12(R12)     SAVE REGS IN IERRCM SAVE AREA
         LR    R11,R15             SET PROGRAM BASE
         ST    R12,RSAVE12         STORE R12
         L     R4,VIERRCU          R4 -> IERRCU MSG MODULE
*
*        GET THE TIOT ADDR
*
         EXTRACT TIOTADDR,'S',FIELDS=(TIOT)  GET ADDR OF TIOT
*
         L     R5,TIOTADDR         ESTABLIST BASE FOR TIOT DSECT
*
*        SORT ATTACHED ?
*
         CPITEST  CPIATT           SORT BEEN ATTACHED ?
         BZ    READSYS             NO, BRANCH TO READ SYSIN DD STMT
*
*----------------------------------------------------------------------
*
*        SORT HAS BEEN ATTACHED
*
*----------------------------------------------------------------------
*
*        EXAMINE STATEMENTS FROM ATTACHING PROGRAM
*
*        USER SUPPLIED POINTERS WERE MOVED TO THE CPI FIELDS BY
*        IERRCM. THESE POINTERS ARE CHECKED THAT ENTRY LENGTHS DO
*        NOT EXCEED THE LIMITS. IF THEY DO ERROR MESSAGE IER002
*        IS GENERATED AND PROCESSING TERMINATED
*
         MVI   IER070A,C' '
         MVC   IER070A+1(L'IER070A-1),IER070A   BLANK OUT MSG AREA
         MVC   IER070A(33),=CL33'from Program Parameter List'
         LM    R0,R1,IER070        LOAD PRINT OUT AREA ADDR
         L     R15,VGAPRT          R15 -> MSG WRITER RTN
         BASR  R14,R15             CALL MSG WRITER ROUTINE
         LA    R3,CPISSORT         R3 -> START/END ADDR OF SORT STMT
         BAS   R10,PROCESS         PROCESS PARAMETER STRING
         LA    R3,CPISRECD         R3 -> START/END ADDR OF RECORD STMT
         BAS   R10,PROCESS         PROCESS PARAMETER STRING
         LA    R3,CPISMODS         R3 -> START/END ADDR OF MODS STMT
         BAS   R10,PROCESS         PROCESS PARAMETER STRING
         LA    R3,CPISOPTR         R3 -> START/END ADDR OF OPTION STMT
         BAS   R10,PROCESS         PROCESS PARAMETER STRING
         LA    R3,CPISDEBG         R3 -> START/END ADDR OF DEBUG STMT
         BAS   R10,PROCESS         PROCESS PARAMETER STRING
         B     READCTL             ENTRIES OK, GOTO READ SORTCNTL DD
*
*----------------------------------------------------------------------
*
*        READ SYSIN DD CNTL STATEMENTS FOR NON ATTACHED SORT
*
*----------------------------------------------------------------------
*
READSYS  LA    R1,SYSIN            R1 -> INPUT DCB
         MVC   DCBDDNAM,=CL8'SYSIN'  SET DDNAME TO SYSIN
         BAS   R6,READIN           PROCESS SYSIN DD STMTS
         CLI   RETCODE+3,0         SUCCESSFUL SYSIN PROCESSING ?
         BNE   RLEAVE              NO, BRANCH TO EXIT
         B     READPARM            GO READ IERPARM DD STATEMENT
*
*----------------------------------------------------------------------
*
*        READ SORTCNTL DD CNTL STATEMENTS IF SORT ATTACHED
*
*----------------------------------------------------------------------
*
READCTL  LA    R1,SYSIN            R1 -> INPUT DCB
         MVC   DCBDDNAM,=CL8'SORTCNTL'  SET DDNAME TO SORTCNTL
         MVC   DCBDDNAM(4),CPIDDSRT  FOUR LETTER DDNAME PREFIX
READCTLB BAS   R6,READIN           PROCESS SORTCNTL DD STMTS
         CLI   RETCODE+3,0         SUCCESSFUL SORTCNTL PROCESSING ?
         BNE   RLEAVE              NO, BRANCH TO EXIT
*                                  GO READ IERPARM DD STATEMENT
*
*----------------------------------------------------------------------
*
*        READ IERPARM DD CNTL STATEMENTS FOR ALL CASES
*
*----------------------------------------------------------------------
*
READPARM LA    R1,SYSIN            R1 -> INPUT DCB
         MVC   DCBDDNAM,CPIPDDN    SET DDNAME TO CPIPDDN
READPARB BAS   R6,READIN           PROCESS IERPARM DD STMT
*
*----------------------------------------------------------------------
*
*        RETURN TO CALLER
*
*----------------------------------------------------------------------
*
*        BEFORE RETURN DETERMINE IF A SORT OR MERGE STMT HAS
*        BEEN PROCESSED
*
RLEAVE   CPITEST  CPISCARD+CPIMCARD  PROCESS A SORT OR A MERGE STMT ?
         BNZ   RLEAVEA             YES, EXIT
         L     R1,IER010           IER010A NO S/M STMT FOUND
         MVC   CPIABMNO,3(R1)      MOVE MSG NO INTO ABEND CODE
         LM    R0,R1,IER010        IER010A NO S/M STMT FOUND
         L     R15,VGAPRT          R15 -> MSG WRITER
         BASR  R14,R15             CALL MSG WRITER
         MVI   RETCODE+3,4         SET ERROR RETURN CODE
*
RLEAVEA  L     R15,RETCODE         SET RETURN CODE
         L     R12,RSAVE12         RESTORE REGS
         L     R14,12(,R12)
         LM    R0,R11,20(R12)
         BR    R14                 RETURN
*
*----------------------------------------------------------------------
*
*        READ INPUT ROUTINE FOR SYSIN, SORTCNTL AND IERPARM
*
*----------------------------------------------------------------------
*
*        INITIALIZE POINTERS AND SWITCHES FOR USE WITHIN THE
*        INPUT READ ROUTINE
*        SCAN TIOT FOR DDNAME BEFORE ATTEMPTING OPEN
*        IF NOT FOUND RETURN TO CALLER
*
*        ON ENTRY
*        R1 -> DCB
*
READIN   MVI   RERRORSW,X'00'      SET ERROR SWITCH OFF
         MVI   STMTSW,X'00'
         MVI   WCOMSW,X'00'        SET COMMENT SWITCH OFF
         MVI   WDONE,X'00'         SET 'WORKING ON' SWITCH OFF
         MVI   WCOL16,X'00'        SET COLUMN 16 SWITCH OFF
         LA    R3,60               INITIALIZE TOTAL STMT COUNT
         MVC   IER063A,DCBDDNAM    IN CASE OF ERROR
         LA    R0,EODSYSIN         RESET EOD ADDR
         STCM  R0,B'0111',DCBEODA
         L     R5,TIOTADDR         R5 -> TIOT
*
         USING TIOT1,R5
*
         SR    R15,R15
READINA  CLC   TIOEDDNM,DCBDDNAM   TIOT ENTRY FOUND ?
         BE    READINB             YES, PROCESS
         IC    R15,TIOELNGH        L'CURRENT TIOT ENTRY
         AR    R5,R15              INCR TO NEXT TIOT ENTRY
         CLI   TIOELNGH,0          L'NEXT TIOT ENTRY = 0 ?
         BNE   READINA             NO, PROCESS NEXT TIOT ENTRY
         BR    R6                  NO TIOT ENTRY, RETURN TO CALLER
*
         DROP  R5
*
READINB  L     R8,CPINCNTL         R8 -> NEXT CNTL STMT STORAGE AREA
         MVI   IER070A,C' '
         MVC   IER070A+1(L'IER070A-1),IER070A   BLANK OUT MSG AREA
         MVC   IER070A(19),=CL19'Input from DD Name '
         MVC   IER070A+19(8),DCBDDNAM  DDNAME
         LM    R0,R1,IER070        LOAD PRINT OUT AREA ADDR
         L     R15,VGAPRT          R15 -> MSG WRITER RTN
         BASR  R14,R15             CALL MSG WRITER ROUTINE
*
         OPEN  (SYSIN,INPUT)       OPEN SYSIN DCB
*
*        CHECK FOR SUCCESSFUL OPEN OF SYSIN
*        IF NOT SUCCESSFUL GENERATE ERROR MSG IER063
*
         LTR   R15,R15             OPEN SUCCESSFUL ?
         BZ    RREAD               YES, BRANCH
*                                  DATA SET FAILED TO OPEN
         L     R1,IER063
         MVC   CPIABMNO,3(R1)      MOVE MSG NO INTO ABEND CODE
         LM    R0,R1,IER063        IER063A OPEN ERROR - SYSIN
         L     R15,VGAPRT
         BASR  R14,R15             CALL ERROR MESSAGE
         MVI   RETCODE+3,4         SET ERROR CODE
         BR    R6                  RETURN TO CALLER
*
*        READ INPUT RECORDS INTO STMTAREA
*
*        IF END OF DATA GOTO LAST STMT ROUTINE
*        CHECK FOR BLANK FIRST COLUMN FOLLOWED BY STMT DEFINER
*
RREAD    LA    R7,70               INITIALIZE COLUMN COUNT
         LA    R9,STMTAREA         R9 -> STMTAREA
*
         GET   SYSIN,STMTAREA      GET NEXT STMT
*
         BAS   R10,CNTLPRT         CALL CONTROL STMT PRINT ROUTINE
         CLI   STMTAREA,C'*'       COMMENT RECORD ?
         BE    RREAD               YES, DISCARD RECORD
RREADA   BCT   R3,RNEXT            60 STMTS BEEN READ ?
         B     RERROR18            YES, ERROR EXIT 18
*
RNEXT    CLI   STMTAREA,C' '       COLUMN ONE BLANK ?
         BE    RRBLOOP             YES, LOOP TO DISCARD ALL BLANKS
*
*        COLUMN 1 NOT BLANK, SKIP OVER LABEL
*
         LA    R15,70              SET LABEL CHAR COUNT
RRLLOOP  CLI   0(R9),C' '          END OF LABEL ?
         BE    RRBLOOP
         LA    R9,1(,R9)           INCREMENT COLUMN COUNTER
         BCTR  R7,0                DECREMENT COLUMN COUNT
         BCT   R15,RRLLOOP
         B     RERROR1
RCOMPARE CLI   0(R9),C' '          SEARCH FOR NON BLANKS
         BNE   RTEST               BLANKS FOUND, TEST FOR STMT DEF
RRBLOOP  LA    R9,1(,R9)           INCREMENT COLUMN COUNTER
         BCT   R7,RCOMPARE         DECREMENT COLUMN COUNT
         B     RERROR11            WHOLE STMT BLANK, ERROR EXIT 11
*
*        FOUND A NON BLANK, TEST FOR A SUPPORTED KEYWORD
*
*        IF NONE OF THE SUPPORTED KEYWORDS BRANCH TO RERROR7
*
RTEST    ST    R9,STRPTR           SAVE ADDR OF KEYWORD
         CLC   KWSORT,0(R9)        SORT ?
         BE    RSORT               YES, BRANCH TO PROCESS
         CLC   KWMERGE,0(R9)       MERGE ?
         BE    RMERGE              YES, BRANCH TO PROCESS
         CLC   KWRECORD,0(R9)      RECORD ?
         BE    RRECORD             YES, BRANCH TO PROCESS
         CLC   KWMODS,0(R9)        MODS ?
         BE    RMODS               YES, BRANCH TO PROCESS
         CLC   KWOPTION,0(R9)      OPTION ?
         BE    ROPTION             YES, BRANCH TO PROCESS
         CLC   KWDEBUG,0(R9)       DEBUG ?
         BE    RDEBUG              YES, BRANCH TO PROCESS
         CLC   KWEND,0(R9)         END ?
         BE    RCCEND              YES, BRANCH TO PROCESS
         CLC   KWINPFIL,0(R9)      INPFIL ?
         BE    RCHECK              YES, BRANCH TO DISCARD
         CLC   KWOUTFIL,0(R9)      OUTFIL ?
         BE    RCHECK              YES, BRANCH TO DISCARD
         B     RERROR7             INVALID KEYWORD, GOTO ERROR EXIT7
*
*        PROCESS SORT CONTROL STATEMENT
*
*        SET THE SORTCARD FLAG IN CPICNTL AND UPDATE THE COLUMN
*        POINTER TO THE WORK AREA
*
RSORT    CLI   0(R9),C' '          SEARCH FOR BLANK FOLLOWING SORT
         BE    RSET1               GO SET BIT IN CPICNTL
         LA    R9,1(,R9)           UPDATE POINTER
         BCT   R7,RSORT            DECREMENT COLUMN COUNT
         B     RERROR14            NOT BLANK, ERROR EXIT 14
*
RSET1    CPISETON CPISCARD         SET SORT FLAG IN CPICNTL
*
*        USED BY BOTH SORT AND MERGE RECORD STATEMENTS
*
*        TEST FOR ALREADY PROCESSED SORT/MERGE STMTS, PLACE
*        ADDR OF STARTING POINT INTO THE CPI FIELDS AND
*        INITIALIZES THE CONTINUATION COUNT (R2)
*
RCOMMON  TM    WDONE,WDSORT        SORT/MERGE STMTS BEEN PROCESSED ?
         BO    RERROR8             YES, ERROR EXIT 8
         MVI   STMTSW,STMTSORT     INDICATE WORKING ON SORT/MERGE STMT
         OI    WDONE,WDSORT        INDICATE S/M STMT PROCESSED
         ST    R8,CPISSORT         PLACE STARTING ADDR IN CPI
         LA    R2,20               INITIALIZE CONTINUATION COUNTER
         B     RCONT               BRANCH TO FURTHER CHECKS
*
*        PROCESS MERGE CONTROL STATEMENT
*
*        UPDATE POINTER TO COLUMN AND SETS BIT IN CPICNTL FOR
*        MERGE
*
RMERGE   CLI   0(R9),C' '          UPDATE POINTER TO COLUMN
         BE    RSET2               GO SET MERGE BIT IN CPICNTL
         LA    R9,1(,R9)
         BCT   R7,RMERGE           IF COLUMN 71 EXCEEDED, GOTO ERROR
         B     RERROR14            EXIT 14
*
RSET2    CPISETON CPIMCARD         SET MERGE BIT IN CPI
         B     RCOMMON             GOTO COMMON ROUTINE
*
*        PROCESS MODS CONTROL STATEMENT
*
*        UPDATES POINTER, TURNS ON MODS FLAG IN CPI, AND
*        INITIALIZES CONTINUATION COUNT
*
RMODS    CLI   0(R9),C' '          UPDATE POINTER
         BE    RSET3               NO MOD, BRANCH
         LA    R9,1(,R9)
         BCT   R7,RMODS            UPDATE COUNTER
         B     RERROR14            GOTO PRINT DEFINER ERROR
*
RSET3    TM    WDONE,WDMODS        MODS STMT BEEN PROCESSED ?
         BO    RERROR8             YES, BRANCH
         MVI   STMTSW,STMTMODS     INDICATE WORKING ON MODS STMT
         CPISETON CPIMODCD         SET MOD BIT IN CPI
         ST    R8,CPISMODS         STORE STARTING ADDR IN CPI FIELD
         LA    R2,20               INITIALIZE CONTNUATION COUNTER
         B     RCONT               CONTINUE AT RCONT
*
*        PROCESS RECORD CONTROL STATEMENT
*
*        UPDATES POINTER, TURNS ON RECORD FLAG IN CPICNTL, AND
*        INITIALIZES CONTINUATION COUNT
*
RRECORD  CLI   0(R9),C' '          UPDATE POINTER
         BE    RSET4
         LA    R9,1(,R9)
         BCT   R7,RRECORD
         B     RERROR14
*
RSET4    TM    WDONE,WDRECORD      RECORD STMT BEEN PROCESSED ?
         BO    RERROR8             YES, ERROR EXIT8
         MVI   STMTSW,STMTREC      INDICATE WORKING ON RECORD STMTS
         CPISETON CPIRCARD         SET RECORD FLAG IN CPI
         ST    R8,CPISRECD         STORE STARTING ADDR IN CPI FIELD
         LA    R2,20               INITIALIZE CONTINUATION COUNTER
         B     RCONT               CONTINUE
*
*        CHECK REMAINDER OF THE STMT FOR CONTINUATION, COMMENTS.
*        MOVE STMT IMAGES FROM INPUT WORK AREA TO CONTROL AREA
*        STORAGE AND UPDATES ENDING ADDR,
*        COUNTS CONTINUATION STMTS
*
RCONT    CLI   0(R9),C' '          MORE NON BLANKS ?
         BNE   RMOREBL             YES, GOTO RMOREBL
         LA    R9,1(,R9)           NO, INCREMENT POINTER AND KEEP
         BCT   R7,RCONT            SEARCHING
         B     RERROR14            IF EXCEED COL 71 ERROR EXIT 14
*
RMOREBL  CLI   0(R9),C' '          OPERAND FOUND, SEARCH FOR BLANKS
         BE    RCOMMA              YES, GOTO RCOMMA
         LA    R9,1(,R9)           UPDATE POINTER
         BCT   R7,RMOREBL          KEEP SEARCHING FOR BLANKS
*
*        DROPPED OUT OF BLANK SEARCH LOOP WITH R9 -> COL 72
*
         CLI   0(R9),C' '          COLUMN 72 BLANK ?
         BNE   RMOVE2              NO, GOTO REMOV2
RMOVE1   CLI   WCOL16,X'00'        COL 16 SWITCH ON ?
         BNE   RMOVE3              YES, BRANCH
         L     R15,STRPTR          R15 -> KEYWORD IN STATEMENT AREA
         LA    R14,STMTAREA+70     R14 -> LAST BYTE
         SR    R14,R15             R14 = NUMBER OF BYTES TO MOVE
         EX    R14,EXMVC1          MOVE DATA INTO DICT AREA
         AR    R8,R14              UPDATE POINTER TO END OF ENTRY
RWHICH   CLI   STMTSW,STMTSORT     SORT/MERGE STMT ?
         BE    RSTORE1             YES, GOTO RSTORE1
         CLI   STMTSW,STMTREC      RECORD STMT ?
         BE    RSTORE2             YES, GOTO RSTORE2
         CLI   STMTSW,STMTMODS     MODS STMT ?
         BE    RSTORE3             YES, GOTO RSTORE3
         CLI   STMTSW,STMTOPT      OPTIONS STMT ?
         BE    RSTORE4             YES, GOTO RSTORE4
         CLI   STMTSW,STMTDEB      DEBUG STMT ?
         BE    RSTORE5             YES, GOTO RSTORE5
         B     RERROR7             NO FLAG SET, ERROR
*
RMOVE3   MVC   0(56,R8),STMTAREA+15  MOVE CHARS FROM COL 16-71 TO DICT
         LA    R8,55(,R8)          UPDATE POINTER TO END OF ENTRYZ
         B     RWHICH              BRANCH TO TEST TYPE OF STMT
*
*----------------------------------------------------------------------
*
*        COMPLETE PROCESSING FOR A SPECIFIC CONTROL STATEMENT
*
*----------------------------------------------------------------------
*
RSTORE1  ST    R8,CPIESORT         STORE ENDING ADDR FOR SORT/MERGE
         OI    WDONE,WDSORT        INDICATE SORT/MERGE PROCESSED
         B     RRETURN             READ ANOTHER RECORD
*
RSTORE2  ST    R8,CPIERECD         STORE ENDING ADDR FOR RECORD STMT
         OI    WDONE,WDRECORD      INDICATE RECORD PROCESSED
         B     RRETURN             READ ANOTHER RECORD
*
RSTORE3  ST    R8,CPIEMODS         STORE ENDING ADDR FOR MODS STMT
         OI    WDONE,WDMODS        INDICATE MODS PROCESSED
         B     RRETURN             READ ANOTHER RECORD
*
RSTORE4  ST    R8,CPIEOPTR         STORE ENDING ADDR FOR OPTIONS STMT
         OI    WDONE,WDOPTION      INDICATE OPTIONS PROCESSED
         B     RRETURN             READ ANOTHER RECORD
*
RSTORE5  ST    R8,CPIEDEDB         STORE ENDING ADDR FOR DEBUG STMT
         OI    WDONE,WDDEBUG       INDICATE DEBUG PROCESSED
         B     RRETURN             READ ANOTHER RECORD
*
RRETURN  LA    R8,1(,R8)           UPDATE POINTER TO NEXT START ADDR
         ST    R8,CPINCNTL         UPDATE NEXT TO USE CNTL AREA ADDR
RRETURNA MVI   STMTSW,0            CLEAR SWITCH
         MVI   WCOL16,0            CLEAR COLUMN 16 SWITCH
         B     RREAD               READ ANOTHER RECORD
*
RCOMMA   BCTR  R9,0                THE PREVIOUS CHARACTER A COMMA ?
         CLI   0(R9),C','
         BE    RCHECK72            YES, CHECK COL 72 FOR BLANKS
         CLI   STMTAREA+71,C' '    COL 72 BLANKS ?
         BE    RMOVE1              YES, MOVE TO DICTIONARY
         MVI   WCOMSW,X'01'        NO, TURN ON COMMENT SWITCH
*
*        MOVE CHARACTERS FROM THE WORK AREA TO THE DICTIONARY
*
RMOVE2   L     R15,STRPTR
         LA    R14,STMTAREA+70     R14 -> LAST BYTE
         SR    R14,R15             R14 = L'DATA
         EX    R14,EXMVC1          MOVE DATA
         AR    R8,R14              UPDATE DICT PTR
RENTRY   BCT   R2,RREAD2           IF TOO MANY STMTS, ERROR EXIT 8
         B     RERROR8             GOTO PRINT EXCESS STMTS
*
RREAD2   LA    R1,SYSIN
         MVC   DCBEODA,ERROR16X    SET UP END OF STMTS ROUTINE
*                                  (RERROR16) INTO DCB FOR GET
*
         GET   SYSIN,STMTAREA      READ NEXT RECORD FROM SYSIN
*
         LA    R1,SYSIN
         MVC   DCBEODA,EODSYSX     RESET END OF STMTS ADDR
         BAS   R10,CNTLPRT         CALL CONTROL STMT PRINT ROUTINE
         CLI   STMTAREA,C'*'       COMMENT RECORD ?
         BE    RREAD2              YES, DISCARD
         BCT   R3,RNEXT1           RECORDS EXCEEDED 60 ?
         B     RERROR18            YES, ERROR EXIT 18
*
RNEXT1   LA    R7,15               REINITIALIZE COLUMN COUNT
         LA    R9,STMTAREA         REINITIALIZE COLUMN POINTER
RBLANKS  CLI   0(R9),C' '          COLS 1-15 BLANK ?
         BNE   RERROR3             NO, ERROR EXIT 3
         LA    R9,1(,R9)           INCREMENT POINTER
         BCT   R7,RBLANKS          DECREMENT COLUMN COUNT
         MVI   WCOL16,X'01'        COLS 1-15 BLANK, TURN ON COL 16 SW
         CLI   WCOMSW,X'00'        COMMENT SWITCH ON ?
         BE    REINIT              NO, RESET COL COUNT, GOTO INIT
RCOL72   CLI   STMTAREA+71,C' '    COLUMN 72 BLANK ?
         BNE   RENTRY              NO, READ UNTIL ALL COMMENTS DONE
         MVI   WCOMSW,X'00'        YES, TURN OFF COMMENT SWITCH
         B     RWHICH              GOTO RWHICH
*
REINIT   CLI   STMTAREA+15,C' '    COLUMN 16 BLANK ?
         BE    RTURNON             YES, GOTO RTURNON
         LA    R7,56               RESET COLUMN COUNT
         LA    R15,STMTAREA+15     R15 -> FIRST BYTE OF CONT RECORD
         ST    R15,STRPTR          INIT STRPTR TO FIRST CHAR
         B     RMOREBL             GOTO RMOREBL
*
RTURNON  MVI   WCOMSW,X'01'        TURN ON COMMENT SWITCH
         B     RCOL72              BRANCH TO CHECK COL 72
*
RCHECK72 CLI   STMTAREA+71,C' '    COLUMN 72 BLANK ?
         BE    RERROR15            YES, ERROR EXIT 15
         LA    R9,1(,R9)           RESET POINTER IN STMTAREA
         L     R15,STRPTR          R15 -> KEYWORD/CONT TEXT POSITION
         SR    R9,R15              FIND NUMBER OF CHARS TO MOVE
         EX    R9,EXMVC1           MOVE TEXT OUT OF STATEMENT AREA
         AR    R8,R9               UPDATE DICT PTR BY NO BYTES MOVED
         B     RENTRY              CHECK STMT COUNT
*
*----------------------------------------------------------------------
*
*        PROCESS OPTION CONTROL STATEMENT
*
*----------------------------------------------------------------------
*
*        UPDATES POINTER, TURNS ON OPTION FLAG IN CPICNTL, AND
*        INITIALIZES CONTINUATION COUNT
*
ROPTION  CLI   0(R9),C' '          UPDATE POINTER
         BE    RSET5
         LA    R9,1(,R9)
         BCT   R7,ROPTION
         B     RERROR14
*
RSET5    TM    WDONE,WDOPTION      OPTION STMT BEEN PROCESSED ?
         BO    RERROR8             YES, ERROR EXIT8
         MVI   STMTSW,STMTOPT      INDICATE WORKING ON OPTION STMTS
         CPISETON CPIOSTMT         SET OPTION FLAG IN CPI
         ST    R8,CPISOPTR         STORE STARTING ADDR IN CPI FIELD
         LA    R2,20               INITIALIZE CONTINUATION COUNTER
         B     RCONT               CONTINUE
*
*----------------------------------------------------------------------
*
*        PROCESS DEBUG CONTROL STATEMENT
*
*----------------------------------------------------------------------
*
*        UPDATES POINTER, TURNS ON DEBUG FLAG IN CPICNTL, AND
*        INITIALIZES CONTINUATION COUNT
*
RDEBUG   CLI   0(R9),C' '          UPDATE POINTER
         BE    RSET6
         LA    R9,1(,R9)
         BCT   R7,RDEBUG
         B     RERROR14
*
RSET6    TM    WDONE,WDDEBUG       DEBUG STMT BEEN PROCESSED ?
         BO    RERROR8             YES, ERROR EXIT8
         MVI   STMTSW,STMTDEB      INDICATE WORKING ON DEBUG STMTS
         CPISETON CPIDSTMT         SET CPIDSTMT FLAG IN CPI
         ST    R8,CPISDEBG         STORE STARTING ADDR IN CPI FIELD
         LA    R2,20               INITIALIZE CONTINUATION COUNTER
         B     RCONT               CONTINUE
*
*----------------------------------------------------------------------
*
*        ERROR MESSAGE GENERATION
*
*----------------------------------------------------------------------
*
RERROR1  EQU   *
RERROR3  LM    R0,R1,IER001        IER001A COL 1 OR 1-15 NOT BLANK
         B     RPRINT
*
RERROR8  LM    R0,R1,IER002        IER002A EXCESS STMTS OR PARM
         B     RPRINT
*
RERROR7  EQU   *
RERROR11 LM    R0,R1,IER005        IER005A STMT DEFINER ERR
         B     RPRINT
*
RERROR14 LM    R0,R1,IER006        IER006A OP DEFINER ERR
         B     RPRINT
*
RERROR15 LM    R0,R1,IER004        IER004A ILLEGAL OP DELIMITER
         B     RPRINT
*
RERROR16 LM    R0,R1,IER003        IER003A NO CONTINUATION STMT
         B     RPRINT2
*
RPRINT1  L     R15,VGAPRT
         BASR  R14,R15             CALL PRINT ROUTINE
         LR    R1,R0
         MVC   CPIABMNO,3(R1)      MOVE MSG NO INTO ABEND CODE
         MVI   RERRORSW,X'01'      SET ERROR SWITCH ON
         B     RRETURN1            RETURN
*
RPRINT2  L     R15,VGAPRT
         BASR  R14,R15             CALL PRINT ROUTINE
         LR    R1,R0
         MVC   CPIABMNO,3(R1)      MOVE MSG NO INTO ABEND CODE
         MVI   RERRORSW,X'01'      TURN ON ERROR SWITCH
         B     EODSYSIN            GOTO EODSYSIN
*
RPRINT   L     R15,VGAPRT
         BASR  R14,R15             CALL PRINT ROUTINE
         LR    R1,R0
         MVC   CPIABMNO,3(R1)      MOVE MSG NO INTO ABEND CODE
         MVI   RERRORSW,X'01'      TURN ON ERROR SWITCH
*
RCHECK   CLI   STMTAREA+71,C' '    COLUMN 72 BLANK ?
         BE    RRETURNA            IF BLANK, READ ANOTHER STMT
*
         GET   SYSIN,STMTAREA      GET NEXT STMT
*
         BAS   R10,CNTLPRT         CALL CONTROL STMT PRINT ROUTINE
         BCT   R3,RCHECK           HAVE 60 RECORDS BEEN EXCEEDED ?
RERROR18 LM    R0,R1,IER002        IER002A - EXCESS STMTS OR PARA
         L     R15,VGAPRT
         BASR  R14,R15             CALL PRINT ROUTINE
         LR    R1,R0
         MVC   CPIABMNO,3(R1)      MOVE MSG NO INTO ABEND CODE
         MVI   RERRORSW,X'01'      TURN ON ERROR SWITCH
*
RREAD3   GET   SYSIN,STMTAREA      GET NEXT STMT
*
         BAS   R10,CNTLPRT         CALL CONTROL STMT PRINT ROUTINE
         CLI   STMTAREA,C'*'       COMMENT RECORD ?
         BE    RREAD3              YES, DISCARD
RREAD3A  CLI   STMTAREA,C' '       COLUMN ONE BLANK ?
         BNE   RREAD3              NO, READ ANOTHER STMT
         LA    R7,70               INITIALIZE COLUMN COUNT
         LA    R9,STMTAREA+1       INITIALIZE COLUMN POINTER
RCOMPAR1 CLI   0(R9),C' '          SEARCH FOR NON BLANK
         BNE   RTEST1              NOT BLANK BRANCH TO RTEST1
         LA    R9,1(,R9)           UPDATE POINTER
         BCT   R7,RCOMPAR1         DECREMENT COLUMN COUNT
         B     RREAD3              STMT BLANK, READ NEXT STMT
*
RTEST1   CLC   KWEND,0(R9)         END STMT ?
         BNE   RREAD3              NO, READ NEXT STMT
*
*        RETURN TO ROUTINE FROM WHICH THE READ ROUTINE WAS
*        CALLED. IT CHECKS THE ERROR SWITCH TO DETERMINE IF ANY
*        ERRORS HAD BEEN ENCOUNTERED. IF SO, IT PLACES A 4 IN
*        RETCODE
*
RRETURN1 CLI   RERRORSW,X'01'      ERROR SWITCH ON ?
         BNE   RRETURN2            NO, BRANCH
         MVI   RETCODE+3,4         YES, SET ERROR RETURN CODE
*
RRETURN2 CLOSE (SYSIN)             CLOSE SYSIN DCB
*
         LTR   R15,R15             SUCCESSFULL CLOSE ?
         BZ    RRETURN3            YES, BRANCH
*
         DC    H'0'                CLOSE FAILED FORCE 0C1 ABEND
*
RRETURN3 FREEPOOL SYSIN            FREE SYSIN QSAM BUFFERS
*
         BR    R6                  RETURN TO CALLER
*
*        END OF DATA DCB EXIT
*
EODSYSIN B     RRETURN1            RETURN
*
*        CHECK FOR CONTINUATION OR NO CONTINUATION ON END STMT
*        AND LEGALITY OF CONTINUATION IF PRESENT
*
RCCEND   CLI   STMTAREA+71,C' '    COLUMN 72 BLANK ?
         BE    EODSYSIN            YES, GOTO EODSYSIN
RCCGET   LA    R1,SYSIN
         MVC   DCBEODA,ERROR16X    SET UP END OF STMTS ROUTINE
*                                  (RERROR16) IN DCB
         GET   SYSIN,STMTAREA      GET NEXT STMT
*
         BAS   R10,CNTLPRT         CALL CONTROL STMT PRINT ROUTINE
         CLI   STMTAREA,C'*'       COMMENT RECORD ?
         BE    RCCGET              YES, DISCARD
         BCT   R3,RCC1TO15         60 RECORDS BEEN READ ?
         B     RERROR18            YES, ERROR
*
RCC1TO15 CLC   STMTAREA(15),KCCBLANK COLUMNS 1 TO 15 BLANK ?
         BNE   RERROR3             NO, BRANCH
         CLI   STMTAREA+71,C' '    COLUMN 72 BLANK ?
         BE    EODSYSIN            YES, GOTO EODSYSIN
         B     RCCGET              NO, GOTO GET ANOTHER STMT
*
*----------------------------------------------------------------------
*
*        PROCESS A PARAMETER STRING PASSED FROM PROGRAM PARAMETER LIST
*
*----------------------------------------------------------------------
*
*        THE PARAMETER STRING WILL BE:
*        MOVED TO THE STORAGE AREA
*        WRITTEN TO THE MESSAGE STREAM IF LIST OPTION IS ON
*        TRANSLATED TO UPPER CASE FOR LATER ANALYSIS
*        THE PARAMETER STRING START AND END ADDR WILL BE UPDATED
*        TO REFLECT THE NEW LOCATION IN THE STORAGE AREA
*        THE PTR TO THE NEXT AVAILABLE BYTE IN THE STORAGE AREA
*        WILL BE UPDATED TO THE NEXT AVAILABLE BYTE
*
*        INPUT -
*        R3 -> START ADDR OF PARAMETER STRING
*              END ADDR OF PARAMETER STRING
*
PROCESS  LM    R5,R6,0(R3)         R5 -> START OF PARAMETER
*                                  R6 -> END OF PARAMETER
         SR    R6,R5               CALC L'PARAMETER -1
         BZR   R10                 NO PARAMETER, RETURN TO CALLER
         BNP   PROCESSR            INCORRECT ADDRS, ERROR
         LA    R6,1(,R6)           CORRECT L'PARM
         C     R6,MAXPARM          EXCEED MAXIMUM LENGTH ?
         BH    PROCESSR            YES, ERROR
         L     R7,CPINCNTL         R7 -> NEXT TO USE STORAGE AREA
         ST    R7,0(,R3)           SET NEW START ADDR OF PARAMETER
*
*        START OF PROCESSING LOOP
*
PROCESSA C     R6,F71              MORE THAN 71 BYTES OF PARM ?
         BL    PROCESST            NO, BRANCH
*
*        MORE THAN 71 BYTES OF PARAMETER STRING
*        STEP BACKWARDS TO FIND A BLANK OR COMMA
*
         LA    R9,70
PROCESSF LA    R8,0(R5,R9)         R8 -> BYTE 71
         CLI   0(R8),C' '          BLANK ?
         BE    PROCESSC            YES, BRANCH
         CLI   0(R8),C','          COMMA
         BE    PROCESSC            YES, BRANCH
         BCT   R9,PROCESSF         DECR LENGTH
         B     PROCESSR            ERROR, BAD PARAMETER
*
*        PROCESS PART PARAMETER
*
PROCESSC EX    R9,PARMMVC          MOVE PART PARM TO STORAGE AREA
         MVI   IER070A,C' '
         MVC   IER070A+1(L'IER070A-1),IER070A   BLANK OUT MSG AREA
         EX    R9,MSGMVC           MOVE PARM PARM INTO IER070 MSG
         LM    R0,R1,IER070        LOAD PRINT OUT AREA ADDR
         L     R15,VGAPRT          R15 -> MSG WRITER RTN
         BASR  R14,R15             CALL MSG WRITER ROUTINE
         EX    R9,PARMTR           TRANSLATE PART PARM TO UPPERCASE
         LA    R9,1(,R9)
         LA    R5,0(R9,R5)         INCR INPUT PARM PTR
         LA    R7,0(R9,R7)         INCR STORAGE AREA PTR
         SR    R6,R9               DECR REMAINING CHARS IN PARM
         BZ    PROCESSX            ALL PROCESSED ? BRANCH
         B     PROCESSA            LOOP
*
*        PROCESS LAST PART OF PARAMETER
*
PROCESST LR    R9,R6
         BCTR  R9,0                DECR REMAINING COUNT
         B     PROCESSC
*
*        END OF PARAMETER PROCESSING
*
PROCESSX BCTR  R7,0                R7 -> LAST BYTE OF PARAMETER
         ST    R7,4(,R3)           UPDATE END OF PARAMETER ADDR
         LA    R7,1(,R7)
         ST    R7,CPINCNTL         UPDATE NEXT AVAILABLE STORAGE ADDR
         BR    R10                 RETURN TO CALLER
*
*        ERROR PROCESSING
*
PROCESSR L     R1,IER002
         MVC   CPIABMNO,3(R1)      MOVE MSG NO INTO ABEND CODE
         LM    R0,R1,IER002        IER002A EXCESS STMTS OR PARAMETER
         L     R15,VGAPRT
         BASR  R14,R15             CALL PRINT ROUTINE
         MVI   RETCODE+3,4         SET RETURN CODE
         B     RLEAVE              GOTO RETURN
*
*----------------------------------------------------------------------
*
*        LIST THE SORT CONTROL RECORDS
*        TRANSLATE LOWER CASE TO UPPER CASE AFTER LISTING
*
*----------------------------------------------------------------------
*
CNTLPRT  MVC   IER070A,STMTAREA    MOVE RECORD INTO MSG
         LM    R0,R1,IER070        LOAD PRINT OUT AREA ADDR
         L     R15,VGAPRT          R15 -> PRINT ROUTINE ADDR
         BASR  R14,R15             CALL MSG WRITER ROUTINE
CNTLPRTA TR    STMTAREA(72),LCTOUC  TRANSLATE LOWER CASE CHARS TO UPPER
         BR    R10                 RETURN TO CALLER
*
*----------------------------------------------------------------------
*
*        CONSTANTS AND WORK AREAS
*
*----------------------------------------------------------------------
*
VIERRCU  DC    V(IERRCU)           ADDR OF MESSAGE MODULE
VGAPRT   DC    V(IERGAPRT)         ADDR OF PRINT ROUTINE
*
EXMVC1   MVC   0(0,R8),0(R15)      MOVE DATA FROM STMTAREA TO DICT
PARMMVC  MVC   0(0,R7),0(R5)       MOVE PART PARM TO STORAGE AREA
MSGMVC   MVC   IER070A(0),0(R5)    MOVE PART PARM TO MESSAGE AREA
PARMTR   TR    0(0,R7),LCTOUC      TRANSLATE LOWER CASE CHARS TO UPPER
KCCBLANK DC    CL15' '             15 BLANKS
*
STMTAREA DC    CL80' '             80 BYTE INPUT READ AREA
STRPTR   DC    A(0)                -> FIRST SIGNIFICANT NON BLANK IN
*                                     STATEMENT AREA
*
TIOTADDR DC    A(0)
RSAVE12  DC    F'0'                SAVE AREA FOR R12
RETCODE  DC    F'0'
MAXPARM  DC    F'1100'             MAXIMUM LENGTH PROGRAM PARAMETER
F71      DC    F'71'               MAXIMUM MSG SEGMENT
*
EODSYSX  DC    AL3(EODSYSIN)       SAVE ADDR OF SYSIN EOD ROUTINE
ERROR16X DC    AL3(RERROR16)       ERROR EOD SYSIN ADDR ROUTINE
*
WCOMSW   DC    X'00'               COMMENT SWITCH
*
STMTSW   DC    X'00'               WORKING ON SWITCH
STMTSORT EQU   X'01'
STMTMERG EQU   X'02'               NOT USED
STMTMODS EQU   X'04'
STMTREC  EQU   X'08'
STMTOPT  EQU   X'10'
STMTDEB  EQU   X'20'
*
WDONE    DC    X'00'               DONE WITH SWITCH
WDSORT   EQU   X'01'
WDMERGE  EQU   X'02'               NOT USED
WDRECORD EQU   X'04'
WDMODS   EQU   X'08'
WDOPTION EQU   X'10'
WDDEBUG  EQU   X'20'
*
RERRORSW DC    X'00'               ERROR SWITCH
WCOL16   DC    X'00'               COLUMN 16 SWITCH
*
*        CONTROL STMT KEYWORDS
*
KWSORT   DC    C'SORT '
KWMERGE  DC    C'MERGE '
KWRECORD DC    C'RECORD '
KWMODS   DC    C'MODS '
KWOPTION DC    C'OPTION '
KWDEBUG  DC    C'DEBUG '
KWEND    DC    C'END '
*
*        CONTROL STMT KEYWORDS
*        RECOGNIZED BUT NOT PROCESSED
*
KWINPFIL DC    C'INPFIL '          INPFILE  (DOS SORT CONTROL)
KWOUTFIL DC    C'OUTFIL '          OUTFILE  (DOS SORT CONTROL)
*
*        TRANSLATE TABLE
*        EBCDIC LOWER CASE TO UPPER CASE
*        ALL OTHER CHARS UNCHANGED
*
LCTOUC   DC    256AL1(*-LCTOUC)
         ORG   LCTOUC+X'81'
         DC    C'ABCDEFGHI'
         ORG   LCTOUC+X'91'
         DC    C'JKLMNOPQR'
         ORG   LCTOUC+X'A2'
         DC    C'STUVWXYZ'
         ORG
*
*        INPUT DCB FOR SYSIN, SORTCNTL AND IERPARM DD STATEMENTS
*
SYSIN    DCB   DSORG=PS,MACRF=(GM),RECFM=FB,LRECL=80,                  X
               DDNAME=SYSIN,EODAD=EODSYSIN
*
*        LTORG
*
         LTORG
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRCU SOURCE
*
*----------------------------------------------------------------------
*
DIERRCU  DSECT
*
         COPY IERRCUI
*
         PRINT NOGEN
*
*        MAP DCB
*
         DCBD  DSORG=(PS),DEVD=(DA,TA)
*
*        MAP TIOT
*
TIOT     DSECT
*
         IEFTIOT1
*
         PRINT GEN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMCPI
*
         END
./ ADD NAME=IERRCD   0101-20211-20211-1200-00403-00403-00000-RELEASE 00
RCD      TITLE 'IERRCD - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRCD
*
*        FUNCTION/OPERATION -
*        SCAN CONTROL RECORDS AND CHECK FOR SYNTAX ERRORS
*        THE FOLLOWING IS A LIST OF THE LEGAL KEYWORD SYNTAX
*
*        1. KEYWORD
*        2. KEYWORD=VALUE
*        3. KEYWORD=(VALUE, ... ,VALUE)
*
*        AS AN EXAMPLE THE CONTROL STATEMENT -                  COL 72
*                                                               V
*        SORT FIELDS=(21,10,CH,D,1,20,CH,A,31,30,CH,D),CKPT,    C
*        DYNALLOC=(2314,6)
*
*        WOULD RESULT IN THE FOLLOWING DATA STORED AT THE ADDR
*        POINTED TO BY CPIAFLDD
*        ASSUMING AN ADDR OF B1860
*
*                  NO OF FIELDS
*                  |NAME OF FIRST FIELD PADDED TO 8 CHARS WITH X'FF'
*                  ||                  NUMBER OF SUBFIELDS
*                  ||                  |VALUE OF EACH SUBFIELD PADDED
*                  ||                  ||     TO 8 CHARS WITH X'FF'
*                  VV                  VV
*                   F I E  L D S        2 1
*        0B1860   03C6C9C5 D3C4E2FF FF0CF2F1 FFFFFFFF
*        0B1870   FFFFF1F0 FFFFFFFF FFFFC3C8 FFFFFFFF
*        0B1880   FFFFC4FF FFFFFFFF FFFFF1FF FFFFFFFF
*        0B1890   FFFFF2F0 FFFFFFFF FFFFC3C8 FFFFFFFF
*        0B18A0   FFFFC1FF FFFFFFFF FFFFF3F1 FFFFFFFF
*        0B18B0   FFFFF3F0 FFFFFFFF FFFFC3C8 FFFFFFFF
*
*                      LAST SUBFIELD    START OF NEXT FIELD
*                      |                |
*                      V                V
*        0B18C0   FFFFC4FF FFFFFFFF FFFFC3C8 D2D7FFFF
*
*                      ZERO SUBFIELDS
*                      |
*                      |START OF NEXT FIELD
*                      ||
*                      ||                  NUMBER OF SUBFIELDS
*                      ||                  | VALUE OF EACH SUBFIELD
*                      ||                  | |     PADDED TO 8 CHARS
*                      ||                  | |     WITH X'FF'
*                      VV                  V V
*        0B18D0   FFFF00C4 E8D5C1D3 D3D6C302 F2F3F1F4
*        0B18E0   FFFFFFFF F6FFFFFF FFFFFFFF 00000000
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACROS USED BY MODULE - N/A
*
*        ENTRY POINTS - ENTRY FROM IERRCE FOR SORT/MERGE SCAN
*                       CALLING SEQUENCE -
*                       LA   R1,KSORT OR KMSERGE  ID FOR SCAN
*                       L    R15,=V(IERRCD)
*                       BALR R14,R15
*
*                     - ENTRY FROM IERRCG FOR RECORD SCAN
*                       CALLING SEQUENCE -
*                       LA   R1,KRECORD           ID FOR SCAN
*                       L    R15,=V(IERRCD)
*                       BALR R14,R15
*
*                     - ENTRY FROM IERRCH FOR MODS SCAN
*                       CALLING SEQUENCE -
*                       LA   R1,KMODS             ID FOR SCAN
*                       L    R15,=V(IERRCH)
*                       BALR R14,R15
*
*                     - ENTRY FROM IERRCX FOR OPTION SCAN
*                       CALLING SEQUENCE -
*                       LA   R1,KOPTION           ID FOR SCAN
*                       L    R15,=V(IERRCX)
*                       BALR R14,R15
*
*                     - ENTRY FROM IERRCX FOR DEBUG SCAN
*                       CALLING SEQUENCE -
*                       LA   R1,KDEBUG            ID FOR SCAN
*                       L    R15,=V(IERRCY)
*                       BALR R14,R15
*
*        INPUT - CPI FIELDS REFERENCED - N/A
*
*        OUTPUT - CPI FIELDS INITIALIZED OR ALTERED - N/A
*
*        EXTERNAL ROUTINES - EXTRN IERGAPRT - MESSAGE WRITER
*
*        EXITS - NORMAL - LA R15,0 SET NORMAL RETURN CODE
*                         BR R14   RETURN TO CALLER
*
*        EXITS - ERROR - LA R15,4 SET ERROR RETURN CODE
*                        BR R14  RETURN TO CALLER
*
*        TABLES/WORK AREAS -
*        THE CONTROL AREA IS USED AS TEMPORARY SCAN AREA FOR
*        THE CONDENSED IMAGE
*
*        NOTES -
*        THIS MODULE IS A COMPONENT OF SORT'S DEFINITION PHASE
*
IERRCD   CSECT
*
         USING *,R12
         USING IERRC5,R13
*
         IERENTRY 'IERRCD &SYSDATE &SYSTIME',REG=R12
*
         L     R6,VIERRCU          R6 -> MESSAGE TEXT MODULE
         USING DIERRCU,R6          SET ADDRESSABILITY TO IERRCU
         MVC   IER007A,0(R1)       PUT STMT ID IER007A - SYNTAX ERR
         MVC   IER008A,0(R1)       PUT STMT ID IER008A - FD OR VALUE
         MVC   IER009A,0(R1)       PUT STMT ID IER009I - EXCESS INFO
*
*        ON ENTRY -
*        R3 -> START OF STRING TO SCAN
*        R4 -> END OF STRING TO SCAN
*
         SR    R2,R2               ZERO BXH INCR
         LA    R4,1(,R4)           INCR END STRING ADDR
         MVI   SWITCH,X'00'        TURN OFF ALL SWITCHES
         XC    CDFDCNT,CDFDCNT     ZERO FIELD DEFINER COUNT
         L     R5,CPIAFLDD         R5 -> REDUCTION AREA
         LA    R5,1(,R5)           INCR REDUCTION AREA ADDR PAST
*                                  COUNT TO ADDR OF FIRST CONTROL FLD
*
*        DISCARD ANY LEADING BLANKS
*        DISCARD INITIAL CONTROL WORD
*        DISCARD ANY TRAILING BLANKS AFTER CONTROL WORD
*
CD001    CLI   0(R3),C' '          SCAN
         LA    R3,1(,R3)                FOR A
         BE    CD001                          NON BLANK
*
*        NON BLANK FOUND
*
CD002    CLI   0(R3),C' '          SCAN
         LA    R3,1(,R3)                FOR A
         BNE   CD002                          BLANK
*
*        BLANK FOUND
*
CD003    CLI   0(R3),C' '          SCAN
         BNE   CD004                    FOR A
         LA    R3,1(,R3)                      NON BLANK
         BXH   R4,R2,CD003         IF NOT FOUND BEFORE END OF STMT
         B     CDEE07              ERROR, BRANCH TO EE07
*
*        FOUND CONTROL FIELD
*        PROCESS CONTROL FIELD
*
CD004    BCTR  R3,0                BACKSPACE ONE CHARACTER
         C     R5,CPIAFLDX         FILLED REDUCTION AREA ?
         BNL   CDEE21              YES, BRANCH, ERROR
         L     R8,CDFDCNT          NO, GET FIELD DEFINER COUNT
         LA    R8,1(,R8)           INCR FD = FD + 1
         ST    R8,CDFDCNT          STORE UPDATED FIELD DEFINER COUNT
         XC    CDVLCNT,CDVLCNT     CLEAR VALUE COUNT (VC)
         LA    R10,9               I = 9
*
*        BEGIN LOOP TO MOVE CONTROL FIELD INTO REDUCTION AREA
*        INSPECT FOR VALID CONTROL FIELD TERMINATORS
*
CD005    LA    R3,1(,R3)           GET A CHARACTER FROM STMT
         BXLE  R4,R2,CD018         END OF STMT ? BRANCH TO CD018
         CLI   0(R3),C' '          BLANK ?
         BE    CD020               YES, BRANCH TO BLANK1
         CLI   0(R3),C','          COMMA ?
         BE    CD022               YES, BRANCH TO COMMA1
         CLI   0(R3),C')'          RIGHT BRACKET ?
         BE    CDEE04              YES, BRANCH TO RIGHT1
         CLI   0(R3),C'('          LEFT BRACKET ?
         BE    CD024               YES, BRANCH TO LEFT1
         CLI   0(R3),C'='          EQUAL ?
         BE    CD026               YES, BRANCH TO EQUALS1
         TM    SWITCH,SWITCHD      SWITCH D ?
         BO    CD017               ON, HAVE FD=XXXXXXXX
         MVC   0(1,R5),0(R3)       PUT A CHARACTER IN REDUCT AREA
         LA    R5,1(,R5)           REDUCT = REDUCT + 1
*
*        LIMIT CONTROL FIELD CHARACTER LENGTH
*
         BCT   R10,CD005           I = I - 1, IF NOT 0 LOOP FOR
*                                  NEXT CHARACTER
         B     CDEE13              IF 0, BRANCH TO EE13
*
*        VALID LEFT BRACKET FOUND
*
CD016    LR    R7,R5               SAVE VALUE COUNT ADDR
         LA    R5,1(,R5)           REDUCT = REDUCT + 1
         NI    SWITCH,255-SWITCHB-SWITCHC-SWITCHD TURN OFF SWITCH B,C,D
CD009    NI    SWITCH,255-SWITCHA  TURN OFF SWITCH A
         LA    R10,9               I = 9
         L     R8,CDVLCNT          GET VALUE COUNT
         LA    R8,1(,R8)           VC = VC + 1
         ST    R8,CDVLCNT          PUT UPDATED VALUE COUNT
CD010    LA    R3,1(,R3)           GET A CHARACTER FROM STMT
         BXLE  R4,R2,CD019         END OF STMT TAKE BRANCH TO EOC2
         CLI   0(R3),C' '          BLANK ?
         BE    CD021               YES, BRANCH TO BLANK2
         CLI   0(R3),C','          COMMA ?
         BE    CD023               YES, BRANCH TO COMMA2
         TM    SWITCH,SWITCHC      SWITCH C ON ?
         BO    CD011               ON, BRANCH
         TM    SWITCH,SWITCHB      SWITCH B ON ?
         BO    CDEE14              ON, BRANCH
CD011    CLI   0(R3),C')'          RIGHT BRACKET ?
         BE    CD025               YES, BRANCH TO RIGHT2
         CLI   0(R3),C'('          LEFT BRACKET ?
         BE    CDEE16              YES, BRANCH TO LEFT2
         CLI   0(R3),C'='          EQUALS ?
         BE    CDEE17              YES, BRANCH TO EQUALS2
         TM    SWITCH,SWITCHA      SWITCH A ON ?
         BO    CD012               ON, BRANCH
         OI    SWITCH,X'01'        NOT ON, TURN ON SWITCH A
CD012    MVC   0(1,R5),0(R3)       PUT A CHARACTER IN REDUCT AREA
         LA    R5,1(,R5)           REDUCT = REDUCT + 1
         BCT   R10,CD010           I = I - 1, IF ¬ 0 BRANCH
         B     CDEE18              ZERO, BRANCH TO EE18
*
CD017    MVI   SWITCH,SWITCHA+SWITCHB+SWITCHC  TURN ON SWA,SWB,SWC
*                                              TURN OFF SWD
         MVI   0(R5),X'01'         PUT VALUE COUNT = 1 IN REDUCT AREA
         LA    R5,1(,R5)           REDUCT = REDUCT + 1
         LA    R10,9               I = 9
         B     CD012               BRANCH TO PROCESS A VALUE
*
*        SCANNED TO END OF STMT
*
CD018    TM    SWITCH,SWITCHD      SWITCH D ON ?
         BO    CDEE01              ON, BRANCH
         BAS   R9,CDRUNONI         RUN DOWN I
         MVI   0(R5),0             PUT VALUE COUNT = 0 IN REDUCT AREA
*
*        RETURN TO CALLER
*
CD006    L     R15,CPIAFLDD        R15 -> FIELD COUNT LOCATION
         MVC   0(1,R15),CDFDCNT+3  PUT FIELD DEFINER COUNT IN REDUCT
         SR    R15,R15             SET RETURN CODE TO 0
         BR    R14                 RETURN
*
CD019    TM    SWITCH,SWITCHB      SWITCH B ON ?
         BZ    CDEE19              OFF, BRANCH TO EE19
         BAS   R9,CDRUNONI         RUN DOWN I
         B     CD006               BRANCH TO RETURN
*
CD020    TM    SWITCH,SWITCHD      SWITCH D ON ?
         BO    CDEE02              ON, BRANCH
         BAS   R9,CDRUNONI         RUN DOWN I
         MVI   0(R5),0             PUT VALUE COUNT = 0 IN REDUCT AREA
CD007    LA    R3,1(,R3)           GET A CHARACTER FROM STMT
         BXLE  R4,R2,CD006         END OF STMT ? BRANCH
         CLI   0(R3),C' '          NO, COMPARE FOR A BLANK
         BE    CD007               FOUND, CONTINUE TO LOOK FOR MORE
         LM    R0,R1,IER009        IER009I - EXCESS INFO ON STMT
         L     R15,VGAPRT          R15 -> PRT MSG RTN
         LR    R10,R14             SAVE R14
         BASR  R14,R15             CALL PRINT MSG RTN
         LR    R14,R10             RESTORE R14
         B     CD006               BRANCH TO RETURN
*
CD021    TM    SWITCH,SWITCHB      SWITCH B ON ?
         BZ    CDEE20              OFF, BRANCH TO EE20
         BAS   R9,CDRUNONI         RUN DOWN I
         B     CD007               BRANCH TO CHECK REST OF STMT
*
CD022    TM    SWITCH,SWITCHD      SWITCH D ON ?
         BO    CDEE03              ON, BRANCH TO EE03
         BAS   R9,CDRUNONI         RUN DOWN I
         MVI   0(R5),0             PUT VALUE COUNT = 0 IN REDUCT AREA
         LA    R5,1(,R5)           REDUCT = REDUCT + 1
CD008    LA    R3,1(,R3)           GET A CHARACTER FROM STMT
         BXLE  R4,R2,CDEE07        IF END OF STMT TAKE BRANCH
         CLI   0(R3),C' '          BLANK ?
         BE    CDEE08              YES, BRANCH
         CLI   0(R3),C','          COMMA ?
         BE    CDEE09              YES, BRANCH
         CLI   0(R3),C')'          RIGHT BRACKET ?
         BE    CDEE10              YES, BRANCH
         CLI   0(R3),C'('          LEFT BRACKET ?
         BE    CDEE11              YES, BRANCH
         CLI   0(R3),C'='          EQUALS ?
         BE    CDEE12              YES, BRANCH
         B     CD004               BRANCH TO PROCESS ANOTHER FD
*
*        FOUND A COMMA SEPARATOR
*
CD023    BAS   R9,CDRUNONI         RUN DOWN I
         TM    SWITCH,SWITCHB      SWITCH B ON ?
         BO    CD008               ON, BRANCH TO PROCESS ANOTHER FD
         TM    SWITCH,SWITCHC      SWITCH C ON ?
         BO    CD008               ON, BRANCH TO PROCESS ANOTHER FD
         B     CD009               OFF, BRANCH TO PROCESS ANOTHER VAL
*
*        FOUND A LEFT BRACKET
*
CD024    TM    SWITCH,SWITCHD      SWITCH D ON ?
         BO    CD016               ON, BRANCH TO PROCESS ANOTHER VAL
         B     CDEE05              OFF, BRANCH TO EE05
*
*        FOUND A RIGHT BRACKET
*
CD025    TM    SWITCH,SWITCHC      SWITCH C ON ?
         BO    CDEE15              ON, BRANCH TO EE15
         CLC   CDVLCNT+2(2),K256   VC = 256 ?
         BNE   CD0255              NO, BRANCH
         CPISETON CPIVALCT         YES, SET BIT FOR RCE
CD0255   MVC   0(1,R7),CDVLCNT+3   PUT VALUE COUNT IN REDUCT AREA
         OI    SWITCH,SWITCHB      TURN ON SWITCH B
         B     CD010               BRANCH TO LOOK FOR ANOTHER FD
*
*        FOUND AN =
*
CD026    TM    SWITCH,SWITCHD      SWITCH D ALREADY ON ?
         BO    CDEE06              ON, BRANCH TO CDEE06, ERROR
         OI    SWITCH,SWITCHD      OFF ,TURN IT ON AS VALID = FOUND
         BAS   R9,CDRUNONI         PAD OUT CONTROL FIELD
         B     CD005               BRANCH TO LOOK FOR A ( OR VALUE
*
*        PAD OUT ALL FIELDS DEFINERS VALUES WITH X'FF'S ON THE RIGHT
*        TO A LENGTH OF 8
*
CDRUNONI BCT   R10,CD015
         BR    R9
*
CD015    MVI   0(R5),X'FF'         PAD OUT REDUCTION AREA
         LA    R5,1(,R5)
         B     CDRUNONI
*
*        ERROR PROCESSING
*
CDEE01   EQU   *
CDEE02   EQU   *
CDEE03   EQU   *
CDEE04   EQU   *
CDEE05   EQU   *
CDEE06   EQU   *
CDEE07   EQU   *
CDEE08   EQU   *
CDEE09   EQU   *
CDEE10   EQU   *
CDEE11   EQU   *
CDEE12   EQU   *
CDEE14   EQU   *
CDEE15   EQU   *
CDEE16   EQU   *
CDEE17   EQU   *
CDEE19   EQU   *
CDEE20   LM    R0,R1,IER007        IER007A SYNTAX ERROR
         B     CDPRINT
*
CDEE13   EQU   *
CDEE18   LM    R0,R1,IER008        IER008A PARAMETER OR VALUE > 8 CHARS
         B     CDPRINT
*
CDEE21   LM    R0,R1,IER028        IER028A IER028A MORE THAN 17 EXITS
*
CDPRINT  L     R15,VGAPRT          R15 -> PRT MSG ROUTINE
         LR    R10,R14             SAVE R14
         BASR  R14,R15             CALL MSG WRITER
         LR    R1,R0               R1 -> MSG TEXT
         MVC   CPIABMNO,3(R1)      MOVE MSG NO INTO ABEND CODE
         LR    R14,R10             RESTORE R14
         LA    R15,4               SET RETURN CODE
         BR    R14                 RETURN TO CALLER
*
CDVLCNT  DC    F'0'
CDFDCNT  DC    F'0'
*
VGAPRT   DC    V(IERGAPRT)
VIERRCU  DC    V(IERRCU)
*
K256     DC    H'256'
*
SWITCH   DC    X'00'
SWITCHA  EQU   X'01'
SWITCHB  EQU   X'02'
SWITCHC  EQU   X'04'
SWITCHD  EQU   X'08'               FOUND AN =
*
DIERRCU  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRCU SOURCE
*
*----------------------------------------------------------------------
*
         COPY IERRCUI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMCPI
*
         END
./ ADD NAME=IERRCE   0101-20211-20211-1200-00868-00868-00000-RELEASE 00
RCE      TITLE 'IERRCE - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRCE
*
*        FUNCTION/OPERATION -
*        ANALYZE THE SORT/MERGE STMT AND PLACE THE RESULTS IN
*        THE CPI. THE FOLLOWING IS A LIST OF THE FIELDS ON THE
*        SORT/MERGE STMT AND WHERE THIS INFORMATION IS PLACED IN
*        CPI -
*        1. FIELDS   - CPIPCF01
*        2. FORMAT   - CPIPCF01
*        3. SIZE/    - CPIFILSZ
*           FILSZ
*        4. SKIPREC  - CPISKPRD
*        5. STOPAFT  - CPISTOPR
*        6. CKPT     - CPICNTL
*        7. DYNALLOC - CPIDYNA     DYNALLOC OFF OR ON
*                    - CPIDYND     DEVICE TYPE FOR DYNAMIC ALLOCATION
*                    - CPIDYNN     NUMBER OF DYNALLOC WORK DATA SETS
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACROS USED BY MODULE -
*        SMCPI
*        GETMAIN
*
*        ENTRY POINTS - ENTRY FROM SORT PHASE CONTROL
*                       CALLING SEQUENCE -
*                       L    RP,=V(IERRCE)
*                       BALR RO,RP
*
*        INPUT - CPI FIELDS REFERENCED - N/A
*
*        OUTPUT - CPI FIELDS INITIALIZED OR ALTERED -
*        CPIFILSZ
*        CPINUMCF
*        CPIPCF01
*        CPISKPRD
*
*        ALL THESE VALUES ARE TAKEN FROM THE SORT/MERGE STMT AND
*        MOVED INTO CPI
*
*        EXTERNAL ROUTINES -
*        EXTRN IERGAPRT - ERROR MSG PRINT ROUTINE
*        EXTRN IERRCD   - SCAN ROUTINE
*
*        EXITS - NORMAL - LA RP,0 SET NORMAL RETURN CODE
*                         BR RO   RETURN TO CALLER
*
*        EXITS - ERROR  - LA RP,4 SET ERROR RETURN CODE
*                         BR RO   RETURN TO CALLER
*
*        TABLES/WORK AREA -
*        CEFSLTAB - IDENTIFY CONTROL FIELD INFORMATION
*        KEYWORD  - IDENTIFY VALID FIELD DEFINERS
*
*        NOTES - THIS MODULE IS PART OF SORT'S DEFINITION PHASE
*        REGISTER USAGE FROM START OF MODULE TO FIELDS DEFINER
*
*        R0  - NOT USED
*        R1  - NOT USED
*        R2  - ADDR FOR SCAN, CRA = CRA + 8*VC + 1
*        R3  - ADDR FOR SCAN, NOT USED
*        R4  - ADDR FOR SCAN, NUMBER OF FIELD DEFINERS
*        R5  - ADDR FOR SCAN, NOT USED
*        R6  - NOT USED
*        R7  - NOT USED
*        R8  - CURRENT REDUCTION AREA ADDR
*        R9  - CURRENT FIELD DEFINER TABLE ADDR
*        R10 - I
*        R11 - BASE
*        R12 - NOT USED
*        R13 - ADDR OF PPI
*        R14 - NOT USED
*        R15 - NOT USED
*
IERRCE   CSECT
*
         USING *,R11
         USING IERRC5,R13
*
         IERENTRY 'IERRCE &SYSDATE &SYSTIME'
*
         STM   R2,R11,0(R12)       SAVE R2 - R11
         LR    R11,R15             SET PROGRAM BASE
         ST    R12,CESAVE12        SAVE R12
         ST    R14,CESAVE14        SAVE R14
         NI    SWITCH,X'00'        TURN OFF ALL PROGRAM SWITCHES
         CPITEST  CPISCARD         SORT STMT PRESENT ?
         BZ    CE001               NO, BRANCH TO MERGE STMT TEST
         LA    R1,KSORT            R1 -> SORT RECORD CONSTANT
         CPISETON CPIPH1+CPIPH2+CPIPH3  YES, SET PHASE 1, 2 AND 3 FLAGS
         B     CE002               BRANCH TO GET ADDR FOR SCAN
*
CE001    CPITEST  CPIMCARD         MERGE STMT PRESENT ?
         BZ    CEEE01              NO, BRANCH TO EE1
         LA    R1,KMERGE           R1 -> MERGE RECORD CONSTANT
         CPISETON CPIMERGO         SET MERGE ONLY
CE002    LM    R3,R4,CPISSORT      R3 = STRT OF SORT, R4 = END OF SORT
         L     R12,VIERRCD         R12 -> IERRCD
         BASR  R14,R12             CALL SCAN ROUTINE
         LTR   R15,R15             TEST RETURN CODE REGISTER
         BNZ   CE045               NOT ZERO, ERROR BRANCH TO RETURN
         L     R8,CPIAFLDD         R8 -> FIELD DEFINER/REDUCTION AREA
         CLI   0(R8),((KEYWORDE-KEYWORD)/KEYWORDL)  MORE FIELDS THAN
*                                  KEYWORD TABLE ENTRIES ?
         BH    CEEE02              YES, BRANCH TO EE2
         CLI   0(R8),0             ZERO FIELDS ?
         BE    CEEE03              YES, BRANCH TO EE03
         SR    R4,R4               CLEAR R4
         IC    R4,0(,R8)           R4 = NUMBER OF FIELDS
         LA    R8,1(,R8)           R8 -> TO FIRST FIELD
*
*----------------------------------------------------------------------
*
*        SCAN KEYWORDS SETUP IN REDUCTION AREA BY IERRCD
*
*----------------------------------------------------------------------
*
CE007    LA    R10,((KEYWORDE-KEYWORD)/KEYWORDL)  MAX ENTRIES IN TAB
         LA    R9,KEYWORD          R9 -> FIELD DEFINER KEYWORD TABLE
CE003    CLC   0(8,R9),0(R8)       MATCHING KEYWORD ENTRY ?
         BE    CE004               YES, BRANCH TO DEFINER CHECK
         LA    R9,KEYWORDL(,R9)    FDTAB = FDTAB + 14, NEXT ENTRY
         BCT   R10,CE003           I = I - 1, IF I ¬ 0 BRANCH
         B     CEEE04              NO KEYWORD MATCH, ERROR
*
CE004    TM    8(R9),X'01'         PREVIOUSLY DEFINED FLAG ON ?
         BO    CEEE05              YES, BRANCH TO EE5, DUP KEYWORD
         OI    8(R9),X'01'         SET DEFINED BIT ON
         LA    R8,8(,R8)           R8 -> SUBFIELD COUNT
         CLC   9(1,R9),0(R8)       MAXIMUM SUBFIELD COUNT EXCEEDED ?
         BL    CEEE06A             YES, ERROR
         STCM  R8,B'1111',10(R9)   PUT REDUCT ADDR IN FDTAB + 10
         BCT   R4,CE005            FD = FD - 1, IF ¬ 0 BRANCH
         B     CE006               FD = 0 BRANCH TO CHECK FIELDS
*
CE005    SR    R2,R2               CLEAR R2
         IC    R2,0(,R8)           R2 = SUBFIELD COUNT
         SLL   R2,3                MULT SUBFIELD COUNT BY 8
         LA    R8,1(R2,R8)         REDUCT = REDUCT + 8*VC + 1
         B     CE007               BRANCH TO PROCESS NEXT FIELD
*
*----------------------------------------------------------------------
*
*        PROCESS FIELDS KEYWORD
*
*----------------------------------------------------------------------
*
*        REGISTER USAGE
*
*        R0  - NOT USED
*        R1  - NOT USED
*        R2  - L' CALCULATIONS
*        R3  - L'
*        R4  - R
*        R5  - Q
*        R6  - RX, 4092
*        R7  - RX, CVD'ED INTO
*        R8  - AF - ADDR OF FIELDS DEFINER IN REDUCTION AREA
*        R9  - ADDR OF FORMAT DEFINER, ADDR OF FSL TABLE
*        R10 - I
*        R11 - BASE
*        R12 - CURRENT ADDR OF FIELDS AREA IN PPI
*        R13 - ADDRESS OF PPI
*        R14 - NOT USED
*        R15 - NOT USED
*
CE006    TM    KWFIELDS+8,X'01'    PRESENCE OF FIELDS DEFINER ?
         BZ    CEEE07              NO, BRANCH TO EE7
         ICM   R8,B'1111',KWFIELDS+10  GET ADDR OF FIELDS DEFINER - AF
         LA    R12,CPINUMCF        GET ADDR OF CPI TO BE FILLED IN
         TM    KWFORMAT+8,X'01'    PRESENCE OF FORMAT DEFINER ?
         BZ    CE008               NO, BRANCH
         CLI   0(R8),X'03'         COMPARE VC TO O
         BL    CEEE10              LOW, BRANCH TO EE10
         CLI   0(R8),X'C0'         FORMAT FD LOWERS MAX VC ALLOWED
         BH    CEEE06B             BRANCH IF 'FIELD' VC TOO HIGH
         LA    R3,3                PUT A 3 IN R3
         SR    R4,R4               CLEAR R4
         SR    R5,R5               CLEAR R5
         IC    R5,0(,R8)           PUT VC IN R5
         DR    R4,R3               QR = VC/3
         OI    SWITCH,SWITCHA      TURN ON SWITCH A
         ICM   R9,B'1111',KWFORMAT+10  R9 -> FORMAT DEFINER
         MVC   CEFSL(2),1(R9)      PUT FORMAT VALUE IN FORSEQL
         CLI   3(R9),X'FF'         THIRD FORMAT CHARACTER A X'FF' ?
         BNE   CEEE27              NO,  BRANCH TO EE27
         B     CE009               BRANCH TO PROCESS CONTROL FIELDS
*
CE008    CLI   0(R8),X'04'         COMPARE VC TO 4
         BL    CE0132
         LA    R3,4                PUT A 4 IN R3
         SR    R4,R4               CLEAR R4
         SR    R5,R5               CLEAR R5
         IC    R5,0(,R8)           PUT VC IN R5
         DR    R4,R3               QR = VC/4
CE009    LTR   R4,R4               R = 0 ?
         BNZ   CEEE09              NO, BRANCH TO EE9
         STH   R5,CPINUMCF         PUT Q IN NUMBER OF CONTROL FIELDS
         CH    R5,K12              > 12 CONTROL FIELDS
         BH    CE0125              YES
         LA    R12,2(,R12)         APPI = APPI+2
CE0095   LA    R8,1(,R8)           AF = AF+1
         SR    R3,R3               SET L' = 0
CE010    LA    R10,8               SET I = 8
         MVI   CEHLDBTS,X'00'      CLEAR HOLD BITS AREA
         SR    R6,R6               CLEAR R6 - RX
         SR    R7,R7               CLEAR R7 - RX
         CLI   0(R8),C'.'          (AF) = . ?
         BE    CEEE11              YES, BRANCH TO EE11
         CLI   0(R8),X'FF'         (AF) = X'FF' ?
         BE    CEEE12              YES, BRANCH TO EE12
CE011    CLI   0(R8),C'0'          COMPARE (AF) TO A 0
         BL    CEEE13              < '0', BRANCH TO EE13
         CLI   0(R8),C'9'
         BH    CEEE14              > '9', BRANCH TO EE14
         SLDL  R6,8                SHIFT RX LEFT 8 BITS
         IC    R7,0(,R8)           INSERT CHARACTER INTO RX
CE012    LA    R8,1(,R8)           AF = AF + 1
         BCT   R10,CE013           I = I - 1
         B     CE014               IF I = 0 BRANCH TO CONVERT ROUTINE
*
CE0125   MH    R5,K6               NO CF * 6 = SPACE REQ'D FOR
         STH   R5,WK               CONTROL FIELD INFORMATION
         TM    WK+1,X'07'
         BZ    CE0126
         NI    WK+1,X'F8'
         LH    R5,WK
         LA    R5,8(,R5)
CE0126   LR    R0,R5
*
         GETMAIN R,LV=(0)
*
         ST    R1,WK2              CORE AREA ADDR IS RETURNED IN R1
         LR    R12,R1              SAVE GETMAINED ADDR IN R12
         BCTR  R5,0
         MVI   0(R1),X'00'         ZERO OUT CF AREA
         CH    R5,K256             > 256 ?
         BNH   CE01266             NO, BRANCH
         MVC   1(256,R1),0(R1)     LARGEST VALUE OF AREA IS =
         LA    R1,256(,R1)         64 * 6
         SH    R5,K256
CE01266  BCTR  R5,0
         EX    R5,KMOVE
         MVC   CPIADDCF(3),WK2+1
         LH    R5,CPINUMCF
         B     CE0095
*
CE013    CLI   0(R8),C'.'          (AF) = . ?
         BE    CE015               YES, BRANCH
         CLI   0(R8),X'FF'         (AF) = X'FF' ?
         BE    CE012               EQUAL, BRANCH
         B     CE011               NOT EQUAL, GET ANOTHER CHAR
*
CE0132   CLI   0(R8),X'00'
         BNE   CEEE08
         CPITEST  CPIVALCT
         BZ    CEEE08
         LA    R5,64
         STH   R5,CPINUMCF
         B     CE0125
*
CE015    LA    R8,1(,R8)           AF = AF + 1
         BCT   R10,CE016           I = I - 1
         B     CE014               IF I = 0 BRANCH TO CONVERT ROUTINE
*
CE016    CLI   0(R8),X'FF'         (AF) = X'FF' ?
         BE    CE012               EQUAL, BRANCH TO RUN DOWN I
         CLI   0(R8),C'0'          (AF) = '0' ?
         BL    CEEE15              LOW, BRANCH LOW TO EE15
         CLI   0(R8),C'7'          (AF) = '7' ?
         BH    CEEE16              HIGH, BRANCH TO EE16
         NI    0(R8),X'0F'         'AND' OUT HIGH ORDER BITS
         MVC   CEHLDBTS(1),0(R8)   PUT BITS IN HOLD BITS AREA
         LA    R8,1(,R8)           AF = AF + 1
         BCT   R10,CE017           I = I - 1
         B     CE014               IF I = 0 BRANCH TO CONVERT ROUTINE
*
CE017    CLI   0(R8),X'FF'         (AF) = X'FF' ?
         BE    CE012               EQUAL, BRANCH TO RUN DOWN I
         B     CEEE17              NOT EQUAL, BRANCH TO EE17
*
CE014    STM   R6,R7,CEPACKA       STORE RX INTO PACK AREA
         PACK  CEPACKB,CEPACKA
         CVB   R7,CEPACKB          CONVERT TO BINARY AND PUT IN RX
         LTR   R7,R7               IS RX = 0
         BZ    CE018               ZERO,,BRANCH TO TEST FOR D OR L
         TM    SWITCH,SWITCHB      SWITCH B ON ?
         BO    CE019               ON, BRANCH TO COMPUTE L'
         LA    R6,4092             PUT 4092 IN R6
         CR    R7,R6               COMPARE RX TO 4092
         BH    CEEE18              HIGH, BRANCH TO EE18
         BCTR  R7,0                RX = RX - 1
         STH   R7,0(,R12)          PUT RX(BYTES) IN D FIELD OF PPI
         MVC   2(1,R12),CEHLDBTS   PUT D BITS IN D FIELD OF PPI
         OI    SWITCH,SWITCHB      TURN ON SWITCH B
         B     CE010               BRANCH TO PROCESS LENGTH VALUE
*
CE018    TM    SWITCH,SWITCHB      SWITCH B ON ?
         BZ    CEEE19              NOT ON, BRANCH TO EE19
         CLI   CEHLDBTS,X'00'      COMPARE HOLD BITS TO 0
         BE    CEEE20              EQUAL, BRANCH TO EE20
CE019    SR    R2,R2               CLEAR R2
         IC    R2,CEHLDBTS         PUT LENGTH BITS IN R2
         CLI   2(R12),X'00'        COMPARE D BITS TO 0
         BNE   CE020               BRANCH NOT EQUAL TO COMPUTE L'
         LA    R2,7(,R2)           K = L BITS + 7
         B     CE021               BRANCH TO FINISH COMPUTING L'
*
CE020    MVC   *+9(1),2(R12)       PUT D BITS IN FOLLOWING LA INSTRUCT
         LA    R2,0(,R2)           K = L BITS + D BITS
         LA    R3,1(,R3)           L' = L' + 1
CE021    SRL   R2,3                K = K/8
         AR    R3,R2               L' = L' + K
         AR    R3,R7               L' = L' + RX
         LA    R2,256              PUT 256 IN R2
         CR    R3,R2               > 256 ?
         BH    CEEE21              > 256, BRANCH
         BCTR  R7,0                RX = RX - 1
         STC   R7,3(,R12)          PUT RX(BYTES) IN L FIELD OF PPI
         MVC   4(1,R12),CEHLDBTS   PUT L BITS IN L FIELD OF PPI
         TM    SWITCH,SWITCHA      SWITCH A ON ?
         BO    CE022               ON, BRANCH
         MVC   CEFSL(2),0(R8)      PUT FORMAT VALUE IN FORSEQL
         CLI   2(R8),X'FF'         THIRD FORMAT CHARACTER X'FF' ?
         BNE   CEEE28              NO, BRANCH TO EE28
         LA    R8,8(,R8)           AF = AF + 8
CE022    MVC   CEFSL+2(1),0(R8)    PUT SEQUENCE VALUE IN FORSEQL
         CLI   1(R8),X'FF'         SECOND SEQUENCE CHAR X'FF' ?
         BNE   CEEE29              NO, BRANCH TO EE29
         LA    R8,8(,R8)           AF = AF + 8
         CLI   4(R12),X'00'        L BITS PRESENT ?
         BH    CE023               YES, BRANCH TO SET LENGTH TO 1
         CLI   2(R12),X'00'        D BITS PRESENT ?
         BH    CE023               YES, BRANCH TO SET LENGTH TO 1
         CLI   3(R12),X'00'        L BYTES = 0 ?
         BE    CE024               YES, BRANCH TO SET LENGTH TO 2
         MVI   CEFSL+3,X'03'       SET LENGTH TO 3
         B     CE025               BRANCH TO COMPARE AGAINST FSLTAB
*
CE023    MVI   CEFSL+3,X'01'       SET LENGTH TO 1
         B     CE025               BRANCH TO COMPARE AGAINST FSLTAB
*
CE024    MVI   CEFSL+3,X'02'       SET LENGTH TO 2
CE025    LA    R10,39              I = 39
         LA    R9,CEFSLTAB-6       PUT ADDRESS OF FSLTAB IN R9
CE026    LA    R9,6(,R9)           FLSTAB = FLSTAB + 6
         CLC   0(4,R9),CEFSL       COMPARE FSLTAB TO FORSEQL
         BE    CE027               BRANCH EQUAL TO TEST F(X)
         BCT   R10,CE026           I = I - 1, IF I NOT 0 TAKE BRANCH
         B     CEEE22              IF I = 0 BRANCH TO EE22
*
CE027    CLI   5(R9),8             COMPARE F(X) TO 8 ?
         BL    CE028               < 8, BRANCH
         CPISETON CPIEXTRT         SET EXTRACT ON
CE028    CLI   5(R9),60            COMPARE F(X) TO 60
         BNH   CE029               < 60, BRANCH
         CPISETON CPIETCF          SET E TYPE CF PRESENT
CE029    CLI   4(R9),X'01'         COMPARE MAXL INDICATOR TO 1
         BNE   CE030               NOT EQUAL, BRANCH
         CLI   3(R12),31           LENGTH > 31 ?
         BH    CEEE23              YES, BRANCH
CE030    MVC   5(1,R12),5(R9)      PUT F(X) IN FORMAT SEQUENCE FIELD
         MVC   CEWK1+1(3),0(R12)   MOVE D-SIZE BITS TO FULL WORD
         MVC   CEWK2+2(2),3(R12)   MOVE L-SIZE BITS TO FULL WORD
         L     R6,CEWK1            ADD DISPLACEMENT VALUE
         A     R6,CEWK2            TO LENGTH VALUE
         C     R6,FFFC00           COMPARE SUM TO 4092
         BH    CEEE17              >, BRANCH
         BCT   R5,CE031            Q = Q - 1, IF NOT 0 TAKE BRANCH
         B     CE0315              IF 0 BRANCH OUT OF CF LOOP
*
CE031    LA    R12,6(,R12)         APPI = APPI + 6
         NI    SWITCH,255-SWITCHB  TURN OFF SWITCH B
         B     CE010               BRANCH TO PROCESS ANOTHER CF
*
CE0315   CLC   CPINUMCF(2),K12     NO CONTROL FIELDS > 12 ?
         BNH   CE032               NO
         L     R5,WK2              YES, MOVE PRIMARY CF INFO INTO CPI
         MVC   CPIPCF01(6),0(R5)
         CPISETON CPIEXTRT         SET EXTRACT FLAG
*
*----------------------------------------------------------------------
*
*        PROCESS CHECKPOINT KEYWORD
*
*----------------------------------------------------------------------
*
CE032    TM    KWCKPT+8,X'01'      CKPT DEFINER PRESENT ?
         BZ    CE033               NO, BRANCH
         CPISETON CPICHKPT         TURN ON CHECKPOINT FLAG
*
*----------------------------------------------------------------------
*
*        PROCESS SIZE/FILSZ KEYWORD
*
*----------------------------------------------------------------------
*
*        FILESZ/SIZE=NUMBER
*        FILESZ/SIZE=ENUMBER       ESTIMATED
*        FILESZ/SIZE=UNUMBER       ESTIMATED
*        ALLOW EITHER ONE BUT NOT BOTH
*
CE033    TM    KWSIZE+8,X'01'      SIZE DEFINER PRESENT ?
         BO    CE033B
         TM    KWFILSZ+8,X'01'     FILSZ DEFINER PRESENT ?
         BZ    CE034               NO, BRANCH
         ICM   R8,B'1111',KWFILSZ+10  ADDR OF SIZE DEFINER IN REDUCT
         LA    R0,8(,R8)           R0 -> LAST CHAR OF FIELD
         B     CE033C
*
CE033B   TM    KWFILSZ+8,X'01'     FILSZ DEFINER PRESENT ?
         BO    CEEE05              YES, BRANCH TO EE5, DUP KEYWORD
         ICM   R8,B'1111',KWSIZE+10  ADDR OF SIZE DEFINER IN REDUCT
         LA    R0,8(,R8)           R0 -> LAST CHAR OF FIELD
CE033C   CLI   0(R8),0             NO VALUE PROVIDED ?
         BE    CEEE07              YES, ERROR
         CLI   1(R8),C'E'          ESTIMATED VALUE ?
         BE    CE033D              YES, BRANCH
         CLI   1(R8),C'U'          ESTIMATED VALUE ?
         BNE   CE033F              NO, BRANCH
CE033D   CPISETON  CPIFSZE         SET ON FILE SIZE ESTIMATED FLAG
         LA    R8,1(R8)            INCR PTR PAST THE E(STIMATE)
CE033F   LA    R8,1(,R8)           INCR PTR
         SR    R1,R1               NO SUFFIX ALLOWED
         BAS   R14,NUMBER          EXTRACT NUMERIC FIELD
         STCM  R1,B'0111',CPIFILSZ  STORE FILESIZE VALUE INTO CPI
*
*----------------------------------------------------------------------
*
*        PROCESS SKIPREC KEYWORD
*
*----------------------------------------------------------------------
*
CE034    TM    KWSKIPRC+8,X'01'    SKIPREC DEFINER PRESENT ?
         BZ    CE040               NO, BRANCH
         ICM   R8,B'1111',KWSKIPRC+10  ADDR OF SKIPREC DEFINER
         LA    R0,8(,R8)           R0 -> LAST CHAR OF FIELD
         CLI   0(R8),0             NO VALUE PROVIDED ?
         BE    CEEE07              YES, ERROR
         LA    R8,1(,R8)           INCR PTR
         SR    R1,R1               NO SUFFIX ALLOWED
         BAS   R14,NUMBER          EXTRACT NUMERIC FIELD
         STCM  R1,B'0111',CPISKPRD  STORE SKIPREC VALUE IN CPI
         CPISETON CPISKIP          SET SKIPREC FLAG
*
*----------------------------------------------------------------------
*
*        PROCESS STOPAFT KEYWORD
*
*----------------------------------------------------------------------
*
CE040    TM    KWSTOPA+8,X'01'     STOPAFT DEFINER PRESENT ?
         BZ    CE050               NO, BRANCH
         ICM   R8,B'1111',KWSTOPA+10  ADDR OF SKIPREC DEFINER
         LA    R0,8(,R8)           R0 -> LAST CHAR OF FIELD
         CLI   0(R8),0             NO VALUE PROVIDED ?
         BE    CEEE07              YES, ERROR
         LA    R8,1(,R8)           INCR PTR
         SR    R1,R1               NO SUFFIX ALLOWED
         BAS   R14,NUMBER          EXTRACT NUMERIC FIELD
         STCM  R1,B'1111',CPISTOPR  STORE STOPAFT VALUE IN CPI
         CPISETON  CPISTOPF        SET STOPAFT FLAG
*
*----------------------------------------------------------------------
*
*        PROCESS DYNALLOC KEYWORD
*
*----------------------------------------------------------------------
*
*        DYNALLOC=OFF|NO           TURN OFF DYNAMIC ALLOCATION
*        DYNALLOC=(ÝDEVNAME¨Ý,NUMBER¨)
*        WHERE DEVTYPE IS THE DEVICE NAME FOR DEVICE UNIT TYPE
*              NUMBER OF SORKWKXX UNITS TO BE ALLOCATED
*
CE050    TM    KWDYNAL+8,X'01'     DYNALLOC DEFINER PRESENT ?
         BZ    CE041               NO, BRANCH
         ICM   R8,B'1111',KWDYNAL+10  ADDR OF DYNALLOC DEFINER
         CLI   0(R8),0             ANY SUBFIELDS ?
         BE    CEEE10              NO, BRANCH TO EE10
         CLI   0(R8),2             MORE THAN 2 SUBFIELDS ?
         BH    CEEE06C             YES, ERROR
         CPISETON  CPIDYNA         TURN ON DYNAMIC ALLOCATION
         SR    R5,R5
         IC    R5,0(,R8)           GET SUBFIELD COUNT
         LA    R8,1(,R8)           R8 -> FIRST SUBFIELD
         BCTR  R5,0
         LTR   R5,R5
         BNZ   CE051               THERE ARE TWO SUBFIELDS TO PROCESS
         CLC   KNO,0(R8)           DYNALLOC=NO ?
         BE    CE050A
         CLC   KOFF,0(R8)          DYNALLOC=OFF ?
         BE    CE050A
         B     CE051
*
CE050A   CPISETOF  CPIDYNA         NO DYNAMIC ALLOCATION
         B     CE041               GOTO FINAL PROCESSING
*
CE051    CLI   0(R8),X'FF'         DEVICE NAME FIELD NULL ?
         BE    CE052               YES, BRANCH
*                                  PROCESS DEVICE NAME FIELD
         MVC   CPIDYND,0(R8)       MOVE SUBFIELD TO CPI
*                                  REMOVE X'FF' PADDING
         LA    R2,CPIDYND+7        R2 -> LAST CHAR OF CPIDYND
         LA    R3,7
CE053    CLI   0(R2),X'FF'         X'FF' PADDING ?
         BNE   CE052               NO, BRANCH
         MVI   0(R2),C' '          YES, SET TO BLANK
         BCTR  R2,0                DECR PTR
         BCT   R3,CE053            LOOP TO PROCESS NEXT CHAR
CE052    LTR   R5,R5               ANY MORE DYNALLOC SUBPARAMETERS ?
         BZ    CE041               NO, GOTO FINAL PROCESSING
         LA    R8,8(,R8)           PROCESS SECOND SUBFIELD
         LA    R0,7(,R8)           R0 -> LAST CHAR OF FIELD
         SR    R1,R1               NO SUFFIX ALLOWED
         BAS   R14,NUMBER          EXTRACT NUMERIC FIELD
         CH    R1,=H'3'            LESS THAN 3 SORTWKXX AREAS ?
         BL    CEEE32              YES, ERROR
         CH    R1,=H'17'           MORE THAN 17 SORTWKXX AREAS ?
         BH    CEEE32              YES, ERROR
         STCM  R1,B'0011',CPIDYNN  SET NO OF SORKWKXX DATA SETS IN CPI
*
*----------------------------------------------------------------------
*
*        FINAL PROCESSING
*
*----------------------------------------------------------------------
*
CE041    CPITEST  CPIEXTRT         EXTRACT FLAG ON ?
         BZ    CE043               NO, BRANCH
CE042    CPISETON CPISCF           SET SINGLE CF INDICATOR ON
         B     CE044               BRANCH TO RETURN
*
CE043    CLI   CPINUMCF+1,1        NUMBER OF CF'S = 1 ?
         BE    CE042               YES, BRANCH
         CPISETON CPIEQUAL         SET EQUALS FLAG
         CPISETON CPIMCF           SET MULTIPLE CF INDICATOR
CE044    SR    R15,R15             SET RETURN CODE TO 0
         CLI   CPIPCF01+5,60       F+S VALUE OF MAJOR CF > 60 ?
         BH    CE045               YES, BRANCH
         SR    R2,R2               CLEAR R2
         SR    R3,R3               CLEAR R3
         IC    R3,CPIPCF01+5       GET F+S VALUE OF MAJOR CF
         D     R2,CEK8             F+S = F+S/8
         LTR   R2,R2               REMAINDER ZERO ?
         BZ    CE045               YES, BRANCH
         CPISETON CPIUOSEQ+CPIPH1CO  SET DECENDING OUTPUT
CE045    L     R12,CESAVE12        RESTORE R12
         L     R14,CESAVE14        RESTORE R14
         LM    R2,R11,0(R12)       RESTORE R2 THROUGH R11
         BR    R14                 RETURN
*
*----------------------------------------------------------------------
*
*        ERROR PROCESSING
*
*----------------------------------------------------------------------
*
CEEE01   LA    R1,IER010-DIERRCU   IER010A NO S/M STMT
         B     CEPRINT
*
CEEE02   LA    R1,IER011-DIERRCU   IER011A TOO MANY S/M KEYWORDS
         B     CEPRINT
*
CEEE07   EQU   *
CEEE03   LA    R1,IER012-DIERRCU   IER012A NO FLD DEFINER
         B     CEPRINT
*
CEEE04   LA    R1,IER013-DIERRCU   IER013A INVALID S/M KEYWORD
         B     CEPRINT
*
CEEE05   LA    R1,IER014-DIERRCU   IER014A DUPLICATE S/M KEYWORD
         B     CEPRINT
*
CEEE06A  DC    H'0'
CEEE06B  DC    H'0'
CEEE06C  DC    H'0'
CEEE06   LA    R1,IER015-DIERRCU   IER015A TOO MANY PARAMETERS
         B     CEPRINT
*
CEEE09   EQU   *
CEEE10   EQU   *
CEEE08   LA    R1,IER016-DIERRCU   IER016A INVALID VALUES IN FLD
         B     CEPRINT
*
CEEE12   EQU   *
CEEE13   EQU   *
CEEE14   EQU   *
CEEE15   EQU   *
CEEE16   EQU   *
CEEE17   EQU   *
CEEE18   EQU   *
CEEE19   EQU   *
CEEE20   EQU   *
CEEE21   EQU   *
CEEE11   LA    R1,IER017-DIERRCU   IER017A ERR IN DISP/LENGTH VALUE
         B     CEPRINT
*
CEEE23   EQU   *
CEEE27   EQU   *
CEEE28   EQU   *
CEEE29   EQU   *
CEEE22   LA    R1,IER018-DIERRCU   IER018A - CTL FLD ERR
         B     CEPRINT
*
CEEE32   LA    R1,IER075-DIERRCU   IER075A - DYNALLOC ERROR
         B     CEPRINT
*
CEEE24   LA    R1,IER019-DIERRCU   IER019A - SIZE/SKIPREC ETC ERROR
*
CEPRINT  A     R1,VIERRCU          ADD ADDR OF IERRCU TO MSG OFFSET
         LM    R0,R1,0(R1)         R0 -> MSG, R1 = L'MSG
         L     R15,VGAPRT          R15 -> MSG PRINT ROUTINE
         BASR  R14,R15             CALL PRINT ROUTINE
         LR    R1,R0               R1 -> MSG TXT
         MVC   CPIABMNO,3(R1)      MOVE MSG NO INTO ABEND CODE
         LA    R15,4               SET RETURN CODE
         B     CE045               BRANCH TO EXIT LINKAGE
*
*----------------------------------------------------------------------
*
*        EXTRACT NUMERIC DATA ROUTINE
*
*----------------------------------------------------------------------
*
*        ON ENTRY -
*        R0  -> LAST BYTE OF FIELD
*        R1  = 0, NO SUFFIX ALLOWED
*              4, SUFFIX OF K OR M VALID
*        R6, R7 WORK REGS
*        R8 -> FIELD RIGHT PADDED WITH X'FF'
*        R14 = RETURN ADDR
*        R15 = WORK REG TO APPLY K OR M SUFFIX
*
*        R1 = RESULT (WITH OPTIONAL SUFFIX APPLIED)
*
NUMBER   SR    R6,R6
         SR    R7,R7               CLEAR R6, R7
         SR    R15,R15             CLEAR K OR M SUFFIX VALUE
NUMBERA  CLI   0(R8),X'FF'         PADDING ?
         BE    NUMBERB             YES, FINISHED EXTRACTING FIELD
         CLI   0(R8),C'0'          CHAR VALUE < C'0' ?
         BL    NUMBERC(R1)         YES, CHECK FOR POSSIBLE SUFFIX
         CLI   0(R8),C'9'          CHAR VALUE > C'9' ?
         BH    CEEE24              YES, ERROR
         SLDL  R6,8                MAKE ROOM FOR CHAR
         IC    R7,0(,R8)           INSERT VALID CHAR
         LA    R8,1(,R8)           INCR INPUT PTR
         CR    R8,R0               PROCESSED ALL CHARS ?
         BNH   NUMBERA             NO, LOOP
*
NUMBERB  STM   R6,R7,CEPACKA       SAVE EXTRACTED CHARS
         PACK  CEPACKB,CEPACKA
         CVB   R1,CEPACKB          GET BINARY VALUE
         SLL   R1,0(R15)           APPLY K OR M SUFFIX, IF ANY
         BR    R14                 RETURN TO CALLER
*
NUMBERC  B     CEEE24              +00 SUFFIX NOT ALLOWED
         LA    R15,10              +04 SETUP FOR MULTIPLY BY 1024 (1K)
         CLI   0(R8),C'K'          K SUFFIX ?
         BE    NUMBERS             YES, BRANCH
         CLI   0(R8),C'M'          M SUFFIX ?
         BNE   CEEE24              NO, INVALID SUFFIX
         LA    R15,20              YES, MULTIPLY BY 1048576 (1M)
NUMBERS  BCTR  R0,0                R0 -> LAST BYTE IN FIELD
         CR    R8,R0               SUFFIX LAST IN FIELD ?
         BE    NUMBERB             YES, PROCESS NUMBER
         CLI   1(R8),X'FF'         SUFFIX LAST IN FIELD ?
         BE    NUMBERB             YES, VALID
         B     CEEE24              NO, ERROR
*
VIERRCD  DC    V(IERRCD)
VGAPRT   DC    V(IERGAPRT)         MESSAGE WRITER
VIERRCU  DC    V(IERRCU)           MESSAGE TEXT MODULE
*
WK       DC    F'0'
WK2      DC    F'0'
K6       DC    H'6'
K12      DC    H'12'
K256     DC    H'256'
*
KMOVE    MVC   1(1,R1),0(R1)       *** EX INSTRUCTION ***
*
*        CEFSLTAB
*
CEFSLTAB DS    0CL234
         DC    C'CHA'
         DC    X'030200'
         DC    C'CHD'
         DC    X'030204'
         DC    C'CHE'
         DC    X'030240'
         DC    C'CHA'
         DC    X'020200'
         DC    C'CHD'
         DC    X'020204'
         DC    C'CHE'
         DC    X'020240'
         DC    C'BIA'
         DC    X'030200'
         DC    C'BID'
         DC    X'030204'
         DC    C'BIE'
         DC    X'030240'
         DC    C'BIA'
         DC    X'020200'
         DC    C'BID'
         DC    X'020204'
         DC    C'BIE'
         DC    X'020240'
         DC    C'BIA'
         DC    X'010238'
         DC    C'BID'
         DC    X'01023C'
         DC    C'BIE'
         DC    X'01025C'
         DC    C'FIA'
         DC    X'030210'
         DC    C'FID'
         DC    X'030214'
         DC    C'FIE'
         DC    X'030248'
         DC    C'FIA'
         DC    X'020210'
         DC    C'FID'
         DC    X'020214'
         DC    C'FIE'
         DC    X'020248'
         DC    C'ZDA'
         DC    X'030118'
         DC    C'ZDD'
         DC    X'03011C'
         DC    C'ZDE'
         DC    X'03014C'
         DC    C'ZDA'
         DC    X'020130'
         DC    C'ZDD'
         DC    X'020134'
         DC    C'ZDE'
         DC    X'020158'
         DC    C'PDA'
         DC    X'030120'
         DC    C'PDD'
         DC    X'030124'
         DC    C'PDE'
         DC    X'030150'
         DC    C'PDA'
         DC    X'020128'
         DC    C'PDD'
         DC    X'02012C'
         DC    C'PDE'
         DC    X'020154'
         DC    C'FLA'
         DC    X'030208'
         DC    C'FLD'
         DC    X'03020C'
         DC    C'FLE'
         DC    X'030244'
         DC    C'FLA'
         DC    X'020208'
         DC    C'FLD'
         DC    X'02020C'
         DC    C'FLE'
         DC    X'020244'
*
*        KEYWORD
*
*        EACH ENTRY IS 14 BYTES IN LENGTH
*        KEYWORDS ARE PADDED OUT WITH X'FF' TO 8 BYTES IN LENGTH
*
KEYWORD  DC    0F'0'               START OF SORT KEYWORD TABLE
KWFIELDS DC    C'FIELDS',X'FFFF'   KEYWORD NAME PADDED TO 8 CHARS
         DC    X'00'               PREVIOUSLY DEFINED FLAG
         DC    AL1(252)            MAXIMUM SUBFIELD COUNT PERMITTED
         DC    AL4(0)              ADDR
*
KEYWORDL EQU   *-KEYWORD           L'KEYWORD ENTRY
*
KWFORMAT DC    C'FORMAT',X'FFFF'
         DC    X'00'
         DC    AL1(1)
         DC    AL4(0)
*
KWSIZE   DC    C'SIZE',X'FFFFFFFF'
         DC    X'00'
         DC    AL1(1)
         DC    AL4(0)
*
KWFILSZ  DC    C'FILSZ',X'FFFFFF'  ALIAS OF SIZE
         DC    X'00'
         DC    AL1(1)
         DC    AL4(0)
*
KWSKIPRC DC    C'SKIPREC',X'FF'
         DC    X'00'
         DC    AL1(1)
         DC    AL4(0)
*
KWSTOPA  DC    C'STOPAFT',X'FF'
         DC    X'00'
         DC    AL1(1)
         DC    AL4(0)
*
KWCKPT   DC    C'CKPT',X'FFFFFFFF'
         DC    X'00'
         DC    AL1(0)
         DC    AL4(0)
*
KWDYNAL  DC    C'DYNALLOC'
         DC    X'00'
         DC    AL1(2)
         DC    AL4(0)
*
KEYWORDE EQU   *
*
*        END OF KEYWORD TABLE
*
CESAVE12 DC    F'0'
CESAVE14 DC    F'0'
CETEMP1  DC    F'0'
CEK8     DC    F'8'
CEWK1    DC    F'0'
CEWK2    DC    F'0'
FFFC00   DC    X'000FFB00'
*
CEPACKA  DC    D'0'
CEPACKB  DC    D'0'
*
CEFSL    DC    F'0'
KSORT    DC    CL6'SORT'           FOR USE IN IER007 MSG IF ISSUED
KMERGE   DC    CL6'MERGE'
KNO      DC    CL8'NO'             PAD OUT WITH X'FF'
         ORG   KNO+2
         DC    XL6'FFFFFFFFFF'
KOFF     DC    CL8'OFF'            PAD OUT WITH X'FF'
         ORG   KOFF+3
         DC    XL5'FFFFFFFFFF'
CEHLDBTS DC    X'00'
SWITCH   DC    X'00'
SWITCHA  EQU   X'01'
SWITCHB  EQU   X'02'
SWITCHC  EQU   X'04'
SWITCHD  EQU   X'08'
*
*        LTORG
*
         LTORG
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
DIERRCU  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRCU SOURCE
*
*----------------------------------------------------------------------
*
         COPY IERRCUI
*
         SMCPI
*
         END
./ ADD NAME=IERRCF   0101-20211-20211-1200-00216-00216-00000-RELEASE 00
RCF      TITLE 'IERRCF - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRCF
*
*        MODULE FUNCTION/OPERATION -
*        1. CALCULATE A TABLE OF BLKSIZES FOR THE DASD TYPE
*           ALLOCATED TO THE SORTWKXX DATA SETS
*           FOR LARGE TRACK SIZE DEVICES WHERE THE PHYSICAL TRACK
*           IS LARGER THAN 32K THEN THE LARGEST BLKSIZE WILL BE
*           HALF TRACK BLOCKING TO AVOID ANY HALF WORD PROBLEMS
*           WITH THE BUFFER BLOCK/DEBLOCK CODE.
*        2. CALCULATE THE NUMBER OF SORT DIRECTORY BLOCKS PER
*           TRACK FOR THE DASD TYPE ALLOCATED TO THE SORTWKXX
*           DATA SETS. BALN TECHNIQUE USE ONLY
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACROS USED -
*        SMCPI  TRKCALC
*
*        REGISTER USAGE -
*        THIS MODULE USES THE TRKCALC FUNCTION. TO AVOID THE
*        OVERHEAD OF SAVING AND RESTORING REGISTERS R0-R1,
*        R9-R11, R14-R15 MUST NOT BE USED ACROSS A CALL TO THE
*        TRKCALC FUNCTION.
*
*        ENTRY POINT - ENTRY CSECT NAME IERRCF - ENTRY
*                                                CALLING SEQUENCE -
*                                                L      R15,V(IERRCF)
*                                                BALR   R14,R15
*
*        INPUT - CPI FIELDS REFERENCED -
*                CPIDVCT - ADDR OF DASD DEVICE ENTRY IN IECZDTAB
*
*        OUTPUT - CPI FIELDS REFERENCED -
*        CPIBLKTB - ADDR OF CALCULATED BLKSIZES IN IERRCF
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL - ZERO IN R15
*
*        TABLES/WORK AREAS -
*        THE CPIBLKTB TABLE IS BUILT BASED ON THE DASD DEVICE
*        CHARACTERISTICS IN THE IECZDTAB DEVICE ENTRY. THE TABLE
*        HAS TEN ENTRIES OF A HALF WORD BLKSIZE FOLLOWED BY
*        A HALFWORD COUNT OF THE NUMBER OF BLKS PER TRACK IN
*        DESCENDING ORDER WITH LAST ENTRY IN THE TABLE SET TO ZERO.
*        THE SORT BLKSIZE STORED IN THE TABLE IN CALCULATED
*        BY THE SORT ALGORITHM
*
*        SB = (QUOTIENT(DB,8)-2)*8)
*        WHERE
*        SB = SORT BLKSIZE
*        DB = DASD BLKSIZE
*
*        CPIBLKTB
*         _________________________
*        | 0(0)       | 2(2)       |
*        | BLKSIZE    | NO OF BLKS |
*        |            | PER TRACK  |
*        |____________|____________|
*        | 4(4)       | 6(6)       |
*        | BLKSIZE    | NO OF BLKS |
*        |            | PER TRACK  |
*        |____________|____________|
*        | 8(8)       | 10(A)      |
*        | BLKSIZE    | NO OF BLKS |
*        |            | PER TRACK  |
*        |____________|____________|
*        | 12(C)      | 14(E)      |
*        | BLKSIZE    | NO OF BLKS |
*        |            | PER TRACK  |
*        |____________|____________|
*        | 16(10)     | 18(12)     |
*        | BLKSIZE    | NO OF BLKS |
*        |            | PER TRACK  |
*        |____________|____________|
*        | 20(14)     | 22(16)     |
*        | BLKSIZE    | NO OF BLKS |
*        |            | PER TRACK  |
*        |____________|____________|
*        | 24(18)     | 26(1A)     |
*        | BLKSIZE    | NO OF BLKS |
*        |            | PER TRACK  |
*        |____________|____________|
*        | 28(1C)     | 30(1E)     |
*        | BLKSIZE    | NO OF BLKS |
*        |            | PER TRACK  |
*        |____________|____________|
*        | 32(20)     | 34(22)     |
*        | BLKSIZE    | NO OF BLKS |
*        |            | PER TRACK  |
*        |____________|____________|
*        | 36(24)     | 38(26)     |
*        | H'0'       |            |
*        | END OF TAB | END OF TAB |
*        |____________|____________|
*
*
IERRCF   CSECT
*
         USING *,R15               PROGRAM BASE
         USING IERRC5,R13          CPI BASE
         USING DVCT,R8             DASD DEVICE CHARACTERISTICS TABLE
*
         IERENTRY 'IERRCF &SYSDATE &SYSTIME'
*
         STM   R0,R15,SAVEREGS     SAVE REGS R0-R15
         DROP  R15
         LA    R12,0(,R15)         SET PROGRAM BASE
         USING IERRCF,R12
         L     R8,CPIDVCT          R8 -> IECZDTAB DEVICE ENTRY
         LA    R2,CPIBLKTB         R2 -> BLKSIZE TABLE IN CPI
         LA    R7,9                SET ITERATION COUNT TO 9
         MVI   3(R2),1             SET ONE BLK PER TRACK
         CLC   DVCTRKLN,KH32767    TRACK LENGTH > 32767 ?
         BL    RCF001              NO, BRANCH
*
*        TRACK LENGTH EXCEEDS 32767
*
         MVI   3(R2),2             SET TWO BLKS PER TRACK
*                                  (HALF TRACK BLOCKING)
RCF001   SR    R4,R4
         SR    R5,R5
         ICM   R5,B'0011',DVCTRKLN  R5 = DEVICE TRACK LENGTH
         LH    R3,2(,R2)            R1 = NO OF BLKS PER TRK IN CPIBLKTB
         CH    R3,KH1              FULL TRACK ?
         BE    RCF004              YES, BYPASS DIVISION
         DR    R4,R3               NO, DIVIDE BY BLOCKS PER TRACK
         SH    R5,OHEAD            SUBTRACT MINIMAL BLK OVERHEAD
*                                  TO REDUCE TRKCALC SPINNING
RCF004   ICM   R5,B'1000',KH1+1    SET R TO X'01'
*
RCF002   TRKCALC  FUNCTN=TRKCAP,DEVTAB=(R8),RKDD=(R5),MF=(E,TRKCAP)
*
         LTR   R15,R15             RECORD FIT ON TRACK ?
         BNZ   RCF005              NO, DECR L'RECORD
         CH    R0,2(,R2)           CORRECT NO OF RECORDS ?
         BE    RCF003              YES, BRANCH
RCF005   BCTR  R5,0                NO, DECR THE L'RECORD AND LOOP
         B     RCF002
*
*        IMPLEMENT SORT BLKSIZE ALGORITHM
*
*        SB = (QUOTIENT(DB,8)-2)*8)
*        WHERE
*        SB = SORT BLKSIZE
*        DB = DASD BLKSIZE
*
RCF003   SR   R4,R4
         D    R4,KF8
         SH   R5,KH2
         MH   R5,KF8+2
         STH  R5,0(,R2)            STORE RESULT IN CPIBLKTB
         LH   R1,2(,R2)            GET CURRENT RECORD COUNT
         LA   R2,4(,R2)            INCR CPIBLKTB PTR
         LA   R1,1(,R1)            INCR RECORD NUMBER
         STH  R1,2(,R2)            STORE RECORD NO
         BCT  R7,RCF002            LOOP TO CALC NEXT L'RECORD
*
*----------------------------------------------------------------------
*
*        CALCULATE NUMBER OF SORT DIRECTORY BLOCKS PER TRACK FOR BALN
*
*----------------------------------------------------------------------
*
         LA    R5,64               L'SORT BALN DIRECTORY BLOCK ENTRY
         ICM   R5,B'1000',KH1+1    SET R TO X'01'
*
         TRKCALC  FUNCTN=TRKCAP,DEVTAB=(R8),RKDD=(R5),MF=(E,TRKCAP)
*
         STH   R0,CPIDIRBK         STORE NUMBER OF DIR BLOCKS PER TRACK
*
*----------------------------------------------------------------------
*
*        RETURN TO CALLER
*
*----------------------------------------------------------------------
*
         LM    R0,R15,SAVEREGS     RESTORE REGS
         SR    R15,R15             SET RETURN CODE
         BR    R14                 RETURN TO CALLER
*
*        CONSTANTS AND WORK AREA
*
SAVEREGS DC    16F'0'
*
KH1      DC    H'1'
KH2      DC    H'2'
KH32767  DC    H'32767'
KF8      DC    F'8'
OHEAD    DC    H'0'                GUESSTIMATED RECORD OVERHEAD
*
*        TRKCALC
*
TRKCAP   TRKCALC  MF=L
*
*        LTORG
*
         LTORG
*
*        IHADVCT                   MAP DEVICE CHARACTERISTICS TABLE
*
         IHADVCT
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMCPI
*
         END
./ ADD NAME=IERRCG   0101-20211-20211-1200-00400-00400-00000-RELEASE 00
RCG      TITLE 'IERRCG - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRCG
*
*        FUNCTION/OPERATION -
*        ANALYZE THE RECORD STMT AND PLACE THE RESULTS IN THE
*        CPI. THE FOLLOWING IS A LIST OF THE FIELDS ON THE RECORD
*        STMT AND WHERE THIS INFORMATION IS PLACED IN CPI -
*        1. TYPE   - CPICNTL (CPIFIX OR CPIVAR)
*        2. LENGTH - CPIRCDL1 THROUGH CPIRCDL5
*
*        MODULE IN WHICH THIS MODULES APPEARS AS A DSECT - N/A
*
*        MACROS USED BY MODULE -
*        SMCPI
*
*        ENTRY POINTS - ENTRY IERRCG
*                       ENTRY FROM SORT PHASE
*                       CALLING SEQUENCE
*                       L   R15,=V(IERRCG)
*                       BALR R14,R15
*
*        INPUT - CPI FIELDS REFERENCED -
*        CPINUMCF
*        CPIPCF01
*        CPICNTL
*        THESE VALUES ARE USED TO CALCULATE THE DEFAULT VALUES
*        OF L1 TO L5
*
*        OUTPUT - CPI FIELDS INITIALIZED OR ALTERED -
*        CPIRCDL1   CPIRCDL2   CPIRCDL4   CPIRCDL5   CPICNTL
*        ALL THESE VALUES ARE TAKEN FROM THE RECORD STMT AND
*        MOVED INTO CPI
*
*        EXTERNAL ROUTINES -
*        EXTRN - IERGAPRT - MESSAGE WRITER
*        EXTRN - IERRCD   - SCAN ROUTINE
*
*        EXITS - NORMAL - R15 = 0
*
*        EXITS - ERROR  - R15 = 4
*
*        TABLES/WORK AREA -
*        CGFDTAB IS USED TO IDENTIFY VALID FIELD DEFINERS
*
*        REGISTER USAGE FROM START OF MODULE TO END OF HE' CALCULATION
*
*        R0  - NOT USED
*        R1  - NOT USED
*        R2  - E' CALCULATION
*        R3  - ADDR FOR SCAN, E'
*        R4  - ADDR FOR SCAN, HE'
*        R5  - ADDR FOR SCAN
*        R6  - NOT USED
*        R7  - NOT USED
*        R8  - CURRENT REDUCTION AREA ADDR
*        R9  - CURRENT FIELD DEFINER TABLE ADDR
*        R10 - I, Q
*        R11 - BASE
*        R12 - ADDR OF CONTROL FIELDS IN CPI
*        R13 - ADDR OF CPI
*        R14 - NOT USED
*        R15 - NOT USED
*
IERRCG   CSECT
*
         USING *,R11
         USING IERRC5,R13
*
         IERENTRY 'IERRCG &SYSDATE &SYSTIME'
*
         STM   R2,R11,0(R12)       SAVE REGISTERS 2 THROUGH 11
         LR    R11,R15             SET PROGRAM BASE
         ST    R12,CGSAVE12        SAVE R12
         ST    R14,CGSAVE14        SAVE R14
         CPITEST  CPIRCARD         RECORD STMT TO PROCESS ?
         BZ    CG022               NO, EXIT TO IERRCM
*
         LM    R3,R4,CPISRECD      R3 = STRTREC, R4 = ENDREC
         LA    R1,KRECORD          R1 -> RECORD CONSTANT
         L     R12,VIERRCD         R12 -> SCAN ROUTINE
         BASR  R14,R12             BRANCH TO SCAN ROUTINE
         LTR   R15,R15             RETURN CODE ?
         BNZ   CG023               ERROR ? BRANCH
         L     R8,CPIAFLDD         R8 -> REDUCTION AREA
         CLI   0(R8),2             NUMBER OF FD'S > 2 ?
         BH    CGEE01              YES, BRANCH TO EE1
         CLI   0(R8),0             NUMBER OF FD'S = 0 ?
         BE    CGEE01              YES, BRANCH TO EE1
         SR    R4,R4               CLEAR R4
         IC    R4,0(,R8)           PUT NUMBER OF FD'S INTO R4
         LA    R8,1(,R8)           REDUCT = REDUCT + 1
CG002    LA    R10,2               SET I = 2
         LA    R9,CGFDTAB-12       FDTAB IS FIELD DEFINER TABLE ADDR
CG003    LA    R9,12(,R9)          FDTAB = FDTAB + 12
         CLC   0(7,R9),0(R8)       COMPARE FD TO FDTAB ENTRY
         BE    CG004               BRANCH EQUAL TO DEFINER CHECK
         BCT   R10,CG003           I = I - 1, IF I ¬ 0 BRANCH
         B     CGEE03              KEYWORD NOT FOUND, BRANCH
*
CG004    TM    7(R9),X'01'         PREVIOUSLY DEFINED ?
         BO    CGEE04              YES, ERROR BRANCH TO EE4
         OI    7(R9),X'01'         SET DEFINED BIT
         LA    R8,8(,R8)           REDUCT = REDUCT + 8
         CLC   8(1,R9),0(R8)       COMPARE VC IN FDTAB ENTRY TO VC CARD
         BL    CGEE05              BRANCH LOW TO EE05
         ST    R8,8(,R9)           PUT REDUCT ADDR IN FDTAB + 8
         BCT   R4,CG005            FD = FD - 1, IF ¬ 0 BRANCH
         B     CG006               FD = 0, BRANCH TO CHECK TYPE
*
CG005    SR    R2,R2               CLEAR R2
         IC    R2,0(,R8)           PUT VC FROM REDUCT IN R2
         SLL   R2,3                VC = 8*VC
         LA    R8,1(R2,R8)         REDUCT = REDUCT + 8*VC + 1
         B     CG002               BRANCH TO GET ANOTHER FD FROM REDUCT
*
CG006    TM    CGTYPE+7,X'01'      TYPE DEFINER PRESENT ?
         BZ    CGEE06              NO, BRANCH TO EE6
         L     R8,CGTYPE+8         GET ADDR OF TYPE DEFINER (ATD)
         LA    R8,1(,R8)           ATD = ATD + 1
         CLI   0(R8),C'F'          TYPE = F ?
         BNE   CG007               NO, BRANCH TO TEST FOR TYPE = V
         CPISETON CPIFIX           SET FIXED BIT IN SW1 OF CPI
         B     CG008               BRANCH TO CHECK VALIDITY
*
CG007    CLI   0(R8),C'V'          TYPE = V ?
         BNE   CGEE07              NO, BRANCH TO EE7
         CPISETON CPIVAR           YES, SET VARIABLE FLAG IN CPI
CG008    CLI   1(R8),X'FF'         SECOND CHARACTER X'FF' ?
         BNE   CGEE18              NO, BRANCH TO EE18
         TM    CGLENGTH+7,X'01'    LENGTH DEFINER PRESENT ?
         BZ    CGEE08              NO, BRANCH TO EE8
         L     R8,CGLENGTH+8       GET ADDR OF LENGTH DEFINER (ALD)
         CLI   0(R8),X'03'         COMPARE VC TO 3
         BNH   CG009               NOT HIGH, BRANCH
         CPITEST  CPIVAR           TYPE = V ?
         BZ    CGEE09              NO, BRANCH TO EE9
CG009    LH    R10,CPINUMCF        GET NUMBER OF CONTROL FIELDS (Q)
         CH    R10,K12             MORE THAN 12 CONTROL FIELDS
         BH    CG0105              YES, BRANCH
*
         LA    R12,CPIPCF01-6      GET STARTING ADDR OF CONTROL FLDS
         SR    R4,R4               CLEAR HE'
CG010    LA    R12,6(,R12)         AFD = AFD + 6
         SR    R3,R3               CLEAR E'
         IC    R3,4(,R12)          GET L(BITS)
         SR    R2,R2               CLEAR R2
         IC    R2,2(,R12)          GET D(BITS)
         LA    R3,7(R2,R3)         K = L(BITS) + D(BITS) + 7
         SRL   R3,3                K = K/8
         STC   R3,CG029+3          PUT IN DISPLACEMENT OF FOLLOWING LA
         CLI   3(R12),X'FF'        L(BYTES) = 255 ?
         BNE   CG030               NO, BRANCH
         CLI   4(R12),X'00'        L(BITS) = 0 ?
         BE    CG030               YES, BRANCH
         SR    R3,R3               CLEAR R3
         B     CG029-4             BRANCH TO GET D(BYTES)
*
CG0105   MVC   WRK+1(3),CPIADDCF
         L     R12,WRK
         SH    R12,K6
         B     CG010-2
*
CG030    IC    R3,3(,R12)          GET L(BYTES)
         LA    R3,1(,R3)           L(BYTES) = L(BYTES) + 1
         LH    R2,0(,R12)          GET D(BYTES)
CG029    LA    R3,0(R2,R3)         E' = K + D(BYTES) + L(BYTES)
         CR    R3,R4               COMPARE E' TO HE'
         BNH   CG011               LESS THAN OR EQUAL ? BRANCH
         LR    R4,R3               HE' = E'
CG011    BCT   R10,CG010           Q = Q - 1, IF NOT 0 TAKE BRANCH
         STH   R4,CGHIGHE          PUT HE'
*
*        REGISTER USAGE FROM END OF HE' CALCULATION TO END OF MODULE
*
*        R0  - NOT USED
*        R1  - NOT USED
*        R2  - NOT USED
*        R3  - L CALCULATION
*        R4  - VC
*        R5  - J
*        R6  - RX
*        R7  - RX, CVB'ED INTO
*        R8  - ALV - ADDR OF LENGTH VALUE IN REDUCT
*        R9  - NOT USED
*        R10 - I
*        R11 - BASE
*        R12 - ADDR OF L'S IN PPI
*        R13 - ADDR OF PPI
*        R14 - NOT USED
*        R15 - NOT USED
*
         SR    R4,R4               CLEAR R5
         IC    R4,0(,R8)           GET VC FOR LENGTH FROM REDUCT
         LA    R8,1(,R8)           ALV = ALV + 1
         LA    R12,CPIRCDL1        GET ADDR OF LENGTH FIELDS IN CPI
         LA    R10,5               I = 5
CG012    LA    R5,8                J = 8
         SR    R6,R6               CLEAR RX
         SR    R7,R7               CLEAR RX
         TM    SWITCH,SWITCHA      SWITCH A ON ?
         BO    CG013               YES, BRANCH TO PROCESS ASSUMED VAL
         CLI   0(R8),X'FF'         X'FF' ?
         BE    CG013               YES, BRANCH TO PROCESS ASSUMED VAL
CG014    CLI   0(R8),C'0'          '0' ?
         BL    CGEE10              BRANCH LOW TO EE10
         CLI   0(R8),C'9'          '9' ?
         BH    CGEE11              BRANCH HIGH TO EE11
         SLDL  R6,8                SHIFT RX LEFT 8 BITS
         IC    R7,0(,R8)           INSERT CHARACTER INTO RX
CG015    LA    R8,1(,R8)           ALV = ALV + 1
         BCT   R5,CG016            J = J - 1, IF NOT 0 RELOOP
         B     CG017               END OF LOOP, BRANCH
*
CG016    CLI   0(R8),X'FF'         X'FF' ?
         BE    CG015               YES, BRANCH
         B     CG014               NO, BRANCH TO PROCESS ANOTHER CH
*
CG017    STM   R6,R7,CGPACKA       STORE RX INTO PACK AREA
         PACK  CGPACKB,CGPACKA
         CVB   R7,CGPACKB          CONVERT OT BINARY INTO RX
         C     R7,CGK32767         COMPARE L(I) TO MAX LENGTH
         BH    CGEE12              BRANCH HIGH TO EE12
         STH   R7,0(,R12)          STORE L(I) IN PPI
CG028    TM    SWITCH,SWITCHA      SWITCH A ON ?
         BO    CG018               YES, BRANCH
         BCT   R4,CG018            VC = VC - 1, IF ¬ 0 BRANCH
         OI    SWITCH,SWITCHA      END OF LOOP, SET SWITCH A ON
CG018    BCT   R10,CG019           I = I - 1, IF ¬ 0 BRANCH
         B     CG021               END OF LOOP, BRANCH
*
CG019    C     R10,CGK2            COMPARE I TO 2
         BNE   CG020               NOT EQUAL, BRANCH
         CPITEST  CPIFIX           TYPE = F ?
         BO    CG021               YES, BRANCH
CG020    LA    R12,2(,R12)         APPI = APPI + 2
         B     CG012               BRANCH TO PROCESS ANOTHER VALUE
*
CG021    CLC   CGHIGHE,CPIRCDL2    COMPARE HE' TO L2
         BH    CGEE14              GREATER, BRANCH TO EE14
         CPITEST  CPIFIX           TYPE = F ?
         BO    CG022               YES, BRANCH
         CLC   CGHIGHE,CPIRCDL4    COMPARE HE' TO L4 FOR TYPE = V
         BH    CGEE14              GREATER, BRANCH TO EE14
         CLC   CPIRCDL4,CPIRCDL2   COMPARE L4 TO L2
         BH    CGEE15              HIGH, BRANCH TO EE15
         CLC   CPIRCDL5,CPIRCDL2   COMPARE L5 TO L2
         BH    CGEE16              HIGH, BRANCH TO EE16
         CLC   CPIRCDL5,CGHIGHE    COMPARE L5 TO HE'
         BH    CG0215              HIGH, BRANCH TO CG0215
         MVC   CPIRCDL5,CGHIGHE    L5 EQUAL HE'
CG0215   CLC   CPIRCDL5,CPIRCDL1   COMPARE L5 TO L1
         BH    CGEE17              HIGH, BRANCH TO EE17
CG022    SR    R15,R15             SET RETURN CODE TO 0
CG023    L     R12,CGSAVE12        RESTORE R12
         L     R14,CGSAVE14        RESTORE R14
         LM    R2,R11,0(R12)       RESTORE R2 - R11
         BR    R14                 RETURN WITH RETURN CODE IN R15
*
CG013    LR    R3,R10              PUT VALUE OF I IN INDEX
         LA    R8,8(,R8)           AVAIL = AVAIL + 8
         SLL   R3,2                INDEX = 4*INDEX
CGBRTAB1 B     CGBRTAB1(R3)        BRANCH AS INDEX VALUE INDICATES
         B     CG027               +04
         B     CG026               +08
         B     CG025               +12
         B     CG024               +16
         B     CGEE13              +20
*
CG024    MVC   0(2,R12),CPIRCDL1   SET APPI = L1
         B     CG028               BRANCH TO TEST SWITCH A
*
CG025    CPITEST  CPIMERGO         MERGE ONLY ?
         BO    CG024               YES, BRANCH
         MVC   0(2,R12),CPIRCDL2   SET APPI = L2
         B     CG028               BRANCH TO TEST SWITCH A
*
CG026    CLC   CGK18(2),CGHIGHE    IS HE' > 18 ?
         BH    CG031               NO, BRANCH
         MVC   0(2,R12),CGHIGHE    SET APPI = HE'
         B     CG028               BRANCH TO TEST SWITCH A
*
CG031    MVC   0(2,R12),CGK18      SET APPI = 18
         B     CG028               BRANCH TO TEST SWITCH A
*
*
CG027    LH    R3,CPIRCDL2         PUT L2 IN K
         AH    R3,CPIRCDL4         K = L2 + L4
         SRL   R3,1                K = K/2
         STH   R3,CPIRCDL5         PUT K IN L5
         B     CG028               BRANCH TO TEST SWITCH A
*
*        ERROR PROCESSING
*
         USING DIERRCU,R8          ADDR DSECT
*
CGEE01   EQU   *                   ONLY 1 0R 2 FD PERMITTED
CGEE03   EQU   *
CGEE04   EQU   *
CGEE05   L     R8,VIERRCU          R8 -> MESSAGE CSECT
         LM    R0,R1,IER020        IER020A INVALID RECORD KEYWORD
         B     CGPRINT             BRANCH TO PRINT LINKAGE
*
CGEE06   L     R8,VIERRCU          R8 -> MESSAGE CSECT
         LM    R0,R1,IER021        IER021A NO TYPE DEFINITION
         B     CGPRINT             BRANCH TO PRINT LINKAGE
*
CGEE07   EQU   *
CGEE18   L     R8,VIERRCU          R8 -> MESSAGE CSECT
         LM    R0,R1,IER022        IER022A RECORD TYPE NOT F OR V
         B     CGPRINT             BRANCH TO PRINT LINKAGE
*
CGEE08   L     R8,VIERRCU          R8 -> MESSAGE CSECT
         LM    R0,R1,IER023        IER023A NO LENGTH OPERAND FOUND
         B     CGPRINT             BRANCH TO PRINT LINKAGE
*
CGEE09   EQU   *
CGEE10   EQU   *
CGEE11   EQU   *
CGEE15   EQU   *
CGEE16   EQU   *
CGEE17   L     R8,VIERRCU          R8 -> MESSAGE CSECT
         LM    R0,R1,IER024        IER024A INCORRECT VALUE IN LENGTH
         B     CGPRINT             BRANCH TO PRINT LINKAGE
*
CGEE12   L     R8,VIERRCU          R8 -> MESSAGE CSECT
         LM    R0,R1,IER025        IER025A RECORD LENGTH > MAX ALLOWED
         B     CGPRINT             BRANCH TO PRINT LINKAGE
*
CGEE13   L     R8,VIERRCU          R8 -> MESSAGE CSECT
         LM    R0,R1,IER026        IER026A L1 VALUE NOT PROVIDED
         B     CGPRINT             BRANCH TO PRINT LINKAGE
*
CGEE14   L     R8,VIERRCU          R8 -> MESSAGE CSECT
         LM    R0,R1,IER027        IER027A CONTROL FIELD IS DEFINED OR
*
         DROP  R8
*
CGPRINT  L     R15,VGAPRT          R15 -> MESSAGE WRITER
         BASR  R14,R15             CALL MESSAGE WRITER
         LR    R1,R0               R1 -> MSG TEXT
         MVC   CPIABMNO,3(R1)      MOVE MSG NO INTO ABEND CODE
         LA    R15,4               SET ERROR RETURN CODE OF 4
         B     CG023               BRANCH TO EXIT LINKAGE
*
*
VIERRCD  DC    V(IERRCD)
VGAPRT   DC    V(IERGAPRT)
VIERRCU  DC    V(IERRCU)
*
CGPACKA  DC    D'0'
CGPACKB  DC    D'0'
*
*        RECORD STMT SUPPORTED KEYWORDS
*
*        KEYWORDS ARE 7 BYTES IN LENGTH PADDED WITH X'FF'
*
CGFDTAB  EQU   *                   START OF KEYWORD TABLE
CGTYPE   DC    C'TYPE',X'FFFFFF'
         DC    X'0001000000'
CGLENGTH DC    C'LENGTH',X'FF'
         DC    X'0005000000'
*
CGK32767 DC    F'32767'            MAXIMUM RECORD LENGTH
CGK2     DC    F'2'
CGSAVE12 DC    F'0'
CGSAVE14 DC    F'0'
CGHIGHE  DC    H'0'
CGK18    DC    H'18'
WRK      DC    F'0'
K6       DC    H'6'
K12      DC    H'12'
KRECORD  DC    CL6'RECORD'         MESSAGE IDENTIFIER
*
SWITCH   DC    X'00'
SWITCHA  EQU   X'01'
*
*        LTORG
*
         LTORG
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRCU SOURCE
*
*----------------------------------------------------------------------
*
DIERRCU  DSECT
*
         COPY IERRCUI
*
         SMCPI
*
         END
./ ADD NAME=IERRCH   0101-20211-20211-1200-00835-00835-00000-RELEASE 00
RCH      TITLE 'IERRCH - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRCH
*
*        MODULE FUNCTION/OPERATION -
*        ANALYSE INFORMATION OBTAINED FROM MODS CONTROL RECORDS.
*        PLACE RELEVANT INFORMATION INTO CPI AND THE CONTROL
*        AREA FOR LATER USE BY SORT DEFINITION.
*        SUM THE SIZES OF RUNNING MODS FOR EACH PHASE AND PASS
*        THEM ON FOR LATER USE BY B AND G CALCULATIONS
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACROS USED -
*        DCB
*        CLOSE
*        OPEN
*        READ
*        CHECK
*        WRITE
*        STOW
*        SMCPI
*
*        ENTRY POINT - ENTRY FROM IERRCM
*                      CALLING SEQUENCE -
*                      L      R15,V(IERRCH)
*                      BALR   R14,R15
*
*        INPUT - CPI FIELDS REFERENCED - CPICNTL
*
*        OUTPUT - CPI FIELDS REFERENCED -
*        CPICNTL
*        CPIPH1RSZ
*        CPIPH2RSZ
*        CPIPH3RSZ
*        CPILINK
*        CPISORCE
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL - IERRCM WITH ZERO IN R15
*
*        EXITS - ERROR - IERRCM WITH FOUR IN R15
*
*        TABLES/WORK AREAS -
*
*        WTABLE   - CONTAINS INFORMATION ABOUT EACH USER MOD
*        RNAMETAB - TRANSLATE AND TEST TABLE FOR CHECKING
*                   VALIDITY OF USER MODS NAME AND SOURCE
IERRCH   CSECT
*
         USING *,R11               PROGRAM BASE
         USING IERRC5,R13          CPI BASE
*
         IERENTRY 'IERRCH &SYSDATE &SYSTIME'
*
         STM   R2,R11,0(R12)       SAVE REGS R2-R11 IN IERRCM SAVEARE
         LR    R11,R15             SET PROGRAM BASE
         ST    R12,MODSAV12        SAVE R12
         ST    R14,MODSAV14        SAVE R14
         CPITEST  CPIATT           SORT ATTACHED ?
         BO    RMATTACH            YES, BRANCH
         CPITEST  CPIMODCD         MODS CARD PRESENT ?
         BO    RMODINIT            YES, BRANCH
*
*        IF NO MODS CARD IS PRESENT, CPIETCF IS CHECKED. IF ON,
*        AN E-TYPE CONTROL FIELD IS PRESENT AND EXIT 61 MUST BE
*        ACTIVATED. IN THIS CASE, IT HAS NOT BEEN AND HENCE ERROR
*        EXIT 10 IS TAKEN. IF CPIETCF IS NOT ON, NORMAL RETURN
*        IS MADE
*
         CPITEST  CPIETCF          HAS AN E-TYPE CONTROL FIELD BEEN
         BO    RMODER10            SPECIFIED ? YES, ERROR EXIT 10
         SR    R15,R15             NO, ZERO R15, RETURN
         CPISETON CPINOMOD         SET NO MODS FLAG
*
*        RESTORE REGISTERS AND RETURNING
*
MODRET   L     R12,MODSAV12        RESTORE R12
         L     R14,MODSAV14        RESTORE R14
         LM    R2,R11,0(R12)       RESTORE R2-R11
         BR    R14                 RETURN
*
RMODINIT CPISETON CPIMODS          SET INDICATING MODS FLAG
         LM    R3,R4,CPISMODS      R3 = STRTMOD, R4 = ENDMOD
         L     R12,VIERRCD         GET ADDR OF SCAN ROUTINE
         LA    R1,KMODS            IDENTIFY MODS CARD TO SCAN ROUTINE
         BASR  R14,R12             BRANCH TO SCAN ROUTINE
         LTR   R15,R15             TEST RETURN CODE
         BNZ   MODRET              ERROR FOUND BY SCAN, RETURN
         L     R5,CPIAFLDD         R5 -> REDUCTION AREA
         CLI   0(R5),17            NO OF FD'S MORE THAN 17 ?
         BH    RMODER1             YES, ERROR EXIT 1
         SR    R4,R4               ZERO R4
         IC    R4,0(,R5)           INITIATE FD COUNT
         LA    R5,1(,R5)           CRA=CRA+1
RINITI   LA    R9,17               INITIALIZE I TO 17
         LA    R8,WTABLE-32        INITIALIZE POINTER TO WTABLE
*
*        SEARCH THE MODS TABLE USING THE FIELD DEFINER AS THE
*        SEARCH ARGUMENT. IF NO EQUAL COMPARE, AN ERROR MESSAGE
*        INDICATING IMPROPER EXIT IS PRINTED. IF AN EQUAL,
*        PROCESSING CONTINUES
*
RMSEARCH LA    R8,32(,R8)          UPDATE POINTER BY 32
         CLC   0(7,R8),0(R5)       COMPARE FD TO TABLE ENTRY
         BE    RCANHE              EQUAL COMPARE, BRANCH TO RCANHE
         BCT   R9,RMSEARCH         I=I-1. IF I NOT 0, GOTO RMSEARCH
         B     RMODER2             IF I=0, GOTO ERROR EXIT 2
*
RCANHE   CPITEST  CPIMCARD         MERGE ONLY ?
         BZ    RMCONT              NO, BRANCH TO RMCONT
         CLI   1(R8),C'1'          YES, IS EXIT IN PHASE 1 ?
         BE    RMODER2             YES, ERROR EXIT 2
         CLI   1(R8),C'2'          EXIT IN PHASE 2 ?
         BE    RMODER2             YES, ERROR EXIT 2
*
*        CHECK FOR PREVIOUSLY DEFINED EXITS
*
*        IF THE EXIT HAD BEEN DEFINED PREVIOUSLY, ERROR EXIT 4 IS
*        TAKEN. IF NOT, THE EXIT IS ACTIVATED, AND THE VALUES
*        CHECKED FOR VALIDITY. IF INVALID, PROPER ERROR EXITS ARE
*        TAKEN. IF VALID, THE VALUES ARE PROCESSED
*
RMCONT   TM    7(R8),X'01'         EXIT PREVIOUSLY BEEN DEFINED ?
         BO    RMODER4             YES, ERROR EXIT 4
         MVI   7(R8),X'01'         NO, INDICATE IT NOW HAS BEEN
         OC    CPICNTL+12(3),8(R8)  ACTIVATE EXIT BY SETTING BIT IN
*                                  CPICNTL EXIT MODIFICATIONS FLAGS
         LA    R5,8(,R5)           CRA=CRA+8
         CLI   0(R5),3             NUMBER OF VALUES = 3 ?
         BE    RCHINCR1            YES, BRANCH
*
         CLI   0(R5),4             NO, NUMBER OF VALUES = 4 ?
         BNE   RMODER5             NO, ERROR EXIT 5
*
*        SET THE SWITCH INDICATING AN S OR AN N HAS BEEN
*        SPECIFIED AS A FOURTH PARAMETER. IT SETS RCH3OR4 TO AN
*        UNCONDITIONAL BRANCH
*
         OI    RCH3OR4+1,X'F0'     SET SWITCH TO INDICATE 4 PARAMETERS
RCHINCR1 LA    R5,1(,R5)           CRA=CRA+1
         LA    R6,RVALID           LOAD ADDR OF ROUTINE TO DETERMINE
         BASR  R7,R6               VALID FIRST CHARACTER
         TRT   1(7,R5),RNAMETAB    ARE REMAINING CHARS VALID ?
         BM    RMODER6             INVALID CHAR, ERROR EXIT 6
         MVC   12(8,R8),0(R5)      ALL CHARS VALID, MOVE NAME TO TABLE
         LA    R5,8(,R5)           CRA=CRA+8
*
*        CHECK FOR VALIDITY OF CHARACTERS WITHIN LENGTH FIELD
*        CONVERTS LENGTH TO BINARY, PLACES IT INTO MODS TABLE,
*        AND ADDS IT TO THE LENGTH OF PHASE
*
RMODLEN  SR    R6,R6               ZERO R6
         SR    R7,R7               ZERO R7
         LA    R3,8                INITIALIZE CHAR COUNT
RMCOMP   CLI   0(R5),C'0'          C'0' ?
         BL    RMODER6             LOW, ERROR EXIT 6
         CLI   0(R5),C'9'          C'9' ?
         BH    RMODER6             HIGH, ERROR EXIT 6
         SLDL  R6,8
         IC    R7,0(,R5)           INSERT CHAR INTO R7
RMINCR   LA    R5,1(,R5)           CRA=CRA+1
         BCT   R3,RCHECK           ALL BEEN PROCESSED ?
         B     RCONVRT             YES, GOTO CONVERT
*
RCHECK   CLI   0(R5),X'FF'         X'FF' ?
         BE    RMINCR              YES, GOTO UPDATE CRA
         B     RMCOMP              NO, GOTO PROCESS NEXT CHARACTER
*
RCONVRT  STM   R6,R7,RPACK1        PLACE NUMBER INTO PACK AREA
         PACK  RPACK2(8),RPACK1(8)
         CVB   R7,RPACK2           CONVERT TO BINARY
         ST    R7,20(,R8)          STORE LENGTH IN MOD TABLE
         CLI   1(R8),C'6'          C'6' ?
         BE    RCHADD              YES, BRANCH
         CLI   2(R8),C'1'          C'1' ?
         BE    RSVALID             YES, BRANCH
         CLI   1(R8),C'1'          THIS EXIT IN PHASE 1 ?
         BE    RMADD1              YES, GOTO ADD LENGTH TO PHASE1
         CLI   1(R8),C'2'          EXIT IN PHASE 2 ?
         BE    RMADD2              YES, GOTO ADD LENGTH TO PHASE2
         CLI   1(R8),C'3'          IS THIS EXIT IN PHASE 3
         BE    RMADD3              YES, GOTO ADD LENGTH TO PHASE3
RCHADD   ST    R7,RMPARSUM         IF E61, ADD LENGTH OF MODIFICATION
         ICM   R9,B'0111',CPIP1RSZ   MODULE TO CURRENT TOTAL LENGTH
         LA    R7,0(R7,R9)           PHASE 1
         STCM  R7,B'0111',CPIP1RSZ
*
         L     R7,RMPARSUM
         ICM   R9,B'0111',CPIP2RSZ
         LA    R7,0(R7,R9)           PHASE 2
         STCM  R7,B'0111',CPIP2RSZ
*
         L     R7,RMPARSUM
         ICM   R9,B'0111',CPIP3RSZ
         LA    R7,0(R7,R9)           PHASE 3
         STCM  R7,B'0111',CPIP3RSZ
         B     RSVALID               GOTO CHECK VALIDITY OF SOURCE
*
RMADD1   ICM   R9,B'0111',CPIP1RSZ   ADD LENGTH OF USER MODIFICATION
         LA    R7,0(R7,R9)           ROUTINE TO CURRENT PHASE1
         STCM  R7,B'0111',CPIP1RSZ   SAVE PH1 RUNNING MODS
         B     RSVALID               GO CHK VALIDITY OF 1ST CHAR
*
RMADD2   ICM   R9,B'0111',CPIP2RSZ   SAME PROCEDURE AS RMADD1
         LA    R7,0(R7,R9)
         STCM  R7,B'0111',CPIP2RSZ   SAVE PH2 RUNNING MODS SIZE
         B     RSVALID               GO CHK VALIDITY OF 1ST CHAR
*
RMADD3   ICM   R9,B'0111',CPIP3RSZ   SAME PROCEDURE AS RMADD1
         LA    R7,0(R7,R9)
         STCM  R7,B'0111',CPIP3RSZ   SAVE PH3 RUNNING MODS SIZE
*
*        CHECK THE VALIDITY OF THE SOURCE DD NAME CHARACTERS
*
*        IF INVALID THE PROPER ERROR EXIT IS TAKEN. IF VALID, THE
*        SOURCE DD NAME IS PLACED IN THE MODS TABLE
*
RSVALID  LA    R6,RVALID           BRANCH AND LINK TO ROUTINE WHICH
         BASR  R7,R6               DETERMINES VALIDITY OF 1ST CHAR
         TRT   1(7,R5),RNAMETAB    REMAINING CHARS VALID ?
         BM    RMODER6             INVALID, ERROR EXIT 6
         MVC   24(8,R8),0(R5)      MOVE SOURCE DD NAME TO MOD TABLE
         LA    R5,8(,R5)           CRA=CRA+8
*
*        SET UP CPILINK AND THE MODS ACTIVE BYTE DEPENDING UPON
*        THE PARAMETER SPECIFIED ON THE MODS CARD
*
*        THE FOLLOWING INSTRUCTION IS SET UP ACCORDING TO 3 OR 4
*        PARAMETERS ON THE MODS CARD. IF 3, IT IS MADE A NOP.
*        IF 4, IT IS MADE AN UNCONDITIONAL BRANCH
*
RCH3OR4  NOP   RCH4                UNCONDITIONAL BRANCH IF 4
         OC    CPILINK,8(R8)       INDICATE EXIT IS TO BE LINKEDITED
         MVI   7(R8),X'03'         CHANGE ACTIVE BYTE IN MOD TABLE TO
*                                  INDICATE LINK-EDIT
RCHLINK  OI    CPILINK+2,X'08'     SET LINK-EDIT BIT ON IN CPILINK
         B     RCHALL              CONTINUE AT RCHALL
*
RCH4     MVI   RCH3OR4+1,X'00'
         CLC   0(8,R5),KSCON       FOURTH PARAMETER 'S' ?
         BNE   RCHISN              NO, BRANCH
*
         CLC   0(4,R8),KE11        E11 ?
         BNE   RCHIS21             NO, BRANCH
*
         OI    CPILINK+2,X'40'     YES, INDICATE LINK EDIT E11 ALONE
*                                  IN CPILINK
RCHIND   MVI   7(R8),X'05'         INDICATE LINK EDIT ALONE IN MOD TAB
         LA    R5,8(0,R5)          CRA=CRA+8
         B     RCHLINK             GO SET LINK EDIT BIT ON
*
RCHIS21  CLC   0(4,R8),KE21        E21 ?
         BNE   RCHIS31             NO, BRANCH
*
         OI    CPILINK+2,X'20'     YES, INDICATE LINK EDIT E21 ALONE
*                                  IN CPILINK
         B     RCHIND              INDICATE LINK EDIT ALONE IN MOD TAB
*
RCHIS31  CLC   0(4,R8),KE31        E31 ?
         BNE   RMODER5             NO, BRANCH TO ERROR MESSAGE
*
         OI    CPILINK+2,X'10'     YES, INDICATE LINK EDIT ALONE IN
*                                  CPILINK
         B     RCHIND              INDICATE LINK EDIT ALONE IN MOD TAB
*
RCHISN   CLC   0(8,R5),KNCON       FOURTH PARAMETER 'N' ?
         BNE   RMODER5             NO, BRANCH TO ERROR MESSAGE
*
         CLC   12(7,R8),0(R8)      MOD NAME = EXIT NAME ?
         BNE   RMODER5             NO, ERROR MESSAGE
*
         LA    R5,8(,R5)           YES, CRA=CRA+8
*
*        DETERMINE IF ALL THE FIELD DEFINERS HAVE BEEN HANDLED
*
*        IF NOT, IT RETURN TO REPEAT PROCESS. IF SO, IT MAKE
*        SEVERAL TESTS BEFORE EXITING. IT CHECKS FOR MODS
*        APPEARING MORE THAN ONCE IN THE SAME PHASE. IF SO,
*        ERROR. IT CHECKS FOR PROPER USE OF E61
*
RCHALL   BCT   R4,RINITI           IF ALL FD'S NOT PROCESSED, RETURN
*                                  TO COMPLETE PROCESSING
         ST    R4,RNUMBER
         ST    R4,RTEE             T=0
         MVI   RNUMBER+3,X'05'     NUMBER=5
         LA    R6,WTABLE-20        R6=WTABLE-20
RPLACE   L     R3,RNUMBER          R3=NUMBER
RPLACE1  LA    R6,32(,R6)          R6=R6+32
         CLI   0(R6),X'00'         NAME PRESENT ?
         BE    RLOADNUM            NO, BRANCH TO RLOADNUM
         LA    R7,32(,R6)          R7=R6+32
RISIT1   CLI   0(R7),X'00'         NAME PRESENT ?
         BE    RDEC                NO, BRANCH TO RDEC
         CLC   0(8,R6),0(R7)       COMPARE NAMES
         BE    RCHISSOR            EQUAL ? BRANCH
RDEC     BCT   R3,RADJUST          R3=R3-1, R3 ¬ 0, BRANCH
         CLC   0(8,R6),MEXIT61+12  NAME SAME AS E61 ?
         BE    RCHSOR1             EQUAL ? BRANCH
RLOADNUM L     R3,RNUMBER          R3=NUMBER
         BCT   R3,RPLACE2          R3=R3-1, IF R3 ¬ 0 BRANCH
         L     R3,RTEE             R3=T
         LA    R3,1(0,R3)          R3=R3+1
         ST    R3,RTEE             T=T+1
         CLI   RTEE+3,2            T > 2 ?
         BH    RBIT33              YES, CONTINUE AT RBIT33
         MVI   RNUMBER+3,4         NO, NUMBER=4
         LA    R6,32(,R6)          R6=R6+32
         B     RPLACE              GO BACK TO RPLACE
*
RADJUST  LA    R7,32(0,R7)         GH=R7+32
         B     RISIT1              GO CHK FOR PRESENCE OF NAME
*
RPLACE2  ST    R3,RNUMBER          NUMBER=NUMBER+1
         B     RPLACE1             START AGAIN
*
*
RCHISSOR CLC   12(8,R6),12(R7)     SOURCES OF MODS ALSO EQUAL ?
         BNE   RDEC                NO, TAKE BRANCH
*
         SH    R6,KH5              DECREMENT MOD TABLE POINTERS TO
         SH    R7,KH5              ACTIVATED BYTE
         CLI   0(R6),X'03'         BOTH MODS TO BE LINK EDITED
         BNE   RMODER9             TOGETHER ?
         CLI   0(R7),X'03'         NO, ERROR MESSAGE 9
         BNE   RMODER9             GOTO GIVE ERROR MESSAGE
*
         AH    R6,KH5              YES, RESTORE MOD TABLE POINTERS
         AH    R7,KH5
         MVI   0(R7),X'00'         ZERO FIRST BYTE OF 2ND ENTRY NAME
*                                  IN MOD TABLE
         B     RDEC                GOTO DECREMEN COUNT
*
RCHSOR1  CLC   12(8,R6),MEXIT61+24  THE 2 SOURCES EQUAL ?
         BNE   RLOADNUM            NO, BRANCH
*
         SH    R6,KH5              DECR PTR TO ACTIVE BYTE OF FIRST ENT
         CLI   0(R6),X'03'         TO BE LINK-EDITED ?
         BNE   RMODER9             NO, ERROR MESSAGE 9
         AH    R6,KH5              YES, RESTORE ENTRY POINTER
         CLI   MEXIT61+7,X'03'     E61 TO BE LINK EDITED ?
         BNE   RMODER9             NO, ERROR MESSAGE 9
*
         MVI   0(R6),X'00'         YES, ZERO FIRST BYTE OF NAME
         B     RLOADNUM            GOTO RELOAD NUMBER
*
RMATTACH CPITEST  CPIME15          E15 ACTIVATED BY ATTACHED SORT ?
         BO    RSETMOD             YES, BRANCH
         CPITEST  CPIME35          NO, E35 ACTIVATED ?
         BZ    RNOMOD              NO
RSETMOD  CPISETON CPIMODS          SET MODS ON
         B     RSETZERO            RETURN
*
RNOMOD   CPISETON CPINOMOD         NO MODS
         B     RSETZERO            RETURN
*
*        CHECK THAT ALL THE MODS WHICH ARE TO BE LOADED WITHOUT
*        LINK EDITING HAVE SPECIFIED THE SAME SOURCE AND MOVES
*        THAT SOURCE NAME INTO CPISORCE
*
RBIT33   LA    R5,MEXIT61          INITIALIZE POINTER FOR SEARCHING
         LA    R4,32               THROUGH MODS TABLE
         LA    R3,WTABLE
*
RCHNOLE  CLI   7(R3),X'01'         THIS EXIT ACTIVATED WITH NO
*                                  LINK EDIT ?
         BNE   RCHUPPTR            NO, TAKE BRANCH
*
*        THE FOLLOWING INSTRUCTION IS USED AS A FIRST TIME
*        SWITCH. IT IS A NOP THE FIRST TIME IT IS EXECUTED,
*        THEN IT IS CHANTED TO AN UNCONDITIONAL BRANCH
*
RCHSW    NOP   RCHSOREQ            FIRST TIME SWITCH
         OI    RCHSW+1,X'F0'       FIRST TIME SET SWITCH TO
*                                  UNCONDITONAL BRANCH
         CLC   24(6,R3),KSYSINFF   SOURCE SYSIN ?
         BE    RMODER5             YES, ERROR MESSAGE
         MVC   RPACK1(8),24(R3)    MOVE SOURCE NAME INTO TEMP AREA
         MVC   CPISORCE(8),24(R3)  MOVE SOURCE NAME INTO CPISORCE
         LA    R7,CPISORCE         SET UP REGISTERS FOR MOVING BLANKS
         LA    R9,7(,R7)           INTO SOURCE NAME
         LA    R8,1
RCHCOMP  CLI   0(R7),X'FF'         CHARACTER A PADDING CHARACTER ?
         BNE   RCHINCR             NO, BRANCH
*
         MVI   0(R7),C' '          YES, MAKE IT A BLANK
RCHINCR  BXLE  R7,R8,RCHCOMP       SOURCE COMPLETELY MOVED - NO BRANCH
*
         B     RCHUPPTR            YES, BRANCH
*
RCHSOREQ CLC   24(8,R3),RPACK1     NEW SOURCE EQUAL OLD SOURCE ?
         BNE   RMODER5             NO, ERROR
*
RCHUPPTR BXLE  R3,R4,RCHNOLE       TABLE COMPLETELY CHECKED - NO BRANCH
*
*        CHECK FOR PROPER USE OF E61
*
*        IF CPIETCF IS ON E61 MUST BE ACTIVATED. IF
*        CPIETCF IS NOT ON, E61 CANNOT BE ACTIVATED
*
         CPITEST  CPIETCF          E-TYPE CNTL FIELDS PRESENT ?
         BO    RISON               YES, BRANCH TO RISON
         TM    MEXIT61+7,X'01'     E61 BEEN DEFINED ?
         BO    RMODER11            YES, ERROR EXIT 11
RSETZERO SR    R15,R15             SET ZERO IN R15
*
*        COPY USER MODIFICATIONS
*
*        SOURCE IS SYSIN, FROM SYSIN ONTO SORTMODS
*
         LA    R5,MEXIT61+12       INITIALIZE END OF TABLE POINTER
         LA    R4,32               INCREMENT
         LA    R3,WTABLE+12        BEGINNING POINTER
RMISSYS  CLC   KSYSINFF(6),12(R3)  MODIFICATION SOURCE SYSIN ?
         BE    COPY                YES, BRANCH TO COPY
SDDONE   BXLE  R3,R4,RMISSYS       NO, UP POINTER
*
CPYCLOSE CLOSE (SYSIN)             CLOSE SYSIN
*
         TM    CPYSW1+1,X'FF'      SYSIN OPENED ?
         BZ    CPYNOSYS            NO, SKIP FREEPOOL
*
         FREEPOOL SYSIN
*
CPYNOSYS CLOSE (SORTMODS)          CLOSE SORTMODS
*
         L     R15,CPYSAVE
         B     RMRETURN            RETURN TO MAIN PROGRAM
*
CPYERROR LA    R15,4               ERROR - RETURN AND
*
RMRETURN L     R12,MODSAV12
         L     R14,MODSAV14        RESTORE REGISTERS
         L     R2,CPIACNTL         R2 -> TARGET
         LA    R3,WTABLEL          R3 = L'TARGET
         LA    R4,WTABLE           R4 -> SOURCE
         LR    R5,R3               L'SOURCE = L'TARGET
         MVCL  R2,R4               MOVE MODS TABLE INTO CONTROL AREA
         LM    R2,R11,0(R12)       RESTORE REGS 2-11
         BR    R14                 RETURN
*
*        SUBROUTINE IS USED WHENEVER THERE ARE USER ROUTINES FOR
*        MODIFICATION IN SYSIN. IT COPIES EACH OF THE USER
*        ROUTINES FROM SYSIN ONTO THE DISK AND ORGANIZES THEM
*        INTO A PARTITIONED DATA SET SO THAT THEY CAN LATER BE
*        INCLUDED WITH THE PROPER SORT/MERGE MODULES FOR LINK
*        EDITING AND LOADING. BSAM AND BPAM ARE USED TO PERFORM
*        I/O FUNCTIONS.
*
*        R3 -> CORE AREA WHICH CONTAINS THE NAME OF THE USER ROUTINE
*        THIS NAME HAS RIGHT HAND PADDING OF X'FF'
*
COPY     MVC   12(8,R3),KSORTMOD   CHANGE SOURCE NAME TO SORTMODS
         MVI   CPYSW2,X'00'        TURN DATA READ SWITCH OFF
         ST    R15,CPYSAVE
CPYSW1   NOP   CPYREAD             OPEN FIRST TIME THRU ONLY
         OI    CPYSW1+1,X'F0'      SET SW TO SKIP OPENS NEXT TIME
*
         OPEN  (SYSIN,(INPUT),SORTMODS,(OUTPUT))  OPEN SYSIN, SORTMODS
*
*        CHECK THAT THE TWO PREVIOUS OPENS WERE SUCCESSFULL
*
         LTR   R15,R15             BOTH OPENS SUCCESSFUL ?
         BZ    CPYREAD             YES, CONTINUE PROCESSING
         L     R3,VIERRCU          R3 -> IERRCU MSG MODULE
         USING DIERRCU,R3
         LM    R0,R1,IER063        IER063A OPEN ERROR -
*
         LA    R1,SYSIN            R1 -> SYSIN DCB
         USING IHADCB,R1
         TM    DCBOFLGS,DCBOFOPN   SYSIN OPEN SUCCESSFULLY ?
         BO    CPYNEXT             YES, BRANCH
         MVC   IER063A,IER063F     MOVE DDNAME INTO MSG
         B     RMPRINTA            GO PRINT MESSAGE
*
CPYNEXT  LA    R1,SORTMODS         R1 -> SORTMODS DCB
         TM    DCBOFLGS,DCBOFOPN   SORTMODS OPEN SUCCESSFULLY ?
         BO    CPYREAD             YES, BRANCH AND CONTINUE
         MVC   IER063A,IER063G     MOVE DDNAME INTO MSG
         DROP  R3,R1
         B     RMPRINTA            GO PRINT MESSAGE
*
CPYREAD  GET   SYSIN,IOAREA
*
         CLI   IOAREA,C' '         BLANK IN COLUMN 1 ?
         BNE   CPYACPT             NO, BRANCH
         TM    CPYSW2,X'FF'        HAD ANY DATA CARDS YET ?
         BZ    CPYREAD             NO, THIS MUST BE A SORT CONT CARD
CPYACPT  MVI   CPYSW2,X'FF'        TURN DATA READ SWITCH ON
SYSINEOD TM    CPYSW2,X'FF'        IF ONLY AN END OF FILE WAS READ
         BZ    RMODER7             THE SWITCH IS 0 AND IN ERROR
*
         WRITE CPYDECB2,SF,SORTMODS,IOAREA   WRITE A RECORD
*
         CHECK CPYDECB2            WAIT FOR WRITE TO COMPLETE
*
         CLC   KCPYEND(3),IOAREA+1 THE LAST CARD FOR THIS ROUTINE ?
         BNE   CPYREAD             NO, READ NEXT CARD
         MVC   CPYSTWAR(8),0(R3)   YES, MOVE MEMBER NAME INTO STOW AREA
*
*        CHANGE RIGHT HAND PADDING OF MEMBER NAME FROM X'FF' TO
*        BLANKS
*
         LA    R6,CPYSTWAR+7       SET PTR TO LAST CHAR OF NAME
CPYCHKPD CLI   0(R6),X'FF'         CHECK FOR PAD CHARACTER
         BNE   CPYSTOW             NO, BRANCH TO STOW
         MVI   0(R6),C' '          MOVE IN BLANK PADDING
         BCT   R6,0                DECR TO PREVIOUS CHAR
         B     CPYCHKPD            LOOP THROUGH CPYSTWAR
*
*        CHANGE OF PADDING IS COMPLETE - ISSUE STOW
*
CPYSTOW  STOW  SORTMODS,CPYSTWAR,A   STOW MEMBER NAME INTO SORTMODS
*
         LTR   R15,R15             SUCESSFULL STOW ?
         BNZ   CPYERROR            NO, BRANCH
         L     R15,CPYSAVE         RESTORE R15
         B     SDDONE              RETURN TO MAIN PROGRAM
*
RISON    TM    MEXIT61+7,X'01'     E61 BEEN ACTIVATED ?
         BO    RSETZERO            YES, BRANCH TO RSETZERO
         USING DIERRCU,R3          ESTABLISH DSECT ADDRESSABILITY
RMODER10 LA    R3,IER032-DIERRCU   IER032A EXIT E61 REQUIRED BUT NOT
RMPRINT  A     R3,VIERRCU
         LM    R0,R1,0(R3)         R0 -> ADDR OF MSG, R1 = L'MSG
RMPRINTA L     R15,VGAPRT          R15 -> MSG WRITER
         BASR  R14,R15             CALL MSG WRITER
         L     R1,0(,R3)
         MVC   CPIABMNO,3(R1)      MOVE MSG NUMBER INTO ABEND NO
         LA    R15,4               SET ERROR CODE IN R15
         B     RMRETURN            GO RESTORE REGS AND RETURN
*
RMODER1  LA    R3,IER028-DIERRCU   IER028A MORE THAN 17 EXITS
         B     RMPRINT
*
RMODER2  LA    R3,IER029-DIERRCU   IER029A INVALID EXIT NUMBER
         B     RMPRINT
*
RMODER4  LA    R3,IER030-DIERRCU   IER030A DUPLICATE EXIT DEFINITION
         B     RMPRINT
*
RMODER6  LA    R3,IER031-DIERRCU   IER031A INVALID CHARACTER IN MODS
         B     RMPRINT
*
RMODER11 LA    R3,IER033-DIERRCU   IER033A NO E CONTROL FIELD SPECIFIED
         B     RMPRINT
*
RMODER5  LA    R3,IER034-DIERRCU   IER034A PARAMETER ERROR ON MODS
         B     RMPRINT
*
RMODER9  LA    R3,IER035-DIERRCU   IER035A DUPLICATE EXIT MODULE NAME
         B     RMPRINT
*
RMODER7  LA    R3,IER065-DIERRCU   IER065A SYSIN DECK STRUCTURE ERROR
         B     RMPRINT
*
         DROP  R3
*
*        CHECK THE FIRST CHARACTER OF THE NAME FOR VALIDITY
*        THE CHARACTER MUST BE ALPHABETIC ELSE ERROR EXIT 10
*        IS TAKEN
*
RVALID   CLI   0(R5),C'A'
         BL    RMSP                GO TEST FOR SPECIAL CHAR
         CLI   0(R5),C'R'
         BH    RMZ                 GO TEST FOR CHAR Z
         CLI   0(R5),C'J'
         BNL   RMLEAVE             RETURN TO CONTINUE VALIDITY CHECK
         CLI   0(R5),C'I'
         BH    RMODER6             GO GET MSG ADDR
RMLEAVE  BR    R7                  RETURN TO CONTINUE VALIDITY CHECK
*
RMSP     CLI   0(R5),C'@'
         BE    RMLEAVE
         CLI   0(R5),C'#'
         BE    RMLEAVE
         CLI   0(R5),C'$'
         BE    RMLEAVE
         B     RMODER6             GO GET MSG ADDR
*
RMZ      CLI   0(R5),C'Z'
         BH    RMODER6             GO GET MSG ADDR
         CLI   0(R5),C'S'
         BL    RMODER6             GO GET MSG ADDR
         BR    R7                  RETURN TO CONTINUE VALIDITY CHECK
*
*        CONSTANTS AND WORK AREA
*
         DS    0F'0'
KH5      DC    H'5'                USED TO UPDATE POINTERS
KNCON    DC    X'D5FFFFFFFFFFFFFF' CONSTANT -N-
KSCON    DC    X'E2FFFFFFFFFFFFFF' CONSTANT -S-
KE11     DC    X'C5F1F1FF'         CONSTANT E11
KE21     DC    X'C5F2F1FF'         CONSTANT E21
KE31     DC    X'C5F3F1FF'         CONSTANT E31
KSORTMOD DC    CL8'SORTMODS'       CONSTANT
KSYSINFF DC    X'E2E8E2C9D5FF'     SYSINFF CONSTANT
CPYSTWAR DC    D'0'                STOW AREA
         DC    A(0)                NOT USED
CPYSAVE  DC    A(0)                SAVE AREA FOR R15
*
KMODS    DC    CL6'MODS'           CONSTANT PASSED TO SCAN ROUTINE
KCPYEND  DC    C'END'              CONSTANT
CPYSW2   DC    X'00'               DATA READ SWITCH
*
IOAREA   DC    XL80'00'            READ/WRITE AREA FOR SYSIN/SORTMODS
*
         DC    0D'0'
VIERRCD  DC    V(IERRCD)           ADDR OF SCAN ROUTINE
VIERRCU  DC    V(IERRCU)           ADDR OF MESSAGE MODULE
VGAPRT   DC    V(IERGAPRT)         ADDR OF PRINT ROUTINE
MODSAV12 DC    F'0'                SAVE AREA FOR R12
MODSAV14 DC    F'0'                SAVE AREA FOR R14
RPACK1   DC    D'0'                PACK AREA -
RPACK2   DC    D'0'                          - USED FOR CONVERSION
RMPARSUM DC    F'0'                PARTIAL MOD SUM
RNUMBER  DC    F'0'                NUMBER FOR MODS PER PHASE
RTEE     DC    F'0'                T FOR MODS PER PHASE
RMTEMP   DC    F'0'                TEMP PARTIAL SUM
*
         PRINT NOGEN
*
SYSIN    DCB   DSORG=PS,MACRF=(GM),RECFM=FB,LRECL=80,                  X
               EODAD=SYSINEOD,SYNAD=CPYERROR,DDNAME=SYSIN
*
SORTMODS DCB   DSORG=PO,MACRF=(W),DDNAME=SORTMODS,RECFM=F,LRECL=80,    X
               BLKSIZE=80,SYNAD=CPYERROR
*
         PRINT GEN
*
*        TRANSLATE AND TEST TABLE
*
*        USED FOR CHECKING THE VALIDITY OF CHARACTERS IN THE
*        SOURCE AND NAME PARAMETERS ON THE MODS CARD
*
         DC    0D'0'
RNAMETAB DC    91X'01'             T
         DC    X'00'                R
         DC    31X'01'               A
         DC    2X'00'                 N
         DC    68X'01'                 S    T
         DC    9X'00'                   L    E
         DC    7X'01'                    A    S
         DC    9X'00'                     T    T
         DC    8X'01'                      E
         DC    8X'00'                            T
         DC    6X'01'                        A    A
         DC    10X'00'                        N    B
         DC    5X'01'                          D    L
         DC    X'00'                                 E
*
*        INFORMATION TABLE FOR USER MODIFICATION MODULES
*
*        EACH EXIT HAS AN ENTRY IN THE TABLE. THE ENTRY
*        INITIALLY CONTAINS THE NAME OF THE EXIT PADDED WITH
*        X'FF' IN THE FIRST SEVEN BYTES. THE NINTH THROUGH 12TH
*        BYTES ORIGINALLY CONTAIN A MASK WHICH, IF THE EXIT IS
*        ACTIVATED IS USED TO SET THE CORRECT FLAG IN CPICNTL EXIT FLAG
*
*        WHEN AN EXIT IS ACTIVATED, IERRCH SETS BYTE 8 IN ITS
*        CORRESPONDING ENTRY TO X'01' TO INDICATE IT HAS BEEN
*        ACTIVATED AND PLACES ITS NAME IN BYTES 13-20, ITS LENGTH
*        IN BYTES 21-24, AND ITS SOURCE NAME IN BYTES 25-32. AT
*        THE END OF THE ROUTINE, THIS TABLE IS MOVED INTO THE
*        CONTROL AREA FOR LATER USE BY IERRCP
*
         DC    0D'0'
WTABLE   DC    CL3'E11'        +0  EXIT NAME E11
         DC    X'FFFFFFFF'     +3  FF PADDING
         DC    X'00'           +7  DEFINITION BYTE
         DC    X'80000000'     +8  MASK FOR SETTING CPICNTL EXIT FLAG
         DC    8X'00'              MOD NAME
         DC    4X'00'              MOD LENGTH
         DC    8X'00'              MOD SOURCE
*
MEXIT15  DC    CL3'E15'            E15
         DC    X'FFFFFFFF'         PADDING
         DC    X'00'               MASK TO INDICATE IF EXIT ACTIVATED
         DC    X'40000000'         MASK
         DC    8X'00'              NAME FIELD
         DC    4X'00'              LENGTH FIELD
         DC    8X'00'              SOURCE NAME
*
MEXIT16  DC    CL3'E16'            E16
         DC    X'FFFFFFFF'         PADDING
         DC    X'00'               MASK TO INDICATE IF EXIT ACTIVATED
         DC    X'20000000'         MASK
         DC    8X'00'              NAME FIELD
         DC    4X'00'              LENGTH FIELD
         DC    8X'00'              SOURCE NAME
*
MEXIT17  DC    CL3'E17'            E17
         DC    X'FFFFFFFF'         PADDING
         DC    X'00'               MASK TO INDICATE IF EXIT ACTIVATED
         DC    X'10000000'         MASK
         DC    8X'00'              NAME FIELD
         DC    4X'00'              LENGTH FIELD
         DC    8X'00'              SOURCE NAME
*
MEXIT18  DC    CL3'E18'            E18
         DC    X'FFFFFFFF'         PADDING
         DC    X'00'               MASK TO INDICATE IF EXIT ACTIVATED
         DC    X'08000000'         MASK
         DC    8X'00'              NAME FIELD
         DC    4X'00'              LENGTH FIELD
         DC    8X'00'              SOURCE NAME
*
MEXIT19  DC    CL3'E19'            E19
         DC    X'FFFFFFFF'         PADDING
         DC    X'00'               MASK TO INDICATE IF EXIT ACTIVATED
         DC    X'00020000'         MASK
         DC    8X'00'              NAME FIELD
         DC    4X'00'              LENGTH FIELD
         DC    8X'00'              SOURCE NAME
*
MEXIT21  DC    CL3'E21'            E21
         DC    X'FFFFFFFF'         PADDING
         DC    X'00'               MASK TO INDICATE IF EXIT ACTIVATED
         DC    X'04000000'         MASK
         DC    8X'00'              NAME FIELD
         DC    4X'00'              LENGTH FIELD
         DC    8X'00'              SOURCE NAME
*
MEXIT25  DC    CL3'E25'            E25
         DC    X'FFFFFFFF'         PADDING
         DC    X'00'               MASK TO INDICATE IF EXIT ACTIVATED
         DC    X'02000000'         MASK
         DC    8X'00'              NAME FIELD
         DC    4X'00'              LENGTH FIELD
         DC    8X'00'              SOURCE NAME
*
MEXIT27  DC    CL3'E27'            E27
         DC    X'FFFFFFFF'         PADDING
         DC    X'00'               MASK TO INDICATE IF EXIT ACTIVATED
         DC    X'01000000'         MASK
         DC    8X'00'              NAME FIELD
         DC    4X'00'              LENGTH FIELD
         DC    8X'00'              SOURCE NAME
*
MEXIT28  DC    CL3'E28'            EI8
         DC    X'FFFFFFFF'         PADDING
         DC    X'00'               MASK TO INDICATE IF EXIT ACTIVATED
         DC    X'00800000'         MASK
         DC    8X'00'              NAME FIELD
         DC    4X'00'              LENGTH FIELD
         DC    8X'00'              SOURCE NAME
*
MEXIT29  DC    CL3'E29'            E29
         DC    X'FFFFFFFF'         PADDING
         DC    X'00'               MASK TO INDICATE IF EXIT ACTIVATED
         DC    X'00010000'         MASK
         DC    8X'00'              NAME FIELD
         DC    4X'00'              LENGTH FIELD
         DC    8X'00'              SOURCE NAME
*
MEXIT31  DC    CL3'E31'            E31
         DC    X'FFFFFFFF'         PADDING
         DC    X'00'               MASK TO INDICATE IF EXIT ACTIVATED
         DC    X'00400000'         MASK
         DC    8X'00'              NAME FIELD
         DC    4X'00'              LENGTH FIELD
         DC    8X'00'              SOURCE NAME
*
MEXIT35  DC    CL3'E35'            E35
         DC    X'FFFFFFFF'         PADDING
         DC    X'00'               MASK TO INDICATE IF EXIT ACTIVATED
         DC    X'00200000'         MASK
         DC    8X'00'              NAME FIELD
         DC    4X'00'              LENGTH FIELD
         DC    8X'00'              SOURCE NAME
*
MEXIT37  DC    CL3'E37'            E37
         DC    X'FFFFFFFF'         PADDING
         DC    X'00'               MASK TO INDICATE IF EXIT ACTIVATED
         DC    X'00100000'         MASK
         DC    8X'00'              NAME FIELD
         DC    4X'00'              LENGTH FIELD
         DC    8X'00'              SOURCE NAME
*
MEXIT38  DC    CL3'E38'            E38
         DC    X'FFFFFFFF'         PADDING
         DC    X'00'               MASK TO INDICATE IF EXIT ACTIVATED
         DC    X'00080000'         MASK
         DC    8X'00'              NAME FIELD
         DC    4X'00'              LENGTH FIELD
         DC    8X'00'              SOURCE NAME
*
MEXIT39  DC    CL3'E39'            E39
         DC    X'FFFFFFFF'         PADDING
         DC    X'00'               MASK TO INDICATE IF EXIT ACTIVATED
         DC    X'00008000'         MASK
         DC    8X'00'              NAME FIELD
         DC    4X'00'              LENGTH FIELD
         DC    8X'00'              SOURCE NAME
*
MEXIT61  DC    CL3'E61'            E61
         DC    X'FFFFFFFF'         PADDING
         DC    X'00'               MASK TO INDICATE IF EXIT ACTIVATED
         DC    X'00040000'         MASK
         DC    8X'00'              NAME FIELD
         DC    4X'00'              LENGTH FIELD
         DC    8X'00'              SOURCE NAME
*
WTABLEL  EQU   *-WTABLE            LENGTH OF WTABLE
*
DIERRCU  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRCU SOURCE
*
*----------------------------------------------------------------------
*
         COPY IERRCUI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
*        MAP DCB
*
         PRINT NOGEN
*
         DCBD  DSORG=(PS),DEVD=(DA)
*
         PRINT GEN
*
         SMCPI
*
         END
./ ADD NAME=IERRCI   0101-20211-20211-1200-02164-02164-00000-RELEASE 00
RCI      TITLE ' IERRCI - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRCI
*
*        MODULE FUNCTION/OPERATION -
*        IMPLEMENT DYNAMIC ALLOCATION OF SORTWORK DATA SETS IF
*        REQUESTED AND GATHER SYSTEM INFORMATION FOR SORT. THE
*        FOLLOWING IS A LIST OF THE ITEMS AND SOURCE OF EACH -
*        1.  FIXED OR VARIABLE RECORDS - JFCB OR DSCB
*        2.  TAPE OR DISK - UCB
*        3.  LRECL, < OR > 256 - JFCB OR DSCB
*        4.  SINGLE OR DOUBLE WORD ALIGNMENT - JFCB
*        5.  CHANNEL ENVIRONMENT - UCB
*        6.  INPUT WORK UNIT - TIOT
*        7.  TAPE SWITCH OR TAU - UCB
*        8.  CHANNEL ENVIRONMENT - UCB
*        9.  NUMBER OF WORK UNITS - TIOT
*        10. INPUT BLOCKING - JFCB OR DSCB
*        11. OUTPUT BLOCKING - JFCB OR DSCB
*        12. RECORD LENGTHS - JFCB OR DSCB
*        CHANGE LOG -
*
*        REPLACE USE OF SNAP TO PRINT CONTROL BLOCKS FOR      REL 1.1
*        DIAGNOSTIC PURPOSES WITH IERFMT MODULE
*
*        MACROS USED -
*        OBTAIN
*        SMCPI
*        CAMLST
*        DCB
*
*        ENTRY POINT - ENTRY IERRCI
*                      ENTRY FROM - IERRCM
*                                   CALLING SEQUENCE -
*                                   L R15,=V(IERRCI)
*                                   BALR R14,R15
*
*        INPUT - CPI FIELDS REFERENCED -
*        CPICNTL - MERGE AND ATTACHED TEST
*                - E35 AND E15 ACTIVATED
*
*        OUTPUT - CPI FIELDS INITIALIZED OR ALTERED -
*        CPINWKU  - NO OF WORK UNITS (DATA SETS)
*        CPIIPBLK - INPUT BLOCKING
*        CPIOPBLK - OUTPUT BLOCKING
*        CPIRCDL1
*        CPIRCDL2
*        CPIRCDL3
*        CPIRCDL4
*        CPIRCDL5
*        CPICNTL - 1. TAPE, DISK
*                  2. CHANNEL ENVIRONMENT
*                  3. DATA CHAINING
*                  4. INPUT A WORK
*                  5. WORD ALIGNMENT
*                  6. FIXED OR VARIABLE
*                  7. LE OR GT 256
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL -
*        IERRCM WITH ZERO IN R15
*
*        EXITS - ERROR -
*        IERRCM WITH FOUR IN R15
*
*        TABLES/WORK AREAS -
*        SORTWTAB - CHECKING SORT TIOT ENTIES
*        MERGWTAB - CHECKING MERGE TIOT ENTRIES
*
IERRCI   CSECT
*
         USING *,R10,R11
         USING TIOT1,R5
         USING UCB,R9
         USING IERRC5,R13
*
         IERENTRY 'IERRCI &SYSDATE &SYSTIME'
*
         STM   R14,R12,12(R12)     SAVE R14 - R12
         LA    R10,0(,R15)         SET BASE REGISTER
         LA    R11,2048(,R10)
         LA    R11,2048(,R11)
         ST    R12,CISAVE12        SAVE R12
*
*        GET THE TIOT ADDR
*
         EXTRACT TIOTADDR,'S',FIELDS=(TIOT)  GET ADDR OF TIOT
*
*----------------------------------------------------------------------
*
*        SCAN TIOT TO DETERMINE WHICH DATA SETS WERE PROVIDED
*        BY JCL
*
*----------------------------------------------------------------------
*
         USING UTABLE,R8           ADRESSABILITY FOR SORT TIOT TABLE
         L     R5,TIOTADDR         ESTABLIST BASE FOR TIOT DSECT
         SR    R6,R6               CLEAR R6, WORK DATA SET COUNTER
         SR    R7,R7               CLEAR R7
         NI    CISWITCH,X'00'      TURN OFF ALL SWITCHES
*
*        SET DDN PREFIX TO USER SPECIFIED VALUE
*
         LA    R8,SORTWTAB         R8 -> SORT UNIT TABLE
         LA    R12,34              SET LOOP COUNTER TO 32 SORKWKXX
*                                  DDNAMES PLUS SORTIN AND SORTOUT
CI001P   MVC   DDNAME(4),CPIDDSRT  SET DDN PREFIX TO USER SPEC VALUE
         LA    R8,UTABLEL(,R8)     INCR R8 TO NEXT UNIT TABLE ENTRY
         BCT   R12,CI001P          LOOP BACK UNTIL LIST IS EXHAUSTED
*
*        DETERMINE IF MERGE PROCESSING
*
         CPITEST  CPIMERGO         MERGE ONLY ?
         BO    CI100               YES, BRANCH TO MERGE PROCESSING
*
*        SORT PROCESSING
*
*        FOR EACH DD ENTRY IN THE TIOT LOOP THROUGH THE UNIT
*        TABLE TO FIND A MATCH WITH THE TIOT DDNAME
*
CI001    LA    R12,34              SET LOOP COUNTER TO 32 SORKWKXX
*                                  DDNAMES PLUS SORTIN AND SORTOUT
         LA    R8,SORTWTAB         R8 -> SORT UNIT TABLE
CI002    CLC   TIOEDDNM,DDNAME     DDNAME MATCH UNIT TABLE ENTRY ?
         BE    CI003               YES, BRANCH
         LA    R8,UTABLEL(,R8)     NO, INCR UNIT TABLE ADDR TO NEXT ENT
         BCT   R12,CI002           LOOP TO NEXT UNIT TABLE ENTRY
         B     CI004               THIS TIOT ENTRY NOT IN UNIT TABLE
*
*        TIOT DDNAME MATCHES ENTRY IN SORT UNIT TABLE
*
CI003    TM    STATUS,STATDEF      PREVIOUSLY DEFINED ?
         BO    CIEE02              YES, BRANCH TO ERROR EXIT
         OI    STATUS,STATDEF      SET ON DEFINED BIT IN UNIT TABLE
         SR    R9,R9
         ICM   R9,B'0111',TIOEFSRT  R9 -> UCB
         STCM  R9,B'0111',UCBPTR    SAVE UCB ADDR IN UNIT TAB UCBPTR
         TM    STATUS,STATIN+STATOUT SORTIN OR SORTOUT ?
         BNZ   CI004               YES, SORTIN OR SORTOUT DATA SET
*
*        PROCESS SORTWKXX
*
         CPITEST CPIDYNA           DYNALLOC SET ON ?
         BZ    CI003A              NO, NORMAL PROCESSING
         CPITEST CPIDYNI           IGNORE CURRENT SORTWK DATA SETS ?
         BO    CI004               YES, DO NOT PROCESS THIS SORTWKXX
*                                  TIOT ENTRY
*
*        ISSUE DEVTYPE TO OBTAIN THE DEVICE CHARACTERISTICS
*
CI003A   DEVTYPE DDNAME,DVADATA,DEVTAB
*
         CLI   DVAUNIT,UCB2400     WORKUNIT TYPE 2400 TAPE ?
         BE    CI007D              YES, BRANCH
         CLI   DVAUNIT,UCB3400     WORKUNIT TYPE 3400 TAPE ?
         BE    CI007D              YES, BRANCH
         CLI   DVACLASS,UCB3DACC   DASD WORKAREA ?
         BNE   CIEE03              NO, BRANCH TO ERROR EXIT
*
*        TAPE OR DASD SORTWORK AREAS
*
*        STORE DEVICE INFORMATION
*
CI007D   O     R7,LDEVMASK        R7 = LOGICAL DEVICE NO
*
*        THE FIRST SORTWKXX DD STMT LOCATED IN TIOT FOUND FORCES
*        THE DEVICE TYPE FOR ALL SUBSEQUENT SORTWKXX DATA SETS
*
         ICM   R0,B'1111',CIWKFCT  PREVIOUSLY INITIALIZED ?
         BNZ   CI007B              NO, INITIALIZE WITH FIRST SORTWKXX
         MVC   CIWKFCT,DVAUCBTY    MOVE DEV TYPE FIELD INTO WKFCT
CI007B   CLC   DVACLASS(2),CIWKFCT+2  SAME DEVICE TYPE AND UNIT TYPE
*                                     AS FIRST SORTWKXX DATA SET ?
         BNE   CIEE04              NO, ERROR - DIFFERENT DEVICE
         CLI   DVACLASS,UCB3DACC   DASD DEVICE ?
         BE    CI008A              YES, BRANCH TO DASD PROCESSING
         CLI   DVACLASS,UCB3TAPE   TAPE DEVICE ?
         BNE   CIEE03              NO, UNSUPPORTED DEVICE TYPE
         CLI   DVAUNIT,UCB2400     UNIT TYPE 2400 TAPE ?
         BE    CI010               YES, BRANCH
         CLI   DVAUNIT,UCB3400     UNIT TYPE 3400 TAPE ?
         BE    CI010               NO, BRANCH
         B     CIEE03              UNSUPPORTED UNIT TYPE
*
*        ADD ADDITIONAL SUPPORT FOR NEWER MODEL TAPES HERE
*
*        UCB3423 X'82' 3423 MAGNETIC TAPE
*        UCB3480 X'80' 3480 MAGNETIC TAPE
*        UCB3490 X'81' 3490 MAGNETIC TAPE
*        UCB3591 X'83' 3590 MAGNETIC TAPE
*
*        CONFIRM DASD DEVICE TYPE
*
*        LOCATE DEVICE ENTRY IN IECZDTAB FOR THIS DASD UNIT TYPE
*        IF NOT DONE PREVIOUSLY
*
CI008A   ICM   R3,B'1111',CPIDVCT  ALREADY STORED IECZDTAB ADDR ?
         BNZ   CI011               YES, BRANCH
         LA    R2,DVCTYPMK         SET R1 TO MASK TO EXTACT UNIT TYPE
         N     R2,UCBTYP           DASD UNIT TYPE NOW IN R2
         ST    R2,DASDUNIT         SAVE DASD UNIT TYPE
         L     R1,CVTPTR             R1 -> CVT
         L     R1,CVTZDTAB-CVT(,R1)  R1 -> IECZDTAB
         USING DVCTI,R1              R1 -> INDEX AT START OF IECZDTAB
         IC    R3,DVCTIOFF(R2)       R3  = DEVICE OFFSET IN IECZDTAB
         DROP  R1
         AR    R3,R1                 R3 -> DEVICE ENTRY IN IECZDTAB
         ST    R3,CPIDVCT          SAVE IECZDTAB DEVICE ENTRY
         CPISETON CPI2314          SET 2314 DISK AS A GENERIC TERM FOR
*                                  DASD SORT, DETERMINE TECHNIQUE
*                                  TO BE USED IN IERRCN
         MVI   CIMAXWKU+1,17       MAX TO 17
         B     CI011               GOTO UPDATE WORK UNIT COUNT
*
*        TAPE UNITS
*
CI010    CPISETON CPITAPE          SET TAPE
*
CI011    LA    R6,1(,R6)           UPDATE WORK UNIT COUNT
*
*        FINISHED PROCESSING THIS TIOT ENTRY
*        GET NEXT TIOT ENTRY
*
CI004    SR    R15,R15
         IC    R15,TIOELNGH        L'CURRENT TIOT ENTRY
         AR    R5,R15              INCR TO NEXT TIOT ENTRY
         CLI   TIOELNGH,0          L'NEXT TIOT ENTRY = 0 ?
         BNE   CI001               NO, PROCESS NEXT TIOT ENTRY
*
*        ENTIRE TIOT HAS BEEN SCANNED
*
*        PROCESS SORTIN DATA SET IF PROVIDED
*
CI004A   LA    R15,SORTDCB         R15 -> SORTDCB
         USING IHADCB,R15
         MVC   DCBDDNAM,SORTIN     CONVERT SORTIN TO SORT PREFIX
         DROP  R15
         CPITEST  CPIATT           SORT INVOKED ?
         BZ    CI063               NO, BRANCH
         CPITEST  CPIME15          EXIT E15 ACTIVATED ?
         BO    CI064               YES, BRANCH TO RESET SORTIN
         TM    SORTIN+15,STATDEF   SORTIN DEFINED ?
         BZ    CIEE07              NO, BRANCH TO ERROR MSG
         B     CI061
*
CI064    NI    SORTIN+15,255-STATDEF   RESET SORTIN
         B     CI061
*
CI063    TM    SORTIN+15,STATDEF   SORTIN DEFINED ?
         BZ    CIEE07              NO, BRANCH TO ERROR MSG
*
*        PROCESS SORTOUT DATA SET IF PROVIDED
*
CI061    CPITEST  CPIATT           SORT INVOKED ?
         BZ    CI065               NO, BRANCH
         CPITEST  CPIME35          EXIT E35 ACTIVE ?
         BO    CI066               YES, RESET SORTOUT
         TM    SORTOUT+15,STATDEF  SORTOUT DEFINED ?
         BZ    CIEE07              NO, ERROR
         B     CI062
*
CI066    NI    SORTOUT+15,255-STATDEF  RESET SORTOUT
         B     CI062
*
CI065    TM    SORTOUT+15,STATDEF  SORTOUT DEFINED ?
         BZ    CIEE07              NO, ERROR
*
CI062    LTR   R6,R6               FOUND ANY SORTWK TIOT ENTRIES ?
         BNZ   CI062A              YES, BRANCH
         CPITEST CPIDYNA           DYNALLOC ACTIVATED ?
         BO    CI013               YES, BRANCH TO BYPASS WELL DEFINED
*                                  TESTING
CI062A   CH    R6,CIMINWKU         ENOUGH WORK UNITS ?
         BL    CIEE08              NO, ERROR
         L     R0,HEXFFFF          SET R0 TO ALL BITS ON
         SR    R1,R1               CLEAR R1
         SRDL  R0,0(R6)            SHIFT NUMBER OF WORK UNIT BITS
*                                  INTO R1
         XR    R1,R7               MATCH BIT FOR BIT ?
         BNZ   CIEE09              NOT ZERO, BRANCH, ERROR
         CPITEST  CPITAPE          TAPE SORT ?
         BO    CI060               YES, BRANCH
         CH    R6,CIMAXWKU         > 17 DISK AREAS FOR DASD SORT ?
         BNH   CI060               NO, BRANCH
         LH    R6,CIMAXWKU         SET MAX DISK AREAS TO 17 FOR DASD
*
CI060    STH   R6,CPINWKU          STORE NO OF WORK UNITS IN CPI
         CPITEST  CPITAPE          TAPE SORT ?
         BO    CI013               YES, BRANCH
*
*        THE DASD DEVICE TYPE HAS BEEN DETERMINED PREVIOUSLY
*        CALL IERRCF TO CALCULATE THE TABLE OF OPTIMUM BLKSIZES
*        FOR THE SPECIFIC DASD DEVICE
*
         L     R15,VIERRCF
         BASR  R14,R15             CALL IERRCF FOR DASD BLKSIZE CALCS
*
*        DETERMINE CHANNEL ENVIRONMENT
*
CI013    CPISETOF CPIMPSEN-CPINCHAN
         CPISETON CPIMPSE1                SELECTOR ENVIRONMENT
*
*        FORCE TWO SELECTOR CHAN ENVIRONMENT
*
CI014    TM    CISWITCH,SWA        SWITCH A ON ?
         BO    CI015               ON, BRANCH
         CPISETON CPITAU           SET SWITCH/TAU ON
         B     CI016               BRANCH TO CHECK DATA CHAINING
*
CI015    CPISETOF CPITAU           OFF SWITCH/TAU OFF
CI016    CPISETON CPINODC          SET NO DATA CHAINING
         CPISETOF CPINODCI-CPINODCO   NO CHAINING INPUT & OUTPUT
         CPISETON CPIDWA           ON DOUBLE WORD ALIGNMENT
         CPISETOF CPISWA           OFF SINGLE WORD ALIGNMENT
         CPITEST  CPITAPE          TAPE SORT ?
         BZ    CI050               NOT TAPE, BRANCH
*
*        TEST TAPE UNIT ASSIGNMENT
*
         SR    R9,R9               CLEAR R9
         LH    R12,CPINWKU         GET NUMBER OF WORK UNITS
         LA    R5,SORTWK01+12      GET ADDR OF FIRST UCB POINTER
CI019    CLC   SORTIN+12(3),0(R5)  UCB POINTERS EQUAL ?
         BNE   CI018               NO, BRANCH
         LA    R9,1(,R9)           UCB COUNT = COUNT + 1
CI018    LA    R5,16(,R5)          UPDATE COMPARE REGISTER
         BCT   R12,CI019           END OF TABLE ? BRANCH
         CH    R9,*-10             UCB COUNT EQUAL TO 1 ?
         BH    CIEE11              IF > 1, BRANCH
         BL    CI017               IF < 1, BRANCH
         CLC   SORTIN+12(3),SORTWK01+12  INPUT EQUAL TO SORTWK01 ?
         BNE   CIEE11              NO, NOT EQUAL BRANCH
         CPISETON CPIINWRK         SET INPUT A WORK
         B     CI020               BRANCH TO CHECK SORTOUT
*
CI017    CPISETOF CPIINWRK         SET INPUT NOT A WORK UNIT
CI020    SR    R9,R9               CLEAR R9
         LH    R12,CPINWKU         GET NUMBER OF WORK UNITS
         LA    R5,SORTWK01+12      GET ADDR OF FIRST UCB POINTER
CI021    CLC   SORTOUT+12(3),0(R5)  UCB ADDR EQUAL ?
         BE    CIEE12              YES, BRANCH
         LA    R5,16(,R5)          UPDATE COMPARE REGISTER
         BCT   R12,CI021           IF NOT END OF TABLE BRANCH
*
CI050    TM    SORTIN+15,STATDEF   SORTIN DEFINED ?
         BO    GETJIN              YES, BRANCH
         OI    CISWITCH,SWC        TURN ON SWITCH C
         B     CICHECK             BRANCH TO CHECK SORTOUT
*
*        DASD PROCESSING
*
*        DETERMINE DCB CHARACTERISTICS OF SORTIN
*
GETJIN   LA    R15,SORTDCB         R15 -> SORTDCB
         USING IHADCB,R15
         MVC   DCBDDNAM,SORTIN     SET DDNAME IN DCB FOR OUTPUT
         DROP  R15
         RDJFCB (SORTDCB)          GET JFCB FOR SORTIN
*
         MVC   JINFRM,JFCRECFM     GET RECFM FROM JFCB
         MVC   JINBLK,JFCBLKSI     GET BLKSIZE FROM JFCB
         MVC   JINLRCL,JFCLRECL    GET LRECL FROM JFCB
*
         OBTAIN SORTDSCB           GET DSCB FOR SORTIN
*
         LTR   R15,R15             TEST RETURN CODE
         BZ    CI501               CODE = ZERO, BRANCH
         OI    CISWITCH,SWC        DSCB NOT FOUND
         B     CICHECK             BRANCH TO CHECK FOR SORTOUT
*
CI501    MVC   DINFRM,DS1RECFM     GET RECFM FROM DSCB
         MVC   DINBLK,DS1BLKL      GET BLKSIZE FROM DSCB
         MVC   DINLRCL,DS1LRECL    GET LRECL FROM DSCB
         MVC   DINSTAR,DS1LSTAR    GET DS1LSTAR FROM DSCB
*
*        PROCESS SORTOUT
*
*        DETERMINE DCB CHARACTERISTICS OF SORTOUT
*
CICHECK  TM    SORTOUT+15,STATDEF  SORTOUT DEFINED ?
         BO    GETJOUT             YES, BRANCH
         OI    CISWITCH,SWD        TURN ON SWITCH D
         B     CI504               BRANCH TO PROCESS INFORMATION
*
GETJOUT  LA    R15,SORTDCB         R15 -> SORTDCB
         USING IHADCB,R15
         MVC   DCBDDNAM,SORTOUT    SET DDNAME IN DCB FOR OUTPUT
         DROP  R15
*
         RDJFCB (SORTDCB)          GET JFCB FOR SORTOUT
*
         MVC   JOUTFRM,JFCRECFM    GET RECFM FROM JFCB
         MVC   JOUTBLK,JFCBLKSI    GET BLKSIZE FROM JFCB
         MVC   JOUTLRCL,JFCLRECL   GET LRECL FROM JFCB
*
         OBTAIN SORTDSCB           GET DSCB FOR SORTOUT
*
         LTR   R15,R15             ZERO RETURN CODE ?
         BZ    CI503               YES, BRANCH
         OI    CISWITCH,SWD        DSCB NOT FOUND
         B     CI504
*
CI503    MVC   DOUTFRM,DS1RECFM    GET RECFM FROM DSCB
         MVC   DOUTBLK,DS1BLKL     GET BLKSIZE FROM DSCB
         MVC   DOUTLRCL,DS1LRECL   GET LRECL FROM DSCB
*
*        PROCESS DCB SETTINGS FOR SORTIN AND SORTOUT
*
*        MERGE FIELDS FROM THE JFCB AND DSCB AND PLACE THE
*        RESULT IN CPI.
*        THE DDNAMES INVOLVED ARE SORTIN AND SORTOUT FOR A SORT
*        FOR A MERGE THE SORTIN01 DCB CHARACTERISTICS ARE SET IN
*        SORTIN FIELDS.
*        THE FIELDS IN THE JFCB AND DSCB THAT ARE ACCESSED ARE
*        RECORD FORMAT, LOGICAL RECORD LENGTH AND BLOCKING
*
*        ALL RECFM VALUES ARE SUPPORTED EXCEPT RECFM=U
*
CI504    MVC   CIINFRM,JINFRM      GET INPUT RECORD FORMAT FROM JFCB
CI024    TM    CIINFRM,JFCUND      RECFM=U ?
         BZ    CI022               NO, BRANCH TO CHECK DSCB
*                                  AS NEITHER F OR V FLAGS ARE ON
         BO    CIEE13              RECFM=U, BRANCH TO ERROR MSG
         B     CI023               GOTO GET OUTPUT RECORD TYPE
*                                  AS EITHER F OR V FLAGS ARE ON
*
CI022    TM    CISWITCH,SWC        SWITCH C ON ? DSCB READ OK ?
         BZ    CI201               NO, BRANCH. DSCB AVAILABLE
*
*        NO DSCB AVAILABLE FOR SORTIN
*
CI022A   CPITEST  CPIATT           SORT ATTACHED OR LINKED TO ?
         BZ    CIEE13              NO, BRANCH. ERROR
         MVC   JINFRM,CPICNTL      GET RECFM FROM CPICNTL
         NI    JINFRM,JFCUND       TURN OFF ALL BUT RECFM
         B     CI504               BRANCH TO REPROCESS RECFM
*
*        DSCB AVAILABLE FOR SORTIN
*
CI201    MVC   CIINFRM,DINFRM      GET INPUT RECORD FORMAT FROM DSCB
         TM    CIINFRM,JFCUND      RECFM=U ?
         BZ    CI022A              NO, BRANCH
         B     CI024               GOTO CHECK RECORD FORMAT
*
CI023    MVC   CIOUTFRM,JOUTFRM    GET OUTPUT RECORD FORMAT FROM JFCB
CI027    TM    CIOUTFRM,JFCUND     RECFM=U ?
         BZ    CI025               NO, BRANCH TO CHECK DSCB
         BO    CIEE13              RECFM=U, BRANCH TO ERROR MSG
         B     CI031               GOTO CHECK BLKSIZE PARM
*
CI025    TM    CISWITCH,SWD        SWITCH D ON ?
         BZ    CI202               NO, BRANCH
CI025A   CPITEST  CPIATT           SORT ATTACHED OR LINKED TO ?
         BZ    CIEE14              NO, BRANCH
         MVC   JOUTFRM,CPICNTL     GET RECFM FROM CPICNTL
         NI    JOUTFRM,JFCUND      TURN OFF ALL BUT RECFM
         B     CI023               GOTO REPROCESS IT
*
CI202    MVC   CIOUTFRM,DOUTFRM    GET OUTPUT RECORD FORMAT FROM DSCB
         TM    CIOUTFRM,JFCUND     ANY RECFM VALUE PROVIDED ?
         BZ    CI025A              NO, BRANCH
         B     CI027               GOTO CHECK RECORD FORMAT
*
CI031    CLC   JINBLK,KF0          INPUT BLKSIZ SPECIFIED ON DD STMT ?
         BE    CI032               NO, GO CHECK OTHER SOURCES
         MVC   CIINBLK,JINBLK      YES, PUT INPUT BLKSIZ IN INBLK
         B     CI036               BRANCH TO CHECK OPT BLK
*
CI032    TM    CISWITCH,SWC        DSCB LOCATED ?
         BZ    CI206               YES, BRANCH TO CHECK IT
         CPITEST  CPIATT           NO, SORT ATTACHED OR LINKED ?
         BZ    CIEE18              NO, BRANCH TO ERROR MSG
         CPITEST  CPIME15          E15 ACTIVE ?
         BZ    CIEE18              NO, BRANCH TO ERROR MSG
         MVC   CIINBLK,CPIRCDL1    SET BLKING TO RECORD LENGTH
         B     CI036               YES, BRANCH TO CHECK OPT BLK
*
CI206    CLC   DINBLK,KF0          INPUT BLKSIZ SPECIFIED IN DSCB
         BE    CIEE18              NO, BRANCH TO ERROR MESSAGE
         MVC   CIINBLK,DINBLK      YES, PUT INPUT BLKSIZ IN INBLK
*
CI036    CLC   JOUTBLK,KF0         OUTPUT BLKSIZ SPEC ON DD STMT ?
         BE    CI037               NO, GO CHECK OTHER SOURCES
         MVC   CIOUTBLK,JOUTBLK    YES, PUT OUTPUT BLKSIZ IN OUTBLK
         B     CI203               BRANCH TO CHECK RECFM
*
CI037    TM    CISWITCH,SWD        OUTPUT DSCB AVAILABLE ?
         BZ    CI207               YES, BRANCH TO CHECK IT
         CPITEST  CPIATT           NO,  SORT ATTACHED OR LINKED ?
         BZ    CIEE19              NO, BRANCH TO ERROR MSG
         CPITEST  CPIME35          E35 ACTIVE ?
         BZ    CIEE19              NO, BRANCH TO ERROR MSG
         MVC   CIOUTBLK,CPIRCDL3   SET BLKING TO RECLEN
         B     CI203               YES, BRANCH TO CHECK RECFM
*
CI207    CLC   DOUTBLK,KF0         OUTPUT BLK SPECIFIED IN DSCB ?
         BE    CIEE19              NO, BRANCH TO ERROR MSG
         MVC   CIOUTBLK,DOUTBLK    YES, PUT OUTPUT BLKSIZE IN OUTBLK
*
CI203    CLC   JINLRCL,KF0         INPUT LRECL SPECIFIED ?
         BE    CI028               NO, CHECK OTHER SOURCES
         MVC   CITL1,JINLRCL       YES, PUT INPUT LRECL IN TL1
         B     CI033               BRANCH TO SET BLOCKING IN CPI
*
CI028    TM    CISWITCH,SWC        INPUT DSCB AVAILABLE ?
         BZ    CI204               YES, BRANCH TO CHECK IT
         CPITEST  CPIATT           SORT ATTACHED OR LINKED TO ?
         BZ    CI204               NO, CHECK OTHER SOURCES
         MVC   CITL1,CPIRCDL1      YES, GET LRECL FROM CPI
         B     CI033               BRANCH TO SET BLOCKING IN CPI
*
CI204    CLC   DINLRCL,KF0         INPUT LRECL SPECIFIED IN DSCB ?
         BNE   CI204A              NO, BRANCH
         TM    CIINFRM,DCBRECF     FIXED LENGTH RECORDS ?
         BZ    CIEE16              NO, BRANCH
         TM    CIINFRM,DCBRECBR    BLOCKED ?
         BO    CIEE16              YES, BRANCH - ERROR
         MVC   CITL1,CIINBLK       LRECL=BLKSIZE
         B     CI033               BRANCH
*
CI204A   MVC   CITL1,DINLRCL       MOVE LRECL INFO
*
CI033    TM    CIINFRM,JFCFIX      RECFM=F ?
         BZ    CI033A              NO,  BRANCH
         TM    CIINFRM,JFCRFB      BLOCKED ?
         BO    CI034               YES, BRANCH
         CLC   CITL1,CIINBLK       NO, COMPARE LRECL AND BLKSIZE
         BNE   CIEE14              UNEQUAL, ERROR
         B     CI034
*                                  RECFM=V
CI033A   MVC   CPIIPBLK,CIINBLK    SET INPUT BLOCK SIZE IN CPI
         B     CI029               BRANCH TO CHECK OUTPUT LRECL
*
CI034    SR    R2,R2               CLEAR R2
         LH    R3,CIINBLK          GET INPUT BLOCK SIZE
         LH    R4,CITL1            GET INPUT LRECL
         DR    R2,R4               DIVIDE TO GET RECORDS/BLOCK
         LTR   R2,R2               TEST FOR REMAINDER
         BZ    CI035               NO REMAINDER, BRANCH
         LA    R3,1(,R3)           ADD ONE RECORD
CI035    STH   R3,CPIIPBLK         PUT RECORDS/BLOCK IN CPI
*
CI029    CLC   JOUTLRCL,KF0        OPT LRECL SPECIFIED ?
         BE    CI030               NO, CHECK OTHER SOURCES
         MVC   CITL3,JOUTLRCL      YES, PUT OUTPUT LRECL IN TL3
         B     CI038               BRANCH TO SET BLOCKING IN CPI
*
CI030    TM    CISWITCH,SWD        DSCB LOCATED ?
         BZ    CI205               YES, BRANCH TO CHECK IT
         CPITEST  CPIATT           NO, SORT ATTACHED OR LINKED ?
         BZ    CI205               NO, CHCK OTHER SOURCES
         MVC   CITL3,CPIRCDL3      YES, GET LRECL FROM CPI
         B     CI038               BRANCH TO SET BLOCKING IN CPI
*
CI205    CLC   DOUTLRCL,KF0        OPT LRECL SPECIFIED IN DSCB ?
         BNE   CI205A              NO, BRANCH
         TM    CIOUTFRM,JFCFIX     RECFM=F ?
         BZ    CIEE17              NO, ERROR
         TM    CIOUTFRM,JFCRFB     BLOCKED ?
         BO    CIEE17              YES, ERROR
         MVC   CITL3,CIOUTBLK      MOVE OUTPUT LRECL INFO
         B     CI038               UNCOND BR
*
CI205A   MVC   CITL3,DOUTLRCL      MOVE OUTPUT LRECL INFO
*
CI038    TM    CIOUTFRM,JFCFIX     RECFM=F ?
         BZ    CI038A              NO, BRANCH
         TM    CIOUTFRM,JFCRFB     BLOCKED ?
         BO    CI039               YES, BRANCH
         CLC   CITL3,CIOUTBLK      NO, COMPARE LRECL AND BLKSIZE
         BNE   CIEE14              UNEQUAL, ERROR
         B     CI039
*                                  RECFM=V
CI038A   MVC   CPIOPBLK,CIOUTBLK   PUT BYTES/BLOCK IN CPI
         B     CI026A              BRANCH TO COMPARE IN/OUT RECFM
*
CI039    SR    R2,R2               CLEAR R2
         LH    R3,CIOUTBLK         GET BYTES/OUTPUT BLOCK
         LH    R4,CITL3            GET LOGICAL RECORD LENGTH
         DR    R2,R4               DIVIDE TO GET RECORDS/BLOCK
         LTR   R2,R2               TEST FOR REMAINDER
         BZ    CI040               NO REMAINDER, BRANCH
         LA    R3,1(0,R3)          ADD ONE TO BLOCKING
CI040    STH   R3,CPIOPBLK         PUT RECORDS/BLOCK IN CPI
*
*        CHECK FOR VARIABLE SPANNED RECORDS (VBS)
*        ON SORTIN AND SORTOUT
*
CI026A   TM    CIINFRM,JFCVAR      VARIABLE LENGTH RECORDS ?
         BZ    CI040A              NO, NOT VARIABLE
         TM    CIINFRM,JFCRFS      YES, SPANNED INPUT ?
         BZ    CI040A              NO
         CPISETON  CPIMVSI         YES, SET VBS INPUT FLAG
CI040A   TM    CIOUTFRM,JFCVAR     VARIABLE LENGTH RECORD OUTPUT ?
         BZ    CI026               NO
         TM    CIOUTFRM,JFCRFS     YES, SPANNED OUTPUT ?
         BZ    CI026               NO
         CPISETON  CPIMVSO         YES, SET VBS OUTPUT FLAG
*
*        VALIDATE RECFM VALUES FOR SORTIN AND SORTOUT
*
CI026    CPITEST  CPIATT           SORT ATTACHED OR LINKED TO ?
         BZ    CI026B              NO
         CPITEST CPIME15           YES, E15 ACTIVE ?
         BZ    CI026C              NO
         MVC   CITL1,CPIRCDL1      YES, GET LRECL FROM CPI
         MVC   CIINFRM,CPICNTL     GET RECFM FROM CPI
CI026C   CPITEST  CPIME35          E35 ACTIVE ?
         BZ    CI026B              NO
         MVC   CITL3,CPIRCDL3      YES, GET LRECL FROM CPI
         MVC   CIOUTFRM,CPICNTL         GET RECFM FROM CPI
CI026B   NI    CIINFRM,JFCFIX+JFCVAR    CLEAR LOW SIX BITS
         NI    CIOUTFRM,JFCFIX+JFCVAR   CLEAR LOW SIX BITS
         CLC   CIINFRM,CIOUTFRM    INPUT AND OUTPUT FORMATS SAME ?
         BNE   CIEE15              NO, BRANCH TO ERROR MSG
         NI    CPICNTL,255-JFCFIX-JFCVAR  YES, CLEAR FIXED OR VAR FLAGS
         OC    CPICNTL(1),CIINFRM  SET FIXED OR VARIABLE IN CPICNTL
*
CI041    MVC   CPIRCDL1,CITL1      PUT L1 IN CPI
         MVC   CPIRCDL3,CITL3      PUT L3 IN CPI
         CPITEST  CPIFIX           TYPE = F ?
         BO    CI053               YES, BRANCH
         CLC   CPIRCDL4,KF0        L4 = 0 ?
         BE    CI054               YES, BRANCH
*
*        TEST IF A RECORD CONTROL STATEMENT HAS BEEN PROVIDED
*
CI053    CPITEST  CPIRCARD         PROVIDED WITH RECORD STMT ?
         BO    CI042               YES, BRANCH
*
*        NO RECORD STATEMENT PROVIDED
*
CI054    MVC   CPIRCDL2,CPIRCDL1   SET L2 = L1
         LH    R5,CPINUMCF         GET NUMBER OF CONTROL FIELDS (Q)
         LA    R12,CPIPCF01-6      GET STARTING ADDR OF CONTROL FLDS
         SR    R4,R4               CLEAR REG
         CLI   CPINUMCF+1,12       NO OF CF > 12 ?
         BNH   CI044               NO, BRANCH
         SR    R12,R12
         ICM   R12,B'0111',CPIADDCF  GET ADDR OF ADDITIONAL CONTROL
         B     CI044A                FIELDS CORE GOTTEN VIA GETMAIN
*
CI044    LA    R12,6(,R12)         AFD = AFD + 6
CI044A   SR    R3,R3               CLEAR E'
         IC    R3,4(,R12)          GET L(BITS)
         SR    R2,R2               CLEAR R2
         IC    R2,2(,R12)          GET D(BITS)
         LA    R3,7(R2,R3)         K = L(BITS) + D(BITS) + 7
         SRL   R3,3                K = K/8
         STC   R3,CI051+3          PUT IN DISPLACEMENT OF FOLLOWING LA
         CLI   3(R12),255          L(BYTES) = 255 ?
         BNE   CI052               NO, BRANCH
         CLI   4(R12),X'00'        L(BITS) = 0 ?
         BE    CI052               YES, BRANCH
         SR    R3,R3               CLEAR R3
         B     CI052A              BRANCH TO GET D(BYTES)
*
CI052    IC    R3,3(,R12)          GET L(BYTES)
         LA    R3,1(,R3)           L(BYTES) = L(BYTES) + 1
CI052A   LH    R2,0(,R12)          GET D(BYTES)
CI051    LA    R3,0(R2,R3)         E' = K + D(BYTES) + L(BYTES)
         CR    R3,R4               COMPARE E' TO HE'
         BNH   CI043               IF LESS THAN OR EQUAL BRANCH
         LR    R4,R3               HE' = E'
CI043    BCT   R5,CI044            Q = Q - 1, IF ¬ 0 BRANCH
         STH   R4,CIKWORK
         CLC   CIKWORK(2),CPIRCDL2  END OF LAST CONTROL FIELD BEYOND ?
         BH    CIEE22              GOTO SET MSG INDEX
         CH    R4,MINLRECL         COMPARE L4 TO 18
         BNL   CI045               NOT LOW, BRANCH
         LA    R4,18               SET L4 EQUAL TO 18
CI045    STH   R4,CPIRCDL4         PUT L4 IN CPI
         AH    R4,CPIRCDL2         ADD L2 TO L4
         SRL   R4,1                DIVIDE BY 2 AND ROUND DOWN
         STH   R4,CPIRCDL5         PUT L5 IN CPI
*
*        PROCESSING WITH OR WITHOUT RECORD CONTROL STATEMENT
*
CI042    CLC   CPIRCDL1,MINLRECL   COMPARE L1 TO 18
         LA    R15,RCODE1
         BL    CIEE20              LOW ? BRANCH
         CLC   CPIRCDL2,MINLRECL   COMPARE L2 TO 18
         LA    R15,RCODE2
         BL    CIEE20              LOW ? BRANCH
         CLC   CPIRCDL3,MINLRECL   COMPARE L3 TO 18
         LA    R15,RCODE3
         BL    CIEE20              LOW ? BRANCH
         CPITEST  CPIFIX           TYPE = F
         BO    CI055               YES, BRANCH
         CLC   CPIRCDL4,MINLRECL   COMPARE L4 TO 18
         LA    R15,RCODE4
         BL    CIEE20              LOW ? BRANCH
         CLC   CPIRCDL5,MINLRECL   COMPARE L5 TO 18
         LA    R15,RCODE5
         BL    CIEE20              LOW ? BRANCH
CI055    CLC   CPIRCDL2,KH256      COMPARE L2 TO 256
         BH    CI046               HIGH ? BRANCH
         CPISETON CPILE256         SET LRECL < 256
         B     CI047               BRANCH TO TEST LENGTH VS DEVICES
*
CI046    CPISETON CPIGT256         SET LRECL > 256
CI047    CPITEST  CPIMERGO         MERGE ONLY ?
         BO    CI049               YES, BRANCH
*
CI048    CLC   CPIRCDL2,KH32767    COMPARE L2 TO 32767
         LA    R15,RCODE9
         BH    CIEE20              HIGH, BRANCH
CI049    CLC   CPIIPBLK,KH32767    COMPARE INPUT BLOCKING TO 32767
         LA    R15,RCODEA
         BH    CIEE20              HIGH, BRANCH
         CLC   CPIOPBLK,KH32767    COMPARE OUTPUT BLOCKING TO 32767
         LA    R15,RCODEB
         BH    CIEE20              HIGH, BRANCH
*
*        CALCULATE SIZE OF INPUT, OUTPUT BUFFERS
*
CI056    LH    R3,CPIIPBLK         OBTAIN INPUT BLOCK FACTOR
         LH    R4,CPIOPBLK         OBTAIN OUTPUT BLOCK FACTOR
         CPITEST  CPIVAR           VARIABLE LENGTH RECORDS ?
         BO    CI056B              YES, BRANCH
         MH    R3,CPIRCDL1         INPUT RECORD LENGTH
         MH    R4,CPIRCDL3         OUTPUT RECORD LENGTH
CI056B   AH    R3,CIK7             ADD BYTES FOR ALIGNMENT
         AH    R4,CIK7             ADD BYTES FOR ALIGNMENT
         SRL   R3,3                ALIGN
         SRL   R4,3                          BUFFERS
         SLL   R3,3                ALIGN
         SLL   R4,3                        BUFFERS
         CPITEST  CPIMERGO         MERGE ONLY ?
         BZ    CI056A              NO, BRANCH
         LA    R3,8(,R3)           ADD 8 BYTES FOR QSAM BUFCB
CI056A   STH   R3,CPILAB03         STORE BUFFER SIZE
         STH   R4,CPILAB09+2       STORE BUFFER SIZE
         CPITEST  CPIMERGO         MERGE ONLY ?
         BO    CI057               YES, BRANCH
*
         DROP  R8
*
*----------------------------------------------------------------------
*
*        DETERMINE IF DYNAMIC ALLOCATION IS REQUESTED
*        FOR SORTING OPERATIONS
*
*----------------------------------------------------------------------
*
         CPITEST  CPIDYNA          DYNAMIC ALLOCATION FLAG ON ?
         BZ    CI057               NO, STANDARD PROCESSING
         MVC   DYNDDN(4),CPIDDSRT  SET DDN PREFIX TO USER SPEC VALUE
         CPITEST CPIDYNI           IGNORE PROVIDED SORTWK DATA SETS ?
         BO    CI001BB             YES, DELETE ANY SORTWK DATA SETS
         ICM   R15,B'0011',CPINWKU  SORTWKXX DATA SETS PROVIDED ?
         BNZ   CI057               YES, STANDARD PROCESSING
         B     CI001T              GO ALLOCATE SORTWK DATA SETS
*
*----------------------------------------------------------------------
*
*        DYNAMIC ALLOCATION CPIDYNI PROCESSING
*        LOOP THROUGH THE TIOT FREEING ANY SORTWKXX DATA SETS
*
*----------------------------------------------------------------------
*
CI001BB  L     R15,TIOTADDR
CI001B   CLC   DYNDDN(6),TIOEDDNM  DDNAME A SORTWKXX DATA SET ?
         BNE   CI001C              NO, DO NOT FREE IT
         CLI   TIOEDDNM+6,C'0'     ENSURE DDNAME IS SORTWKXX
         BL    CI001C              WHERE XX IS 00-99 ONLY
         CLI   TIOEDDNM+6,C'9'
         BH    CI001C
         CLI   TIOEDDNM+7,C'0'
         BL    CI001C
         CLI   TIOEDDNM+7,C'9'
         BH    CI001C
*
*        DEALLOCATE A PREALLOCATED SORTWKXX DATA SET
*
         LA    R6,DYNAREA+4        R6 -> S99RB
         USING S99RB,R6
         XC    S99RB(S99RBEND-S99RB),S99RB  ZERO ALL OF RB
         MVI   S99RBLN,S99RBEND-S99RB  SET LENGTH OF RB
         MVI   S99VERB,S99VRBUN        REQUEST UNALLOCATION VERB
         LA    R7,S99RB+(S99RBEND-S99RB) R7 -> TEXT UNIT PTRS
         USING S99TUPL,R7          ADDRESSABILITY FOR S99TUPL DSECT
         ST    R7,S99TXTPP         S99TXTPP - > FIRST TEXT UNIT PTR
*
*        ALLOW FOR A MAX OF 12 TEXT UNIT PTRS AND THEN STORE THE
*        ACTUAL TEXT UNITS AFTER THE TU PTRS IN DYNAREA
*
         LA    R8,12*4(,R7)        R8 -> TEXT UNIT AREA
         USING S99TUNIT,R8

*        R7 -> S99TUPL             LIST OF PTRS TO TEXT UNITS
*        R8 -> S99TUNIT            TEXT UNITS AND THE ASSOCIATED DATA
*
*        DDNAME SPECIFICATION KEY AND DDNAME PARM
*
         ST    R8,S99TUPTR         STORE ADDR OF TEXT UNIT IN PTR LIST
         LA    R7,4(,R7)           INCREMENT S99TUPL TO NEXT ENTRY
         MVC   S99TUKEY(#DDNAMDL),#DDNAMD  MOVE DDNAME KEY SPEC
         MVC   S99TUPAR(L'TIOEDDNM),TIOEDDNM  MOVE IN DDNAME FROM TIOT
         LA    R8,L'TIOEDDNM+6(,R8)  INCR PTR
*
*        UNALLOCATE EVEN IF PERMANTLY ALLOCATED SPECIFICATION
*
         ST    R8,S99TUPTR         STORE ADDR OF TEXT UNIT IN PTR LIST
         MVC   S99TUKEY(#UNALCL),#UNALC  MOVE DDNAME KEY SPEC
*
         OI    S99TUPTR,S99TUPLN   LAST ENTRY, TERMINATE LIST
         LA    R1,DYNAREA          R1 -> S99RBPTR
*
         DYNALLOC
*
         LTR   R15,R15             SUCCESSFUL DELETION ?
         BNZ   DYNERRD             NO, BRANCH TO ERROR PROCESSING
         CLC   S99INFO,=XL2'0000'  ANY INFORMATION REASON PROVIDED ?
         BNE   DYNERRD             YES, BRANCH TO ERROR PROCESSING
*
*        GET NEXT TIOT ENTRY
*
CI001C   SR    R15,R15
         IC    R15,TIOELNGH        L'CURRENT TIOT ENTRY
         AR    R5,R15              INCR TO NEXT TIOT ENTRY
         CLI   TIOELNGH,0          L'NEXT TIOT ENTRY = 0 ?
         BNE   CI001B              NO, PROCESS NEXT TIOT ENTRY
*
*----------------------------------------------------------------------
*
*        ALLOCATE A TEST DATA SET TO DETERMINE DEVICE CHARACTERISTICS
*
*----------------------------------------------------------------------
*
*        WHILST THIS STEP IS NOT REQUIRED FOR A DEVICE UNIT TYPE
*        NAME IT IS REQUIRED IF A USER SPECIFIED GROUP NAME OR
*        ESOTERIC NAME HAS BEEN SPECIFIED TO IDENTIFY THE ACTUAL
*        DEVICE TYPE SELECTED BY ALLOCATION. FOR SIMPLICITY IS IS
*        PERFORMED FOR BOTH TYPES OF ALLOCATIONS
*
CI001T   LA    R6,DYNAREA+4        R6 -> S99RB
         XC    S99RB(S99RBEND-S99RB),S99RB  ZERO ALL OF RB
         MVI   S99RBLN,S99RBEND-S99RB  SET LENGTH OF RB
         MVI   S99VERB,S99VRBAL    REQUEST ALLOCATION VERB
         OI    S99FLAG1,S99NOMNT   DO NOT MOUNT OR USE OFFLINE DEVICE
         LA    R7,S99RB+(S99RBEND-S99RB) R7 -> TEXT UNIT PTRS
         ST    R7,S99TXTPP         S99TXTPP - > FIRST TEXT UNIT PTR
*
*        ALLOW FOR A MAX OF 12 TEXT UNIT PTRS AND THEN STORE THE
*        ACTUAL TEXT UNITS AFTER THE TU PTRS IN DYNAREA
*
         LA    R8,12*4(,R7)        R8 -> TEXT UNIT AREA

*        R7 -> S99TUPL             LIST OF PTRS TO TEXT UNITS
*        R8 -> S99TUNIT            TEXT UNITS AND THE ASSOCIATED DATA
*
*        DDNAME SPECIFICATION KEY AND DDNAME PARM
*
         ST    R8,S99TUPTR         STORE ADDR OF TEXT UNIT IN PTR LIST
         LA    R7,4(,R7)           INCREMENT S99TUPL TO NEXT ENTRY
         MVC   S99TUKEY(#DDNAMAL),#DDNAMA  MOVE DDNAME KEY SPEC
         MVC   S99TUPAR(L'TESTDDN),TESTDDN   MOVE IN TEST DDNAME
         LA    R8,L'TESTDDN+6(,R8)  INCR PTR
*
*        DSNAME SPECIFICATION KEY AND DSNAME PARM
*
         ST    R8,S99TUPTR         STORE ADDR OF TEXT UNIT IN PTR LIST
         LA    R7,4(,R7)           INCREMENT S99TUPL TO NEXT ENTRY
         MVC   S99TUKEY(#DSNAMAL),#DSNAMA  MOVE IN DSNAME KEY SPEC
         LA    R1,L'TESTDSN        GET L'TESTDSN
         STCM  R1,B'0011',S99TULNG  SET L'TESTDSN IN SPEC
         MVC   S99TUPAR(L'TESTDSN),TESTDSN   MOVE IN TEST DSNAME
         LA    R8,6(R1,R8)         INCREMENT PTR
*
*        UNIT SPECIFICATION KEY AND UNIT PARM
*
         ST    R8,S99TUPTR         STORE ADDR OF TEXT UNIT IN PTR LIST
         LA    R7,4(,R7)           INCREMENT S99TUPL TO NEXT ENTRY
         MVC   S99TUKEY(#UNITL),#UNIT  MOVE UNIT KEY SPEC
         MVC   S99TUPAR(L'CPIDYND),CPIDYND   MOVE IN UNIT DEVICE TYPE
         LA    R2,S99TUPAR+7       R2 -> LAST CHAR OF UNIT DEVICE TYPE
         LA    R1,8                MAXIMUM OF 8 CHARS
CI001RB  CLI   0(R2),C' '          BLANK ?
         BNE   CI001E              NO, BRANCH
         BCTR  R2,0                DECR PTR
         BCT   R1,CI001RB          TEST NEXT CHAR
CI001E   STCM  R1,B'0011',S99TULNG  SET L'UNIT DEVICE TYPE
         LA    R8,6(R1,R8)         INCR PTR
*
*        TRACK SPACE SPECIFICATION KEY
*
         ST    R8,S99TUPTR         STORE ADDR OF TEXT UNIT IN PTR LIST
         LA    R7,4(,R7)           INCREMENT S99TUPL TO NEXT ENTRY
         MVC   S99TUKEY(#TRACKL),#TRACK MOVE TRACK KEY SPEC
         LA    R8,#TRACKL(,R8)     INCR PTR
*
*        PRIME SPACE SPECIFICATION KEY
*
         ST    R8,S99TUPTR         STORE ADDR OF TEXT UNIT IN PTR LIST
         LA    R7,4(,R7)           INCREMENT S99TUPL TO NEXT ENTRY
         MVC   S99TUKEY(#PRIMEL),#PRIME  MOVE PRIME KEY SPEC
         LA    R0,1                ALLOCATE JUST ONE TRACK
         STCM  R0,B'0111',S99TUPAR
         LA    R8,#PRIMEL+3(,R8)   INCR PTR
*
*        DATA SET STATUS SPECIFICATION KEY
*
         ST    R8,S99TUPTR         STORE ADDR OF TEXT UNIT IN PTR LIST
         LA    R7,4(,R7)           INCREMENT S99TUPL TO NEXT ENTRY
         MVC   S99TUKEY(#STATUSL),#STATUS  MOVE STATUS KEY SPEC
         MVI   S99TUPAR,X'04'      SET STATUS TO NEW
         LA    R8,#STATUSL+1(,R8)  INCR PTR
*
*        DATA SET DISPOSITION SPECIFICATION KEY
*
         ST    R8,S99TUPTR         STORE ADDR OF TEXT UNIT IN PTR LIST
         LA    R7,4(,R7)           INCREMENT S99TUPL TO NEXT ENTRY
         MVC   S99TUKEY(#DISPL),#DISP  MOVE DISPOSITION KEY SPEC
         MVI   S99TUPAR,X'04'      SET STATUS TO DELETE
         LA    R8,#STATUSL+1(,R8)  INCR PTR
*
         OI    S99TUPTR,S99TUPLN   LAST ENTRY, TERMINATE LIST
         LA    R1,DYNAREA          R1 -> S99RBPTR
*
         DYNALLOC
*
         LTR   R15,R15             SUCCESSFUL ALLOCATION ?
         BNZ   DYNERRA             NO, BRANCH TO ERROR PROCESSING
         CLC   S99INFO,=XL2'0000'  ANY INFORMATION REASON PROVIDED ?
         BNE   DYNERRA             YES, BRANCH TO ERROR PROCESSING
         LA    R15,SORTDCB
         USING IHADCB,R15
         MVC   DCBDDNAM,TESTDDN
         DROP  R15
*
*        LOCATE THE NEWLY ALLOCATED DATA SET IN THE TIOT TO GET THE
*        UCB ADDR AND HENCE THE UCBTYPE
*
         SR    R15,R15
         L     R5,TIOTADDR         R5 -> TIOT
CI001G   CLC   TIOEDDNM,TESTDDN    THIS DDNAME THE TEST DATA SET ?
         BE    CI001H              YES, BRANCH
         IC    R15,TIOELNGH        L'CURRENT TIOT ENTRY
         AR    R5,R15              INCR TO NEXT TIOT ENTRY
         CLI   TIOELNGH,0          L'NEXT TIOT ENTRY = 0 ?
         BNE   CI001G              NO, PROCESS NEXT TIOT ENTRY
*                                  UCB NOT FOUND, SHOULD NOT HAPPEN
CI001H   SR    R9,R9
         ICM   R9,B'0111',TIOEFSRT R9-> UCB, IEFUCBOB MAPPING UCB
*
*        LOCATE DEVICE ENTRY IN IECZDTAB FOR THIS DASD DEVICE TYPE
*
         LA    R2,DVCTYPMK         SET R2 TO MASK TO EXTACT UNIT TYPE
         N     R2,UCBTYP           DASD UNIT TYPE NOW IN R2
         ST    R2,DASDUNIT         SAVE DASD UNIT TYPE
         SR    R3,R3               ZERO WORK REG
         L     R1,CVTPTR             R1 -> CVT
         L     R1,CVTZDTAB-CVT(,R1)  R1 -> IECZDTAB
         USING DVCTI,R1              R1 -> INDEX AT START OF IECZDTAB
         IC    R3,DVCTIOFF(R2)       R3  = DEVICE OFFSET IN IECZDTAB
         DROP  R1
         AR    R3,R1                 R3 -> DEVICE ENTRY IN IECZDTAB
         ST    R3,CPIDVCT          SAVE IECZDTAB DEVICE ENTRY ADDR
*
*        DEALLOCATE THE TEST DATA SET AS ITS NO LONGER NEEDED
*
         LA    R6,DYNAREA+4        R6 -> S99RB
         USING S99RB,R6
         XC    S99RB(S99RBEND-S99RB),S99RB  ZERO ALL OF RB
         MVI   S99RBLN,S99RBEND-S99RB  SET LENGTH OF RB
         MVI   S99VERB,S99VRBUN    REQUEST UNALLOCATION VERB
         LA    R7,S99RB+(S99RBEND-S99RB) R7 -> TEXT UNIT PTRS
         ST    R7,S99TXTPP         S99TXTPP - > FIRST TEXT UNIT PTR
*
*        ALLOW FOR A MAX OF 12 TEXT UNIT PTRS AND THEN STORE THE
*        ACTUAL TEXT UNITS AFTER THE TU PTRS IN DYNAREA
*
         LA    R8,12*4(,R7)        R8 -> TEXT UNIT AREA

*        R7 -> S99TUPL             LIST OF PTRS TO TEXT UNITS
*        R8 -> S99TUNIT            TEXT UNITS AND THE ASSOCIATED DATA
*
*        DDNAME SPECIFICATION KEY AND DDNAME PARM
*
         ST    R8,S99TUPTR         STORE ADDR OF TEXT UNIT IN PTR LIST
         MVC   S99TUKEY(#DDNAMDL),#DDNAMD  MOVE DDNAME KEY SPEC
         MVC   S99TUPAR(L'TESTDDN),TESTDDN   MOVE IN TEST DDNAME
*
         OI    S99TUPTR,S99TUPLN   LAST ENTRY, TERMINATE LIST
         LA    R1,DYNAREA          R1 -> S99RBPTR
*
         DYNALLOC
*
         LTR   R15,R15             SUCCESSFUL DELETION ?
         BNZ   DYNERRD             NO, BRANCH TO ERROR PROCESSING
         CLC   S99INFO,=XL2'0000'  ANY INFORMATION REASON PROVIDED ?
         BNE   DYNERRD             YES, BRANCH TO ERROR PROCESSING
*
*----------------------------------------------------------------------
*
*        CALCULATE DASD SIZE FOR SORTWKXX DATA SETS
*
*----------------------------------------------------------------------
*
*        IF FILESZ IS PROVIDED AND THE RECORD LENGTH IS KNOWN
*        THEN THE DASD STORAGE REQUIRED WILL BE CALCULATED. IF
*        THE NUMBER OF RECORDS (FILESZ) HAS NOT BEEN PROVIDED AND
*        THE SORTIN DATA SET IS DASD RESIDENT THEN AN
*        APPROXIMATE FILESZ WIL BE CALCULATED BASED ON THE DASD
*        SPACE USED AND THE SORTIN DASD UNIT TYPE SPECIFICATIONS.
*
*        IF NOT THEN THE DEFAULT DASD STORAGE ALLOCATION IS
*        USED. WHATEVER VALUE IS CHOSEN IS THEN UPLIFTED BY THE
*        DYNAPCT % INCREASE.
*
*        DASD UNIT TYPE IS KNOWN.
*        CALL IERRCF TO CALCULATE THE TABLE OF POSSIBLE DASD
*        BLKSIZES
*
         L     R15,VIERRCF         CALL IERRCF TO CALC SORTWKXX TABLE
         BASR  R14,R15             WITH MAXIMUM SORTWKXX BLKSIZE
         SR    R14,R14
         ICM   R14,B'0011',CPIBLKTB  R14 = MAXIMUM DASD BLOCKSIZE
         SH    R14,MAXOHEAD        SUBTRACT MAX SORT BLOCK OVERHEAD
         LA    R15,RCODE6          SET REASON CODE IF NEEDED
         CLM   R14,B'0011',CPIRCDL1  < RECORD LENGTH ?
         BL    CIEE20                YES, ERROR
         CLM   R14,B'0011',CPIRCDL2  < CHANGED RECORD LENGTH ?
         BL    CIEE20                YES, ERROR
         SR    R3,R3
         SR    R4,R4
         ICM   R4,B'0011',CPIRCDL1  GET L'RECORD
         BZ    CI001K              ZERO, USE DEFAULT SPACE ALLOCATION
         CLM   R4,B'0011',CPIRCDL2  COMPARE WITH L'MODIFIED RECORD
         BNL   CI001D0             L'MODIFIED IS LESS, BRANCH
         ICM   R4,B'0011',CPIRCDL2  GET L'MODIFIED RECORD
CI001D0  CPITEST  CPIFIX           FIXED LENGTH RECORDS ?
         BO    CI001D1             YES, BRANCH
*                                  NO, VARIABLE LENGTH
         ICM   R4,B'0011',CPIRCDL5  USE MEDIAN L'RECORD
CI001D1  STH   R4,AVLRECL          SAVE THE RECORD LENGTH VALUE
         ICM   R3,B'0111',CPIFILSZ  FILE SIZE PROVIDED ?
         BNZ   CI001D2             YES, BRANCH
*
*        NO FILE SIZE PROVIDED
*        ATTEMPT CALCULATION OF NUMBER OF RECORDS TO BE SORTED
*        NOTE: DASD ONLY
*
         ICM   R9,B'0111',SORTIN+12  R9 -> SORTIN UCB
         BZ    CI001K              NO SORTIN UCB FOUND - ATTACHED E15
         CLI   UCBTBYT3,UCB3DACC   SORTIN RESIDENT ON DASD ?
         BNE   CI001K              NO, CANNOT CALC APROX FILE SIZE
         LA    R2,DVCTYPMK         SET R1 TO MASK TO EXTACT UNIT TYPE
         N     R2,UCBTYP           DASD UNIT TYPE NOW IN R2
         L     R1,CVTPTR             R1 -> CVT
         L     R1,CVTZDTAB-CVT(,R1)  R1 -> IECZDTAB
         SR    R4,R4
         USING DVCTI,R1              R1 -> INDEX AT START OF IECZDTAB
         IC    R4,DVCTIOFF(R2)       R4  = DEVICE OFFSET IN IECZDTAB
         DROP  R1
         AR    R4,R1                 R4 -> DEVICE ENTRY IN IECZDTAB
         USING DVCT,R4
         SR    R7,R7
         ICM   R7,B'0011',DVCTRKLN   GET PHYSICAL TRACK LENGTH OF
*                                    SORTIN DATA SET
         DROP  R4
         SR    R1,R1
         ICM   R1,B'0011',CIINBLK    R1 = SORTIN BLKSIZE
         BZ    CI001K                ZERO, USE DEFAULT SPACE ALLOCATION
         SR    R6,R6
         DR    R6,R1                 R7 = BLOCKS PER TRACK
         ICM   R2,B'0011',DINSTAR    GET DS1LSTAR VALUE FOR SORTIN
         BZ    CI001K                NO VALUE SET
         CLI   DINSTAR+2,0           RECORD ON TRACK ?
         BE    CI001D3               NO, BRANCH
         LA    R2,1(,R2)             YES, ADD ANOTHER TRACK
CI001D3  MR    R6,R2                 BLOCKS PER TRACK * TRACKS USED
*                                    R7 = TOTAL INPUT BLOCKS USED
         LH    R2,AVLRECL            GET L'INPUT RECORD
         SR    R0,R0
         DR    R0,R2                 DIVIDE SORTIN BLKSIZE BY L'RECORD
*                                    R1 = INPUT BLOCKING FACTOR
         MR    R6,R1                 R7 = NUMBER OF INPUT RECORDS
         LR    R3,R7                 R3 = CALCULATED RECORD COUNT
         LR    R4,R2                 R4 = L'INPUT RECORD
*
*        CALCULATE INTERMEDIATE STORAGE REQUIRED
*
CI001D2  SR    R8,R8
         SR    R9,R9
         ICM   R9,B'0011',CPIBLKTB  GET SORTWKXX BLOCKSIZE
         SH    R9,MAXOHEAD         SUBTRACT MAXIMUM BLOCK OVERHEAD
         DR    R8,R4               DIVIDE SORT BLOCK SIZE
*                                  BY RECORD LENGTH TO CALC NUMBER
*                                  A BLOCKING FACTOR IN R9
         SR    R2,R2
         LA    R15,RCODE6          REASON CODE IF NEEDED
         LTR   R9,R9               AT LEAST ONE RECORD PER BLOCK ?
         BZ    CIEE20              NO, ERROR
         DR    R2,R9               DIVIDE NUMBER OF RECORDS (FILSZ)
*                                  BY BLOCKING FACTOR TO GET
*                                  NUMBER OF BLOCKS REQUIRED IN R3
         B     CI001KA
*
*        NO FILE SIZE/RECORD LENGTH AVAILABLE
*        USE DEFAULT ALLOCATION VALUE
*
CI001K   L     R3,CPIDYNS          GET DEFAULT ALLOCATION IN MBYTES
         SLL   R3,20               CONVERT DEFAULT MBYTES TO BYTES
         SR    R1,R1
         ICM   R1,B'0011',CPIBLKTB  GET SORTWKXX BLOCKSIZE
         SR    R2,R2
         DR    R2,R1               R3 = NUMBER OF BLOCKS REQUIRED
*
*        CALCULATE PERCENTAGE UPLIFT
*        ON ENTRY
*        R3 = NUMBER OF BLOCKS REQUIRED
*
CI001KA  LR    R9,R3               TAKE A COPY OF NUMBER BLKS REQUIRED
         LH    R0,CPIDYNP
         SR    R8,R8
         D     R8,=F'100'
         LA    R9,1(,R9)           ROUND UP
         MR    R8,R0               CALC % INCREASE FOR SORT OVERHEAD
*                                  BLOCKS REQUIRED * PERCENT OVERHEAD
         AR    R9,R3               ADD BLOCKS TO CALCULATED OVERHEAD
         CLC   CPIBLKTB+2(2),=H'1'  ONE BLOCK PER TRACK ?
         BE    CI001J              YES, BRANCH
         SRL   R9,1                NO, HALF THE TRACK COUNT
CI001J   LH    R2,CPIDYNN          GET TOTAL NUMBER OF SORTWK DATA SETS
         CH    R2,=H'7'            GOING TO BE A CRCX SORT ?
         BNL   CI001JA             YES, BRANCH
         BCTR  R2,0                BALN, ALLOCATE OVER 1 LESS DATA SET
CI001JA  SR    R8,R8
         DR    R8,R2               CALC NUMBER OF TRACKS PER DATA SET
         LA    R9,1(,R9)           ROUND UP
         CH    R9,=H'5'            AT LEAST 5 TRACKS ?
         BNL   CI001L              YES, BRANCH
         LA    R9,5                NO, SET TO 5 TRACKS MINIMUM
CI001L   ST    R9,TRACKCNT         SAVE TRACK VALUE FOR DYNALLOC PARM
         LH    R2,CPIDYNN          SET TOTAL NUMBER OF SORTWK DATA SETS
         STH   R2,CPINWKU          STORE NO OF WORK UNITS IN CPI
*
*----------------------------------------------------------------------
*
*        GENERATE DYNAMIC ALLOCATION MESSAGE
*
*----------------------------------------------------------------------
*
         L     R15,VIERRCU         R2 -> MESSAGES
         USING DIERRCU,R15
         CVD   R2,CIWORKD          CONVERT NUMBER OF DATA SETS
         ED    IER076N,CIWORKD+6   MOVE IN AND FORMAT NO DATA SETS
         CVD   R9,CIWORKD          CONVERT TRACK COUNT
         ED    IER076C,CIWORKD+5   MOVE IN AND FORMAT TRACK COUNT
         LM    R0,R1,IER076
         DROP  R15
         L     R15,VGAPRT          R15 -> PRINT MESSAGE ROUTINE
         BASR  R14,R15             CALL MESSAGE ROUTINE
*
*----------------------------------------------------------------------
*
*        ALLOCATE THE SORTWKXX DATA SETS
*
*----------------------------------------------------------------------
*
*        R2  = NUMBER OF SORTWKXX DATA SETS TO ALLOCATE
*
         LA    R6,DYNAREA+4        R6 -> S99RB
         XC    S99RB(S99RBEND-S99RB),S99RB  ZERO ALL OF RB
         MVI   S99RBLN,S99RBEND-S99RB  SET LENGTH OF RB
         MVI   S99VERB,S99VRBAL    REQUEST ALLOCATION VERB
         OI    S99FLAG1,S99NOMNT   DO NOT MOUNT OR USE OFFLINE DEVICE
         LA    R7,S99RB+(S99RBEND-S99RB) R7 -> TEXT UNIT PTRS
         ST    R7,S99TXTPP         S99TXTPP - > FIRST TEXT UNIT PTR
*
*        ALLOW FOR A MAX OF 12 TEXT UNIT PTRS AND THEN STORE THE
*        ACTUAL TEXT UNITS AFTER THE TU PTRS IN DYNAREA
*
         LA    R8,12*4(,R7)        R8 -> TEXT UNIT AREA

*        R7 -> S99TUPL             LIST OF PTRS TO TEXT UNITS
*        R8 -> S99TUNIT            TEXT UNITS AND THE ASSOCIATED DATA
*
*        DDNAME SPECIFICATION KEY AND DDNAME PARM
*
         ST    R8,S99TUPTR         STORE ADDR OF TEXT UNIT IN PTR LIST
         LA    R7,4(,R7)           INCREMENT S99TUPL TO NEXT ENTRY
         MVC   S99TUKEY(#DDNAMAL),#DDNAMA  MOVE IN DDNAME KEY SPEC
         MVC   S99TUPAR(L'DYNDDN),DYNDDN   MOVE IN SORKWKXX DDNAME
         LA    R8,L'DYNDDN+6(,R8)  INCR PTR
*
*        DSNAME SPECIFICATION KEY AND DSNAME PARM
*
         ST    R8,S99TUPTR         STORE ADDR OF TEXT UNIT IN PTR LIST
         LA    R7,4(,R7)           INCREMENT S99TUPL TO NEXT ENTRY
         MVC   S99TUKEY(#DSNAMAL),#DSNAMA  MOVE IN DSNAME KEY SPEC
         LA    R1,L'DYNDSN         GET L'DYNDSN
         STCM  R1,B'0011',S99TULNG  SET L'DYNDSN IN SPEC
         MVC   S99TUPAR(L'DYNDSN),DYNDSN   MOVE IN SORKWKXX DSNAME
         LA    R8,6(R1,R8)         INCREMENT PTR
*
*        UNIT SPECIFICATION KEY AND UNIT PARM
*
         ST    R8,S99TUPTR         STORE ADDR OF TEXT UNIT IN PTR LIST
         LA    R7,4(,R7)           INCREMENT S99TUPL TO NEXT ENTRY
         MVC   S99TUKEY(#UNITL),#UNIT  MOVE UNIT KEY SPEC
         MVC   S99TUPAR(L'CPIDYND),CPIDYND  MOVE IN UNIT DEVICE TYPE
         LA    R3,S99TUPAR+7       R2 -> LAST CHAR OF UNIT DEVICE TYPE
         LA    R1,8                MAXIMUM OF 8 CHARS
CI001U   CLI   0(R3),C' '          BLANK ?
         BNE   CI001V              NO, BRANCH
         BCTR  R3,0                DECR PTR
         BCT   R1,CI001U           TEST NEXT CHAR
CI001V   STCM  R1,B'0011',S99TULNG  SET L'UNIT DEVICE TYPE
         LA    R8,6(R1,R8)         INCR PTR
*
*        TRACK SPACE SPECIFICATION KEY
*
         ST    R8,S99TUPTR         STORE ADDR OF TEXT UNIT IN PTR LIST
         LA    R7,4(,R7)           INCREMENT S99TUPL TO NEXT ENTRY
         MVC   S99TUKEY(#TRACKL),#TRACK MOVE TRACK KEY SPEC
         LA    R8,#TRACKL(,R8)     INCR PTR
*
*        PRIME SPACE SPECIFICATION KEY
*
         ST    R8,S99TUPTR         STORE ADDR OF TEXT UNIT IN PTR LIST
         LA    R7,4(,R7)           INCREMENT S99TUPL TO NEXT ENTRY
         MVC   S99TUKEY(#PRIMEL),#PRIME MOVE PRIME KEY SPEC
         MVC   S99TUPAR(3),TRACKCNT+1   MOVE IN NO OF TRACKS TO ALLOC
         LA    R8,#PRIMEL+3(,R8)     INCR PTR
*
*        DATA SET STATUS SPECIFICATION KEY
*
         ST    R8,S99TUPTR         STORE ADDR OF TEXT UNIT IN PTR LIST
         LA    R7,4(,R7)           INCREMENT S99TUPL TO NEXT ENTRY
         MVC   S99TUKEY(#STATUSL),#STATUS MOVE STATUS KEY SPEC
         MVI   S99TUPAR,X'04'      SET STATUS TO NEW
         LA    R8,#STATUSL+1(,R8)  INCR PTR
*
*        DATA SET DISPOSITION SPECIFICATION KEY
*
         ST    R8,S99TUPTR         STORE ADDR OF TEXT UNIT IN PTR LIST
         LA    R7,4(,R7)           INCREMENT S99TUPL TO NEXT ENTRY
         MVC   S99TUKEY(#DISPL),#DISP  MOVE DISPOSITION KEY SPEC
         MVI   S99TUPAR,X'04'      SET STATUS TO DELETE
         LA    R8,#STATUSL+1(,R8)  INCR PTR
*
         OI    S99TUPTR,S99TUPLN   LAST ENTRY, TERMINATE LIST
CI001M   LA    R1,DYNAREA          R1 -> S99RBPTR
*
         DYNALLOC
*
         LTR   R15,R15             SUCCESSFUL DELETION ?
         BNZ   DYNERRA             NO, BRANCH TO ERROR PROCESSING
         CLC   S99INFO,=XL2'0000'  ANY INFORMATION REASON PROVIDED ?
         BNE   DYNERRA             YES, BRANCH TO ERROR PROCESSING
*
*        CHECK THAT THIS ALLOCATION WAS TO THE SAME UNIT TYPE AS
*        THE FIRST INITIAL TEST ALLOCATION
*
*        FIND THE TIOT ENTRY FOR THIS ALLOCATION
*
         SR    R15,R15
         L     R5,TIOTADDR
CI001MA  CLC   TIOEDDNM,DYNDDN     THIS DDNAME THE ALLOCATED DATA SET ?
         BE    CI001MB             YES, BRANCH
         IC    R15,TIOELNGH        L'CURRENT TIOT ENTRY
         AR    R5,R15              INCR TO NEXT TIOT ENTRY
         CLI   TIOELNGH,0          L'NEXT TIOT ENTRY = 0 ?
         BNE   CI001MA             NO, PROCESS NEXT TIOT ENTRY
*                                  UCB NOT FOUND, SHOULD NOT HAPPEN
CI001MB  SR    R9,R9
         ICM   R9,B'0111',TIOEFSRT  R9-> UCB, IEFUCBOB MAPPING UCB
         LA    R15,DVCTYPMK        SET MASK TO EXTRACT UNIT TYPE
         N     R15,UCBTYP          DASD UNIT TYPE NOW IN R15
         C     R15,DASDUNIT        DASD UNIT MATCH INITIAL ALLOC ?
         BNE   CIEE04              NO, MIXED DASD UNIT ERROR
*
*        INCR SORTWKXX SUFFIX
*
         AP    WORKP2,=PL1'1'      INCR SORTWKXX SUFFIX
         UNPK  CIWORKD(3),WORKP2
         OI    CIWORKD+2,X'F0'     MAKE SIGNED DIGIT PRINTABLE
         MVC   DYNDDN+6(2),CIWORKD+1
         L     R7,S99TXTPP         R7 -> FIRST TEXT POINTER (DDNAME)
         L     R8,S99TUPTR
         MVC   S99TUPAR(L'DYNDDN),DYNDDN   MOVE IN UPDATED SORKWKXX DDN
         LA    R7,4(,R7)           R7 -> SECOND TEXT POINTER (DSNAME)
         L     R8,S99TUPTR
         MVC   S99TUPAR(L'DYNDSN),DYNDSN   MOVE IN UPDATED SORKWKXX DSN
         BCT   R2,CI001M           LOOP TO ALLOCATE NEXT SORTWKXX DD
*
*        DYNAMIC ALLOCATION COMPLETE
*
         CPISETON CPI2314          SET 2314 DISK AS A GENERIC TERM FOR
*                                  DASD SORT, DETERMINE ACTUAL
*                                  TECHNIQUE LATER IN IERRCN
*
         DROP  R6,R7,R8
*
*----------------------------------------------------------------------
*
*        COMPLETE PROCESSING
*
*----------------------------------------------------------------------
*
*        GENERATING DIAGNOSTIC MESSAGES ?
*
CI057    CPITEST  CPIDIAG+CPIDSIM  DIAGNOSTIC MESSAGES ?
         BZ    CI057A              NO, BRANCH
         L     R2,VIERRCU          R2 -> MSG MODULE
         USING DIERRCU,R2
         L     R3,DASDUNIT         R3 = DASD UNIT TYPE
         BCTR  R3,0                DECR FOR TABLE LOOKUP
         SLL   R3,2                EACH DASD DEVICE NAME IS 4 CHARS
         LA    R1,DASDTAB(R3)      R1 -> ENTRY IN DASD TABLE
         MVC   IER985A,0(R1)       MOVE DASD DEVICE NAME INTO MSG
         SR    R1,R1
         L     R3,CPIDVCT          R3 -> DEVICE ENTRY IN IECZDTAB
         USING DVCT,R3
         ICM   R1,B'0011',DVCCYL   GET NUMBER OF CYLS FOR THIS DEVICE
         LH    R15,DVCALT          GET NUMBER OF ALT TRACKS
         LH    R0,DVCTRK           GET NUMBER OF TRACKS PER CYL
         SR    R14,R14
         DR    R14,R0              CALC NUMBER OF ALT CYLS
         SR    R1,R15              CALC NUMBER OF USABLE CYLS ON DEVICE
         CVD   R1,CIWORKD
         MVC   IER985B,EPATTER6    MOVE IN ED PATTERN
         ED    IER985B,CIWORKD+5   FORMAT NUMBER OF CYLS FOR THIS DEV
         CVD   R0,CIWORKD          R0 = NUMBER OF TRACKS PER CYL
         MVC   CIWORKD(4),EPATTER4
         ED    CIWORKD(4),CIWORKD+6
         MVC   IER985C,CIWORKD+1
         SR    R1,R1
         ICM   R1,B'0011',DVCTRKLN  GET PHYSICAL TRACK LENGTH
         CVD   R1,CIWORKD
         MVC   IER985D,EPATTER6    MOVE IN ED PATTERN
         ED    IER985D,CIWORKD+5
         LM    R0,R1,IER985        IER985I SORTWORK DEVICE
         L     R15,VGAPRT
         BASR  R14,R15             CALL MESSAGE WRITER
*
         DROP  R2
         CPITEST  CPITAPE          TAPE ?
         BO    CI057A              YES, BRANCH
         LA    R15,RCODE6          SET REASON CODE IF NEEDED
         SR    R1,R1
         ICM   R1,B'0011',CPIBLKTB  GET MAXIMUM DASD BLOCKSIZE
         SH    R1,MAXOHEAD         SUB MAXIMUM POSSIBLE BLOCK OHEAD
         CLM   R1,B'0011',CPIRCDL1  EXCEED DASD BLKSIZE ?
         BL    CIEE20              YES, ERROR CHECK
         CLM   R1,B'0011',CPIRCDL2  EXCEED DASD BLKSIZE ?
         BL    CIEE20              YES, ERROR CHECK
         LH    R1,CPIRCDL2
*
*----------------------------------------------------------------------
*
*        RETURN TO CALLER
*
*----------------------------------------------------------------------
*
CI057A   SR    R15,R15             SET ZERO RETURN CODE
CI057E   L     R12,CISAVE12        RESTORE CALLERS R12
         L     R14,12(,R12)        RESTORE R14
         LM    R0,R11,20(R12)      RESTORE R0 - R11
         BR    R14                 RETURN TO CALLER
*
*----------------------------------------------------------------------
*
*        MERGE PROCESSING
*
*----------------------------------------------------------------------
*
*        SET DDN PREFIX TO USER SPECIFIED VALUE
*
CI100    LA    R8,MERGWTAB         R8 -> MERGE UNIT TABLE
         USING UTABLE,R8           ADRESSABILITY FOR SORT TIOT TABLE
         LA    R12,17              SET LOOP COUNTER TO 17
*                                  SORTIN01-16 AND SORTOUT
CI100A   MVC   DDNAME(4),CPIDDSRT  SET DDN PREFIX TO USER SPEC VALUE
         LA    R8,UTABLEL(,R8)     INCR R8 TO NEXT UNIT TABLE ENTRY
         BCT   R12,CI100A          LOOP BACK UNTIL LIST IS EXHAUSTED
*
*        BEGIN TIOT SCAN LOOP
*
         SR    R7,R7               CLEAR DEVICE MASK REG
CI100B   LA    R12,17              SET SEARCH VALUE
         LA    R8,MERGWTAB         GET ADDR OF MERGE UNIT TABLE
CI101    CLC   TIOEDDNM,DDNAME     DDNAME A SORT DD ?
         BE    CI102               YES, BRANCH
         LA    R8,UTABLEL(,R8)     NO, UPDATE UNIT TABLE ENTRY
         BCT   R12,CI101           NO, END OF SEARCH BRANCH
         B     CI103               NOT A SORT DD BRANCH
*
CI102    TM    STATUS,STATDEF      PRESENT DD ALREADY DEFINED ?
         BO    CIEE02              YES, BRANCH
         OI    STATUS,STATDEF      SET DEFINED BIT
         O     R7,LDEVMASK         OR IN DEVICE MASK
         LA    R6,1(,R6)           UPDATE SORT UNIT COUNT
CI103    SR    R15,R15             GET LENGTH OF CURRENT TIOT ENTRY
         IC    R15,TIOELNGH        L'CURRENT TIOT ENTRY
         AR    R5,R15              INCR TO NEXT ENTRY
         CLI   TIOELNGH,0          L'NEW TIOT ENTRY = 0 ?
         BNE   CI100B              NO, LOOP THROUGH TABLE
*
*        TIOT HAS BEEN SCANNED FOR MERGE PROCESSING
*
         BCTR  R6,0                REDUCE SORT UNIT COUNT BY 1
*                                  BECAUSE OF COUNTING SORTOUT
         TM    SORTOUTM+15,STATDEF SORTOUT DEFINED ?
         BZ    CIEE07              NO, BRANCH
         OI    SORTOUT+15,STATDEF  SET SORTOUT DEFINED IN SORTWTAB
         C     R6,CIMMWKU          ENOUGH WORK UNITS ?
         BL    CIEE08              NO, BRANCH
         L     R0,HEXFFFF          SET R0 TO ALL BITS ON
         SR    R1,R1               CLEAR R1
         SRDL  R0,0(R6)            SHIFT NUMBER OF WORK UNIT BITS
*                                  INTO R1
         XR    R1,R7               MATCH BIT FOR BIT ?
         BNZ   CIEE09              NOT ZERO, BRANCH, ERROR
         STH   R6,CPINWKU          PUT NUMBER OF WORK UNITS IN CPI
         CPISETON CPINODC          SET NO DATA CHAINING IN CPI
         CPISETON CPISWA           SET SINGLE WORK ALIGN IN CPI
         LA    R15,SORTDCB         R15 -> SORTDCB
         USING IHADCB,R15
         MVC   DCBDDNAM,SORTIN01   SET DDNAME FOR MERGE ONLY
         DROP  R15
*
         RDJFCB (SORTDCB)          GET JFCB FOR SORTIN01
*
         MVC   JINFRM,JFCRECFM     GET RECFM FROM JFCB
         MVC   JINBLK,JFCBLKSI     GET BLKSIZE FROM JFCB
         MVC   JINLRCL,JFCLRECL    GET LRECL FROM JFCB
*
         OBTAIN SORTDSCB           GET DSCB FOR SORTIN01
*
         LTR   R15,R15             ZERO RETURN CODE ?
         BZ    CI502               YES, BRANCH
         OI    CISWITCH,SWC        DSCB NOT FOUND
         B     CICHECK             BRANCH TO CHECK FOR SORTOUT
*
CI502    MVC   DINFRM,DS1RECFM     GET RECFM FROM DSCB
         MVC   DINBLK,DS1BLKL      GET BLKSIZE FROM DSCB
         MVC   DINLRCL,DS1LRECL    GET LRECL FROM DSCB
         B     CICHECK             BRANCH TO CHECK FOR SORTOUT
*
*----------------------------------------------------------------------
*
*        DYNAMIC ALLOCATION ERROR ERROR PROCESSING
*
*----------------------------------------------------------------------
*
         USING S99RB,R6
         USING S99TUPL,R7          ADDRESSABILITY FOR S99TUPL DSECT
         USING S99TUNIT,R8
*
DYNERRA  LA    R1,KALLOC           ALLOCATION ERROR
         B     DYNERRB
*
DYNERRD  LA    R1,KFREE            FREE ERROR
DYNERRB  STH   R15,CIWORKF         SAVE RETURN CODE
         L     R2,VIERRCU
         USING DIERRCU,R2          ADDR MSG TEXT
         MVC   IER073A,0(R1)       ALLOC OR FREE
         L     R7,S99TXTPP         R7 -> FIRST TEXT POINTER (DDNAME)
         L     R8,S99TUPTR
         MVC   IER073C,S99TUPAR    MOVE FAILING DDNAME INTO MSG
         LA    R1,CIWORKF          R1 -> R15 RETURN CODE
         BAS   R14,HEXFMT          CALL HEX FORMAT RTN
         MVC   IER073D,CIWORKD     MOVE FORMATTED RETURN CODE INTO MSG
         LA    R1,S99ERROR         R1 -> ERROR CODE IN S99RB
         BAS   R14,HEXFMT          CALL HEX FMT RTN
         MVC   IER073E,CIWORKD     MOVE FORMATTED HEX CODE INTO MSG
         LA    R1,S99INFO          R1 -> S99INFO
         BAS   R14,HEXFMT          CALL HEX FMT RTN
         MVC   IER073F,CIWORKD     MOVE FORMATTED HEX CODE INTO MSG
         CLC   S99ERROR,=XL2'021C'  INVALID DEVICE NAME ?
         BNE   DYNERRE             NO, BRANCH
         MVC   IER073R,IER0731     YES, EXPLAIN S99ERROR CODE
         B     DYNERRG
*
DYNERRE  CLC   S99ERROR,=XL2'0218'  INSUFFICIENT DASD SPACE ?
         BNE   DYNERRH             NO, BRANCH
*                                  YES, EXPLAIN S99ERROR CODE
         L     R0,TRACKCNT         R0 = NUMBER OF TRACKS REQUESTED
         CVD   R0,CIWORKD
         MVC   IER0732+20(L'EPATTER6),EPATTER6   MOVE IN PATTERN
         ED    IER0732+20(L'EPATTER6),CIWORKD+5  FORMAT TRACKCNT VALUE
         MVC   IER073R,IER0732
         B     DYNERRG
*
DYNERRH  CLC   S99ERROR,=XL2'0410'  DDNAME NOT AVAILABLE ?
         BNE   DYNERRF             NO, BRANCH
         MVC   IER073R,IER0733     YES, EXPLAIN S99ERROR CODE
         B     DYNERRG
*
DYNERRF  EQU   *                   ADD ANY ADDITIONAL EXPLANATORY MSGS
*                                  HERE
DYNERRG  LM    R0,R1,IER073        IER073I DYNAMIC ALLOCATION ERROR
         L     R15,VGAPRT          GET ADDR OF MSG WRITER
         BASR  R14,R15             CALL MSG WRITER
         LR    R1,R0
         MVC   CPIABMNO,3(R1)      MOVE MSG NO INTO ABEND CODE
*
*        OPTIONALLY PRINT THE DYNALLOC SVC 99 PARAMETER LIST AREA
*
         CPITEST CPIDIAG+CPIDSIM   DUMP THE DYNALLOC PARM LIST AREA ?
         BZ    DYNERRX             NO, BRANCH
         LM    R0,R1,IER073P       IER073 HEADER MESSAGE
         L     R15,VGAPRT          R15 -> PRINT ROUTINE
         BASR  R14,R15             CALL PRINT ROUTINE
         LA    R3,DYNAREA          R3 -> FIRST BYTE OF DYNAREA
         LA    R4,DYNAREA+L'DYNAREA-1  R4 -> LAST BYTE OF DYNAREA
         STM   R3,R4,IERFMTP       SAVE STORAGE ADDRS
         LA    R1,IERFMTP          R1 -> PARAMETER LIST
         L     R15,VIERFMT         R15 -> FORMATTING ROUTINE
         BASR  R14,R15             CALL FORMATTING ROUTINE
DYNERRX  LA    R15,4               SET ERROR RETURN CODE OF 4
         B     CI057E              BRANCH TO EXIT LINKAGE
*
         DROP  R2,R6,R7,R8
*
*----------------------------------------------------------------------
*
*        ERROR PROCESSING
*
*----------------------------------------------------------------------
*
         USING DIERRCU,R8          ADDR DSECT
*
CIEE01   LA    R8,IER039-DIERRCU   IER039A INSUFFICIENT STORAGE
         B     CIPRINT
*
CIEE08   EQU   *
CIEE09   EQU   *
         LA    R8,IER040-DIERRCU   IER040A INSUFFICIENT WORK UNITS
         B     CIPRINT
*
CIEE02   EQU   *                   DUPLICATE ENTRY
         SR    R15,R15             REASON CODE ZERO
         B     CIEE04A
*
CIEE03   EQU   *                   UNSUPPORTED UNIT TYPE
         LA    R15,4               REASON CODE 4
         B     CIEE04A
*
CIEE04   EQU   *                   MIXED TYPE
         LA    R15,8               REASON CODE 8
CIEE04A  L     R8,VIERRCU          R8 -> MSG CSECT
         L     R1,IER042RT(R15)    R1 -> REASON TABLE
         MVC   IER042R,0(R1)       MOVE REASON TEXT INTO MSG
         LM    R0,R1,IER042        IER042A SORTWORK UNIT ASSIGNMENT
         B     CIPRINTA
*
CIEE13   EQU   *
CIEE14   EQU   *
CIEE15   EQU   *
CIEE16   EQU   *
CIEE17   EQU   *
CIEE18   EQU   *
CIEE19   EQU   *
         LA    R8,IER043-DIERRCU   IER043A DATA SET ATTRIBUTES NOT SPEC
         B     CIPRINT
*
CIEE06   EQU   *
CIEE07   LA    R8,IER056-DIERRCU   IER056A SORTIN OR SORTOUT NOT FOUND
         B     CIPRINT
*
CIEE11   LA    R8,IER057-DIERRCU   SORTWK01 NOT ASSIGNED TO SORTIN
         B     CIPRINT
*
CIEE12   EQU   *
         LA    R8,IER058-DIERRCU   IER058A SORTOUT ASSIGNED TO SORTWKXX
         B     CIPRINT
*
CIEE22   LA    R8,IER027-DIERRCU   IER027A CONTROL FIELD IS PAST REC
         B     CIPRINT
*
CIEE20   L     R8,VIERRCU          R8 -> MSG CSECT
         CVD   R15,CIWORKD         CONVERT REASON CODE
         MVC   CIWORKD(4),EPATTER4
         ED    CIWORKD(4),CIWORKD+6
         MVC   IER059A,CIWORKD+1
         LM    R0,R1,IER059        IER059A RECORD LENGTH INVALID
         B     CIPRINTA
*
         DROP  R8
*
CIPRINT  A     R8,VIERRCU          ADD ADDR OF MSG MODULE
         LM    R0,R1,0(R8)         R0 -> ADDR OF MSG, R1 = L'MSG
CIPRINTA L     R15,VGAPRT          GET ADDR OF MSG WRITER
         BASR  R14,R15             CALL MSG WRITER
         LR    R1,R0
         MVC   CPIABMNO,3(R1)      MOVE MSG NO INTO ABEND NO
         LA    R15,4               SET ERROR RETURN CODE OF 4
         B     CI057E              BRANCH TO EXIT LINKAGE
*
*----------------------------------------------------------------------
*
*        FORMAT HEX RTN
*
*----------------------------------------------------------------------
*
*        ON ENTRY
*        R1 -> HALF WORD TO BE FORMATTED
*        RESULT RETURNED IN CIWORKD
*
HEXFMT   UNPK  CIWORKD(5),0(3,R1)  UNPACK THE 2 BYTE VALUE
         TR    CIWORKD(4),TRANTAB-240
         BR    R14                 RETURN TO CALLER
*
*----------------------------------------------------------------------
*
*        CONSTANTS AND DATA
*
*----------------------------------------------------------------------
*
         PRINT NOGEN
*
SORTDCB  DCB   DDNAME=SORTIN,EXLST=SORTDCBX,DSORG=PS,MACRF=(E)
*
         PRINT GEN
*
         DC    0F'0'            *
SORTDCBX DC    X'87'            |  REQUEST RDJFCB
         DC    AL3(JFCB)        V  ADDR OF JFCB
*
TIOTADDR DC    F'0'                SET BY EXTRACT
*
VIERRCF  DC    V(IERRCF)           DASD BLKSIZE CALC MODULE
VIERRCU  DC    V(IERRCU)           IERRCU MSG CSECT
VGAPRT   DC    V(IERGAPRT)         MESSAGE WRITER
*
*        DASD DEVICE NAMES
*        THIS IS THE ONLY DASD TYPE INFO IN THIS VERSION OF SORT
*
DASDTAB  DC    CL4'2311'        *  X'01'
         DC    CL4'2301'        |  X'02'
         DC    CL4'2303'        |  X'03'
         DC    CL4'9345'        |  X'04'  2302 REPURPOSED TO 9345
         DC    CL4'2321'        |  X'05'
         DC    CL4'2351'        |  X'06'  2305-1
         DC    CL4'2352'        |  X'07'  2305-2
         DC    CL4'2314'        |  X'08'
         DC    CL4'3330'        |  X'09'
         DC    CL4'3340'        |  X'0A'  ALL MODELS, 3340-35,3340-70
         DC    CL4'3350'        |  X'0B'
         DC    CL4'3375'        |  X'0C'
         DC    CL4'3331'        |  X'0D'  3330-11
         DC    CL4'3380'        |  X'0E'
         DC    CL4'3390'        V  X'0F'  ALL MODELS
*
DASDUNIT DC    F'0'                DASD UNIT TYPE NUMBER
HEXFFFF  DC    X'FFFFFFFF'
EPATTER6 DC    X'402020212020'     EDIT PATTERN
EPATTER4 DC    X'40212020'         EDIT PATTERN
TRANTAB  DC    C'0123456789ABCDEF'  TRANSLATE TABLE FOR HEX CONVERT
*
*        DYNAMIC ALLOCATION KEY DATA
*
#DDNAMD  DC    AL2(DUNDDNAM)       DELETE DDNAME SPECIFICATION
         DC    X'0001'             #
         DC    X'0008'             LENGTH OF PARM DATA
#DDNAMDL EQU   *-#DDNAMD           LENGTH OF KEY SPECIFICATION
*
#DDNAMA  DC    AL2(DALDDNAM)       ALLOCATE DDNAME SPECIFICATION
         DC    X'0001'             #
         DC    X'0008'             LENGTH OF PARM DATA
#DDNAMAL EQU   *-#DDNAMA           LENGTH OF KEY SPECIFICATION
*
#DSNAMA  DC    AL2(DALDSNAM)       ALLOCATE DSNAME SPECIFICATION
         DC    X'0001'             #
         DC    X'0000'             LENGTH OF PARM DATA
#DSNAMAL EQU   *-#DSNAMA           LENGTH OF KEY SPECIFICATION
*
#UNIT    DC    AL2(DALUNIT)        UNIT DESCRIPTION
         DC    X'0001'             #
         DC    X'0000'             LENGTH OF PARM DATA
#UNITL   EQU   *-#UNIT             LENGTH OF KEY SPECIFICATION
*
#TRACK   DC    AL2(DALTRK)         TRACK SPACE DESCRIPTION
         DC    X'0000'             #
#TRACKL  EQU   *-#UNIT             LENGTH OF KEY SPECIFICATION
*
#PRIME   DC    AL2(DALPRIME)       PRIMARY SPACE ALLOCATION
         DC    X'0001'             #
         DC    X'0003'             LENGTH OF PARM DATA
#PRIMEL  EQU   *-#PRIME            LENGTH OF KEY SPECIFICATION
*
#STATUS  DC    AL2(DALSTATS)       DATA SET STATUS SPECIFICATION
         DC    X'0001'             #
         DC    X'0001'             LENGTH OF PARM DATA
#STATUSL EQU   *-#STATUS           LENGTH OF KEY SPECIFICATION
*
#DISP    DC    AL2(DALNDISP)       DATA SET DISPOSITION SPECIFICATION
         DC    X'0001'             #
         DC    X'0001'             LENGTH OF PARM DATA
#DISPL   EQU   *-#DISP             LENGTH OF KEY SPECIFICATION
*
#UNALC   DC    AL2(DUNUNALC)       DEALLOC EVEN IF PERMANENT ALLOC
         DC    X'0000'             #
#UNALCL  EQU   *-#UNALC            LENGTH OF KEY SPECIFICATION
*
TESTDDN  DC    CL8'TESTALLO'       DDNAME TO TEST DEVICE ALLOCATION
*
TESTDSN  DC    C'&&&&TESTALLO'     DSNAME TO TEST DEVICE ALLOCATION
*
TRACKCNT DC    F'0'                NUMBER OF TRACKS FOR EACH SORTWKXX
*
DYNDSN   DC    CL10'&&&&'          DYNAMIC ALLOCATION DSNAME
         ORG   DYNDSN+2
DYNDDN   DC    CL8'SORTWK01'       DDNAME FOR DYNAMIC ALLOCATION
         ORG
KALLOC   DC    CL5'ALLOC'          FOR ERROR MSG
KFREE    DC    CL5'FREE '
WORKP2   DC    PL2'1'              SORKWKXX SUFFIX VALUE
*
*        DATA FOR PRINT DUMP OF SVC 99 PARAMETER LIST AREA
*
IER073P  DC    A(IER073PT)
         DC    A(L'IER073PT)
IER073PT DC    C'IER073A DYNALLOC Error, SVC 99 Parameter List Area'
*
*        PARAMETER LIST FOR IERFMT
*
IERFMTP  DC    A(0)                -> AREA TO PRINT
         DC    A(0)                -> END OF AREA TO PRINT
         DC    V(IERGAPRT)         -> PRINT ROUTINE
*
VIERFMT  DC    V(IERFMT)           -> FORMAT STORAGE ROUTINE
*
*        JFCB
*
         DC    0D'0'
JFCB     DC    XL176'00'
*
         ORG   JFCB
*
         PRINT NOGEN
*
         IEFJFCBN
*
         ORG   ,
*
*        UCB DEVICE CHARACTERISTICS
*
         DC    0F'0'
DVADATA  DC    5F'0'
         ORG   DVADATA
*
         IHADVA DSECT=NO           MAP DEVTYPE DATA
*
         ORG   ,
*
         PRINT GEN
*
*----------------------------------------------------------------------
*
*        WORK AREAS
*
*----------------------------------------------------------------------
*
CISAVE12 DC    F'0'                SAVE R12
*
CIINFCT  DC    F'0'                INPUT TAPE TYPE
*
CIWKFCT  DC    F'0'                SORTWKXX DEVICE UNIT TYPE
*
CIOUTFCT DC    F'0'                OUTPUT TAPE TYPE
*
KF0      DC    F'0'                ZERO USED FOR COMPARISONS
CIMMWKU  DC    F'1'                MORE WORKUNITS ARE REQUIRED
CIMINWKU DC    H'3'                MINIMUM NUMBER OF WORK UNITS
CIMAXWKU DC    H'32'               MAXIMUM NUMBER OF WORK UNITS (TAPE)
*                                  SET TO 17 IF DASD SORT
CIK7     DC    H'7'                ROUNDING
MINLRECL DC    H'18'               MINIMUM LRECL FOR SORT/MERGE
MAXOHEAD DC    H'28'               MAXIMUM SORT BLOCK OVERHEAD
*
CITL1    DC    H'0'                WORKAREA FOR INPUT RECL
CITL3    DC    H'0'                WORKAREA FOR OUTPUT LRECL
CIINBLK  DC    H'0'                WORKAREA FOR INPUT BLOCKING
CIOUTBLK DC    H'0'                WORKAREA FOR OUTPUT BLOCKING
*
*        SORTIN DCB DATA
*
JINLRCL  DC    H'0'                LRECL AS SPECIFIED IN JFCB FOR INP
JINBLK   DC    H'0'                BLOCKSIZE AS SPECIFIED IN JFCB INP
DINLRCL  DC    H'0'                LRECL AS SPECIFIED IN DSCB FOR INP
DINBLK   DC    H'0'                BLOCKSIZE AS SPECIFIED IN DSCB INP
JINFRM   DC    X'0'                INPUT RECORD FORMAT AS IN JFCB
DINFRM   DC    X'0'                INPUT RECORD FORMAT AS IN DSCB
DINSTAR  DC    AL3(0)              DS1LSTAR FROM FMT 1 DSCB
AVLRECL  DC    H'0'                AVERAGE INPUT LRECL
*
*        SORTOUT DCB DATA
*
JOUTLRCL DC    H'0'                LRECL AS SPECIFIED IN JFCB FOR OUT
JOUTBLK  DC    H'0'                BLOCKSIZE AS SPECIFIED IN JFCB OUT
DOUTLRCL DC    H'0'                LRECL AS SPECIFIED IN DSCB FOR OUT
DOUTBLK  DC    H'0'                BLOCKSIZE AS SPECIFIED IF DSCB OUT
JOUTFRM  DC    X'0'                OUTPUT RECORD FORMAT AS IN JFCB
DOUTFRM  DC    X'0'                OUTPUT RECORD FORMAT AS IN DSCB
*
*        DASD AND TAPE CONSTANTS
*
KH256    DC    H'256'              LRECL TEST VALUE
KH32767  DC    H'32767'            MAXIMUM BLOCKSIZE (32K-1)
*
CITP2400 DC    X'8001'             2400 DEVICE CLASS
CITP3400 DC    X'8003'             3400 DEVICE CLASS
*
CIKWORK  DC    H'0'                TEMPORARY SAVE AREA
CIWORKF  DC    F'0'                TEMPORARY WORK AREA
CIWORKD  DC    D'0'                TEMPORARY WORK AREA
*
CIOUTFRM DC    X'00'               OUTPUT RECORD FORMAT
CIINFRM  DC    X'00'               INPUT  RECORD FORMAT
*
CISWITCH DC    X'00'               INDICATOR FOR DSCB
SWA      EQU   128
SWB      EQU   64
SWC      EQU   32
SWD      EQU   16
*
*        WORK AREA FOR DYNAMIC ALLOCATION
*
         DC    0F'0'
DYNAREA  DC    XL256'00'           ALLOW 256 BYTES FOR DYNALLOC PARMS
         ORG   DYNAREA
         DC    XL1'80'             SET S99RBPND
         DC    AL3(DYNAREA+4)      SET S99RBPTR
         ORG
*
*        FORMAT 1 DSCB
*
         DC    0D'0'
FMT1DSCB DC    XL140'00'
         ORG   FMT1DSCB-44         L'DS1DSNAM (FIX IECSDSL1 MAPPING)
*
         PRINT NOGEN
*
         IECSDSL1 (1)              FORMAT 1 DSCB
*
         PRINT GEN
*
         ORG   ,
*
*        CAMLST ENTRY TO READ DSCB
*
SORTDSCB CAMLST SEARCH,JFCBDSNM,JFCBVOLS,FMT1DSCB
*
*        UNIT TABLE
*
*        MAPPED BY DSECT UTABLE
*
*        EACH SORTWKXX DATA SET IS ASSIGNED A BIT IN THE MASK FIELD
*        FROM LEFT TO RIGHT
*        IE MASK FOR SORTWK01 IS X'80000000'
*                    SORTWK02 IS X'40000000'
*
SORTWTAB DC    0F'0'
SORTIN   DC    CL8'SORTIN  '       FILENAME
         DC    X'00000000'         MASK - NOT SET FOR SORTIN
         DC    AL3(0)              UCB ADDR
         DC    AL1(STATIN)         FLAGS
SORTOUT  DC    CL8'SORTOUT '       FILENAME
         DC    X'00000000'         MASK - NOT SET FOR SORTOUT
         DC    AL3(0)              UCB ADDR
         DC    AL1(STATOUT)        FLAGS
SORTWK01 DC    CL8'SORTWK01'       FILENAME
         DC    X'80000000'         MASK
         DC    AL3(0)              UCB ADDR
         DC    AL1(0)              FLAGS
SORTWK02 DC    CL8'SORTWK02'       FILENAME
         DC    X'40000000'         MASK
         DC    AL3(0)              UCB ADDR
         DC    AL1(0)              FLAGS
SORTWK03 DC    CL8'SORTWK03'       FILENAME
         DC    X'20000000'         MASK
         DC    AL3(0)              UCB ADDR
         DC    AL1(0)              FLAGS
SORTWK04 DC    CL8'SORTWK04'       FILENAME
         DC    X'10000000'         MASK
         DC    AL3(0)              UCB ADDR
         DC    AL1(0)              FLAGS
SORTWK05 DC    CL8'SORTWK05'       FILENAME
         DC    X'08000000'         MASK
         DC    AL3(0)              UCB ADDR
         DC    AL1(0)              FLAGS
SORTWK06 DC    CL8'SORTWK06'       FILENAME
         DC    X'04000000'         MASK
         DC    AL3(0)              UCB ADDR
         DC    AL1(0)              FLAGS
SORTWK07 DC    CL8'SORTWK07'       FILENAME
         DC    X'02000000'         MASK
         DC    AL3(0)              UCB ADDR
         DC    AL1(0)              FLAGS
SORTWK08 DC    CL8'SORTWK08'       FILENAME
         DC    X'01000000'         MASK
         DC    AL3(0)              UCB ADDR
         DC    AL1(0)              FLAGS
SORTWK09 DC    CL8'SORTWK09'       FILENAME
         DC    X'00800000'         MASK
         DC    AL3(0)              UCB ADDR
         DC    AL1(0)              FLAGS
SORTWK10 DC    CL8'SORTWK10'       FILENAME
         DC    X'00400000'         MASK
         DC    AL3(0)              UCB ADDR
         DC    AL1(0)              FLAGS
SORTWK11 DC    CL8'SORTWK11'       FILENAME
         DC    X'00200000'         MASK
         DC    AL3(0)              UCB ADDR
         DC    AL1(0)              FLAGS
SORTWK12 DC    CL8'SORTWK12'       FILENAME
         DC    X'00100000'         MASK
         DC    AL3(0)              UCB ADDR
         DC    AL1(0)              FLAGS
SORTWK13 DC    CL8'SORTWK13'       FILENAME
         DC    X'00080000'         MASK
         DC    AL3(0)              UCB ADDR
         DC    AL1(0)              FLAGS
SORTWK14 DC    CL8'SORTWK14'       FILENAME
         DC    X'00040000'         MASK
         DC    AL3(0)              UCB ADDR
         DC    AL1(0)              FLAGS
SORTWK15 DC    CL8'SORTWK15'       FILENAME
         DC    X'00020000'         MASK
         DC    AL3(0)              UCB ADDR
         DC    AL1(0)              FLAGS
SORTWK16 DC    CL8'SORTWK16'       FILENAME
         DC    X'00010000'         MASK
         DC    AL3(0)              UCB ADDR
         DC    AL1(0)              FLAGS
SORTWK17 DC    CL8'SORTWK17'       FILENAME
         DC    X'00008000'         MASK
         DC    AL3(0)              UCB ADDR
         DC    AL1(0)              FLAGS
SORTWK18 DC    CL8'SORTWK18'       FILENAME
         DC    X'00004000'         MASK
         DC    AL3(0)              UCB ADDR
         DC    AL1(0)              FLAGS
SORTWK19 DC    CL8'SORTWK19'       FILENAME
         DC    X'00002000'         MASK
         DC    AL3(0)              UCB ADDR
         DC    AL1(0)              FLAGS
SORTWK20 DC    CL8'SORTWK20'       FILENAME
         DC    X'00001000'         MASK
         DC    AL3(0)              UCB ADDR
         DC    AL1(0)              FLAGS
SORTWK21 DC    CL8'SORTWK21'       FILENAME
         DC    X'00000800'         MASK
         DC    AL3(0)              UCB ADDR
         DC    AL1(0)              FLAGS
SORTWK22 DC    CL8'SORTWK22'       FILENAME
         DC    X'00000400'         MASK
         DC    AL3(0)              UCB ADDR
         DC    AL1(0)              FLAGS
SORTWK23 DC    CL8'SORTWK23'       FILENAME
         DC    X'00000200'         MASK
         DC    AL3(0)              UCB ADDR
         DC    AL1(0)              FLAGS
SORTWK24 DC    CL8'SORTWK24'       FILENAME
         DC    X'00000100'         MASK
         DC    AL3(0)              UCB ADDR
         DC    AL1(0)              FLAGS
SORTWK25 DC    CL8'SORTWK25'       FILENAME
         DC    X'00000080'         MASK
         DC    AL3(0)              UCB ADDR
         DC    AL1(0)              FLAGS
SORTWK26 DC    CL8'SORTWK26'       FILENAME
         DC    X'00000040'         MASK
         DC    AL3(0)              UCB ADDR
         DC    AL1(0)              FLAGS
SORTWK27 DC    CL8'SORTWK27'       FILENAME
         DC    X'00000020'         MASK
         DC    AL3(0)              UCB ADDR
         DC    AL1(0)              FLAGS
SORTWK28 DC    CL8'SORTWK28'       FILENAME
         DC    X'00000010'         MASK
         DC    AL3(0)              UCB ADDR
         DC    AL1(0)              FLAGS
SORTWK29 DC    CL8'SORTWK29'       FILENAME
         DC    X'00000008'         MASK
         DC    AL3(0)              UCB ADDR
         DC    AL1(0)              FLAGS
SORTWK30 DC    CL8'SORTWK30'       FILENAME
         DC    X'00000004'         MASK
         DC    AL3(0)              UCB ADDR
         DC    AL1(0)              FLAGS
SORTWK31 DC    CL8'SORTWK31'       FILENAME
         DC    X'00000002'         MASK
         DC    AL3(0)              UCB ADDR
         DC    AL1(0)              FLAGS
SORTWK32 DC    CL8'SORTWK32'       FILENAME
         DC    X'00000001'         MASK
         DC    AL3(0)              UCB ADDR
         DC    AL1(0)              FLAGS
*
*        MERGE TABLE
*
MERGWTAB DC    0F'0'
SORTOUTM DC    CL8'SORTOUT '       FILENAME
         DC    X'00000000'         MASK
         DC    AL3(0)              UCB ADDR
         DC    AL1(STATOUT)        FLAGS
SORTIN01 DC    CL8'SORTIN01'       FILENAME
         DC    X'80000000'         MASK
         DC    AL3(0)              UCB ADDR
         DC    AL1(0)              FLAGS
SORTIN02 DC    CL8'SORTIN02'       FILENAME
         DC    X'40000000'         MASK
         DC    AL3(0)              UCB ADDR
         DC    AL1(0)              FLAGS
SORTIN03 DC    CL8'SORTIN03'       FILENAME
         DC    X'20000000'         MASK
         DC    AL3(0)              UCB ADDR
         DC    AL1(0)              FLAGS
SORTIN04 DC    CL8'SORTIN04'       FILENAME
         DC    X'10000000'         MASK
         DC    AL3(0)              UCB ADDR
         DC    AL1(0)              FLAGS
SORTIN05 DC    CL8'SORTIN05'       FILENAME
         DC    X'08000000'         MASK
         DC    AL3(0)              UCB ADDR
         DC    AL1(0)              FLAGS
SORTIN06 DC    CL8'SORTIN06'       FILENAME
         DC    X'04000000'         MASK
         DC    AL3(0)              UCB ADDR
         DC    AL1(0)              FLAGS
SORTIN07 DC    CL8'SORTIN07'       FILENAME
         DC    X'02000000'         MASK
         DC    AL3(0)              UCB ADDR
         DC    AL1(0)              FLAGS
SORTIN08 DC    CL8'SORTIN08'       FILENAME
         DC    X'01000000'         MASK
         DC    AL3(0)              UCB ADDR
         DC    AL1(0)              FLAGS
SORTIN09 DC    CL8'SORTIN09'       FILENAME
         DC    X'00800000'         MASK
         DC    AL3(0)              UCB ADDR
         DC    AL1(0)              FLAGS
SORTIN10 DC    CL8'SORTIN10'       FILENAME
         DC    X'00400000'         MASK
         DC    AL3(0)              UCB ADDR
         DC    AL1(0)              FLAGS
SORTIN11 DC    CL8'SORTIN11'       FILENAME
         DC    X'00200000'         MASK
         DC    AL3(0)              UCB ADDR
         DC    AL1(0)              FLAGS
SORTIN12 DC    CL8'SORTIN12'       FILENAME
         DC    X'00100000'         MASK
         DC    AL3(0)              UCB ADDR
         DC    AL1(0)              FLAGS
SORTIN13 DC    CL8'SORTIN13'       FILENAME
         DC    X'00080000'         MASK
         DC    AL3(0)              UCB ADDR
         DC    AL1(0)              FLAGS
SORTIN14 DC    CL8'SORTIN14'       FILENAME
         DC    X'00040000'         MASK
         DC    AL3(0)              UCB ADDR
         DC    AL1(0)              FLAGS
SORTIN15 DC    CL8'SORTIN15'       FILENAME
         DC    X'00020000'         MASK
         DC    AL3(0)              UCB ADDR
         DC    AL1(0)              FLAGS
SORTIN16 DC    CL8'SORTIN16'       FILENAME
         DC    X'00010000'         MASK
         DC    AL3(0)              UCB ADDR
         DC    AL1(0)              FLAGS
*
*        LTORG
*
         LTORG
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         PRINT NOGEN
*
         DCBD  DSORG=QS,DEVD=(DA,TA)  QSAMDCB
*
         PRINT GEN
*
QSAMDCBL EQU   *-IHADCB            L'QSAM DCB CALCULATED BY IHADCB
*
*        REASON CODES FOR MSG IER059 RECORD LENGTH INVALID
*
RCODE1   EQU   1                   L1 < 18
RCODE2   EQU   2                   L2 < 18
RCODE3   EQU   3                   L3 < 18
RCODE4   EQU   4                   L4 < 18
RCODE5   EQU   5                   L5 < 18
RCODE6   EQU   6                   L'RECODE > DASD TRACK CAPACITY
RCODE7   EQU   7
RCODE8   EQU   8
RCODE9   EQU   9                   L2 > 32K
RCODEA   EQU   10                  INPUT BLKSIZE > 32K
RCODEB   EQU   11                  OUTPUT BLKSIZE > 32K
RCODEC   EQU   12
RCODED   EQU   13
RCODEE   EQU   14
RCODEF   EQU   15
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRCU SOURCE
*
*----------------------------------------------------------------------
*
DIERRCU  DSECT
*
         COPY IERRCUI
*
*        MAP SORT UNIT TABLE ENTRY
*
UTABLE   DSECT
DDNAME   DS    CL8
LDEVMASK DS    CL4                 EACH SORTWK DATA SET IS ASSIGNED 1B
UCBPTR   DS    CL3
STATUS   DS    CL1                 FLAGS
STATDEF  EQU   X'20'
STATWORK EQU   X'C0'               SORTWORK
STATIN   EQU   X'80'               SORTIN
STATOUT  EQU   X'40'               SORTOUT
*
UTABLEL  EQU   *-UTABLE            L'UNIT TABLE
*
*        IHADVCT                   MAP DEVICE CHARACTERISTICS TABLE
*
         IHADVCT
*
*        MAP UCB
*
UCB      DSECT
*
         PRINT NOGEN
*
         IEFUCBOB
*
*        DYNAMIC ALLOCATION
*
         IEFZB4D0
*
         IEFZB4D2
*
*        MAP CVT
*
         CVT  DSECT=YES
*
*        MAP TIOT
*
TIOT     DSECT
*
         IEFTIOT1
*
         PRINT GEN
*
         SMCPI
*
         END
./ ADD NAME=IERRCJ   0101-20211-20211-1200-00265-00265-00000-RELEASE 00
RCJ      TITLE 'IERRCJ - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRCJ
*
*        MODULE FUNCTION/OPERATION -
*        1. DETERMINE THE CAPACITY OF THE DASD TYPE AND
*           CALCULATE THE MAXIMUM NUMBER OF RECORDS THAT CAN
*           OCCUPY THE TRACKS AVAILABLE TO THE DASD SORT
*        2. DETERMINE THE NUMBER OF PHYSICAL BLOCKS OF RECORDS
*           THAT CAN BE WRITTEN ON A TRACK OF THE DEVICE FOR
*           PHASE 2 OF THE SORT. IF THE CAPACITY IS EXCEEDED, OR
*           IF THE NUMBER OF AVAILABLE TRACKS DOES NOT EQUAL OR
*           EXCEED THE REQUIRED NUMBER, AN ERROR MESSAGE WILL BE
*           ISSUED
*        3. THIS MODULE IS USED FOR BOTH BALN AND CRCX SORT TECHNIQUES
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACROS - SMPPI
*
*        ENTRY POINT - ENTRY IERRCJ - ENTRY FROM IERRCZ
*                                     CALLING SEQUENCE -
*                                     L     R15,=V(IERRCJ)
*                                     BASR  R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPICNTL  - FIXED OR VARIABLE
*        PPINDSKA - NO OF DASD AREAS
*        PPIDSKED - NUMBER OF TRACKS
*        PPISTAR  - STARTING ADDRS - 00
*        PPIENDAR - ENDING ADDRS   - TT RELATIVE ADDR
*        PPISRTBL - SORT BLOCKING FACTOR
*        PPIRCDL2
*        PPIRCDL4
*        PPIRCDL5
*        PPIFILSZ - FILE SIZE
*        PPIBLKTB - DASD BLKSIZE TABLE (BUILT BY IERRCF)
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPIBPTRK - BLOCKS PER TRACK
*        PPINMAX  - SORT CAPACITY
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL - IERRCZ WITH ZERO IN R15
*
*        EXITS - ERROR - IERRCZ WITH FOUR IN R15
*
IERRCJ   CSECT
*
         USING *,R15
         USING IERRCA,R13
*
         IERENTRY 'IERRCJ &SYSDATE &SYSTIME'
*
         STM   R14,R12,12(R12)     SAVE CALLERS REGS
         ST    R12,SAVER12         SAVE R12
         DROP  R15
         LR    R11,R15             BASE REGISTER = R11
         USING IERRCJ,R11
         USING DIERRCU,R15         MESSAGE MODULE
*
         LA    R15,4               SET R15 TO 4 FOR FIXED RECORDS
         PPITEST  PPIFIX           RECFM=F ?
         BO    CAPDISK             YES, BRANCH
         AR    R15,R15             R15 = 8 FOR VARIABLE LENGTH RECORDS
*
*        CALCULATE TOTAL TRACKS IN SORTWORK AREAS
*        BY SUMMING AREAS IN THE DISK TABLE
*        ON COMPLETION R1 = TOTAL TRACKS
*                      R7 = LARGEST SINGLE AREA
*
CAPDISK  SR    R7,R7               CLEAR FOR LARGEST DISK AREA
         SR    R1,R1               ACCUMULATOR FOR TOTAL NO OF TRACKS
         LH    R2,PPINDSKA         R2 = NUMBER OF DISK AREAS
         LA    R9,PPIDSKED         R9 -> PPIDSKED TABLE
         SR    R6,R6               CLEAR
*
*        BEGIN SUMMATION LOOP
*
NEXTDISK ICM   R6,B'0011',2(R9)    R6 = NO OF TRACKS FROM PPIDSKED
         CLM   R6,B'0011',MINTRAK  < MINIMUM NO OF TRACKS ?
         BL    CAPER01             ERROR, LESS THAN MIN NO OF TRACKS
         CLR   R7,R6               THIS DISK AREA THE LARGEST SO FAR ?
         BNL   DISKADD             NO, TRY NEXT EXTENT
         LR    R7,R6               YES, SET R7 TO SIZE OF LARGEST AREA
*                                  FOUND SO FAR
DISKADD  AR    R1,R6               UPDATE CUMMULATIVE TRACK COUNT
         LA    R9,4(,R9)           UPDATE POINTER TO PPIDSKED ENTRY
         BCT   R2,NEXTDISK         LOOP TO PROCESS NEXT DATA SET
*
*        FOR BALN TECHNIQUE DISCARD THE TRACK COUNT FOR THE
*        LARGEST SORTWKXX AREA
*
         PPITEST PPIVALCT          BALN TECHNIQUE ?
         BNO   DETBLK              NO, BRANCH
         SR    R1,R7               TOTAL TRACKS IN (A-1) SMALLEST AREAS
*
*        DETERMINE BLOCKS PER TRACK
*
DETBLK   LA    R6,PPIBLKTB         R6 -> DISK BLOCK TABLE
         CLC   0(2,R6),PPILAB07+2  DASD BLKSIZE VS SORT BLKSIZE
         BL    CAPERROR            ERROR, INTERNAL PROGRAM ERROR
         LH    R5,2(,R6)           R5 = BLOCKS PER TRACK
         STH   R5,PPIBPTRK         SAVE NO OF BLOCKS PER DASD TRACK
*
*        CALCULATE NMAX
*        ON ENTRY
*        R1 = TOTAL NUMBER OF TRACKS ALLOCATED
*        R5 = BLOCKS PER TRACK
*
         PPITEST  PPIFSZE          FILE SIZE ESTIMATED FLAG SET ?
         BO    CAPCAL              YES, GO CALCULATE N-MAX CAPACITY
         SR    R2,R2               CLEAR
         L     R3,PPIFILSZ         R3 = NUMBER OF RECORDS
         SR    R6,R6               CLEAR
         LH    R7,PPISRTBL         R7 = SORT RECORD BLOCKING FACTOR
         LH    R8,PPIRCDL4         MINIMUM VARIABLE RECORD
         B     *(R15)
         B     DETBLKA         +04 FIXED
         DR    R6,R8           +08 GET MAXIMUM B FOR VARIABLE RECORDS
DETBLKA  SR    R6,R6
         MR    R6,R5               SORT RECORD BLOCKING FACTOR *
*                                  BLOCKS PER TRACK = RECORDS PER TRK
         DR    R2,R7               FILE SIZE / RECORDS PER TRK =
*                                  MINIMUM NUMBER OF TRACKS REQ (R3)
         CLR   R1,R3               AVAILABLE TRACKS VS MINIMUM REQ
         BL    CAPERROR            INSUFFICIENT SPACE TO STORE ALL RECS
*
CAPCAL   SR    R4,R4               CALCULATE N-MAX
         MR    R4,R1               BLOCKS PER TRACK (R5) *
*                                  AVAIL TRACKS = TOTAL NO BLOCKS (R5)
         SH    R5,K2               TAKE OFF 2 BLKS, 1 FOR EACH POSITION
*                                  EOS AFTER E16
         LH    R7,PPISRTBL         R7 = SORT BLOCKING FACTOR
         SR    R6,R6
         PPITEST  PPI2314          CRCX ALGORITHM ?
         BZ    RCJNOT23            NO, BRANCH
         LH    R8,PPIRCDL2         YES, GET MAX RECORD LENGTH
         B     RCJSKIP1            SKIP NEXT INSTRUCTION
*
RCJNOT23 LH    R8,PPIRCDL5         GET MODAL RECORD LENGTH
RCJSKIP1 B     *(R15)
         B     RCJSKIP2        +04 FIXED
         DR    R6,R8           +08 VAR, MODAL B FOR VARIABLE RECORDS
RCJSKIP2 LR    R9,R5               TAKE A COPY OF NUMBER OF BLOCKS REQ
         SR    R8,R8
         LH    R4,PPIDYNP          %UPLIFT
         LA    R4,100(,R4)
         DR    R8,R4
         LH    R4,PPIDYNP          %UPLIFT
         BCTR  R4,0
         MR    R8,R4               %UPLIFT IN BLOCKS
         SR    R5,R9               REDUCE DOWN BLOCK COUNT BY PPIDYNP
         SR    R4,R4
         MR    R4,R7               TOTAL BLOCKS (R5) * SORT RECORD
*                                  BLOCKING FACTOR (R7) =
*                                  TOTAL RECORDS (R5)
         PPITEST  PPIME16          E16 ACTIVE ?
         BZ    RCJNMAX             NO, BRANCH
         PPITEST  PPI2314          CRCX ?
         BZ    RCJNMAX             NO, BRANCH
*
*        THE FOLLOWING ROUTINE (DOWN TO RCJNMAX) IS ONLY FOR CRCX
*        AND E16 WHICH IS THE EXIT FOR NMAX EXCEEDED
*
*        IF E16 IS ACTIVE NMAX WILL BE REDUCED BY 10% FOR AN
*        AVERAGE TRACKS PER AREA OF 40 OR MORE - 20% FOR AN
*        AVERAGE OF AT LEAST 10 BUT LESS THAN 40-50% FOR AN
*        AVERAGE OF LESS THAN 10. THIS IS TO INSURE THAT THE E16
*        EXIT WILL BE TAKEN BEFORE CAPACITY IS EXCEEDED
*
         SR    R4,R4
         LR    R7,R1               NO OF AVAILABLE TRACKS IN R7
         SR    R6,R6
         LH    R9,PPINDSKA         GET NO OF DISK AREAS
         DR    R6,R9               TOTAL TRACKS/NO OF DISK AREAS
         SH    R7,K10              SUBTRACT 10
         BM    RCJLT10             BRANCH IF LESS THAN 10 TRKS PER AREA
         SH    R7,K30              SUBTRACT 30
         BM    RCJLT40             BRANCH IF LESS THAN 40 TRKS PER AREA
         MH    R5,K9               N-MAX TIMES 9
         B     RCJDIV              GO DIVIDE BY 10
*
RCJLT40  MH    R5,K8               N-MAX TIMES 8
         B     RCJDIV              GO DIVIDE BY 20
*
RCJLT10  MH    R5,K5               N-MAX TIMES 5
RCJDIV   LH    R6,K10
         DR    R4,R6               DIVIDE BY 10
*
RCJNMAX  ST    R5,PPINMAX          STORE N-MAX
         CVD   R5,WORKD            CONVERT PPINMAX
         L     R15,VIERRCU         R15 -> MSG TEXT MODULE
         ED    IER038A,WORKD+3
         LM    R0,R1,IER038        IER038I ESTIMATED MAXIMUM RECORDS
         L     R15,VGAPRT
         BASR  R14,R15             CALL MSG WRITER
         SR    R15,R15             SET OK CODE
*
*        RETURN TO CALLER
*
RCJRET   L     R12,SAVER12         R12 -> CALLERS SAVE AREA
         L     R14,12(,R12)        RESTORE RETURN ADDR
         LM    R0,R11,20(R12)      LEAVE R15 AS SET
         BR    R14                 RETURN
*
*        ERROR PROCESSING
*
CAPERROR L     R15,VIERRCU
         L     R1,IER041
         MVC   PPIABMNO,3(R1)      MOVE MSG NO INTO ABEND NO
         LM    R0,R1,IER041        IER041A SIZE GREATER THAN ESTIMATED
         L     R15,VGAPRT
         BASR  R14,R15
         LA    R15,4
         B     RCJRET              RETURN WITH ERROR SET
*
CAPER01  L     R15,VIERRCU
         L     R1,IER040
         MVC   PPIABMNO,3(R1)      MOVE MSG NO INTO ABEND NO
         LM    R0,R1,IER040        IER040A INSUFFICIENT WORK UNITS
         L     R15,VGAPRT
         BASR  R14,R15             CALL MSG WRITER
         LA    R15,4
         B     RCJRET              RETURN WITH ERROR SET
*
WORKD    DC    D'0'                USED FOR CONVERSION
*
VIERRCU  DC    V(IERRCU)           MESSAGE MODULE
VGAPRT   DC    V(IERGAPRT)         MESSAGE WRITER
*
SAVER12  DC    F'0'                SAVE AREA FOR R12
*
MINTRAK  DC    H'5'                MINIMUM NO OF TRACKS PERMITTED
K2       DC    H'2'
K5       DC    H'5'
K8       DC    H'8'
K9       DC    H'9'
K10      DC    H'10'
K20      DC    H'20'
K30      DC    H'30'
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
DIERRCU  DSECT
*
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRCU SOURCE
*
*----------------------------------------------------------------------
*
         COPY IERRCUI
*
         END
./ ADD NAME=IERRCK   0101-20211-20211-1200-01032-01032-00000-RELEASE 00
RCK      TITLE 'IERRCK - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRCK
*
*        MODULE FUNCTION/OPERATION -
*        1.  CALCULATE B AND G FOR THE BALN TECHNIQUE DISK SORT
*        2.  DETERMINE THE MAXIMUM MERGE ORDER (M)
*        3.  THE SIZES OF THE INPUT BLOCKING TO PHASE1
*        4.  THE OUTPUT BLOCKING OF PHASE1 INPUT
*        5.  OUTPUT BLOCKING OF PHASE2
*        6.  THE INPUT BLOCKING TO PHASE3
*        7.  THE OUTPUT BLOCKING OF PHASE3
*        8.  CALCULATE THE NUMBER OF INPUT AND OUTPUT BUFFERS OF PHASE1
*        9.  THE TOTAL NUMBER OF BUFFERS
*        10. NUMBER OF OUTPUT BUFFERS OF PHASES 2 AND 3
*
*        VARIABLE SPANNED RECORDS INPUT -
*        A WORKAREA EQUAL IN SIZE TO THE MAXIMUM RECORD LENGTH
*        IF REQUIRED AND THEREFORE ADDED TO THE SIZE OF RUNNING
*        PROGRAM DURING PHASE 1
*
*        VARIABLE SPANNED RECORD OUTPUT -
*        THE SIZE OF A WORKAREA IS INCLUDED IN THE SIZE OF RUNNING
*        PROGRAMS DURING PHASE 1 AND 3
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACROS USED - SMCPI
*
*        ENTRY POINT - ENTRY IERRCK - ENTRY FROM IERRCM
*                                     CALLING SEQUENCE -
*                                     L      R15,=V(IERRCK)
*                                     BALR   R14,R15
*
*        INPUT - CPI FIELDS REFERENCED -
*        CPILAB07  - L'EXTRACTED CONTROL FIELD
*        CPIEXTSZ  - SIZE OF EXTRACT ROUTINE
*        CPIRCDL1  - INPUT LRECL OR MAX LRECL IF VARIABLE BLOCKED
*        CPIRCDL2
*        CPIRCDL3
*        CPIRCDL5  - MEDIAN LENGTH FOR VARIABLE LENGTH RECORDS
*        CPITAVLC  - TOTAL AVAILABLE STORAGE
*        CPINWKU   - NO OF WORK UNITS
*        CPIPH1RSZ - SIZE OF PH1 USER MODS
*        CPIPH2RSZ - SIZE OF PH2 USER MODS
*        CPIPH3RSZ - SIZE OF PH3 USER MODS
*        CPIIPBLK  - INPUT BLOCKING
*        CPIOPBLK  - OUTPUT BLOCKING
*        CPIBINSZ  - BIN SIZE, CALCULATED BY IERRCN
*
*        CPICNTL - 1. FIXED OR VARIABLE
*                  2. EQUALS OR EXTRACT
*                  3. CHANNEL ENVIRONMENT
*                  4. WORD ALIGNMENT
*                  5. LE OR GT 256
*                  6. BALANCED TECHNIQUE
*                  7. MODS OR NOT
*                  8. SPANNED RECORDS OR NOT
*
*        OUTPUT - CPI FIELDS INITIALIZED OR ALTERED -
*                 CPISRTBL  - B
*                 CPISRTG   - G
*                 CPIPH1RSZ - SIZE OF PH1 USER MODS
*                 CPIPH2RSZ - SIZE OF PH2 USER MODS
*                 CPIPH3RSZ - SIZE OF PH3 USER MODS
*                 CPILAB03
*                 CPILAB07  - SIZES OF BUFFERS
*                 CPILAB09
*                 CPIBUF1   - NUMBER OF PHASE1 BUFFERS
*                 CPIBUF23  - NUMBER PHASE 2 AND 3 BUFFERS
*                 CPIMRGMX  - MAX MERGE ORDER
*                 CPIMRGAL  - ALTERNATE MERGE ORDER
*                 CPICNTL   - 1. BALANCED
*                             2. 8 OR 16 WAY MERGE NETWORK
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL - IERRCM WITH ZERO IN R15
*
*        EXITS - ERROR - IERRCM WITH FOUR IN R15
*
IERRCK   CSECT
*
         USING *,R15               ENTER VIA R15
*
         USING IERRC5,R13          CPI MODULE BASE REGISTER
*
         IERENTRY 'IERRCK &SYSDATE &SYSTIME'
*
         STM   R14,R12,12(R12)     USE SAVE AREA PROVIDED BY IERRCM
         DROP  R15                 FREE R15
         LR    R11,R15
         USING IERRCK,R11          BASE REGISTER = R11
         ST    R12,SAVER12         SAVE SAVEAREA ADDR
         CPISETON  CPIBALN         BALN TECHNIQUE
         LH    R1,CPILAB07         LCF = LENGTH OF EXTRACTED CF
         LA    R1,4(,R1)           4 MORE FOR EXTRACT TABLE
         STH   R1,SAVLCT           SAVE FOR FUTURE REFERENCE
         LA    R14,CALSTOR         SET RETURN ADDR FOR LATER RETURN
*
*        CALCULATE THE SIZE OF THE RUNNING PROGRAMS THAT WILL
*        RESIDE IN AVAILABLE STORAGE DURING THE DIFFERENT PHASES
*        OF THE SORT MERGE
*
         LM    R1,R3,VALUE123      LOAD THE FIXED VALUES FOR 3 PHASES
*
*        WORKAREA SPACE IS ADDED TO THE SIZE OF THE RUNNING
*        PROGRAMS IN PHASE 1 AND OR PHASE 3 IF THERE ARE VARIABLE
*        SPANNED RECORDS IN INPUT AND OR OUTPUT DATA SETS
*
         CPITEST  CPIMVSI          VARIABLE SPANNED INPUT ?
         BZ    NOVBSIN             NO, BRANCH
         AH    R1,CPIRCDL1         YES, ADD L'WORKAREA TO RUN PROG
NOVBSIN  CPITEST  CPIMVSO          VARIABLE SPANNED OUTPUT ?
         BZ    NOVBSOUT            NO, BRANCH
         AH    R3,CPIRCDL2         YES, ADD L'WORKAREA FOR VBS
*
*        TEST FOR USE OF CHECKPOINT ROUTINE
*
NOVBSOUT CPITEST  CPICHKPT         CHECKPOINT REQUESTED ?
         BZ    RCKNOCHK            NO, BRANCH
         AH    R1,KCHK             ADD SIZE OF CHECKPOINT ROUTINE
         AH    R2,KCHK             ADD SIZE OF CHECKPOINT ROUTINE
         AH    R3,KCHK             ADD SIZE OF CHECKPOINT ROUTINE
*
*        ADJUST STORAGE REQUIREMENT IF VARIABLE LENGTH RECORDS
*
RCKNOCHK CPITEST  CPIFIX           FIXED LENGTH RECORDS ?
         BO    EQUALTST            YES, BRANCH
         SH    R1,REC1V            ADJUST FOR SIZE OF VAR LEN RCD RTN
         AH    R2,REC2V            TO PHASE 1 TOTAL
         AH    R3,REC3V            TO PHASE 2 AND PHASE 3 TOTALS
*
*        TEST FOR USE OF EQUALS AND EXTRACT ROUTINE
*
EQUALTST CPITEST  CPIEQUAL         EQUALS ROUTINE ?
         BO    EQUALS              YES, BRANCH
         CPITEST  CPIEXTRT         EXTRACT ROUTINE ?
         BO    EXTRACT             YES, BRANCH
         B     MOVEROUT            CALC MOVE TABLE
*
*        INCREASE STORAGE FOR EQUALS ROUTINE
*
EQUALS   AH    R1,KEQUALS          ADD BYTES FOR EQUALS ROUTINE
         AH    R2,KEQUALS
         AH    R3,KEQUALS
         B     MOVEROUT            CALC MOVE TABLE
*
*        INCREASE STORAGE FOR EXTRACT ROUTINE
*
EXTRACT  AH    R1,CPIEXTSZ         ADD BYTES FOR EXTRACT ROUTINE
         AH    R2,CPIEXTSZ
         AH    R3,CPIEXTSZ
*
*        SAVE CURRENT CALCULATED VALUES
*
MOVEROUT ST    R1,KCONST           SAVE TO RESET CPITAVLC
         ST    R1,COREPH1          RUNNING PGM PH1
         ST    R2,COREPH2          RUNNING PGM PH2
         ST    R3,COREPH3          RUNNING PGM PH3
*
*        BEGIN PHASE 1 CALCULATION
*        ROUTINE IS CALLED WITH RTN ADDR IN R14
*
MOVE     LA    R10,4               SET R10 FOR PHASE 1
*                                  TO CALCULATE MOVE ROUTINE FOR 3 PH
         AH    R1,K112             ADD TO PH1, 40 FOR RSA TABLE AND
*                                  72 FOR GETMAIN AND GETSIZE TABLE
         AH    R2,K280             ADD TO PH2 AND PH3, 280 FOR GETMAIN
         AH    R3,K280             AND GETSIZE TABLES. ASSUME M=16
*
*        INCREASE PHASE 1 AND PHASE 3 STORAGE IF VBS RECORDS
*
         CPITEST  CPIMVSI          INCREASE SIZE OF GETMAIN TABLE PH 1
         BZ    NVBSIN              WITH ONE DOUBLEWORD IF VBS INPUT
         LA    R1,8(,R1)
NVBSIN   CPITEST  CPIMVSO          VBS IN PHASE 3 OUTPUT ?
         BZ    MOVERETN            NO, BRANCH
         LA    R3,8(,R3)
*
*        LOOP THROUGH PHASES
*        R10 IS SET TO INDICATE WHICH PHASE IS BEING PROCESSED
*        R10 =  4, PHASE 1
*        R10 =  4, PHASE 2
*        R10 = 12, PHASE 3
*
MOVERETN SR    R4,R4               FOR RETURN BY OTHER PHASES
         CPITEST  CPIVAR           VARIABLE LENGTH RECORDS ?
         BO    NOMOVE              YES, BRANCH
*
*        PROCESSING FIXED LENGTH RECORDS
*
         EX    0,MOVERTN1-4(R10)   USER MODIFICATION EXITS ?
         B     MOVERTN2            NO USER EXITS
*
*        SET CC TO TEST FOR EXIT ROUTINES ACTIVATED IN PHASES
*
MOVERTN1 CPITEST  CPIME15          PHASE 1 EXIT 15 ACTIVATED ?
         CPITEST  CPIME25          PHASE 2 EXIT 25 ACTIVATED ?
         CPITEST  CPIME35          PHASE 3 EXIT 35 ACTIVATED ?
*
MOVERTN2 BO    MOVTABLE            YES, EXIT EX5 IS ACTIVE IN PHASE
*                                  NO, NO EX5 EXIT ACTIVE IN PHASE
*
*        DETERMINE IF L'FIXED LENGTH RECORD <= 256
*
         CPITEST  CPILE256         RECORDS <= 256 ?
         BO    NOMOVE              YES, BRANCH
*
*        L'FIXED LENGTH RECORDS > 256
*
MOVTABLE EX    0,MOVERTN3-4(R10)   GET RECORD LENGTH FOR THIS PHASE
         B     MOVERTN4            RECORD LENGTH CONSTANT
*
MOVERTN3 LH    R4,CPIRCDL2         PHASE 1 RECORD LENGTH
         LH    R4,CPIRCDL2         PHASE 2
         LH    R4,CPIRCDL3         PHASE 3
*
*        CALULATE L'MOVE ROUTINE GENERATED IN IERABS
*        RECORD LENGTH FOR PHASE IN R4
*
MOVERTN4 LA    R4,255(,R4)         BYTES FOR ROUNDING OFF
         SRL   R4,8                DIVIDE BY 256
         LR    R5,R4               SAVE
         MH    R4,K6               MULTIPLY BY 6
         LA    R4,3(,R4)           3 BYTES FOR SPECIAL INSTRUCTION
         CH    R5,KH16             NUMBER VS 16 ?
         BNH   NOMOVE              LOW OR EQUAL, BRANCH
         SRL   R5,4                DIVIDE BY 16
         MH    R5,K12              MULTIPLY BY 12
         AR    R4,R5               TOTAL TABLE SIZE
NOMOVE   EX    0,ADDUP-4(R10)      ADD TO PHASE TOTALS
*                                  PHASE 3 WILL CAUSE LOOP TO EXIT
         LA    R10,4(,R10)         GET NEXT PHASE
         B     MOVERETN            CHECK PHASE 2
*
ADDUP    AR    R1,R4               PHASE 1
         NOPR  0                   ALIGNMENT
         AR    R2,R4               PHASE 2
         NOPR  0                   ALIGNMENT
         B     *+4                 CHECK PHASE 3
*
         AR    R3,R4               ADD PHASE 3 VALUE AND DROP OUT
*                                  OF LOOP
*
*        CALCULATE TABLE SIZES
*
*        DCB TABLE OF ADDRS = 4(WORK UNITS + 1)
*        ROUND TABLE SIZES TO FULL WORD BOUNDRIES
*        ADD 8 BYTES FOR CONTROL BLOCK OF BUILD MACRO
*
         LH    R4,CPINWKU          NUMBER OF WORK UNITS
         SLL   R4,2                * 4 FOR DCB TABLE OF ADDRS
         LA    R1,42(,R1)          28 - DCB TABLE, 8 - BUILD MACRO,6
         LA    R2,27(R2,R4)        12 FOR TABLES,15 FOR 5 TABLE ALIGN
         LA    R3,35(R3,R4)        12-TABLES,15-TABLES,8 FOR BUILD MAC
*
*        ADD STORAGE REQUIREMENTS FOR
*        DCB'S
*        IOB+ECB
*        IOB TABLE
*        CONTROL FIELD EXTTRACTION
*
         LA    R1,CPIQDCBL(,R1)    ADD L'DCBIN TO PH1 CORE
         LA    R1,CPIIOBL(,R1)     ADD 48 FOR IOB
         LA    R3,CPIQDCBL(,R3)    ADD SIZE DCBOUT TO PH3 CORE
         LA    R2,CPIIOBL(,R2)
         LH    R4,CPINWKU          REFRESH R4 WITH NO OF WORK UNITS
         MH    R4,=AL2(CPIEDCBL)   CALC DCB REQUIREMENTS
         AR    R1,R4               ADD DCB REQUIRMENT TO PHASE 1
         AR    R2,R4               ADD DCB REQUIRMENT TO PHASE 2
         AR    R3,R4               ADD DCB REQUIRMENT TO PHASE 3
         LH    R4,SAVLCT           LCF
         LA    R4,4(,R4)           LCF + 4
         AR    R2,R4
         AR    R3,R4
         LA    R1,23(,R1)          DOUBLE WORD ALIGNMENT OF CCW
         LA    R2,23(,R2)          PLUS
         LA    R3,23(,R3)          8 FOR EACH OUTPUT BUFF(QSAM/DISK ID)
         BR    R14                 RETURN TO CALLER
*
*        CALCULATE USER EXIT STORAGE REQUIREMENTS
*        FOR PHASE 1
*
CALSTOR  MVC   PH1AVAIL+1(3),CPIP1RSZ  PHASE 1 USER EXIT STORAGE REQ
         ICM   R4,B'1111',PH1AVAIL
         BZ    RCKMODS2            NO USER EXITS, BRANCH
         AH    R1,KMODS1           ADD EXIT MODS OVERHEAD
         A     R1,PH1AVAIL         ADD EXIT MODS STORAGE REQUIREMENTS
         AH    R4,KMODS1           ADD EXIT MODS OVERHEAD
         A     R4,KCONST           NEW TOTAL AVAIL CORE = AM1 VALUE
         ST    R4,KCONST           MINUS RUNNING PGMS
*                                  KCONST NOW HAS TOTAL RUN PGMS SIZE
         ST    R4,COREPH1          RUNNING PGM PHASE 1
*
*        CALCULATE USER EXIT STORAGE REQUIREMENTS
*        FOR PHASE 2
*
RCKMODS2 MVC   PH2AVAIL+1(3),CPIP2RSZ  PHASE 2 USER MODS SIZE
         ICM   R4,B'1111',PH2AVAIL  PHASE 2 MODS ?
         BZ    RCKMODS3            NO, BRANCH
         AH    R2,KMODS2           ADD EXIT MODS OVERHEAD
         A     R2,PH2AVAIL         ADD EXIT MODS STORAGE REQUIREMENTS
         AH    R4,KMODS2           ADD EXIT MODS OVERHEAD
         A     R4,COREPH2          TO PREVIOUS PH2 RP
         ST    R4,COREPH2          STORE PH2 RP
*
*        CALCULATE USER EXIT STORAGE REQUIREMENTS
*        FOR PHASE 2
*
RCKMODS3 MVC   PH3AVAIL+1(3),CPIP3RSZ  PHASE 3 USER MODS SIZE
         ICM   R4,B'1111',PH3AVAIL  PHASE 3 MODS ?
         BZ    RCKNEXT             NO, BRANCH
         AH    R3,KMODS3           ADD EXTRA SIZE FOR SORT PROGRAMS
         A     R3,PH3AVAIL
         AH    R4,KMODS3           ADD EXTRA RP SIZE TO MODS
         A     R4,COREPH3          AND PREVIOUS RPSIZE
         ST    R4,COREPH3          STORE PH 3 RP SIZE
*
*        CALCULATE AVAILABLE STORAGE FOR EACH OF THE 3 PHASES
*
RCKNEXT  SH    R2,K600             -600 FOR QSAM AS NOT NEEDED
         MVC   PH3AVAIL+1(3),CPITAVLC   GET TOTAL AVAILABLE STORAGE
         L     R4,PH3AVAIL
         SR    R4,R1               MINUS RUNNING PROGRAMS
         ST    R4,PH1AVAIL         SET PHASE 1 AVAILABLE CORE
         L     R4,PH3AVAIL         REFRESH TOTAL AVAIL STORAGE
         S     R4,KCONST           MINUS RUN PGMS
         ST    R4,KCONST           UPDATE KCONST TO AVAIL STORAGE
         L     R4,PH3AVAIL         REFRESH TOTAL AVAIL STORAGE
         SR    R4,R2               MINUS RUNNING PROGRAMS
         ST    R4,PH2AVAIL         PHASE 2 AVAILABLE STORAGE
         L     R4,PH3AVAIL         REFRESH TOTAL AVAIL STORAGE
         SR    R4,R3               MINUS RUNNING PROGRAMS
         ST    R4,PH3AVAIL         PHASE 3 AVAILABLE STORAGE
*
*        BALN TECHNIQUE CALCULATIONS
*
         LA    R10,CPIBLKTB        R10 -> TABLE OF CALC DASD BLKSIZES
         LA    R15,4               R15 = 4 FOR FIXED LENGTH RECORDS
         CPITEST  CPIFIX           FIXED LENGTH ?
         BO    DISKCALC            YES, BRANCH
         AR    R15,R15             R15 = 8 FOR VARIABLE LENGTH RECORDS
*
*        BEGIN DISK CALC LOOP
*
DISKCALC SR    R3,R3
DISKRCAL ICM   R3,B'0011',0(R10)   GET DASD BLOCKSIZE, END OF TABLE ?
         BZ    DISKERRA            YES, THE ENTIRE TABLE HAS BEEN
*                                  SCANNED WITH NO WORKABLE SOLUTION.
*                                  TERMINATE SORT
         SR    R3,R15              ALLOW FOR SORTWK BLOCK OVERHEAD
         SH    R3,KH8              ALLOW FOR BUFFER ALIGNMENT
         LH    R4,CPIRCDL2         R4 = MAX RECORD LENGTH
         CR    R3,R4               DASD BLOCK < MAX RECORD LENGTH ?
         BL    DISKERRA+4          ERROR. SHOULD NOT HAPPEN AS
*                                  VALUE CHECKED IN IERRCI
         SR    R2,R2
*
         B     *(R15)              FIXED OR VARIABLE ?
         DR    R2,R4           +04 FIXED LENGTH RECORDS
         NOPR  0                   DIVIDE DASD BLOCK BY MAX RECORD LEN
*
         B     *(R15)          +08 VARIABLE LENGTH RECORDS
         STH   R3,CPISRTBL     +04 FIXED, STORE BLOCKING FACTOR
         B     *(R15)          +08 VARIABLE
         MH    R3,CPIRCDL2     +04 FIXED, MULT RECORD SIZE BY BLOCKING
*                                  FACTOR
         AR    R3,R15          +08 FIXED AND VARIABLE
*                                  ADD 4 OR 8 TO DASD BLOCKSIZE
         LR    R12,R3              TAKE COPY OF CALC DASD BLKSIZE
         BAS   R14,ALIGNBUF        ALIGN BUFFERS TO CORRECT BOUNDRY
         LR    R3,R12
         B     *(R15)              FIXED OR VARIABLE
         B     DISK01          +04 FIXED
         STH   R3,CPISRTBL     +08 VARIABLE
DISK01   STH   R3,CPILAB07         STORE PHASE 2 BUFFER SIZE
*
*        DETERMINE MERGE ORDER
*
*        FIND MERGE ORDER ACCORDING TO -
*
*        F(M)  =  AMT - M(K) - X(Y)
*                 -----------------
*                     BUF + 4
*
*        F(M)  = 2M+2,  M+2,  M+1
*        AMT   = PH2 AVAILABLE CORE
*        M     = MERGE ORDER
*        K     = IOB + CCW + LCF + 4 + BLOCK/DEBLOCK TABLES =
*                52 + 48 + LCF + 8
*        X     = 1 OR  2  OUTPUT BUFFERS
*        Y     = BYTES FOR OUTBUFFER AREAS
*        BUF   =  INPUT BUFFER  SIZE  + 4  BYTES FOR BUFFER TABLE
*
*        OR THE FORMULA MAY BE REDUCED TO -
*
*              M  =   AMT - X(56 + B +4)
*                     ------------------
*                         (B + 4) + K
*
*        ON ENTRY:
*        R3 = CPILAB07, PHASE 2 BUFFER SIZE
*
         AH    R3,K36              4 FOR INPUT, 32 FOR OUTPUT CCW
         LH    R7,SAVLCT           GET LCF
         LA    R7,4(,R7)           LCF + 4
         AH    R7,KK100            52 FOR IOB + TABLE, 48 FOR INPUT CCW
         LA    R7,8(,R7)           FOR BLOCK DEBLOCK TABLES
         SR    R4,R4
         L     R5,PH2AVAIL         R5 = PHASE 2 AVAILABLE STORAGE
         SR    R5,R3               SUBTRACT FOR TWO PHASE 2 BUFFERS
         SR    R5,R3
         SH    R3,K32              TO GET INPUT BUFFER SIZE
         AR    R3,R7               ADD OVERHEAD
*
*        CALCULATE MERGE ORDER
*        MERGE ORDER RESULT IN R5
*
         DR    R4,R3               (PH2 CORE)/(BUFFER)= MERGE ORDER
         CH    R5,KH8              MERGE ORDER VS 8
         BH    SET16               BRANCH TO 16 WAY NETWORK
*
*        SET 8 WAY MERGE ORDER
*
SET8     CPISETOF CPI16WAY         CLEAR 16 WAY NETWORK BIT
         CPISETOF CPIPOLY-CPIOSC-CPI8WAY  CLEAR EXCEPT BALN
         CPISETON CPI8WAY          SET 8 WAY NETWORK
         B     MERGSTOR            STORE MERGE NUMBER
*
*        SET 16 WAY MERGE ORDER
*
SET16    CPISETOF CPIPOLY-CPIOSC-CPI8WAY  CLEAR ALL EXCEPT BALN
         CPISETON CPI16WAY         SET 16 WAY NETWORK
         CH    R5,KH16             M VS 16
         BNH   MERGSTOR            LESS OR EQUAL ? BRANCH
         LA    R5,16               RESTRICT MERGE ORDER TO MAX OF 16
*
*        COMMON MERGE ORDER PROCESSING
*
MERGSTOR STC   R5,CPIMRGMX         STORE MERGE ORDER
         STC   R5,CPIMRGAL
         LA    R5,1(,R5)           NO OF INPUT BUFFERS+1
         CH    R5,CPINWKU          COMPARE NO OF INPUT BUFFERS VS
*                                  WORK AREAS
         BL    DISKERRA+8          NOT ENOUGH BUFFERS FOR WORK AREAS
         LA    R5,1(,R5)           R5 EQUAL TO M+2
         CH    R5,KH4              4 AREAS ?
         BL    DISKERRA+12         NOT ENOUGH BUFFERS FOR WORK AREAS
         STC   R5,CPIBUF23
         MVI   CPILAB09,2
DISK3PH  LA    R9,2                OUTPUT BUFFERS PHASE 3
DISK3PHA STC   R9,CPILAB09+1       SAVE NUMBER OF OUTPUT BUFFERS
         LH    R5,CPILAB09+2       GET OUTPUT BUFFER SIZE
RETRYPH3 L     R3,PH3AVAIL         RESET PH3 AVAILABLE CORE
         CLI   CPIMRGMX,9          M VS 9
         BL    *+8                 LESS
         SH    R3,K676             BYTES FOR 16 WAY NETWORK
         LH    R4,CPILAB07         GET INPUT BLOCKSIZE TO PH3
         LA    R4,12(,R4)          4 - INPUT BUFF,  8 - DISK ADDRESS
         LH    R7,SAVLCT           LENGTH OF EXTRACTED CONTROL FIELDS
         AH    R7,K52              4 FOR LCF, 48 FOR CCW
         LA    R7,60(,R7)          52 FOR IOB + TABLE, 8 FOR BLCK DEBL
         MVC   MERGE+1(1),CPIMRGMX   MERGE ORDER
         MH    R7,MERGE
         SR    R3,R7               TOTAL AREA
         SR    R3,R5               FOR BUFFERS
         BM    REDMERG             IF NEG TRY TO CUT MERGE ORDER,
*                                  BUFFERS OR SORT BLOCKING
         SR    R2,R2
         DR    R2,R4               TOTAL/BS = MAXIMUM INPUT BUFFERS
         CH    R3,MERGE            NUMBER VS M
         BL    REDMERG             IF LOW TRY TO CUT MERGE ORDER,
*                                  BUFFERS OR SORT BLOCKING
         LA    R3,2(,R3)           BUFFER NUMBER BY NUMBER
         SR    R4,R4
         IC    R4,CPIMRGMX
         LA    R4,2(R4,R4)         SET Z=M+1
         CLR   R3,R4               BUFFERS VS Z
         BNH   *+6                 BRANCH LOW OR EQUAL
         LR    R3,R4               EXCHANGE
         STC   R3,CPIBUF23+1       SAVE TOTAL BUFFERS PHASE 3
         B     DISKG               FIND G
*
REDMERG  LH    R3,MERGE            PICK UP MERGE ORDER
         BCTR  R3,0                REDUCE BY ONE
         CH    R3,CPINWKU          < NUMBER OF WORK UNITS ?
         BL    DISKERRA+16         YES, ERR MSG INSUFFICIENT CORE
         STH   R3,MERGE            NO, RESET M TO LOWER VALUE
         STC   R3,CPIMRGMX         UPDATE MRGMX
         STC   R3,CPIMRGAL         UPDATE MRGAL
         B     RETRYPH3            FOR BUFFERS
*
*        CALCULATE A 'G' FOR SORT-MERGE
*
DISKG    STM   R0,R15,SAVREGG      SAVE REGISTERS
*
DISKG1   CLC   CPIIPBLK,CPISRTBL   INPUT OR SORT BLOCKING LARGER ?
         BNH   SET2IN              SORT BLOCKING LARGER, BRANCH
         LA    R10,2               INPUT BLOCKING, SET TWO OUTPUT BUFF
         LA    R9,1                AND ONE INPUT BUFFER
         B     DISKBIBS
*
SET2IN   LA    R10,1               SET ONE OUTPUT BUFFER AND
         LA    R9,2                TWO INPUT BUFFERS
         B     DISKBIBS
*
*
DISKAGO  LA    R10,2               INITIALIZE  I/O BUFFERS
         LA    R9,1
*
DISKBIBS SR    R5,R5               GET TOTAL BUFFERS
         AR    R5,R9
         AR    R5,R10
         STC   R5,CPIBUF1          SAVE TOTAL BUFFERS
         LH    R5,CPILAB03         GET INPUT BUFFER SIZE
         LH    R7,CPILAB07         SORT BLOCKING
         LH    R3,CPIBINSZ         BIN SIZE
*
*        SOLVE
*
*        G =   3(PH1 CORE - A(BS) - B(BI)) - X / (3L + X)
*
*        WHERE  A = NO OF OUTPUT BUFFERS
*               B = NO OF INPUT BUFFERS
*               X = 20 FOR FIXED, 36 FOR VARIABLE
*              BS = SORT BLOCKING
*              BI = INPUT BLOCKING
*               L = BINSIZE
*
         L     R8,PH1AVAIL         PHASE 1 AVAILABLE STORAGE
         SR    R4,R4
         SR    R6,R6
         LA    R5,20(,R5)          ADD 20 TO TOTAL NUMBER OF BUFFERS
         MR    R4,R9               INPUT BUFFERS
         MH    R5,K3               3 * INPUT BLOCKING
         MR    R6,R10              OUTPUT
         CH    R7,K600             OUTPUT VS 600
         BNL   DISKBI1             BRANCH HIGH OR EQUAL
         LH    R7,K600             EXCHANGE
DISKBI1  LA    R7,40(,R7)          32 FOR OUTPUT CCW, 16 FOR BUFF SIZ
         MH    R7,K3               3 * OUTPT BLOCKING
         MH    R8,K3               3 * AVAILABLE
         SR    R8,R7
         SR    R8,R5
         BM    DISKERR+20          BRANCH NEGATIVE
         EX    0,*+4(R15)
         B     *+12                B DT BY BF
         AH    R8,K20
         AH    R8,K36              THIS IS TOTAL SPACE FOR BINS
         ST    R8,DISKSPAC         SAVE SPACE
         LR    R2,R15              SAVE FIXED OR VARIABLE SWITCH
         B     *(R15)              B IF VAR
         B     DISKFIX             +04 FIXED LENGTH RECORDS
         LH    R5,CPIRCDL2         +08 VARIABLE LENGTH RECORDS
*
DISKBINS SR    R4,R4
         AH    R5,K3
         AH    R5,SAVLCT           ADD LENGTH OF EXTRACTED CTRL FIELD
         LH    R3,CPIBINSZ         RESTORE BINSIZE
         SH    R3,KH4              BINSIZE - 4
         DR    R4,R3               (L+3)/(BINSIZE - 4) +  1 = BINS/R4
         LA    R5,1(,R5)
         STH   R5,BINNO            SAVE NO OF BINS PER RECORD
         SR    R4,R4
         MH    R5,CPIBINSZ
         LR    R3,R5
DISKFIX  LR    R9,R8
         SR    R8,R8
         MH    R3,K3               3 * BINSIZE
         EX    0,ADBINBYT-4(R15)   ADD BYTES TO 3 * BINSIZE
         SR    R9,R3               G + 1 RECORDS IN RSA
         BM    DISKERR+24
         DR    R8,R3               G
         ST    R9,SAVGGG           SAVE G G G
         MVC   CPISRTG(3),SAVGGG+1
         C     R9,KF2              G VS 2 ?
         BNL   DISKFULL            BRANCH HIGH OR EQUAL
         B     DISKERR+28
*
ADBINBYT AH    R3,K20              ONE OF THESE EXECUTED
         AH    R3,K36              FIXED OR VARIABLE
*
DISKFULL B     *(R2)               DET BY BNS
         B     DISK1CHK            +04 TRY AGAIN
         LA    R2,4                +08 SET TO FIXED AND GET MODAL G
         LH    R5,CPIRCDL5         MODAL RECORD LENGTH
         L     R8,DISKSPAC         RESTORE BIN SPACE
         B     DISKBINS            TRY AGAIN
*
*        ALIGN BUFFERS TO SINGLE OR DOUBLE WORD BOUNDRIES
*
ALIGNBUF CPITEST  CPISWA           SINGLE WORD ALIGNMENT
         BO    DISKSING            YES, BRANCH
         LA    R12,7(,R12)         DOUBLE WORD ALIGNMENT
         N     R12,EIGHT
         BR    R14                 RETURN
*
DISKSING LA    R12,3(,R12)         SINGLE ALIGNMENT
         N     R12,FOUR
         BR    R14                 RETURN
*
DISK1CHK LH    R6,CPIRCDL5         MODAL RECORD LENGTH
         LH    R5,CPISRTBL          B
         B     *(R15)              B IF VAR
         B     *+10                B IF FIXED
         SH    R5,KH8              8 FOR CHAR CNT, END OF SEQUENCE
         DR    R4,R6               VARIABLE B BY MODAL
         CLR   R5,R9               B VS G
         BNH   DISKOUT             B EQUAL OR LESS THAN G
         B     DISKERR+32                 R THAN G
*
DISKOUT  MVC   MERGE+1(1),CPIMRGMX
         SR    R1,R1               CLEAR FOR ACCUMULATIONS
         SR    R2,R2
         SR    R3,R3
         BAS   R14,MOVE            COMMON MOV
         SR    R5,R5
         SR    R7,R7
         SR    R10,R10
         IC    R7,CPILAB09         GET NO OF OUTPUT BUFFERS PHASE2
         IC    R10,CPILAB09+1      GET NO OF OUTPUT BUFFERS PHASE3
         SR    R4,R4
         SR    R6,R6
         IC    R4,CPIBUF23         GET TOTAL BUFFERS FOR PHASE 2
         IC    R6,CPIBUF23+1       GET TOTAL BUFFERS FOR PHASE 3
         SR    R4,R7               INPUT BUFFERS         PHASE 2
         SR    R6,R10              INPUT BUFFERS         PHASE 3
         MVC   PH1AVAIL+1(3),CPISRTG
         L     R9,PH1AVAIL
         LR    R8,R9               SAVE G G G
         B     *(R15)              FIXED OR VARIABLE
         B     *+8                 +04 FIXED
         B     VARY                +08 VARIABLE
         LA    R8,1(,R8)
         LR    R9,R8
         SR    R8,R8
         LH    R5,K3
         DR    R8,R5               FIND TREE VALUE
         MH    R9,K20
         AR    R1,R9
         B     PHASE2              CAL PH2
*
VARY     BCTR  R8,0                CUT G BY 1
         MH    R8,K12
         AR    R1,R8
*
PHASE2   SR    R5,R5
         IC    R5,CPIBUF1          TOTAL BUFFERS PHASE 1
         IC    R5,PH1BUF-2(R5)     GET BYTE FOR PH1 BUFFERS
         AR    R1,R5               ADD TO PHASE 1 TOTALS
         SLL   R4,2                4 BYTES FOR INPUT BUFFERS PHASE2
         SLL   R6,2                4 BYTES FOR INPUT BUFFERS PHASE3
         MH    R7,K32              24 FOR CCW, 8 FOR OUT BUFF PHASE 2
         AR    R2,R4               PHASE 2
         AR    R2,R7
         AR    R3,R6               PHASE 3
         LH    R5,SAVLCT           GET LENGTH OF EXTRACTED CNTL FIELD
         LA    R5,4(,R5)           LCF + 4
         AH    R5,K48              INPUT CCW = 48 BYTES
         LA    R5,CPIIOBL+4(,R5)   FOR (IOB+ECB) +TABLE FOR DISK
         LA    R5,8(,R5)           8 FOR BLOCK DEBLOCK TABLES
         MH    R5,MERGE
         AR    R2,R5               PHASE 2
         LH    R5,SAVLCT           LCF
         LA    R5,52(,R5)          4 + LCF + 48 FOR CCW
         LA    R5,60(,R5)          52 FOR IOB + TABLE, 8 FOR BLK DEB
         MH    R5,MERGE
         AR    R3,R5               PHASE 3
         CLI   CPIMRGMX,16         MERGE ORDER 16 ?
         BL    CKAROUND            NO, BRANCH
         AH    R2,K12              YES, ADD 12 TO PH2 AND 3 FOR
         AH    R3,K12              SAFETY FACTOR
CKAROUND LR    R12,R1
         BAS   R14,ALIGNBUF        ROUND TOTAL PH1 GENERATED CORE TO
         LR    R1,R12              DOUBLE WORD
         LR    R12,R2
         BAS   R14,ALIGNBUF        ROUND TOTAL PH2 GENERATED CORE TO
         LR    R2,R12              DOUBLE WORD
         LR    R12,R3
         BAS   R14,ALIGNBUF        ROUND TOTAL PH3 GENERATED CORE TO
         LR    R3,R12              DOUBLE WORD
         SH    R1,K24              SUBT EXTRA BYTES NOT TO BE
*                                  INCLUDED IN GEN CORE -
*                                  8 FOR BUILD, 16 FOR QSAM ID
         ST    R1,PH1AVAIL
         ST    R2,PH2AVAIL
         ST    R3,PH3AVAIL
         MVC   CPIP1RSZ,PH1AVAIL+1
         MVC   CPIP2RSZ,PH2AVAIL+1
         MVC   CPIP3RSZ,PH3AVAIL+1
         LH    R2,CPILAB07         UPDATE
         LA    R2,8(,R2)             BUFFER
         STH   R2,CPILAB07             LENGTH
*
*        GENERATE OPTIONAL DIAGNOSTIC MESSAGES
*
         CPITEST  CPIDIAG+CPIDSIM  DIAGNOSTIC SWITCH ON ?
         BZ    NODIAG              NO, BRANCH TO BYPASS CALCULATIONS
         L     R1,COREPH1          RUNNING PROG SIZE PH1
         L     R2,COREPH2          RUNNING PROG SIZE PH2
         L     R3,COREPH3          RUNNING PROG SIZE PH 3
         A     R1,PH1AVAIL         GENERATED CORE PH1
         A     R2,PH2AVAIL         GENERATED CORE PH2
         A     R3,PH3AVAIL         GENERATED CORE PH3
         L     R4,SAVGGG           G
         LA    R4,1(,R4)           G+1
         MH    R4,BINNO            NUMBER OF BINS PER RECORD
         MH    R4,CPIBINSZ         SIZE OF EACH BIN
         AR    R1,R4
         SR    R5,R5               CLEAR R5
         IC    R5,CPILAB09         NUMBER OF OUTPUT BUFFERS
         SR    R4,R4               CLEAR R4
         IC    R4,CPIBUF1          TOTAL NUMBER OF BUFFERS PH1
         SR    R6,R6               CLEAR R6
         IC    R6,CPIBUF23         TOTAL NUMBER OF BUFFERS PH2
         SR    R4,R5               SUBTRACT NUMBER OF PH1 OUTPUT
*                                  BUFFER FROM TOTAL PH1 BUFFERS
         SR    R6,R5               SUBTRACT NUMBER OF PH2 OUTPUT
*                                  BUFFERS FROM TOTAL PH2 BUFFERS
         MH    R5,CPILAB07         SIZE OF PH1 OUTPUT BUFFERS
         AR    R1,R5
         AR    R2,R5
         MH    R4,CPILAB03         SIZE OF PH1 INPUT BUFFERS
         AR    R1,R4
         MH    R6,CPILAB07         SIZE OF PH2 INPUT BUFFER
         AR    R2,R6
         SR    R7,R7               CLEAR R7
         SR    R8,R8               CLEAR R8
         IC    R7,CPIBUF23+1       TOTAL NUMBER OF PH3 BUFFERS
         IC    R8,CPILAB09+1       NUMBER OF OUTPUT BUFFER PH3
         SR    R7,R8               SUBTRACT NUMBER OF PH3 OUTPUT
*                                  BUFFERS FROM TOTAL PH3 BUFFERS
         LR    R9,R7
         SLL   R9,2                FOUR BYTES FOR EACH PH3 INPUT
         AR    R3,R9
         MH    R7,CPILAB07         MULTIPLY BY PH3 INPUTSIZE
         MH    R8,CPILAB09+2       MULTIPLY BY PH3 OUTPUT SIZE
         AR    R3,R7
         AR    R3,R8
         ST    R1,COREPH1          CORESIZE PH1
         ST    R2,COREPH2          CORESIZE PH2
         ST    R3,COREPH3          CORESIZE PH3
*
*        GENERATE MESSAGES
*
NODIAG   L     R3,VIERRCU          R3 -> IERRCU MSG TEXT MODULE
         USING DIERRCU,R3
*
*        GENERATE IER036I BLOCKING = NNNNN
*
         LH    R1,CPISRTBL         GET BLOCKING FACTOR
         CVD   R1,KCONVERT
         MVC   IER036A,EPATTERN    MOVE IN EDIT PATTERN
         ED    IER036A,KCONVERT+5
         LM    R0,R1,IER036        IER036I BLOCKING
         L     R15,VGAPRT          MESSAGE WRITER ADDR
         BASR  R14,R15             CALL MSG WRITER
*
*        GENERATE IER037I RECORDS IN RSA = NNNNN
*
         SR    R1,R1
         ICM   R1,B'0111',CPISRTG
         CVD   R1,KCONVERT
         MVC   IER037A,EPATTERN    MOVE IN EDIT PATTERN
         ED    IER037A,KCONVERT+5
         LM    R0,R1,IER037        IER037I RECORDS IN RSA
         L     R15,VGAPRT          MESSAGE WRITER ADDR
         BASR  R14,R15             CALL MSG WRITER
*
*        GENERATE OPTIONAL DIAGNOSTIC MESSAGES
*
         CPITEST  CPIDIAG+CPIDSIM  DIAGNOSTICS ?
         BZ    RCKRET              NO, BRANCH
*
*        GENERATE IER961I SORT TECHNIQUE - XXXX
*
         MVC   IER961A,KBALN       SET TECHNIQUE
         LM    R0,R1,IER961        IER961I SORT TECHNIQUE -
         L     R15,VGAPRT          MESSAGE WRITER ADDR
         BASR  R14,R15             CALL MSG WRITER
*
*        GENERATE IER962I PHASE 1 NUMBER OF BUFFERS, BUFFER SIZE
*
         MVI   IER962A,C'1'        SET FOR PHASE 1
         SR    R1,R1
         IC    R1,CPIBUF1          NUMBER OF BUFFERS
         CVD   R1,KCONVERT
         MVC   IER962B,EPATTERN
         ED    IER962B,KCONVERT+6
         LH    R1,CPILAB07         BUFFER SIZE
         CVD   R1,KCONVERT
         MVC   IER962C,EPATTERN
         ED    IER962C,KCONVERT+5
         LM    R0,R1,IER962        IER962I PHASE 1 NUMBER OF BUFFERS
         L     R15,VGAPRT          MESSAGE WRITER ADDR
         BASR  R14,R15             CALL MSG WRITER
*
*        GENERATE IER962I PHASE 2 NUMBER OF BUFFERS, BUFFER SIZE
*
         MVI   IER962A,C'2'        SET FOR PHASE 2
         SR    R1,R1
         IC    R1,CPIBUF23         NUMBER OF BUFFERS
         CVD   R1,KCONVERT
         MVC   IER962B,EPATTERN
         ED    IER962B,KCONVERT+6
         LH    R1,CPILAB07         BUFFER SIZE
         CVD   R1,KCONVERT
         MVC   IER962C,EPATTERN
         ED    IER962C,KCONVERT+5
         LM    R0,R1,IER962        IER962I PHASE 2 NUMBER OF BUFFERS
         L     R15,VGAPRT          MESSAGE WRITER ADDR
         BASR  R14,R15             CALL MSG WRITER
*
*        GENERATE IER962I PHASE 3 NUMBER OF BUFFERS, BUFFER SIZE
*
         MVI   IER962A,C'3'        SET FOR PHASE 3
         SR    R1,R1
         IC    R1,CPIBUF23+1       NUMBER OF BUFFERS
         CVD   R1,KCONVERT
         MVC   IER962B,EPATTERN
         ED    IER962B,KCONVERT+6
         LH    R1,CPILAB07         BUFFER SIZE
         CVD   R1,KCONVERT
         MVC   IER962C,EPATTERN
         ED    IER962C,KCONVERT+5
         LM    R0,R1,IER962        IER962I PHASE 3 NUMBER OF BUFFERS
         L     R15,VGAPRT          MESSAGE WRITER ADDR
         BASR  R14,R15             CALL MSG WRITER
*
*        GENERATE IER963 STORAGE = NNNNNNN
*
         SR    R1,R1
         ICM   R1,B'0111',CPITAVLC  GET TOTAL ASSIGNED STORAGE
         CVD   R1,KCONVERT
         MVC   IER963A,EPATTERN
         ED    IER963A,KCONVERT+4
         LM    R0,R1,IER963        IER963I STORAGE =
         L     R15,VGAPRT          MESSAGE WRITER ADDR
         BASR  R14,R15             CALL MSG WRITER
*
*        GENERATE IER964 PHASE 1 STORAGE = NNNNNNNN
*
         MVI   IER964A,C'1'        SET FOR PHASE 1
         L     R1,COREPH1          GET ASSIGNED STORAGE
         CVD   R1,KCONVERT
         MVC   IER964B,EPATTERN
         ED    IER964B,KCONVERT+4
         LM    R0,R1,IER964        PHASE 1 STORAGE = NNNNNNNN
         L     R15,VGAPRT          MESSAGE WRITER ADDR
         BASR  R14,R15             CALL MSG WRITER
*
*        GENERATE IER964 PHASE 2 STORAGE = NNNNNNNN
*
         MVI   IER964A,C'2'        SET FOR PHASE 2
         L     R1,COREPH2          GET ASSIGNED STORAGE
         CVD   R1,KCONVERT
         MVC   IER964B,EPATTERN
         ED    IER964B,KCONVERT+4
         LM    R0,R1,IER964        PHASE 2 STORAGE = NNNNNNNN
         L     R15,VGAPRT          MESSAGE WRITER ADDR
         BASR  R14,R15             CALL MSG WRITER
*
*        GENERATE IER964 PHASE 3 STORAGE = NNNNNNNN
*
         MVI   IER964A,C'3'        SET FOR PHASE 3
         L     R1,COREPH3          GET ASSIGNED STORAGE
         CVD   R1,KCONVERT
         MVC   IER964B,EPATTERN
         ED    IER964B,KCONVERT+4
         LM    R0,R1,IER964        PHASE 3 STORAGE = NNNNNNNN
         L     R15,VGAPRT          MESSAGE WRITER ADDR
         BASR  R14,R15             CALL MSG WRITER
*
*        GENERATE IER965 MERGE ORDER = NNNNN
*
         SR    R1,R1
         IC    R1,CPIMRGMX         GET MERGE ORDER
         CVD   R1,KCONVERT
         MVC   IER965A,EPATTERN
         ED    IER965A,KCONVERT+6
         LM    R0,R1,IER965        IER965 MERGE ORDER = NNNNN
         L     R15,VGAPRT          MESSAGE WRITER ADDR
         BASR  R14,R15             CALL MSG WRITER
*
         DROP  R3
*
RCKRET   MVC   CPITAVLC(3),KCONST+1  RESET TOTAL AVAIL CORE
*
*        RETURN ROUTINE
*
         SR    R15,R15             SAFE RETURN CODE
RCKRETE  L     R12,SAVER12         RESTORE R12
         L     R14,12(,R12)
         LM    R0,R11,20(R12)      RESTORE REGS
         BR    R14                 RETURN WITH RC IN R15
*
DISKERR  B     RESETBLK            FIRST TIME THROUGH RESET
*                                  BLOCKSIZE AND TRY TO CUT M
*                                  THEN NOP TO DROP THRO
*                                  TO INSUFFICIENT STORAGE MSG
DISKERRA NOP   0                   +00
         NOP   0                   +04
         NOP   0                   +08
         NOP   0                   +12
         NOP   0                   +16
         NOP   0                   +20
         NOP   0                   +24
         NOP   0                   +28
         NOP   0                   +32
         NOP   0                   +36
         L     R15,VIERRCU         ADDR MESSAGE MODULE
         USING DIERRCU,R15
         L     R1,IER039
         MVC   CPIABMNO,3(R1)      MOVE MSG NO INTO ABEND CODE
         LM    R0,R1,IER039        IER039A - INSUFFICIENT STORAGE
         L     R15,VGAPRT
         BASR  R14,R15             CALL MSG MODULE
         LA    R15,4               ERROR CODE
         B     RCKRETE             RETURN
*
RESETBLK NI    DISKERR+1,X'0F'     SET BRANCH SO DONT COME AGAIN
         NI    REDMERG+1,X'0F'     NOP BRANCH TO CUT M
         BCTR  R10,0               REDUCE BLOCK INDEX BY 2 TO
         BCT   R10,DISKCALC        RESET & RETURN TO RETRY
*
*        CONSTANTS AND WORK AREAS
*
KCONVERT DC    D'0'                WORK SPACE
EPATTERN DC    XL8'4020202020202020'  LEFT ZERO SUPPRESS PATTERN
*
EIGHT    DC    X'FFFFFFF8'         NEG 8
FOUR     DC    X'FFFFFFFC'         NEG 4
*
         LTORG
*
*        THE VALUE OF CORE FOR FIXED LENGTH RECORDS AND DISK
*        SORT IS ADJUSTED IF VAR LENGTH RECORDS OR AND DISK SORT
*        FIX LENGTH RECORDS RTN
*
VALUE123 DC    F'11090'       *    PHASE 1= 7600+1210+2100+180
         DC    F'11440'       |    PHASE 2= 6685+275+3230+1035+215
         DC    F'9945'        V    PHASE 3= 7780+170+960+1035
*
*        STORAGE ADJUSTMENTS FOR VARIABLE LENGTH RECORDS
*
REC1V    DC    H'185'              PHASE 1 VARIABLE RCDS  (DECREASE)
REC2V    DC    H'100'              PHASE 2 VARIABLE RCDS  (INCREASE)
REC3V    DC    H'75'               PHASE 3 VARIABLE RCDS  (INCREASE)
*
*        USER EXIT ROUTINES OVERHEAD
*
KMODS1   DC    H'510'              ACTIVE USER EXITS, PHASE 1
KMODS2   DC    H'240'              ACTIVE USER EXITS, PHASE 2
KMODS3   DC    H'385'              ACTIVE USER EXITS, PHASE 3
*
KCHK     DC    H'200'              SIZE OF CHECKPOINT MODULE
*
PH3AVAIL DC    F'0'                AVAIL STORAGE
PH2AVAIL DC    F'0'                AVAIL STORAGE
PH1AVAIL DC    F'0'                AVAIL STORAGE
COREPH1  DC    F'0'                CORE USED PH1
COREPH2  DC    F'0'                CORE USED PH2
COREPH3  DC    F'0'                CORE USED PH3
*
SAVREGG  DC    16F'0'              REG SAVE AREA FOR G CALCULATIONS
SAVER12  DC    F'0'                -> SAVEAREA IN IERRCM
KF2      DC    F'2'
SAVGGG   DC    F'0'                SAVE GGG
BINNO    DC    H'1'                BINS PER REC, INIT FOR FIXED
SAVLCT   DC    H'0'                SAVLCT FROM CPILAB07 BEFORE IT IS
*                                  REPURPOSED
KH0 DC         H'0'
DISKSPAC DC    F'0'
KK100    DC    H'100'              52 FOR IOB+TABLE, 48 FOR INPUT CCW
K3       DC    H'3'
KH4      DC    H'4'
K6       DC    H'6'
KH8      DC    H'8'
K10      DC    H'10'
K12      DC    H'12'
KH16     DC    H'16'
K20      DC    H'20'
K24      DC    H'24'
K32      DC    H'32'
K36      DC    H'36'
K48      DC    H'48'               48 BYTES FOR CCW FOR DISK
K52      DC    H'52'               48 = IOB, 4 FOR IOB TABLE
K112     DC    H'112'              PH1 RSA, GETMAIN,GETSIZE TABLES
K280     DC    H'280'              PH2,3 GETMAIN AND GETSIZE TABLES
K600     DC    H'600'              PHASE 1 OUTPUT BUF SIZE +PH2 QSAM
K676     DC    H'676'              EXTRA BYTES FOR 16 WAY MERGE
K1500    DC    H'1500'             PHASE 3 OUTPUT BUFFER SIZE
KEQUALS  DC    H'86'
KBALN    DC    C'BALN'             BALANCED TECHNIQUE USED
KCONST   DC    F'0'                AM1 CORE VALUE - RUN PGM SIZE
MERGE    DC    H'0'                MERGE
PH1BUF   DC    X'1C'     *         24 FOR CCW, 4 FOR INPUT TABLE
         DC    X'34'     |         48 FOR CCW, 4 FOR INPUT TABLE
         DC    X'38'     |         48 FOR CCW, 8 FOR INPUT TABLE
         DC    X'4C'     |  48 FOR CCW,4 FOR IN BUF,16 OUT BUF, 8 QSAM
         DC    X'58'     V  48 FOR CCW,8 FOR IN BUF,16 OUT BUF,16 QSAM
PHASE1   DC    X'04'               PHASE DISP
         DC    X'08'               PHASE DISP
         DC    X'0C'               PHASE DISP
*
VIERRCU  DC    V(IERRCU)           MESSAGE MODULE
VGAPRT   DC    V(IERGAPRT)         MESSAGE WRITER
*
*        MESSAGE DSECT
*
DIERRCU  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRCU SOURCE
*
*----------------------------------------------------------------------
*
         COPY IERRCUI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMCPI
*
         END
./ ADD NAME=IERRCL   0101-20211-20211-1200-00342-00342-00000-RELEASE 00
RCL      TITLE 'IERRCL - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRCL
*
*        MODULE FUNCTION/OPERATION -
*        MERGE ONLY B AND G CALCULATIONS - MERGE ONLY
*        THE FUNCTION OF THIS MODULE IS TO CALCULATE THE SIZE OF
*        RUNNING PROGRAM AREAS, TO CALCULATE THE SIZE OF
*        GENERATED CORE AND PASS THIS ON IN A WORKAREA FOR EACH
*        MERGE ORDER FILE IF VARIABLE SPANNED RECORDS INPUT, A
*        WORKAREA FOR THE OUTPUT IF SPANNED RECORDS IN OUTPUT
*        FILE, INPUT AND 2 OUTPUT BUFFERS CAN BE FITTED IN
*        AVAILABLE CORE. IF THIS FAILS THE PROGRAM TRYS FOR MERGE
*        ORDER INPUT, WORKAREAS IF SPANNED RECORDS, AND A SINGLE
*        OUTPUT BUFFERS. IF THIS FAILS TOO, AN ERROR MESSAGE IS
*        ISSUED. AFTER EITHER OF THE ABOVE SUCESSFUL CONDITIONS,
*        ANY REMAINING CORE IS DIVIDED INTO AS MANY EXTRA INPUT
*        BUFFERS AS POSSIBLE
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACROS USED - SMCPI
*
*        ENTRY POINTS - ENTRY FROM IERRCM
*                       CALLING SEQUENCE -
*                       LA   R12,A(SYSTEM SAVE AREA)
*                       L    R15,VIERRCL
*                       BALR R14,R15
*
*        INPUT - CPI FIELDS REFERENCED -
*        CPIEXTSZ   CPILAB07   CPINWKU   CPIP3RSZ
*        CPIRCDL3   CPITAVLC   CPIIPBLK  CPIRCDL1
*        CPICNTL    CPIOPBLK
*
*        OUTPUT - CPI FIELDS INITIALIZED OR ALTERED -
*        CPIBUF23   CPILAB09   CPICNTL
*        CPILAB07   CPIMRGMX   CPIP3RSZ
*
*        EXTERNAL ROUTINES - EXTRN IERAGPRT - MSG PRINT ROUTINE
*
*        EXTERNAL PARAMETERS - IERAGPRT - MESSAGE PRINT ROUTINE
*
*        EXITS - NORMAL - IERRCZ - SORT SYSTEM CONTROL
*
*        EXITS - ERROR -
*        IERAGPRT - MESSAGE PRINT AND THEN LOAD ERROR
*        CODE 4 AND EXIT TO IERRCZ
*
*        TABLES/WORK AREAS -
*        ALL AVAILABLE CORE AS INDICATED IN CPI IS A WORKING
*        TABLE IN WHICH VARIOUS BUFFERS, DCBS, EXTRACT ROUTINES,
*        RUNNING PROGRAMS ETC WILL BE FITTED
*
*        NOTES -
*        IERRCL DOES NOT SET CPI3RSZ WITH RUNNING PROGRAM SIZE
*        AS IT DID PREVIOUSLY, BUT CALCULATES AND STORES THE SIZE
*        OF GENERATED CORE INSTEAD
*
IERRCL   CSECT
*
         USING *,R11
*
         IERENTRY 'IERRCL &SYSDATE &SYSTIME'
*
         STM   R14,R12,12(R12)
         LR    R11,R15
         USING IERRC5,R13
         USING DIERRCU,R15
         MVC   CPIMRGMX(1),CPINWKU+1  NUMBER OF INPUT UNITS IS MERGE M
         MVC   RCLEXTCF(2),CPILAB07   SAVE LENGTH OF EXTRACTED CNTL FLD
*
*        BASIC RUNNING PROGRAM CALCULATION
*        INCLUDES RUNNING PROG AND ASSIGNMENT PROGRAM
*        AND BASIC AMOUNTS FOR FIXED LENGTH, SINGLE CONTROL
*        FIELDS, AN 8 WAY MERGE AND ROOM FOR PPI
*
         L     R1,KBASIC           SIZE OF R15, AP, PPI, FIX LENGTH
*                                  SINGLE CTL FLDS AND 8 WAY MERGE
         CPITEST  CPICHKPT         CHECKPOINT REQUESTED ?
         BZ    RCLNOCHK            NO, BRANCH
         A     R1,KCHK             ADD SIZE OF CHECKPOINT ROUTINE
*
*        16 OR 8 WAY NETWORK
*
RCLNOCHK CLI    CPIMRGMX,9
         BL    RCL1TO8             IF M < 9 SET UP FOR 8 WAY NETWORK
         CPISETOF CPI8WAY          SET 16 WAY MERGE
         CPISETON CPI16WAY
         AH    R1,K16XTRA          ADD EXTRA FOR 16 WAY MERGE
         B     RCLMGSET            GOTO CF
*
RCL1TO8  CPISETOF CPI16WAY         SET 8 WAY MERGE
         CPISETON CPI8WAY
*
*        SINGLE OR MULTIPLE CONTROL FIELDS
*
RCLMGSET CPITEST  CPISCF           SKIP OVER ADDITION IF SINGLE CTL FLD
         BZ    *+8                 SNGLE CF
         AH    R1,KSINXTRA         ADD EXTRA FOR SINGLE CONTROL FIELD
*
*        FIXED OR VARIABLE LENGTH RECORD ROUTINES
*
         CPITEST  CPIFIX           SKIP OVER ADDITION IF FIXED LEN REC
         BO    *+8                 FIXED
         AH    R1,KVARXTRA         ADD EXTRA FOR VARIABLE LENGTH RECORD
*
*        USER MODS
*
         MVC   BCOUNT+1(3),CPIP3RSZ  SAVE USER MODS
         A     R1,BCOUNT           BYTES FOR USER MODS
         CLC   BCOUNT,K0           USER MODS ?
         BZ    RCLSTORZ            NO MODS
         AH    R1,KMODS            ADD SIZE OF MOD ROUTINES
RCLSTORZ ST    R1,BCOUNT           SAVE RUNNING PROGRAM SIZE
*
*        CHECK FOR THE GENERATION OF A MOVE TABLE FOR FIXED
*        LENGTH RECORDS AND THEN CALCULATES THE SIZE OF THE
*        GENERATED MOVE TABLE. THIS TABLE IS SET UP IN AVAILABLE
*        STORAGE,AND THEREFORE ITS SIZE MUST BE SUBTRACTED FROM
*        THE TOTAL CORE AVAILABLE
*
         SR    R7,R7              CLEAR R7 FOR TABLE SIZE
         CPITEST  CPIVAR          VARIABLE LENGTH RECORDS ?
         BO    RCLNOMOV           YES, NO SUBTRACTION OF TABLE SIZE
         CPITEST  CPIME35         E35 ACTIVE ?
         BO    RCLMOVER           YES, GO CALCULATE MOVE SIZE
         CPITEST  CPILE256        RECORDS <= 256 ?
         BO    RCLNOMOV           YES, NO SUBTRACTION OF TABLE SIZE
RCLMOVER LH    R7,CPIRCDL3        RECORD LENGTH
         LA    R7,255(,R7)        ADD 255 BYTES FOR ROUNDING OFF
         SRL   R7,8               DIVIDE BY 256
         LR    R9,R7              SAVE QUOTIENT IN R9
         MH    R7,K6              MULTIPLY BY 6
         LA    R7,3(,R7)          ADD 2 BYTES FOR SPECIAL BCR INSTRUCT
         C     R9,K16             QUOTIENT VS 16
         BNH   RCLNOMOV           SIZE OF MOVE ROUTINE IN R7
         SRL   R9,4               DIVIDE BY 16
         MH    R9,K12             MULTIPLY BY 12
         AR    R7,R9              STORE TABLE SIZE IN R7
*
*        BEGIN CALCULATION OF NUMBER OF BUFFER
*
RCLNOMOV MVC   PPIMRGMX+1(1),CPIMRGMX
         LH    R3,PPIMRGMX
         SR    R5,R5
         ICM   R5,B'0111',CPITAVLC  GET TOTAL AVAILABLE CORE
         S     R5,BCOUNT           SUBTRACT RUNNING SIZE FROM AVAIL
         CPITEST  CPIEQUAL         EQUAL ROUTINE REQUIRED ?
         BZ    RCLVBS              NO EQUALS RTN, BRANCH
         SH    R5,KEQUALS          ADD IN SIZE OF EQUALS ROUTINE
RCLVBS   CPITEST  CPIEXTRT         EXTRACT ROUTINE ?
         BZ    RCLBACK             NO EXTRACT RTN, BRANCH
         SH    R5,CPIEXTSZ         ADD IN SIZE OF EXTRACT ROUTINE
RCLBACK  SR    R5,R7               MINUS SIZE OF MOVE ROUTINE
*
*        CALCULATE DCB, BLOCK COUNT, DEBLOCK TABLES
*
         LH    R6,PPIMRGMX         LOAD MERGE INTO GEN CORE REG
         LA    R6,1(,R6)           INCREMENT TO M+1 UNITS
*
*        THE FOLLOWING MULTIPLICATION IS
*        (1+1+1)*4*(M+1)
*        WHERE
*        DCB = 1 FOR EACH UNIT, IB = 1 FOR EACH, BLK CNT = 1 FOR
*        EACH * 4 BYTES
*
         MH    R6,K12              (M+1)*(DCB+BLK+IB)*4 BYTES
         LA    R6,7(,R6)
         SRL   R6,3                ALIGN TO NEXT HIGHER DOUBLE WORD
         SLL   R6,3
         SR    R5,R6               REDUCE AVAILABLE CORE BY THIS AMOUNT
         AR    R6,R7               INCREASE GEN CORE REG BY MOVELIST SZ
*
*        ROUTINE TO CALCULATE REMAINDER OF GENERATED CORE FOR
*        CPI AND FITNESS
*
         SR    R8,R8               DETERMINE SIZE OF GETMAIN TABLE =
         IC    R8,CPIMRGMX         ((2*M+3)*4)*2
         CPITEST  CPIMVSI          VBS INPUT ?
         BZ    RCLNVBS1            NO, BRANCH
         MH    R8,CPIRCDL1         M*MAXIMUM RECORD LENGTH
         SR    R5,R8               DECREASE AVAILABLE CORE BY THIS AMT
         SR    R8,R8
         IC    R8,CPIMRGMX         RESERVE EXTRA PLACE IN GETMAIN TABLE
         MH    R8,K3               M*3 (VBS WORK,I* IPT BUFS)
         B     RCLNVBS2            SPECIFICATIONS
*
RCLNVBS1 SLL   R8,1
RCLNVBS2 CPITEST  CPIMVSO          VBS OUTPUT ?
         BZ    RCLNVBS3            NO, BRANCH
         SH    R5,CPIRCDL2         DECREASE AVAIL CORE WITH LENGTH
*                                  OF WORKAREA FOR SPANNED OUTPUT RCD
         LA    R8,1(,R8)           RESERVE PLACE IN GETMAIN TABLE
RCLNVBS3 LA    R8,3(,R8)
         SLL   R8,3
         LA    R8,7(,R8)           ROUND TO DOUBLE WORD
         AR    R6,R8               INCREASE GENERATED CORE
         SR    R5,R8               DECREASE AVAILABLE CORE
         LH    R7,RCLEXTCF
         LA    R7,7(,R7)           DEVELOPE SIZE OF EXTRACTED CONTROL
         SRL   R7,3                FIELDS TO NEXT LARGER DOUBLE WORD
         SLL   R7,3
         LA    R7,CPIQDCBL+4(,R7)  INCREASE BY 4 BYTES + DCB TAB ADDR
         LA    R2,1(,R3)
         STH   R2,HOLDMP1          (R(EXTRACT)+4+DCB)*(M+1) R=ROUNDED
         MH    R7,HOLDMP1
         SR    R5,R7               DECREASE AVAILABLE CORE BY THIS AMT
         AR    R6,R7               INCREASE GENERATED CORE BY THIS AMT
         LA    R6,7(,R6)
         SRL   R6,3                ROUND TO DOUBLE WORD
         SLL   R6,3
         STCM  R6,B'0111',CPIP3RSZ  STORE GENERATED CORE SIZE IN CPI
*
*        PERFORM AN ATTEMPT FOR M+2 BUFFERS
*        IF IT FAILS TRY FOR M INPUT AND 1 OUTPUT BUFFERS
*        IF THIS FAILS, PRINT AN ERROR AND RETURNS WITH AN ERROR
*        CODE. IF THE ATTEMPT FOR THE BUFFERS SUCCEEDS, FILL ANY
*        REMAINING AVAILABLE CORE WITH INPUT BUFFERS TO INCREASE
*        OVERLAP
*
         LA    R1,CPIQDCBL+8       OUTPUT DCB SIZE PLUS EIGHT FOR IOB
         LR    R10,R1
         LR    R9,R1
         LA    R1,CPIQDCBL+8       INPUT DCB SIZE PLUS EIGHT FOR IOB
         LH    R4,CPILAB03         LOAD INPUT BUFFER SIZE
         MVC   CPILAB07,CPILAB03   STORE IT IN CPILAB07
         LA    R4,4(,R4)           4 FOR BUFFER POOL
         AR    R1,R4               ADD INPUT BLOCKING
         LR    R8,R1               LOAD (DCB + IOB + IB) INTO R8
         MH    R1,PPIMRGMX         FORM  M(DCB'S)
         LH    R4,CPILAB09+2       LOAD OUTPUT BUFFER SIZE
RCLAGO   LR    R6,R4
         AR    R10,R4              ADD OUTPUT FOR VARIABLE REC TO R9
         AR    R9,R4                                           TO R10
         AR    R9,R9               FORM 2 OUTPUT BLOCK LENGTHS
         LA    R9,8(,R9)           8 FOR CONTROL BLK FOR BUILD MACRO
*
*        R5  - THE AMOUNT OF CORE LEFT AFTER REMOVING GENERATED CORE
*              PLACE FOR WORKAREAS IF SPANNED RECORDS IN AND/OR
*              OUTPUT, PROGRAMS AND PPI
*        R1  - AMOUNT OF CORE NEEDED FOR M INPUT BUFFERS
*        R6  - SIZE OF A BUFFER FOR OUTPUT
*        R9  - SIZE FOR 2 OUTPUT BUFFERS
*        R10 - SIZE OF 1 OUTPUT BUFFER
*
         SR    R5,R9               MINUS O/B FROM AVAILABLE CORE
         SR    R5,R1               MINUS M(DCB +IOB +IB) FROM AVAIL
         BM    RCLMINUS            IF M+2 BUFFERS WON'T FIT, TRY M+1
         LA    R3,2(,R3)           ADD 2 TO COUNT BUFFERS IN R3
         MVI   CPILAB09+1,2        2 OUTPUT BUFFERS
         LA    R15,0
         B     RCLMAXIM            BRANCH TO CHECK FOR MAXIMUM
*
RCLMINUS AR    R5,R10              INCREASE AVAIL CORE BY 1 OUTPUT BLK
         BM    RCLERROR            MINUS ?  CORE EXCEEDED FOR MINIM
         MVI   CPILAB09+1,1        1 OUTPUT BUFFER
         LA    R3,1(,R3)           ADD 1 TO BUFFER COUNT
         LA    R15,0
*
*        CHECK FOR MAX NUMBER OF BUFFERS
*
RCLMAXIM SR    R5,R8               SUBTRACT INPUT BLOCK FROM AVAIL CORE
         BM    RCLOUTOF            MINUS ? MAX IS REACHED
         LA    R3,1(,R3)           ADD 1 MORE BUFFER TO COUNT
         B     RCLMAXIM            RETRY
*
RCLERROR L     R15,VIERRCU         ADDRESSING MESSAGE MODULE
         LM    R0,R1,IER039        IER039A INSUFFICIENT STORAGE
         L     R15,VGAPRT
         BASR  R14,R15             CALL MESSAGE WRITER ROUTINE
         LR    R1,R0
         MVC   CPIABMNO,3(R1)      MOVE MSG NO INTO ABEND CODE
         MVI   RCLCODE+3,4         SET RETURN CODE
         B     RCLHOME             EXIT
*
RCLOUTOF LH    R4,PPIMRGMX         M
         AR    R4,R4               2M
         LA    R4,2(,R4)
         CLR   R4,R3               2M+2  VS  TOTAL BUFFERS
         BH    RCLSTORE            SET NUMBER OF BUFFERS
         SR    R3,R4               EXTRA INPUT BUFFERS
         LR    R9,R8
         SR    R8,R8               INPUT BUFFER SIZE
         MR    R8,R3               EXTRA BYTES
         AR    R5,R9               TOTAL EXTRAS
         LR    R3,R4               EXCHANGE
RCLSTORE STC   R3,CPIBUF23+1       TOTAL PHASE 3 BUFFERS
*
*        RETURN TO CALLER
*
RCLHOME  L     R15,RCLCODE         SET RETURN CODE
         L     R14,12(,R12)        RESTORE CALLERS REGS
         LM    R0,R11,20(R12)
         BR    R14                 EXIT
*
         DROP  R15
*
*        CONSTANTS
*
VGAPRT   DC    V(IERGAPRT)         MSG PRINT ROUTINE
VIERRCU  DC    V(IERRCU)           MESSAGE MODULE
*
RCLCODE  DC    F'0'                RETURN CODE
CONV     DC    F'0'                COMPUTED AVAIL CORE
K0       DC    F'0'
K16      DC    F'16'
KCHK     DC    F'500'              SIZE OF CHECKPOINT ROUTINE
K3       DC    H'3'                CONST 3
PPIMRGMX DC    H'0'                MAX MERGE ORD
K6       DC    H'6'
K12      DC    H'12'
KEQUALS  DC    H'086'
RCLEXTCF DC    H'0'
KBASIC   DC    F'8325'             FIXED VALUE FOR MERGE
K16XTRA  DC    H'640'              EXTRA OF 16-WAY OVER 8-WAY MERGE
KVARXTRA DC    H'75'               EXTRA OF VARIABLE OVER FIXED RECORDS
KSINXTRA DC    H'50'               EXTRA OF MULTIPLE OVER SINGLE CF
KMODS    DC    H'385'              EXTRAS FOR SORT MODS ROUTINES
HOLDMP1  DC    H'0'                M+1
BCOUNT   DC    F'0'                BYTE COUNT
*
DIERRCU  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRCU SOURCE
*
*----------------------------------------------------------------------
*
         COPY IERRCUI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
*        CPI
*
         SMCPI
*
         END
./ ADD NAME=IERRCM   0101-20211-20211-1200-01690-01690-00000-RELEASE 00
RCM      TITLE 'IERRCM - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRCM
*
*        MODULE FUNCTION/OPERATION -
*        PERFORM THE INITIALIZATION FUNCTIONS FOR THE
*        SORT DEFINITION PHASE -
*        1. INITIALIZE THE CPI
*        2. PROCESSES THE PARAMETERS IN THE EXEC STMT PARM FIELD
*           OR ATTACH/LINK/XCTL LIST
*        3. OPEN SYSOUT AND SORTDIAG IF REQUESTED
*        IF AN ERROR IS FOUND IN ONE OF THE PARAMETER LISTS THE
*        INVALID PARAMETERS ARE IGNORED AND ERROR MESSAGE IER067I
*        IS ISSUED TO IDENTIFY THE ERROR
*
*        CHANGE LOG -
*        DCB RECFM, BLKSIZE AND LRECL CHANGED TO FBA,0,121    REL 1.1
*        FOR SYSOUT AND SORTDIAG DCBS FOR COMPATIBILITY
*
*        IMPLEMENT MESSAGE BUFFERING TO ALLOW FOR A MSGDDN    REL 1.1
*        PARAMETER ON AN OPTION CONTROL STATEMENT TO BE
*        PROCESSED BEFORE ANY MESSAGES ARE WRITTEN TO THE
*        MESSAGE DATA SET
*
*        CHANGE THE MESSAGE WRITING ROUTINE IERGAPRT TO USE   REL 1.1
*        RECFM=FB TO WRITE MESSAGES TO THE MESSAGE DATA SET
*
*        REPLACE USE OF SNAP TO PRINT CONTROL BLOCKS FOR      REL 1.1
*        DIAGNOSTIC PURPOSES WITH IERFMT MODULE
*
*        AFTER THE INITIALIZATION PHASE THE FUNCTION OF THIS MODULE
*        IS TO CONTROL THE EXECUTION OF THE SORT DEFINITION PHASE
*        THE ORDER OF EXECUTION IS -
*        1.  IERRCC - READ CONTROL STATEMENTS
*        2.  IERRCY - ANALYZE DEBUG CONTROL STATEMENTS
*        3.  IERRCE - ANALYZE SORT/MERGE CONTROL STATEMENTS
*        4.  IERRCG - ANALYZE RECORD CONTROL STATEMENTS
*        5.  IERRCX - ANALYZE OPTIONS CONTROL STATEMENTS
*        6.  IERRCH - ANALYZE MODS CONTROL STATEMENTS
*        7.  IERRCI - COLLECT SYSTEM INFORMATION,
*                     DYNAMIC ALLOCATION OF SORKWK DATA SETS
*        8.  IERRC2 - CALC OPTIONAL EXTRACT RTN
*        9.  IERRCN - BIN SIZE CALCULATIONS, SET SORT TECHNIQUE FLAGS
*        10. IERRCS - B & G FOR TAPE (IF NEEDED)
*        11. IERRCK - B & G FOR DISK (IF NEEDED FOR BALN TECHNIQUE)
*        12. IERBGB - B & G FOR DISK (IF NEEDED FOR CRCX TECHNIQUE)
*        13. IERRCL - B & G FOR MERGE ONLY (IF NEEDED)
*        14. IERRCP - SORT DEFINITION (IF USER MODS REQUIRE LINK EDIT)
*
*        IERRCD IS CALLED BY THE CONTROL STATEMENT ANALYSIS MODULES
*        TO PARSE THE CONTROL STATEMENTS PRIOR TO PROCESSING
*
*        MESSAGE WRITER SERVICES ARE PROVIDED FOR IERRCM AND ALL
*        THE CALLED MODULES BY THE SERVICE ROUTINE IERGAPRT WHICH
*        MAY BE ENTERED DIRECTLY BY THE CALLED MODULES
*
*        MACROS -
*        SMCPI   WTO     DCB    FREEMAIN
*        CLOSE   WRITE   CHECK
*
*        ENTRY POINTS - ENTRY IERRCM
*                             ENTRY FROM - IERRCO
*                             CALLING SEQUENCE -
*                             LINK  EP=IERRCM
*
*                     - ENTRY IERGAPRT
*                             ENTRY FROM - SORT DEFINITION MODULES
*                             CALLING SEQUENCE -
*                                      L     R15,VGAPRT
*                                      BALR  R14,R15
*                             VGAPRT   DC    V(IERGAPRT)
*
*        INPUT - CPI FIELDS REFERENCED
*        CPILINK   CPIP3ASZ   CPICNTL
*
*        OUTPUT - CPI FIELDS INITIALIZED OR ALTERED -
*        CPIATP1E   CPIATP3E   CPIDDSRT
*        CPINUMCF   CPICNTL
*
*        EXTERNAL ROUTINES -
*        IERRCC   IERRCH   IERRCN   IERRCL   IERRCE
*        IERRCI   IERRCS   IERRCP   IERRCG   IERRC2
*        IERRCK   IERBGB   IER8CM   IERRCX   IERRCY
*
*        EXTERNAL MODULES -
*        IERAM1 - INSTALLATION OPTIONS
*
*        EXTERNAL PARAMETERS - PARM OR ATTACH PARAMETER LIST
*
*        EXITS - NORMAL -
*        IERRCO - RCO WITH 0 ERROR CODE
*
*        EXITS - ERROR -
*        IERRCO - RCO WITH ERROR CODE =4
*
*        TABLES/WORK AREAS -
*        WORKC    - DIGITS FROM CORE/AM1/MAIN VALUE ON EXEC CARD
*        WORKD    - PACKED CORE/AM1/MAIN VALUE ON EXEC CARD
*        WTRANS   - TO TEST DD NAME FIELD LETTERS FROM ATTACH LIST
*                   FOR VALIDITY
*        WERRSW   - EXEC OR ATTACH PARAMETERS ERROR SWITCH
*        WMSGSW   - MESSAGE OPTION SPECIFIED SWITCH
*        WAM1SW   - CORE/AM1/MAIN VALUE SPECIFIED SWITCH
*        WDDSW    - DDNAME PREFIX CHARS SPECIFIED SWITCH
*        DDCHECK  - TRANSLATE TABLE USED TO CHECK USER DDNAME
*                   PREFIX CHARS FOR VALIDITY
*
IERRCM   CSECT
*
         USING *,R9,R10
         USING IERRC5,R13          R13 -> CPI
*
         SAVE  (14,12),,'IERRCM &SYSDATE &SYSTIME'
*
*        DO NOT CHAIN SAVE AREAS AS THE SUBSEQUENT CODE DOES
*        NOT SUPPORT CHAINING BACK TO LOCATE THE CALLERS
*        PARAMETER LIST PASSED IN R1
*
         LR    R9,R15              SET BASE REGISTERS
         LA    R10,2048(,R9)
         LA    R10,2048(,R10)
         ST    R14,SAVER14         SAVE RETURN ADDR
         ST    R8,AIERRCO          SAVE RCO BASE
*
*        INITIALIZE THE WTO JOBNAME, STEPNAME HEADER
*
         EXTRACT TIOTADDR,'S',FIELDS=(TIOT)  GET ADDR OF TIOT
*
         L     R15,TIOTADDR
         USING TIOT1,R15
         MVC   CPIWTOH(8),TIOCNJOB  GET JOBAME
         MVC   CPIWTOH+9(8),TIOCSTEP  MOVE JOB STEP NAME INTO CPIWTOH
         CLI   TIOCSTEP+8,C' '     ACTUAL JOB STEP NAME ?
         BNH   CM00A               NO, BRANCH
         MVC   CPIWTOH+9(8),TIOCSTEP+8  MOVE JOB STEP NAME INTO CPIWTOH
CM00A    MVI   CPIWTOH+8,C','      COMMA SEPARATOR
         MVI   CPIWTOH+17,C' '     BLANK OUT SPACER
         DROP  R15
*
*        LOAD INSTALLATIONS OPTIONS MODULE IERAM1
*
         LOAD  EP=IERAM1,ERRET=BADAM1
*
         B     CM00B               CONTINUE PROCESSING
*
*        OPTIONS MODULE FAILED TO LOAD
*
BADAM1   MVC   IER069+8(L'CPIWTOH),CPIWTOH  MOVE JOBNAME, STEPNAME
         MVC   WTORCM+4(L'IER069),IER069  IER069A MODULE IERAM1 FAILED
*
         WTO   MF=(E,WTORCM)       ISSUE ERROR MSG
*
*        ERROR MSG IER069 IS A SPECIAL CASE.
*        THE OPTIONS MODULE IERAM1 HAS FAILED TO LOAD. THEREFORE
*        THE CPI HAS NOT BEEN INITIALIZED WITH THE INSTALLTION
*        OPTIONS. AS THIS SITUATION SHOULD ONLY HAPPEN IF THE
*        SORT/MERGE INSTALLATION PROCESS HAS NOT BEEN SUCCESSFULLY
*        COMPLETED THE SORT WILL ABEND WITH USER ABEND CODE 69
*
         LA    R1,69               ERROR MESSAGE IER069, ABEND CODE 069
         LNR   R1,R1               SIGNAL ABEND CODE
         ST    R1,RETCODE
         B     CMRETX              BYPASS INITIALIZATION CODE, END SORT
*
CM00B    LR    R12,R0              R12 -> IERAM1 INSTALLATION OPTIONS
*
*        INITIALIZE CPI FROM DEFAULT VALUES IN IERAM1
*        FIELDS ARE MOVED ACROSS INDIVIDUALLY TO SHOW PROVENENCE
*
         USING DIERAM1,R12         S/M INITIALIZATION OPTIONS DSECT
*
         MVC   CPIVER,AM1VER       VERSION IDENTIFICATION
         MVC   CPICNTL+8(4),AM1FLAGS  INSTALLATION OPTION FLAGS
*                                     SEE IERAM1 AND SMCPI
         MVC   CPIABC,AM1ABC       ABEND CODE OR ERROR RETURN CODE
         MVC   CPIDYND,AM1DYND     DEVICE TYPE FOR DYNAMIC ALLOCATION
         MVC   CPIDYNN,AM1DYNN     NUMBER OF DYN ALLOC WORK DATA SETS
         MVC   CPIDYNS,AM1DYNS     MEGABYTES OF DASD TO ALLOCATE
         MVC   CPIDYNP,AM1DYNP     % DYNAMIC DASD ALLOC OVERHEAD FACTOR
         MVC   CPIMDDN,AM1MDDN     DDNAME FOR MESSAGE DATA SET
         MVC   CPIPDDN,AM1PDDN     DDAME FOR PARAMETER DDN
         MVC   CPISTOR,AM1STOR     STORAGE SIZE
         MVC   CPIMAXL,AM1MAXL     MAXIMUM STORAGE LIMIT FOR SORT/MERGE
         MVC   CPIMINL,AM1MINL     MINIMUM STORAGE LIMIT FOR SORT/MERGE
         MVC   CPIMAXR,AM1RMAX     RESVD STORAGE - SIZE = MAX
         MVC   CPIMAXRI,AM1RMAXI   RESVD STORAGE - SIZE = MAX, INVOKED
         MVC   CPIDDSRT,AM1SDDN    DDNAME PREFIX
         MVC   CPISVC,AM1SVC       0 = NO SVC, 109, OR 200 - 255
         MVC   CPISVCE,AM1SVCE     SVC ESR NUMBER IF AM1SVC = 109
         MVC   CPIWTOC,AM1WTOR     WTO ROUTING AND DESCRIPTOR CODES
*                                  UPDATE WTO ROUTE AND DESCR CODES
         LA    R1,WTORCM           R1 -> WTO ROUTINE IN IERRCM
         AH    R1,WTORCM           R1 -> WTO ROUTE AND DESCR CODES
         MVC   0(4,R1),CPIWTOC     MOVE INSTALL OPTIONS INTO WTO FIELDS
*
*        DELETE THE OPTIONS MODULE AS THE DATA HAS
*        BEEN MOVED TO POPULATE THE RELEVANT CPI FIELDS
*
         DELETE EP=IERAM1
*
         DROP  R12
*
*        SCAN THE TIOT FOR A SORTDIAG ENTRY
*
*        IF PRESENT THEN TURN ON CPIDIAG FLAG
*        THIS IS THE ONLY WAY TO TURN ON DIAGNOSTICS
*        THE DIAG PARM OPTION IS IGNORED IN THIS VERSION
*
         CPISETOF  CPIDIAG         FIRSTLY SET NO DIAGNOSTIC MESSAGES
         L     R1,TIOTADDR         R1 -> TIOT
         USING TIOT1,R1
         LA    R5,SORTDIAG         R5 -> SORTDIAG DCB
         USING IHADCB,R5
         SR    R15,R15
CM00D    CLC   TIOEDDNM,DCBDDNAM   TIOT ENTRY FOR SORTDIAG ?
         BE    CM00D1              YES, BRANCH
         IC    R15,TIOELNGH        L'CURRENT TIOT ENTRY
         AR    R1,R15              INCR TO NEXT TIOT ENTRY
         CLI   TIOELNGH,0          L'NEXT TIOT ENTRY = 0 ?
         BNE   CM00D               NO, PROCESS NEXT TIOT ENTRY
         B     CMSETUP             SORTDIAG NOT FOUND
*
CM00D1   ST    R5,CPIDDCB          STORE SORTDIAG ADDR IN CPI FOR LATER
         CPISETON  CPIDIAG         TURN ON DIAGNOSTIC MESSAGES
         DROP  R1,R5
*
*        SETUP FOR MSG GENERATION AND STORAGE
*
CMSETUP  L     R0,MSGLEN           R0 = L'MESSAGE ARE
*
         GETMAIN R,LV=(0)          GETMAIN MESSAGE AREA
*
         ST    R1,MSGADDR          SAVE ADDR OF GETMAINED AREA
         ST    R1,MSGNEXT          SET ADDR OF NEXT TO USE AREA
         A     R1,MSGLEN           CALC END ADDR OF MESSAGE AREA
         BCTR  R1,0
         ST    R1,MSGEND
         L     R12,VIERRCU
         USING DIERRCU,R12
*
*        DETERMINE IF SORT ATTACHED OR JCL INVOKED EXEC
*        FIRST BYTE AFTER LENGTH BYTES WILL BE ZERO IF ATTACHED
*
         L     R1,4(,R13)          R1 -> CALLER'S SAVE AREA
         L     R1,24(,R1)          R1 -> CALLER'S PARM LIST
         L     R1,0(,R1)           R1 -> BYTE COUNT
         ICM   R0,B'0011',0(R1)    BYTE COUNT ZERO ?
         BZ    CM370               YES, NO PARMS PROVIDED
         CLI   2(R1),X'00'         SORT BEEN ATTACH/LINK/XCTL?
         BE    CM250               YES, BRANCH TO PROCESS ATTACH LIST
*                                  NO, MUST BE JCL INVOKED EXEC
*
*        PROCESS THE PARAMETERS PASSED FROM THE JCL EXEC CARD
*
CM000    LA    R2,2(,R1)           R2 -> START OF PARAMETER LIST
         LR    R3,R2               R3 -> START OF PARAMETER LIST
         AH    R2,0(,R1)           R2 -> END OF PARAMETER LIST PLUS ONE
*
*        CHECK FOR DIAG KEYWORD AND DISCARD
*        NOTE -
*        THE CPIDIAG FLAG MAY ONLY BE TURNED ON BY THE PRESENCE
*        OF A SORTDIAG TIOT ENTRY
*
CM010    CLC   KDIAG,0(R3)         PARM = 'DIAG' ?
         BNE   CM040               NO, BRANCH
*                                  YES, DISCARD THE DIAG PARM
*
CM020    CPITEST  CPIATT           ATTACH ?
         BO    CM320               YES, BRANCH TO PROCESS ATTACH PARM
         LA    R3,5(,R3)           UP POINTER FOR PARM SEARCH
*
CM030    CR    R3,R2               MORE PARAMETERS ?
         BL    CM010               YES, BRANCH
         B     CM370               ELSE RETURN TO MAIN LINE
*
*        CHECK FOR TECHNIQUE
*
*        ONLY ONE TECHNIQUE MAY BE SPECIFIED
*        TEST FOR DUPLICATE SPECS
*
CM040    CLC   KPOLY,0(R3)         PARM = 'POLY' ?
         BNE   CM050               NO, BRANCH
*                                  POLY SPECIFIED
         CPITEST  CPIBALN+CPIPOLY+CPIOSC  TECH ALREADY BEEN CHOSEN ?
         BNZ   CMDERR              YES, ERROR
         CPITEST  CPICRCX          CRCX TECH ALREADY ON ?
         BO    CMDERR              YES, BRANCH
         CPISETON CPIPOLY          TURN ON POLYPHASE SWITCH
         B     CM020               BRANCH TO CHECK FOR MORE PARAMS
*
CM050    CLC   KBALN,0(R3)         PARM = 'BALN' ?
         BNE   CM060               NO, BRANCH
*                                  BALN SPECIFIED
         CPITEST  CPIBALN+CPIPOLY+CPIOSC  TECH ALREADY BEEN CHOSEN ?
         BNZ   CMDERR              YES, ERROR
         CPITEST  CPICRCX          CRCX TECH ALREADY ON ?
         BO    CMDERR              YES, ERROR
         CPISETON CPIBALN          TURN ON BALANCED SWITCH
         B     CM020               BRANCH TO CHECK FOR MORE PARAMS
*
CM060    CLC   KOSCL,0(R3)         PARM = 'OSCL' ?
         BNE   CM070               NO, BRANCH
*                                  OSCL SPECIFIED
         CPITEST  CPIBALN+CPIPOLY+CPIOSC  TECH ALREADY BEEN CHOSEN ?
         BNZ   CMDERR              YES, ERROR
         CPITEST  CPICRCX          CRCX ?
         BO    CMDERR              YES, ERROR
         CPISETON CPIOSC           TURN ON OSCILLATING SWITCH
         B     CM020               BRANCH TO CHECK FOR MORE PARAMS
*
CM070    CLC   KCRCX,0(R3)         PARM = 'CRCX' ?
         BNE   CM103               NO, BRANCH
*                                  CRCX SPECIFIED
         CPITEST  CPIBALN+CPIPOLY+CPIOSC  TECH ALREADY BEEN CHOSEN ?
         BNZ   CMDERR              YES, ERROR
         CPITEST  CPICRCX          CRCX TECH ALREADY ON ?
         BO    CMDERR              YES, ERROR
         CPISETON CPICRCX          TURN ON CRCX TECHNIQUE SWITCH
         B     CM020               BRANCH TO CHECK FOR MORE PARAMS
*
*        DUPLICATE TECHNIQUE SPECIFIED
*
CMDERR   CPISETOF CPIBALN-CPIPOLY-CPIOSC  CLEAR TECHNIQUE SWITCHES
         CPISETOF CPICRCX          TURN OFF CRCX TECH SWITCH
         MVI   WERRSW,WERRSWD      TURN ON ERROR SWITCH
         B     CM020
*
CM103    CPITEST  CPIATT           ATTACH ?
         BO    CM360               YES, BRANCH TO PROCESS ATTACH PARM
*
*        CHECK FOR MESSAGE OPTION
*
         CLC   KMSG,0(R3)          PARM = 'MSG=' ?
         BNE   CM200               NO, BRANCH
         LA    R3,2(,R3)           UP POINTER
*
CM105    TM    WMSGSW,X'FF'        USER ALREADY SPECIFIED MSG OPT ?
         BZ    CM110               NO, BRANCH
         MVI   WERRSW,WERRSWM      YES, TURN ON ERROR SWITCH
*
CM110    OI    WMSGSW,X'FF'        TURN ON MSG OPT SPECIFIED SWITCH
*                                  TURN OFF ALL DEFAULT FLAGS
         CPISETOF  CPICALL-CPICCRT-CPIPALL-CPIPCRT
         CLC   KNO,2(R3)           PARM = 'NO' ?
         BE    CM020               YES, BRANCH TO CHECK FOR MORE PARAMS
*
CM120    CLC   KAP,2(R3)           PARM = 'AP' ?
         BNE   CM130               NO, BRANCH
         CPISETON CPIPALL          ALL MESSAGES TO THE PRINTER
         B     CM020               BRANCH TO CHECK FOR MORE PARAMS
*
CM130    CLC   KAC,2(R3)           PARM = 'AC' ?
         BNE   CM140               NO, BRANCH
         CPISETON CPICALL          ALL MESSAGES TO THE CONSOLE
         B     CM020               BRANCH TO CHECK FOR MORE PARAMS
*
CM140    CLC   KCC,2(R3)           PARM = 'CC' ?
         BNE   CM150               NO, BRANCH
         CPISETON CPICCRT          CRITICAL MESSAGES TO THE CONSOLE
         B     CM020               BRANCH TO CHECK FOR MORE PARAMS
*
CM150    CLC   KCP,2(R3)           PARM = 'CP' ?
         BNE   CM151               NO, BRANCH
         CPISETON CPIPCRT          CRITICAL MESSAGES TO THE PRINTER
         B     CM020               BRANCH TO CHECK FOR MORE PARAMS
*
CM151    CLC   KCB,2(R3)           PARM = 'CB' ?
         BNE   CM152               NO, BRANCH
         CPISETON CPIPCRT+CPIPCRT  CRITICAL MESSAGES TO BOTH
         B     CM020               BRANCH TO CHECK FOR MORE PARAMS
*
CM152    CLC   KAB,2(R3)           PARM = 'AB' ?
         BNE   CM155               NO, BRANCH
         CPISETON CPICALL+CPIPALL  ALL MESSAGES TO BOTH
         B     CM020               BRANCH TO CHECK FOR MORE PARAMS
*
*        ERROR IN THE MESSAGE OPTION PARAMETERS
*        SCAN TO FIND NEXT COMMA OR BLANK
*
CM155    MVI   WERRSW,WERRSWN      TURN ON ERROR SWITCH
         CPITEST  CPIATT           ATTACH ?
         BO    CM320               YES, BRANCH TO PROCESS ATTACH LIST
*
CM170    CLI   0(R3),C','          COMMA ?
         BNE   CM190               NO, BRANCH
         LA    R3,1(,R3)           YES, INCR POINTER
         B     CM030               BRANCH TO CHECK FOR MORE PARAMETERS
*
CM190    LA    R3,1(,R3)           INCR POINTER
         CR    R3,R2               MORE PARAMETERS ?
         BL    CM170               YES, BRANCH
         B     CM370               NO, RETURN TO MAIN LINE
*
*        CHECK FOR AM1, CORE OR MAIN STORAGE VALUE
*
CM200    CLC   KCOREQU,0(R3)       PARM = 'CORE=' ?
         BNE   CM211               NO, BRANCH
         LA    R3,L'KCOREQU(,R3)   UP POINTER
         B     CM220               PROCESS FOLLOWING VALUE
*
CM211    CLC   KAM1EQU,0(R3)       PARM = 'AM1=' ?
         BNE   CM212               NO, BRANCH
         LA    R3,L'KAM1EQU(,R3)   UP POINTER
         B     CM220               PROCESS FOLLOWING VALUE
*
CM212    CLC   KMAINEQU,0(R3)      PARM = 'MAIN=' ?
         BNE   CM212A              NO, BRANCH
         LA    R3,L'KMAINEQU(,R3)  UP POINTER
         B     CM220
*
CM212A   CLC   KMAINSIZ,0(R3)      PARM = 'MAINSIZE=' ?
         BNE   CM213               NO, BRANCH
         LA    R3,L'KMAINSIZ(,R3)  UP POINTER
         B     CM220
*
CM213    MVI   WERRSW,WERRSWI      INVALID PARM KEYWORD
         B     CM170
*
CM220    TM    WAM1SW,WAM1SWP      MAIN SIZE ALREADY BEEN SPECIFIED ?
         BZ    CM225               NO, BRANCH
         MVI   WERRSW,WERRSWT      TURN ON ERROR SWITCH
*
CM225    OI    WAM1SW,WAM1SWP      SET MAIN SIZE SPECIFIED SWITCH
*
*        CHECK FOR MAX KEYWORD
*
         CLC   KMAX,0(R3)          AM1/MAIN/CORE = 'MAX' ?
         BNE   CM226               NO, BRANCH
         LA    R3,L'KMAX(,R3)      YES, INCR POINTER
         CPISETON  CPIMAXS         SET MAXIMUM LIMIT VALUE FLAG
         SR    R6,R6
         B     CM242
*
*        CONVERT NUMBER FROM DECIMAL TO BINARY
*
CM226    SR    R6,R6               CLEAR R6
         SR    R7,R7               CLEAR R7
CM230    CLI   0(R3),C'K'          K SPECIFICATION ?
         BNE   CM231               NO, BRANCH
         OI    WAM1SW,WAM1SWK      YES, SET K SWITCH ON
         B     CM233
*
CM231    CLI   0(R3),C'M'          M SPECIFICATION ?
         BNE   CM232               NO, BRANCH
         OI    WAM1SW,WAM1SWM      YES, SET M SWITCH ON
         B     CM233
*
CM232    CLI   0(R3),C'0'          DIGIT VALID ?
         BL    CM234               NO, BRANCH TO ERROR
         CLI   0(R3),C'9'          DIGIT VALID ?
         BH    CM234               NO, BRANCH TO ERROR
         SLDL  R6,8                MAKE ROOM FOR DIGIT IN DOUBLE REGS
         IC    R7,0(,R3)           PUT DIGIT INTO DOUBLE REGISTERS
CM233    LA    R3,1(,R3)           INCR TO NEXT DIGIT
         CR    R3,R2               END OF PARM FIELD ?
         BE    CM240               YES, GOTO CONVERT NUMBER
         CLI   0(R3),C','          COMMA ?
         BE    CM240               YES, GOTO CONVERT NUMBER
         TM    WAM1SW,WAM1SWK+WAM1SWM  M OR K SWITCHES ON ?
         BZ    CM230               NO, GET ANOTHER DIGIT
CM234    MVI   WERRSW,WERRSWV      TURN ON ERROR SWITCH, BAD VALUE
         B     CM170
*
CM240    STM   R6,R7,WORKC         STORE VALUE INTO WORK AREA
         PACK  WORKD,WORKC         CONVERT ZONED TO PACKED DECIMAL
         CVB   R6,WORKD            CONVERT PACKED NUMBER TO BINARY
         LTR   R6,R6               A NON ZERO VALUE PROVIDED ?
         BZ    CM234               NO, ERROR
         TM    WAM1SW,WAM1SWK      VALUE EXPESSED IN K ?
         BZ    CM241               NO, BRANCH
         SLL   R6,10               MULTIPLY BY 1024 (1K)
CM241    TM    WAM1SW,WAM1SWM      VALUE EXPESSED IN M ?
         BZ    CM242               NO, BRANCH
         SLL   R6,20               MULTIPLY BY 1048576 (1M)
CM242    ST    R6,CPISTOR          SET STORAGE VALUE
         LA    R3,1(,R3)           INCR PAST POSSIBLE COMMA
         CPISETOF  CPIMAXS         SET OFF MAINSIZE/CORE=MAX
         B     CM030               BRANCH TO CHECK FOR MORE PARAMS
*
*        PROCESS THE PARAMETERS IN THE ATTACH/LINK LIST
*
CM250    LA    R3,2(,R1)           R3 -> START OF PARAMETER LIST
         CPISETON CPIATT           SET ATTACH/LINK/XCTL ON
         MVC   CPISSORT(16),0(R3)  MOVE START AND ENDING ADDR OF
*                                  OPTIONAL SORT AND RECORD
*                                  STATEMENTS TO CPI FROM ATTACH
*                                  PARM LIST
         ICM   R0,B'1111',CPISSORT  SORT CONTROL STATEMENT PROVIDED ?
         BZ    CM250A              NO, BRANCH
         CPISETON  CPISCARD        YES, SET ON SORT CONTROL PROVIDED
CM250A   ICM   R0,B'1111',CPISRECD  RECORD CONTROL STATEMENT PROVIDED ?
         BZ    CM250B              NO, BRANCH
         CPISETON  CPIRCARD        YES, SET ON RECORD CONTROL PROVIDED
CM250B   ICM   R0,B'1111',16(R3)   PHASE 1 EXIT (E15) ?
         BZ    CM260               NO, BRANCH
         CPISETON  CPIME15         YES, SET E15 ACTIVE
         STCM  R0,B'0111',CPIATP1E  STORE ADDR OF E15 INTO CPI
*
CM260    ICM   R0,B'1111',20(R3)   PHASE 3 EXIT (E35) ?
         BZ    CM270               NO, BRANCH
         CPISETON  CPIME35         SET E35 ACTIVATED
         STCM  R0,B'0111',CPIATP3E  STORE ADDR OF E35 INTO CPI
*
CM270    LH    R0,0(,R1)           R0 = L'ATTACH PARAMETER LIST
         CH    R0,=H'24'           ANY OPTIONAL PARAMETERS ?
         BE    CM370               NO, BRANCH
*
*        SETUP FOR PROCESSING OPTIONAL PARAMETERS
*
         LA    R3,24(,R3)          INCR POINTER TO OPTIONAL PARAMETERS
CM280    TM    1(R1),X'03'         ATTACH LIST SIZE DIVISABLE BY FOUR ?
         BZ    CM290               YES, BRANCH
         MVI   WERRSW,WERRSWL      TURN ON ERROR SWITCH
CM290    LH    R2,0(,R1)           R2 = L'PARAMETER
         LA    R2,2(R2,R1)         R2 -> END OF PARAMETER PLUS 1
*
*        PROCESS OPTIONAL PARAMETER VALUES
*        R3 -> PARAMETER ENTRY
*        R2 -> END OF PARAMETERS
*
*        CHECK FOR AM1, CORE OR MAIN VALUE
*
CM300    CLI   0(R3),0             CODE INDICATE AM1/CORE/MAIN VALUE ?
         BNE   CM340               NO, BRANCH
         TM    WAM1SW,WAM1SWP      MAIN SIZE ALREADY BEEN SPECIFIED ?
         BZ    CM310               NO, BRANCH
         MVI   WERRSW,WERRSWT      TURN ON ERROR SWITCH
*
CM310    OI    WAM1SW,WAM1SWP      SET MAIN SIZE SPECIFIED SWITCH
         MVC   CPISTOR,0(R3)       SET USER REQUESTED STORAGE VALUE
         CPISETOF  CPIMAXS         SET OFF MAINSIZE/CORE=MAX IF SET
*
*        TEST FOR MESSAGE OPTION
*        USE PARM ROUTINE FOR PROCESSING
*
CM340    CLI   0(R3),X'FF'         CODE INDICATE MESSAGE OPTION ?
         BE    CM105               YES, BRANCH
*                                  RETURN WILL BE TO CM320
*        TEST FOR RESERVED MAIN STORAGE VALUE
*
         CLI   0(R3),X'01'         RESERVE VALUE SPECIFIED ?
         BNE   CM341               NO, TEST NEXT VALUE
         MVC   CPIMAXRI+1(3),1(R3)  MOVE VALUE INTO CPI
         B     CM320
*
*        TEST FOR MODS CONTROL STATEMENT
*
CM341    CLI   0(R3),X'02'         MODS STATEMENT SPECIFIED ?
         BNE   CM342               NO, BRANCH
         LA    R15,8(,R3)          8 BYTES IN ATTACH LIST ?
         CR    R15,R2
         BL    CM350               NO, ERROR
         CLI   4(R3),X'00'         ENDING ADDR HI-ORDER BYTE ZERO ?
         BNE   CM350               NO, ERROR
         MVC   CPISMODS+1(3),1(R3)  MOVE START ADDR INTO CPI
         LA    R3,4(,R3)            INCR PTR
         MVC   CPIEMODS+1(3),1(R3)  MOVE END ADDR INTO CPI
         CPISETON  CPIMCARD        MODS STATEMENT PROVIDED
         B     CM320
*
*        TEST FOR MESSAGE DATA SET NAME
*
CM342    CLI   0(R3),X'03'         DATA SET NAME SPECIFIED ?
         BNE   CM343               NO, BRANCH
         ICM   R15,B'0111',1(R3)   R15 -> DATA SET NAME
         MVC   CPIMDDN,0(R15)      MOVE MSG DATA SET NAME TO CPI
         L     R15,VLCTOUC         R15 -> LOWER -> UPPER CASE TR TABLE
         TR    CPIMDDN,0(R15)      TRANSLATE TO UPPER CASE
         B     CM320
*
*        TEST FOR DEBUG CONTROL STATEMENT
*
CM343    CLI   0(R3),X'05'         DEBUG STATEMENT SPECIFIED ?
         BNE   CM344               NO, BRANCH
         LA    R15,8(,R3)          8 BYTES IN ATTACH LIST ?
         CR    R15,R2
         BL    CM350               NO, ERROR
         CLI   4(R3),X'00'         ENDING ADDR HI-ORDER BYTE ZERO ?
         BNE   CM350               NO, ERROR
         MVC   CPISDEBG+1(3),1(R3)  MOVE START ADDR INTO CPI
         LA    R3,4(,R3)            INCR PTR
         MVC   CPIEDEDB+1(3),1(R3)  MOVE END ADDR INTO CPI
         CPISETON  CPIDSTMT        DEBUG STATEMENT PROVIDED
         B     CM320
*
*        TEST FOR OPTION CONTROL STATEMENT
*
*        NOTE THAT SUPPORT FOR THE OPTION STATEMENT IS NON
*        STANDARD AND SPECIFIC TO S/M FOR MVS 3.8 PROGRAM
*
CM344    CLI   0(R3),X'11'         OPTION STATEMENT SPECIFIED ?
         BNE   CM345               NO, BRANCH
         LA    R15,8(,R3)          8 BYTES IN ATTACH LIST ?
         CR    R15,R2
         BL    CM350               NO, ERROR
         CLI   4(R3),X'00'         ENDING ADDR HI-ORDER BYTE ZERO ?
         BNE   CM350               NO, ERROR
         MVC   CPISOPTR+1(3),1(R3)  MOVE START ADDR INTO CPI
         LA    R3,4(,R3)            INCR PTR
         MVC   CPIEOPTR+1(3),1(R3)  MOVE END ADDR INTO CPI
         CPISETON  CPIOSTMT        OPTION STATEMENT PROVIDED
         B     CM320
*
*        TEST FOR USER EXIT ADDRESS CONSTANT
*
CM345    CLI   0(R3),X'F7'         USER ADDRESS CONSTANT SPECIFIED ?
         BNE   CM347               NO, BRANCH
         MVC   CPIUEXIT+1(3),1(R3)  YES, MOVE INTO CPI
         B     CM320
*
*        TEST FOR PARAMETER LIST NULL ENTRY
*
CM347    CLI   0(R3),X'FD'         PARAMETER LIST NULL ENTRY ?
         BNE   CM348               NO, BRANCH
         B     CM320               YES, NULL ENTRY, IGNORE
*
*        BRANCH TO TEST FOR DIAGNOSTICS AND/OR SORT TECHNIQUE
*        USING PARM ROUTINE
*
CM348    B     CM010               CHECK FOR DIAG/SORT TECHNIQUE
*
*        SINCE THIS PARAMETER HAS NOT YET BEEN IDENTIFIED AND
*        CLAIMED AS DIAG OR A SORT TECHNIQUE DEFAULT IT TO THE
*        FOUR LETTERS TO PREFIX THE SORT DD STMTS
*        DETERMINE IF THEY ARE VALID
*
CM360    TM    WDDSW,X'FF'         DD LETTERS ALREADY BEEN SPECIFIED ?
         BNO   CM365               NO, BRANCH
         MVI   WERRSW,WERRSWE      TURN ON ATTACH ERROR SWITCH
*
CM365    OI    WDDSW,X'FF'         SET DD LETTERS SPECIFIED SWITCH
         MVC   WTRANS,0(R3)        MOVE LETTERS INTO TRANSLATE AREA
         L     R15,VLCTOUC         R15 -> LOWER TO UPPER CASE TR TAB
         TR    WTRANS,0(R15)       TRANSLATE TO UPPER CASE
         TR    WTRANS,DDCHECK      TRANSLATE TO DO CHECK
         CLC   WTRANS,KCHECK       BYTES VALID ALPHANUMERIC CHARS ?
         BH    CM350               NO, BRANCH TO ERROR ROUTINE
         MVC   CPIDDSRT,0(R3)      MOVE NEW LETTERS INTO CPI
         TR    CPIDDSRT,0(R15)     TRANSLATE TO UPPER CASE
*
*        END OF SCAN TEST
*
CM320    LA    R3,4(,R3)           UP POINTER
         CR    R3,R2               MORE PARAMETERS ?
         BL    CM300               YES, BRANCH
         B     CM370               ELSE RETURN TO MAIN LINE
*
*        ERROR ROUTINE FOR ATTACH LIST
*
CM350    MVI   WERRSW,WERRSWE      TURN ON ATTACH ERROR SWITCH
         B     CM320               BRANCH TO CHECK FOR MORE PARAMS
*
*----------------------------------------------------------------------
*
*        GENERATE IER000I STARTUP IDENTIFICATION MSG
*
*----------------------------------------------------------------------
*
CM370    TIME  DEC
*
         STM   R0,R1,WORKD         STORE SYSTEM TIME AND DATE
         ED    IER000C,WORKD       FORMAT TIME
         UNPK  WORKD(3),WORKD+5(2)  UNPACK YY
         MVC   IER000Y+2(2),WORKD  MOVE YEAR ACROSS
         XC    WORKD(6),WORKD      ZERO ALL EXCEPT DDDF IN LAST BYTES
         CVB   R14,WORKD           GET JULIAN DAY IN BINARY
         ST    R1,WORKD            RESTORE THE DATE IN WORKD
         LA    R15,MNTHTBL         R15 -> MNTHTBL
         SH    R15,=H'8'           ADJUST ADDR FOR FIRST ITERATION
         TM    WORKD+1,X'01'       IF ODD YEAR THEN
         BO    NOTLEAP             NOT LEAP YEAR
         TM    WORKD+1,X'12'       TEST FOR LEAP (OK TILL 2099)
         BNM   NEXTMNTH            IF MIXED NOT LEAP YEAR
NOTLEAP  CH    R14,=H'60'          DDD AFTER 28TH FEBRUARY?
         BL    NEXTMNTH            NO, LEAP YEAR IRRELEVANT
         LA    R14,1(,R14)         YES, FUDGE DDD ACCORDINGLY
NEXTMNTH LA    R15,8(,R15)         INCREMENT THRU MONTH TABLE
         SH    R14,0(,R15)         DECREASE NUMBER OF DAYS
         BP    NEXTMNTH            NOT YET, TRY NEXT MONTH
*                                  FOUND THE CORRECT MONTH
         AH    R14,0(,R15)         ADD BACK THE DAYS IN MONTH
         CVD   R14,WORKD           GET DAY OF MONTH
         OI    WORKD+7,X'0F'       MAKE UNPACKED RESULT PRINTABLE
         UNPK  IER000D,WORKD+6(2)  FORMAT DAY OF MONTH
         MVC   IER000M,2(R15)      MOVE IN MONTH NAME
         MVC   IER000V,CPIVER      MOVE IN VERSION NUMBER
         LM    R0,R1,IER000        IER000I INITIAL IDENTIFICATION MSG
         LA    R15,IERGAPRT        R15 -> PRINT ROUTINE
         BASR  R14,R15             CALL PRINT MESSAGE RTN
*
*----------------------------------------------------------------------
*
*        GENERATE IER900I DIAGNOSTICS STARTUP IDENTIFICATION MSG
*
*----------------------------------------------------------------------
*
         CPITEST  CPIDIAG+CPIDSIM  GENERATING DIAGNOSTIC MESSAGES ?
         BZ    CM400A
         LA    R1,IER900D          R1 -> MSG BUILDUP AREA
         LR    R0,R1               TAKE A COPY FOR COMMA COMPARISON
         CPITEST  CPITEXCP         TRACE EXCP ?
         BZ    CM392               NO, BRANCH
         MVC   0(L'KEXCP,R1),KEXCP
         LA    R1,L'KEXCP(,R1)     INCR TEXT ADDR
CM392    CPITEST  CPITWAIT         TRACE COMPLETION OF EXCP AT WAIT
         BZ    CM394               NO, BRANCH
         CR    R0,R1
         BE    CM393
         MVI   0(R1),C','          COMMA SEPARATOR
         LA    R1,1(,R1)
CM393    MVC   0(L'KEXCPW,R1),KEXCPW  MOVE IN KEYWORD
         LA    R1,L'KEXCPW(,R1)    INCR TEXT ADDR
CM394    CPITEST  CPITMODF         TRACE MODULE FLOW ?
         BZ    CM396               NO, BRANCH
         CR    R0,R1
         BE    CM395
         MVI   0(R1),C','
         LA    R1,1(,R1)
CM395    MVC   0(L'KMODFLOW,R1),KMODFLOW
         LA    R1,L'KMODFLOW(,R1)  INCR TEXT ADDR
CM396    EQU   *                   ADD ADDITION FEATURES HERE
         LM    R0,R1,IER900        IER900I - DIAGNOSTIC OPTIONS
         LA    R15,IERGAPRT        R15 -> PRINT ROUTINE
         BASR  R14,R15             CALL PRINT ROUTINE
CM400A   TM    WERRSW,X'FF'        ANY ERROR SWITCHS ON ?
         BZ    CM001               NO, CONTINUE TO DEFINITION PHASE
         SR    R1,R1
         IC    R1,WERRSW           GET ERROR FLAGS
         BCTR  R1,0
         SLL   R1,2                CONVERT TO OFFSET * 4
*                                  INDEX INTO IER067RT FOR ADDR OF MSG
         L     R1,IER067RT(R1)     R1 -> MSG TEXT
         MVC   IER067R,0(R1)
         LM    R0,R1,IER067        IER067I - INVALID EXEC OR ATTACH
         LA    R15,IERGAPRT        R15 -> PRINT ROUTINE
         BASR  R14,R15             CALL PRINT ROUTINE
*                                  PROCESSING CONTINUES
*---------------------------------------------------------------------
*
*        BEGIN DEFINITION PHASE OF INITIALIZATION
*
*---------------------------------------------------------------------
*
*        GETMAIN THE CONTROL STATEMENT STORAGE AREA
*
*        UPDATE THE CODE IF THE LENGTH OF THE AREA IS CHANGED
*
CM001    L     R0,CNTLAREA         CURRENTLY SET TO 6K
         ST    R0,CPILCNTL         SAVE FOR LATER FREEMAIN
*
         GETMAIN R,LV=(0)          GETMAIN CONTROL STMT AREA
*
         ST    R1,CPIACNTL         STORE ADDR OF STORAGE
         ST    R1,CPINCNTL         STORE ADDR OF NEXT TO USE STORAGE
         LR    R0,R1               COPY STORAGE ADDR
         LA    R1,2048(,R1)
         LA    R1,2048(,R1)
         ST    R1,CPIAFLDD         SET ADDR OF REDUCTION AREA
         LA    R1,2047(,R1)
         ST    R1,CPIAFLDX         END OF REDUCTION AREA
         L     R1,CPILCNTL         GET L'CNTL STMT AREA
         SR    R15,R15
         MVCL  R0,R14              ZERO CNTL STMT AREA
         SR    R6,R6               CLEAR MODTAB INDEX
         LA    R12,CMSAVE          R12 -> SAVE AREA FOR CALLED MODULES
         LA    R8,CM005C           ERROR RETURN FROM CMLINK
         LA    R7,CM006
CM005    LA    R15,MODTAB(R6)      R15 -> VCON AND MOD NAME IN MODTAB
CM005A   B     CMLINK              RETURN VIA R7 OR R8
*
CM005C   B     ERRTAB(R6)          TAKE INDEXED ERROR BRANCH
*
CM006    LA    R6,8(,R6)           IF MORE ROUTINES NEEDED BRANCH
         LA    R0,MODTABL          R6 = L'MODTAB
         CR    R6,R0               STEPPED THROUGH MODTAB ?
         BL    CM005               NO, PROCESS NEXT ENTRY
*
*----------------------------------------------------------------------
*
*        SET ESTIMATED FILE SIZE OPTION FLAG
*
*----------------------------------------------------------------------
*
         CPITEST CPIME15           E15 EXIT ACTIVATED ?
         BO    CM012B              YES, BRANCH
         CPITEST CPIATT            SORT ATTACHED ?
         BZ    CM012A              NO, BRANCH
         ICM   R0,B'0111',CPIATP1E  E15 EXIT PROVIDED ?
         BNZ   CM012B               YES, BRANCH
CM012A   ICM   R0,B'0111',CPIFILSZ  FILESIZE VALUE SET ON SORT
*                                   OR OPTION CONTROL STATEMENT ?
         BNZ   CM012C               YES, BRANCH
CM012B   CPISETON  CPIFSZE          SET ON FILE SIZE ESTIMATED FLAG
*                                   IF E15, ATTACHED OR NOT, IS
*                                   ACTIVE OR NO FILSZ VALUE PROVIDED
*
CM012C   TM    CMSWITCH,X'01'      ERROR SWITCH ON ?
         BO    CMEE01              YES, TAKE BRANCH
         LA    R8,CMEE01           SET ERROR EXIT FROM CMLINK
*
*----------------------------------------------------------------------
*
*        CALL APPROPRIATE MODULES DEPENDING ON SET OPTIONS
*
*----------------------------------------------------------------------
*
         CPITEST  CPIMERGO         MERGE ONLY RUN ?
         BZ    CM012               NO, BRANCH
         LA    R15,VIERRCL         YES, R15 -> MERGE ONLY B & G
         BAS   R7,CMLINK           CALL LINK ROUTINE
         B     CM008
*
CM012    CPITEST  CPITAPE          TAPE SORT ?
         BZ    CM013               NO, BRANCH, MUST BE DISK
         LA    R15,VIERRCS         R15 -> TAPE B & G
         BAS   R7,CMLINK           CALL LINK ROUTINE
         B     CM008
*
*        DASD SORT - SELECT MODULE TO IMPLEMENT TECHNIQUE
*
CM013    CPITEST  CPI2314          CRCX DASD SORT ?
         BZ    CM014               NO, BRANCH
         LA    R15,VIERBGB         YES, R15 -> CRCX DISK B & G
         BAS   R7,CMLINK           CALL LINK ROUTINE
         B     CM008
*
CM014    LA    R15,VIERRCK         R15 -> BALN DASD B & G
         BAS   R7,CMLINK           CALL LINK ROUTINE
*
*---------------------------------------------------------------------
*
*        OPEN MESSAGE AND SORTDIAG DCBS IF REQUIRED
*        EMPTY MESSAGE AREA BUFFER
*        CLEANUP PRIOR TO RETURN TO IERRCO00
*
*---------------------------------------------------------------------
*
CM008    CPITEST  CPIDIAG          NEED TO OPEN SORTDIAG ?
         BZ    CMENDA              NO, BRANCH
         LA    R5,SORTDIAG         R5 -> SORTDIAG DCB
         USING IHADCB,R5
         MVC   IER063A,DCBDDNAM    IN CASE OF ERROR MSG
*
         OPEN  ((R5),(OUTPUT))     OPEN SORTDIAG DCB. SHOULD OPEN OK
*                                  AS TIOT ENTRY PREVIOUSLY FOUND
*
         LTR   R15,R15             SORTDIAG OPEN SUCCESSFULL ?
         BZ    CMENDB              YES, CONTINUE
         LM    R0,R1,IER063        NO, IER063A - OPEN ERROR SORTDIAG
         LA    R15,IERGAPRT        R15 -> PRINT ROUTINE
         BASR  R14,R15             BRANCH TO PRINT MESSAGE ON CONSOLE
         LR    R1,R0               R1 -> MSG TEXT
         MVC   CPIABMNO,3(R1)      MOVE MSG NO INTO ABEND MSG
         B     CMEE01
*
*
*----------------------------------------------------------------------
*
*        INITIALIZE MESSAGE WRITER OUTPUT DCB AND SORTDIAG DCB
*
*----------------------------------------------------------------------
*
*        UPDATE WTO ROUTE AND DESCR CODES IN CASE NEEDED
*
CMENDA   LA    R1,WTORCM           R1 -> WTO ROUTINE IN IERRCM
         AH    R1,WTORCM           R1 -> WTO ROUTE AND DESCR CODES
         MVC   0(4,R1),CPIWTOC     MOVE INSTALLATION CODES INTO WTO
         CPITEST  CPIPALL+CPIPCRT  SYSOUT USAGE REQUIRED ?
         BNZ   CMENDB              YES, BRANCH TO OPEN SYSOUT
         CPITEST  CPIDSIM          DIAGNOSTICS REQUESTED ON SYSOUT ?
         BZ    CMENDC              NO, BRANCH
*                                  YES, SYSOUT REQUIRED FOR DIAGNOSTICS
CMENDB   LA    R5,SYSOUT           R5 -> SYSOUT DCB
         ST    R5,CPISDCB          SAVE ADDR IN CPI FOR POSSIBLE DUMPS
         MVC   DCBDDNAM,CPIMDDN    SET DDNAME TO PROVIDED VALUE
*
         OPEN  ((R5),(OUTPUT))     OPEN DCB FOR SYSOUT
*
         LTR   R15,R15             SYSOUT OPEN SUCCESSFULL ?
         BZ    CMENDC              YES, CONTINUE
         CPISETOF  CPIPALL-CPIPCRT  NO, TURN OFF ALL PRINTER MSG FLAGS
         CPISETOF  CPIDSIM
         CPISETON  CPICCRT
         MVC   IER063A,CPIMDDN     MOVE MSG DDNAME INTO MSG
         LM    R0,R1,IER063        IER063A - OPEN ERR SYSOUT
         LA    R15,IERGAPRT        R15 -> PRINT ROUTINE
         BASR  R14,R15             BRANCH TO PRINT MESSAGE ON CONSOLE
         LR    R1,R0
         MVC   CPIABMNO,3(R1)      MSG NO INTO ABEND MSG
         B     CMEE01              EXIT VIA ERROR ROUTINE
*
         DROP  R5
*
CMENDC   MVI   MSGFLAG,MSGNSTOR    SET ON NORMAL MESSAGE PROCESSING
         LM    R2,R3,MSGADDR       R2 -> MESSAGE STORAGE AREA
*                                  R3 -> NEXT TO USE MSG STORAGE AREA
         CR    R2,R3               ANY MESSAGES STORED ?
         BE    CMENDD              NO, BRANCH
*
*        LOOP TO EMPTY MESSAGE AREA
*
CMENDL   ICM   R1,B'1111',0(R2)    R1 = L'MESSAGE
         LA    R0,4(,R2)           R0 -> MESSAGE TEXT
         LA    R15,IERGAPRT        R15 -> PRINT ROUTINE
         BASR  R14,R15             BRANCH TO PRINT MESSAGE ON CONSOLE
         LA    R2,4(R1,R2)         CALC ADDR OF NEXT MESSAGE
         CR    R2,R3               ALL MESSAGES PROCESSED ?
         BL    CMENDL              NO, PROCESS NEXT MESSAGE
*
*        CLOSE OPEN MSG WRITER DATA SET AND SORTDIAG DATA SET
*
         USING IHADCB,R7
CMENDD   LA    R6,CLOSELST-4
         LR    R0,R6               TAKE A COPY FOR LATER TESTING
         LA    R7,SYSOUT           R7 -> SYSOUT DCB
         TM    DCBOFLGS,DCBOFOPN   SYSOUT OPENED ?
         BZ    CM008A              NO ,BRANCH
         LA    R6,4(,R6)           INCR TO NEXT ENTRY IN CLOSELST
         STCM  R7,B'0111',1(R6)    STORE DCB ADDR INTO CLOSELST
CM008A   LA    R7,SORTDIAG         R7 -> SORTDIAG DCB
         TM    DCBOFLGS,DCBOFOPN   SORTDIAG OPENED ?
         BZ    CM008B              NO, BRANCH
         LA    R6,4(,R6)           INCR TO NEXT ENTRY IN CLOSELST
         STCM  R7,B'0111',1(R6)    STORE DCB ADDR INTO CLOSELST
CM008B   CR    R0,R6               ANY DCBS FOUND OPEN ?
         BE    CM009               NO, BRANCH AROUND CLOSE
         OI    0(R6),X'80'         TERMINATE CLOSELST
*
         CLOSE MF=(E,CLOSELST)
*
         DROP  R7
         LTR   R15,R15             CLOSE SUCCESSFULL ?
         BZ    CM009               YES, BRANCH
*
         DC    H'0'                THIS SHOULD NOT HAPPEN FORCE AN
*                                  0C1 ABEND AS A DIAGNOSTIC AID
*
CM009    LM    R0,R1,CPILCNTL      GET CNTL AREA FIELDS
         LTR   R1,R1               CONTROL AREA GETMAINED ?
         BZ    CM009A              NO, BRANCH
*
         FREEMAIN R,LV=(0),A=(1)   FREE THE CONTROL AREA
*
CM009A   LM    R0,R1,MSGLEN        R0 = L'MESSAGE AREA, R1 -> MSG AREA
         LTR   R1,R1               AREA GETMAINED ?
         BZ    CMRETX              NO, BRANCH
*
         FREEMAIN R,LV=(0),A=(1)   FREE THE MESSAGE STORAGE AREA
*
*
*---------------------------------------------------------------------
*
*        RETURN TO IERRCO00
*
*---------------------------------------------------------------------
*
CMRETX   L     R15,RETCODE         GET RETURN CODE SETTING
         L     R8,AIERRCO          RESTORE RCO BASE
         L     R14,SAVER14         RESTORE RETURN REGISTER
         BR    R14                 RETURN TO IERRCO
*
*---------------------------------------------------------------------
*
*        ERROR RETURN CODE PROCESSING
*
*---------------------------------------------------------------------
*
*        THE ERROR MSG NUMBER THAT RESULTED FROM THE ERROR
*        DETECTED IS STORED IN CPIABMNO.
*        DETERMINE HOW TO REFLECT THE ERROR TO THE USER BY TESTING
*        THE VARIOUS OPTION FLAGS SET IN THE CPI.
*
CMEE01   CPITEST CPIERET           USER ABEND REQUESTED ?
         BO    CMEE01A             YES, BRANCH
         MVC   RETCODE,KF16        NO, SET A RETURN CODE OF 16
         B     CMEE01X
*
*        ABEND OPTION REQUESTED
*        DETERMINE ABEND CODE
*
CMEE01A  LH    R15,CPIABC          R15 = DEFAULT ABEND CODE
         CPITEST CPIABMSG          USE MESSAGE NO FOR ABEND CODE ?
         BZ    CMEE01B             NO, BRANCH
*
*        MSG CODE TO BE USED AS ABEND CODE
*
         PACK  WORKD,CPIABMNO      PACK CHARACTER MSG NO
         CVB   R15,WORKD           R15 = BINARY VALUE
CMEE01B  LNR   R15,R15             SIGNAL ABEND CODE
         ST    R15,RETCODE         STORE IN RETCODE
CMEE01X  B     CM008               BRANCH TO CLOSE ALL MSG WRITER
*                                  DATA SETS AND FREE CNTL AREA STORAGE
*
*---------------------------------------------------------------------
*
*        MODULE CALLING ROUTINE WITH OPTIONAL CPI PRINT AREA
*
*---------------------------------------------------------------------
*
*        ON ENTRY
*        R7  -> RETURN ADDR
*        R8  -> ERROR RETURN
*        R15 -> MODTAB ENTRY TO CALL
*
         DROP  R12
*
CMLINK   L     R2,VIERRCU          R2 -> MSG CSECT
         USING DIERRCU,R2          MSG CSECT, USE R2 AS R12 IS USED AS
*                                  A SAVEAREA FOR THE CALLED MODULES
         MVC   IER980M,4(R15)      MOVE MODULE ID INTO MSG
         MVC   IER982M,4(R15)      MOVE MODULE ID INTO PRINT TITLE HDR
         MVC   IER986M,4(R15)      MOVE MODULE ID INTO PRINT TITLE HDR
         CPITEST  CPIDIAG+CPIDSIM  DIAGNOSTIC MSGS BEING GENERATED ?
         BZ    CMLINKA             NO, BRANCH
         CPITEST  CPITMODF         MODULE FLOW DIAGNOSTICS ?
         BZ    CMLINKA             NO, BRANCH
         LR    R11,R15             SAVE ADDR OF MODULE TO CALL
         LM    R0,R1,IER980
         LA    R15,IERGAPRT
         BASR  R14,R15             CALL THE MSG PRINT RTN
         LR    R15,R11             RESTORE THE ADDR OF MODULE TO CALL
CMLINKA  L     R15,0(,R15)         LOAD SELECTED MODULE ADDR
         BASR  R14,R15             CALL SELECTED ROUTINE
CMLINKE  LTR   R11,R15             SAVE RETURN CODE, RETURN CODE ZERO ?
         BZ    CMLINKB             YES, BRANCH
         CPITEST  CPIDIAG+CPIDSIM  DIAGNOSTIC MSGS BEING GENERATED ?
         BZ    CMLINKB             NO, BRANCH
         CPITEST  CPITMODF         MODULE FLOW DIAGNOSTICS ?
         BZ    CMLINKB             NO, BRANCH
         L     R2,VIERRCU          R2 -> MSG CSECT
         MVC   IER980R,IER980C     MOVE IN RETURN CODE MSG
         MVC   IER980V,EPATTERN    MOVE IN EDIT PATTERN
         CVD   R11,WORKD
         ED    IER980V,WORKD+6     FORMAT RETURN CODE VALUE
         LM    R0,R1,IER980
         LA    R15,IERGAPRT
         BASR  R14,R15             CALL THE MSG PRINT RTN
         MVI   IER980R,C' '        BLANK MSG AREA
         MVC   IER980R+1(L'IER980R+L'IER980V-1),IER980R
CMLINKB  CPITEST CPIDIAG+CPIDSIM   GENERATING DIAGNOSTICS ?
         BZ    CMLINKC             NO, BRANCH
         CPITEST CPITSCPI          PRINT THE CPI AND THE CNTL AREA ?
         BZ    CMLINKC             NO, BRANCH
         LM    R0,R1,IER982        PRINT IER982 HEADING
         LA    R15,IERGAPRT
         BASR  R14,R15             CALL MESSAGE WRITER
         ST    R13,IERFMTP         R3 -> FIRST BYTE OF CPI
         LA    R1,CPIEND-1         R4 -> LAST BYTE OF CPI
         ST    R1,IERFMTP+4
         LA    R1,IERFMTP          R1 -> IEFRMT PARAMETER LIST
         L     R15,VIERFMT         R15 -> IERFMT ROUTINE
         BASR  R14,R15             PRINT FORMATTED CPI
         LM    R3,R4,CPILCNTL      GET L' AND START ADDR OF CNTL AREA
         LTR   R4,R4               WAS CNTL AREA GETMAINED ?
         BZ    CMLINKC             NO, BYPASS PRINT
         LM    R0,R1,IER986        PRINT IER986 HEADING
         LA    R15,IERGAPRT        R15 -> MESSAGE WRITER
         BASR  R14,R15             CALL MESSAGE WRITER
         AR    R3,R4
         BCTR  R3,0                CALC END ADDR OF CNTL AREA
         ST    R4,IERFMTP          STORE ADDR OF OF CNTL AREA
         ST    R3,IERFMTP+4        STORE ADDR OF END ADDR OF CNTL AREA
         LA    R1,IERFMTP          R1 -> IEFRMT PARAMETER LIST
         L     R15,VIERFMT         R15 -> IERFMT ROUTINE
         BASR  R14,R15             PRINT CNTL AREA
*
CMLINKC  L     R2,VIERRCU          R2 -> MSG CSECT
         LTR   R11,R11             ERROR RETURN ?
         BZR   R7                  NO, RETURN TO CALLER
         BR    R8                  BRANCH TO ERROR PROCESSING
*
         DROP  R2
*
*---------------------------------------------------------------------
*
*        INTERNAL ENTRY IN MODTAB TO SET STORAGE VALUES
*
*---------------------------------------------------------------------
*
*        CPISTOR HAS BEEN SET BY EITHER:-
*        1. IERAM1 INSTALLATION OPTIONS
*        2. EXEC STATEMENT OR ATTACH PARAMETER
*        3. OPTION STATEMENT
*        OR
*        MAXIMUM AVAILABLE STORAGE HAS BEEN REQUESTED
*
*        VALIDATE THE VALUE AND DETERMINE CPITAVLC
*        WHICH WILL BE USED LATER BY SORT INITIALIZATION MODULES
*        TO SET BUFFER SIZES, MERGE ORDERS ETC
*
CMSTOR   CPITEST  CPIMAXS          SIZE/MAINSIZE/CORE=MAX ?
         BO    CMSTORC             YES, PROCESS MAX REQUEST
         L     R2,CPISTOR          R2 = USER SPECIFIED STORAGE VALUE
         C     R2,CPIMINL          < MINIMUM ALLOWED ?
         BNL   CMSTORA             NO, BRANCH
         L     R2,CPIMINL          YES, OVERRIDE SET TO MINIMUM
CMSTORA  C     R2,CPIMAXL          > MAXIMUM LIMIT ALLOWED ?
         BNH   CMSTORB             NO, BRANCH
         L     R2,CPIMAXL          YES, OVERRIDE SET TO MAXIMUM LIMIT
CMSTORB  STCM  R2,B'0111',CPITAVLC  SET TOTAL AVAILABLE STORAGE VALUE
         S     R2,RCMSIZE          SUBTRACT STORAGE TAKEN BY IERRCM
*
         GETMAIN RC,LV=(R2)        REQUEST USER STORAGE VALUE
*
         LTR   R15,R15             REQUESTED STORAGE OBTAINED ?
         BNZ   CMSTORF             NO, TERMINATE SORT WITH MSG
*
         FREEMAIN R,LV=(R2),A=(1)  FREEMAIN WHATEVER WAS GETMAINED
*
         B     CM006               RETURN TO MODTAB PROCESSING
*
*        GENERATE MSG IER074A AND TERMINATE THE SORT
*
CMSTORF  L     R2,VIERRCU          R2 -> MSG CSECT
         USING DIERRCU,R2
         LM    R0,R1,IER074
         LR    R11,R15             SAVE ADDR OF MODULE TO CALL
         LA    R15,IERGAPRT
         BASR  R14,R15             CALL THE MSG PRINT RTN
         LR    R1,R0
         MVC   CPIABMNO,3(R1)      MSG NO INTO ABEND MSG
         LA    R15,4
         B     CMLINKE             BRANCH ENTRY POINT BACK TO CMLINK
*
         DROP  R2
*
*        DETERMINE THE MAXIMUM STORAGE AVAILABLE
*
CMSTORC  L     R2,CPIMINL          GET MINIMUM VALUE
         S     R2,RCMSIZE          ALLOW FOR IERRCM MODULE
         ST    R2,GETMIN           SET MINIMUM
         L     R2,CPIMAXL          GET MAXIMUM PERMITTED
         S     R2,RCMSIZE          ALLOW FOR IERRCM MODULE
         ST    R2,GETMAX           SET MAXIMUM
*
         GETMAIN VC,LA=GETSTOR,A=GETRESLT
*
         LTR   R15,R15             GETMAIN SUCCESSFULL ?
         BNZ   CMSTORF             NO, MINIMUM REQ FAILED
*
*        FREEMAIN WHATEVER WAS GETMAINED
*
         L     R0,GETRECL          R0 = L'STORAGE
         L     R1,GETRESA          R1 -> STORAGE
*
         FREEMAIN R,LV=(0),A=(1)
*
         L     R1,GETRECL          L'STORAGE AVAILABLE
         A     R1,RCMSIZE          ALLOW FOR IERRCM MODULE
         L     R2,CPIMAXR          R2 = STORAGE RESERVED IF SORT
*                                  INVOKED BY EXEC STMT
         CPITEST CPIATT            SORT INVOKED BY ATTACH/LINK/XCTL ?
         BZ    CMSTORG             NO, BRANCH
         L     R2,CPIMAXRI         YES, SORT INVOKED BY ATTACH/LINK/XC
CMSTORG  SR    R1,R2               SUBTRACT RESERVED STORAGE AMOUNT
         STCM  R1,B'0111',CPITAVLC  SET MAXIMUM STORAGE FOR SORT USE
         B     CM006               RETURN TO MODTAB PROCESSING
*
*---------------------------------------------------------------------
*
*        INTERNAL ENTRY IN MODTAB TO TEST FOR LINK EDIT REQUIREMENT
*
*---------------------------------------------------------------------
*
CMTLNK   TM    CPILINK+2,X'08'     USER REQUIRE LINK EDIT ?
         BZ    CM006               NO, BYPASS RCP
         LA    R15,VIERRCP         R15 -> LINK EDIT DEFN
         B     CM005A              RETURN TO SPECIAL ENTRY POINT TO
*                                  CALL IERRCP MODULE
*
*---------------------------------------------------------------------
*
*        PROCESS ERRORS FROM MODTAB CALLED MODULES
*
*---------------------------------------------------------------------
*
ERRTAB   B     CMEE01           *  ERROR RETURN FROM IERRCC
         NOP   0                |
         B     CMEE01           |                    IERRCY
         NOP   0                |
         B     CMEE01           |  SEE MODTAB FOR    IERRCE
         NOP   0                |
         B     CMX10            |  ORDER             IERRCG
         NOP   0                |
         B     CMEE01           |                    IERRCX
         NOP   0                |
         B     CM011            |                    IERRCH
         NOP   0                |
         B     CMEE01           |                    IER#I1
         NOP   0                |
         B     CMEE01           |                    IER#I2
         NOP   0                |
         B     CMEE01           |                    IERRCI
         NOP   0                |
         B     CMEE01           |                    IERRC2
         NOP   0                |
CM011    OI    CMSWITCH,X'01'   V                    IERRCN
         B     CM006               RETURN AND CONTINUE PROCESSING
*
CM011A   CPITEST  CPIATT           SORT ATTACHED ?
         BO    CMEE01              YES, SCAN TERMINATE
         B     CM011               RETURN & CONT
*
CMX10    OI    CMSWITCH,X'01'      TURN ON ERROR SWITCH
         CLI   CPINUMCF+1,0        CONTROL FLD COUNT = ZERO ?
         BNE   CM006               NO, BRANCH
         MVI   CPINUMCF+1,1        SET CONTROL FLD COUNT TO 1
         B     CM006               RETURN AND CONTINUE PROCESSING
*
*---------------------------------------------------------------------
*
*        SYNAD EXIT FOR SYSOUT AND SORTDIAG DCBS
*
*---------------------------------------------------------------------
*
*
SYNADDR  SYNADAF ACSMETH=BSAM
*
         MVC   WTORCM+4(L'IER061),IER061  MOVE IN MSG HEADER
         LA    R2,WTORCM+L'IER061+4       R2 -> NEXT LOC TO MOVE TEXT
         MVC   0(L'CPIWTOH,R2),CPIWTOH    MOVE IN HEADER
         LA    R2,L'CPIWTOH(,R2)          BUMP TO NEXT AREA
         MVC   0(L'IER061C,R2),IER061C    I/O ERROR TEXT
         LA    R2,L'IER061C(,R2)          BUMP TO NEXT AREA
         MVC   0(61,R2),67(R1)     MOVE SYNAD BUILT MSG INTO WTO
*
         WTO   MF=(E,WTORCM)
*
         LR    R2,R13              SAVE SYNAD R13
         L     R13,4(,R13)         RESTORE ADDR OF CPI
         CPISETOF  CPIPALL-CPIPCRT  TURN OFF ALL PRINTER MSG FLAGS
         CPISETOF  CPIDSIM
         CPISETON  CPICCRT         CRITICAL MESSAGES TO THE CONSOLE
         LR    R2,13               RESTORE SYNAD R13
*
         SYNADRLS
*
         BR    R14                 RETURN TO CALLER
*
*---------------------------------------------------------------------
*
*        IERGAPRT - MESSAGE WRITER
*
*---------------------------------------------------------------------
*
*        ALL INFORMATIONAL, ERROR AND DIAGNOSTIC MESSAGES ARE
*        PROCESSED BY THE MESSAGE WRITER
*
*        ON ENTRY
*        R0  -> MSG TEXT
*        R1   = L'MSG TEXT
*
*        ALL REGISTERS ARE SAVED ON ENTRY AND RESTORED ON EXIT
*
         ENTRY IERGAPRT
*
IERGAPRT IERENTRY 'IERGAPRT &SYSDATE &SYSTIME'
*
         DROP  R9,R10
         USING IERGAPRT,R15
*
         STM   R14,R12,IERGAPS+12  SAVE CALLERS REGS
         DROP  R15
         LR    R9,R15              SET BASE FOR MSG WRITER
         USING IERGAPRT,R9
         LR    R10,R0              R10 -> MSG TEXT
         LR    R11,R1              R11  = L'MSG
*
*        BUFFERING MESSAGES ?
*
         TM    MSGFLAG,MSGNSTOR    NORMAL PROCESSING ?
         BO    GAPRT0              YES, BRANCH
         LM    R6,R7,MSGNEXT       R6 -> NEXT TO USE, R7 -> END OF AREA
         LA    R8,4(R11,R6)        CALC NEXT NEXT TO USE
         CR    R8,R7               ROOM IN AREA FOR MESSAGE ?
         BH    GAPRT0              NO, DISCARD MESSAGE
         ST    R8,MSGNEXT          UPDATE -> NEXT TO USE
         STCM  R11,B'1111',0(R6)   STORE L'MESSAGE
         BCTR  R11,0               DECR FOR MVC
         EX    R11,MSGMVC          MOVE MESSAGE INTO MESSAGE AREA
         B     GAPRTXXX            RETURN TO CALLER
*
*        NORMAL PROCESING
*
GAPRT0   CLC   KIER070,0(R10)      LIST CONTROL STATEMENTS MSG ?
         BNE   GAPRT0A             NO, BRANCH
         CPITEST CPILIST           YES, LIST OF STMTS REQUESTED ?
         BZ    GAPRTXXX            NO, DISCARD MESSAGE
GAPRT0A  LA    R7,SYSOUT           R7 -> SYSOUT DCB
         CLI   3(R10),C'9'         IER9XX DIAGNOSTIC MSG ?
         BE    GAPRTD              YES, PROCESS DIAGNOSTIC MSGS
         CLC   KIER,0(R10)         MSG ID START WITH IER ?
         BNE   GAPRTD              NO, IT MUST BE A DIAGNOSTIC MSG
         CLI   6(R10),C'A'         CRITICAL MSG ?
         BNE   GAPRTI              NO, INFORMATIONAL
*
*        CRITICAL MSG PROCESSING
*
         CPITEST  CPIPCRT+CPIPALL  MESSAGES TO PRINTER ?
         BZ    GAPRT1              NO, BRANCH
         BAS   R8,GAPRTPM          YES, CALL THE PRINT RTN
GAPRT1   CPITEST  CPICCRT+CPICALL  MSGS TO THE CONSOLE ?
         BZ    GAPRT2              NO, BRANCH
         BAS   R8,GAPRTCM          CALL CONSOLE RTN
GAPRT2   B     GAPRT4              BRANCH TO LOG MSG IN SORTDIAG
*
*        INFORMATIONAL MSG PROCESSING
*
GAPRTI   CPITEST  CPIPALL          ALL MSGS TO THE PRINTER ?
         BZ    GAPRT3              NO, BRANCH
         BAS   R8,GAPRTPM          YES, CALL THE PRINT RTN
GAPRT3   CPITEST  CPICALL          ALL MSGS TO THE CONSOLE ?
         BZ    GAPRT4              NO, BRANCH
         BAS   R8,GAPRTCM          CALL CONSOLE RTN
*
*        DIAGNOSTIC MESSAGES
*
*        ALL MESSAGES FLOW THROUGH HERE SO THAT ALL NON
*        DIAGNOSTIC MESSAGES ARE PRINTED ON SORTDIAG (IF
*        REQUESTED) TO ASSIST WITH PROBLEM DIAGNOSIS. IF NON
*        DIAGNOSTIC MESSAGES HAVE ALREADY BEEN PRINTED ON SYSOUT
*        ENSURE THAT THEY ARE NOT DUPLICATED
*
*        NON DIAGNOSTIC MSG ENTRY
*
GAPRT4   CPITEST  CPIDIAG          DIAGNOSTIC MESSAGES BEING WRITTEN
*                                  TO SORTDIAG ?
         BO    GAPRTP              YES, CAPTURE THIS MESSAGE
         B     GAPRTEXT            NO, BRANCH TO EXIT, ALREADY WRITTEN
*
*        DIAGNOSTIC MSG ENTRY
*
GAPRTD   CPITEST  CPIDIAG          PRINTING DIAGNOSTIC MESSAGES ?
         BO    GAPRTP              YES, PRINT
         CPITEST  CPIDSIM          DIAGNOSTIC MESSAGES BEING WRITTEN
*                                  TO SYSOUT ?
         BZ    GAPRTEXT            NO, BRANCH TO EXIT
*                                  YES, CALL SYSOUT PRINT
         LA    R7,SYSOUT           R7 -> SYSOUT DCB
         B     GAPRTPS             BRANCH TO CALL THE PRINT RTN
*
GAPRTP   LA    R7,SORTDIAG         R7 -> SORTDIAG DCB
GAPRTPS  BAS   R8,GAPRTPM          CALL THE PRINT RTN
         B     GAPRTEXT            BRANCH TO EXIT
*
*        WRITE MESSAGES TO PRINTER
*
*        ON ENTRY -
*        R7  -> DCB
*        R8   = RETURN ADDR
*        R9   = BASE
*        R10 -> MESSAGE TEXT
*        R11  = L'MESSAGE TEXT
*
GAPRTPM  LA    R2,L'PRINTL-1       MAXIMUM L'PRINT LINE
         LR    R6,R11              TAKE A COPY OF L'MSG
         CR    R6,R2               L'MSG EXCEED PRINT LINE ?
         BNH   GAPRTPM1            NO, BRANCH
         LR    R6,R2               TRUNCATE MSG TO MSG AREA IN PRINTL
GAPRTPM1 BCTR  R6,0                DECR FOR EX
         EX    R6,PRINTMVC         MOVE MSG INTO PRINT LINE
*
         PUT   (R7),PRINTL         PUT PRINT LINE
*
         BR    R8                  RETURN TO CALLER
*
*        MESSAGES TO CONSOLE
*
*        ON ENTRY -
*        R8   = RETURN ADDR
*        R9   = BASE
*        R10 -> MESSAGE TEXT
*        R11  = L'MESSAGE TEXT
*
GAPRTCM  MVC   WTORCM+4(7),0(R10)  MOVE MESSAGE NO INTO MSG
         MVC   WTORCM+12(L'CPIWTOH),CPIWTOH  MOVE WTO HEADER INTO MSG
         LH    R6,WTORCM           GET L'WTO MSG AREA
         SH    R6,=AL2(4+8+L'CPIWTOH)   R6 = CURR MAX L'MSG AREA
         LR    R5,R11              R5 = CURRENT L'MSG
         SH    R5,=AL2(8)          FIRST 8 BYTES ALREADY IN MSG
         CR    R5,R6               REMAINING TEXT TOO LONG ?
         BNH   GAPRTCM1            NO, BRANCH
         LR    R5,R6               YES, TRUNCATE TO L'MAXIMUM
GAPRTCM1 BCTR  R5,0                DECR LENGTH FOR EX
         EX    R5,GAMOVE           MOVE MSG TEXT INTO WTO
*
         WTO   MF=(E,WTORCM)
*
         BR    R8                  RETURN TO CALLER
*
*        PRINT MESSAGE EXIT PROCESSING
*
GAPRTEXT LH    R1,WTORCM           GET L'MSG AREA
         LA    R0,6                SUB FOR HEADER, FIRST BYTE AND EX
         SR    R1,R0
         MVI   WTORCM+4,C' '       FIRST BLANK
         EX    R1,WTOBLANK         BLANK OUT WTO MSG AREA
         MVI   PRINTL,C' '
         MVC   PRINTL+1(L'PRINTL-1),PRINTL  BLANK PRINT LINE
GAPRTXXX LM    R14,R12,IERGAPS+12  RESTORE CALLERS REGS
         BR    R14                 RETURN TO CALLER
*
*        120 CHARACTER WTO
*
WTORCM   WTO   '                                                       X
                                                                       X
                        ',MF=L,ROUTCDE=11,DESC=7
*
GAMOVE   MVC   WTORCM+4+8+L'CPIWTOH(0),8(R10)  MOVE MSG INTO WTO
WTOBLANK MVC   WTORCM+5(0),WTORCM+4  BLANK MSG AREA
PRINTMVC MVC   PRINTL+1(0),0(R10)    MOVE MSG INTO PRINT LINE PAST ASA
MSGMVC   MVC   4(0,R6),0(R10)        MOVE MESSAGE INTO MESSAGE AREA
*
IERGAPS  DC    18F'0'              MESSAGE WRITER SAVE AREA
*
*        CONSTANTS
*
KF16     DC    F'16'
*
KDIAG    DC    C'DIAG'             EXEC CARD PARM PARAMETER
KBALN    DC    C'BALN'                       ..
KOSCL    DC    C'OSCL'                       ..
KPOLY    DC    C'POLY'                       ..
KCRCX    DC    C'CRCX'                       ..
KCOREQU  DC    C'CORE='                      ..
KAM1EQU  DC    C'AM1='                       ..
KMAINEQU DC    C'MAIN='                      ..
KMAINSIZ DC    C'MAINSIZE='                  ..
KMAX     DC    C'MAX'                        ..
KIER     DC    C'IER'
KIER070  DC    C'IER070'
*
KEXCP    DC    C'EXCPREQ'
KEXCPW   DC    C'EXCPCOMP'
KMODFLOW DC    C'MODFLOW'
*
KMSG     DC    C'MSG'              MESSAGE OPTIONS
KNO      DC    C'NO'               NO MESSAGES
KAP      DC    C'AP'               ALL ON PRINTER
KAC      DC    C'AC'               ALL ON CONSOLE
KCC      DC    C'CC'               CRITICAL ON CONSOLE
KCP      DC    C'CP'               CRITICAL ON PRINTER
KAB      DC    C'AB'               ALL ON BOTH
KCB      DC    C'CB'               CRITICAL ON BOTH
*
KCHECK   DC    X'00010101'         TO CHECK IF TRANSLATED DD LETTERS
*
EPATTERN DC    XL4'40212020'       FORMAT RETURN CODE
*
MODTAB   DC    V(IERRCC),C'RCC '   *   READ CONTROL STMTS
         DC    V(IERRCY),C'RCY '   |   ANALYZE DEBUG CONTROL STMTS
         DC    V(IERRCE),C'RCE '   |   ANALYZE SORT/MERGE CONTROL STMTS
         DC    V(IERRCG),C'RCG '   |   ANALYZE RECORD CONTROL STMTS
         DC    V(IERRCX),C'RCX '   |   ANALYZE OPTIONS CONTROL STMTS
         DC    V(IERRCH),C'RCH '   |   ANALYZE MODS CONTROL STMTS
         DC    A(CMSTOR),C'@@1 '   |   SET STORAGE VALUES (NOT EXT MOD)
         DC    A(CMTLNK),C'@@2 '   |   TEST FOR LKED REQ (NOT EXT MOD)
         DC    V(IERRCI),C'RCI '   |   COLLECT SYSTEM INFORMATION
         DC    V(IERRC2),C'RC2 '   |   CALC OPTIONAL EXTRACT RTN
         DC    V(IERRCN),C'RCN '   |   CALC BIN SIZE
MODTABL  EQU   *-MODTAB            V   L'MODTAB
*
VIERRCK  DC    V(IERRCK),C'RCK '   BALN SORT
VIERRCL  DC    V(IERRCL),C'RCL '
VIERRCP  DC    V(IERRCP),C'RCP '
VIERRCS  DC    V(IERRCS),C'RCS '
VIERBGB  DC    V(IERBGB),C'BGB '   CRCX SORT
VIERRCU  DC    V(IERRCU)           MSG TEXT CSECT
VLCTOUC  DC    V(LCTOUC)           LOWER -> UPPER CASE TR TABLE
*
*        DATA FOR PRINT DUMP OF CPI and CNTL AREA
*
*        CPI TITLE HEADERS
*
IER982   DC    A(IER982I)
         DC    A(IER982X-IER982I)
IER982I  DC    C'IER982I CPI post IER'
IER982M  DC    CL3' '
IER982P  DC    C' Processing'
IER982X  EQU   *
*
IER986   DC    A(IER986I)
         DC    A(IER986X-IER986I)
IER986I  DC    C'IER986I Cntl Stmt area post IER'
IER986M  DC    CL3' '
IER986P  DC    C' processing'
IER986X  EQU   *
*
*        PARAMETER LIST FOR IERFMT
*
IERFMTP  DC    A(0)                START OF AREA TO PRINT
         DC    A(0)                END OF AREA TO PRINT
         DC    A(IERGAPRT)         -> PRINT ROUTINE
*
VIERFMT  DC    V(IERFMT)           -> FORMAT STORAGE ROUTINE
*
CMSAVE   DC    18F'0'              SAVE AREA
*
GETSTOR  DC    0F'0'            *  GETMAIN REQUEST PARAMETER LIST
GETMIN   DC    F'0'             |
GETMAX   DC    F'0'             V
GETRESLT DC    0F'0'            *  GETMAIN RESULT PARAMETER LIST
GETRESA  DC    F'0'             |  -> ALLOCATED STORAGE
GETRECL  DC    F'0'             V  L'ALLOCATED STORAGE
*
AIERRCO  DC    A(0)                IERRCO ADDR
SAVER14  DC    A(0)                FOR RETURN ADDR IN RCO
RETCODE  DC    F'0'                RETURN CODE
CMSWITCH DC    X'00'               CMSWITCH
*
*        MESSAGE STORAGE AREA DATA
*
MSGLEN   DC    F'50000'            L'MESSAGE STORAGE AREA FOR GET/FREE
MSGADDR  DC    A(0)                -> MESSAGE STORAGE AREA
MSGNEXT  DC    A(0)                -> NEXT TO USE MESSAGE STORAGE AREA
MSGEND   DC    A(0)                -> END OF MESSAGE STORAGE AREA
MSGFLAG  DC    X'00'               X'00' = STORE MESSAGES
MSGNSTOR EQU   X'01'               X'01' = NORMAL PROCESSING
*
*        LENGTH OF CONTROL STATEMENT READ IN AND ANALYSIS AREA
*
CNTLAREA DC    F'6044'             6K STORAGE AND ANALYSIS AREA
*
*        PRINT LINE FOR SYSOUT AND SORTDIAG
*
         DC    0F'0'
PRINTL   DC    CL121'1 '           PRINT LINE
*
*        CLOSE LIST
*
CLOSELST CLOSE (,LEAVE,,LEAVE),MF=L
*
         PRINT NOGEN
*
*        SYSOUT DCB
*
SYSOUT   DCB   DSORG=PS,MACRF=(PM),DDNAME=SYSOUT,                      X
               RECFM=FBA,LRECL=121,SYNAD=SYNADDR
*
*        SORTDIAG DCB
*
SORTDIAG DCB   DSORG=PS,MACRF=(PM),DDNAME=SORTDIAG,                    X
               RECFM=FBA,LRECL=121,SYNAD=SYNADDR
*
         PRINT GEN
*
*        MESSAGE TEXT FOR THE SYSOUT AND SORTDIAG SYNAD EXIT
*        IT IS ISSUED BY WTO AS I/O TO THE SYSOUT DATA SET
*        TRIGGERED OFF THE SYNAD EXIT
*
IER061   DC    C'IER061A '         MESSAGE NUMBER
IER061C  DC    C'I/O ERROR'        MESSAGE CONTINUATION
*
*        THIS MESSAGE IS ISSUED BY WTO AS THE OPTIONS MODULE HAS
*        FAILED TO LOAD SO THE MESSAGE WRITER IS NOT INITIALIZED
*
IER069   DC    C'IER069A JJJJJJJJ,SSSSSSSS Module IERAM1 LOAD Failed'
*
*        WORK AREAS
*
WORKD    DC    D'0'
WORKC    DC    D'0'
WTRANS   DC    F'0'
TIOTADDR DC    A(0)                TIOT ADDR FROM EXTRACT SVC
RCMSIZE  DC    F'51200'            ESTIMATED SIZE OF IERCM LOAD MODULE
*                                  USED TO TEST MINIMAL STORAGE AVAIL
*
WERRSW   DC    X'00'               EXEC OR ATTACH PARAMS ERROR SWITCH
WERRSWD  EQU   01                  DUPLICATE TECHNIQUE SPECIFICATION
WERRSWM  EQU   02                  DUPLICATE MESSAGE SPECIFICATION
WERRSWN  EQU   03                  INCORRECT MESSAGE OPTIONS
WERRSWI  EQU   04                  INVALID KEYWORD
WERRSWT  EQU   05                  DUPLICATE STORAGE SPECIFICATION
WERRSWV  EQU   06                  INVALID STORAGE VALUE
WERRSWE  EQU   07                  INVALID ENTRY IN ATTACH PARM LIST
WERRSWL  EQU   08                  ATTACH PARM LIST LENGTH ERROR
*
WMSGSW   DC    X'00'               MESSAGE OPTION SPECIFIED SWITCH
WAM1SW   DC    X'00'               CORE/AM1 VALUE SPECIFIED SWITCH
WAM1SWP  EQU   X'01'               VALUE PROVIDED
WAM1SWK  EQU   X'02'               VALUE PROVIDED AS K
WAM1SWM  EQU   X'04'               VALUE PROVIDED AS M
WDDSW    DC    X'00'               DD LETTERS SPECIFIED SWITCH
*
*        LTORG
*
         LTORG
*
*        TRANSLATE TABLE TO TEST VALIDITY OF DDNAME PREFIX CHARS
*
         ENTRY DDCHECK             MAKE TABLE AVAILABLE TO IERRCX
*
DDCHECK  DC    91X'FF'             TRANSLATE TABLE FOR DD LETTERS
         DC    X'01'               EBCDIC CHARACTER '$'
         DC    31X'FF'             TRANS TABLE CONT
         DC    2X'01'              EBCDIC CHARACTERS '#' AND '@'
         DC    68X'FF'             TRANS TABLE CONT
         DC    9X'00'              EBCDIC LETTERS 'A' THRU 'I'
         DC    7X'FF'              TRANS TABLE CONT
         DC    9X'00'              EBCDIC LETTERS 'J' THRU 'R'
         DC    8X'FF'              TRANS TABLE CONT
         DC    8X'00'              EBCDIC LETTERS 'S' THRU 'Z'
         DC    6X'FF'              TRANS TABLE CONT
         DC    10X'01'             EBCDIC NUMBERS '0' THRU '9'
         DC    6X'FF'              TRANS TABLE CONT
*
*        DAYS IN MONTH AND MONTH ABREVIATION TABLE
*
MNTHTBL  DC    H'31'               JAN DAYS IN MONTH
         DC    C'Jan '                 3 CHAR MONTH CODE
         DC    C'01'                   MONTH NUMBER
         DC    H'29'               FEB
         DC    C'Feb '
         DC    C'02'
         DC    H'31'               MAR
         DC    C'Mar '
         DC    C'03'
         DC    H'30'               APR
         DC    C'Apr '
         DC    C'04'
         DC    H'31'               MAY
         DC    C'May '
         DC    C'05'
         DC    H'30'               JUN
         DC    C'Jun '
         DC    C'06'
         DC    H'31'               JUL
         DC    C'Jul '
         DC    C'07'
         DC    H'31'               AUG
         DC    C'Aug '
         DC    C'08'
         DC    H'30'               SEP
         DC    C'Sep '
         DC    C'09'
         DC    H'31'               OCT
         DC    C'Oct '
         DC    C'10'
         DC    H'30'               NOV
         DC    C'Nov '
         DC    C'11'
         DC    H'255'              DEC (ALLOW FOR STUPID DDD)
         DC    C'Dec '
         DC    C'12'
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
*        IERAM1
*
DIERAM1  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERAM1 SOURCE
*
*----------------------------------------------------------------------
*
         COPY IERAM1I
*
DIERRCU  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRCU SOURCE
*
*----------------------------------------------------------------------
*
         COPY IERRCUI
*
         PRINT NOGEN
*
*        MAP TIOT
*
TIOT     DSECT
*
         IEFTIOT1
*
*        DCB DSECT
*
         DCBD  DSORG=PS,DEVD=(DA)
*
         PRINT GEN
*
         SMCPI
*
         END
./ ADD NAME=IERRCN   0101-20211-20211-1200-00313-00313-00000-RELEASE 00
RCN      TITLE 'IERRCN - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRCN
*
*        MODULE FUNCTION/OPERATION -
*        CALCULATE THE SIZE OF THE BINS TO BE USED FOR ALL
*        RECORDS IN THE RECORD STORAGE AREA, DURING THIS SORT
*        RUN. THIS IS DONE BY USING INFORMATION PROVIDED BY
*        THE USER OR OBTAINED FROM THE SYSTEM. THIS INFORMATION
*        CONSISTS OF THE EXTRACTION SIZE FOR FIXED LENGTH
*        RECORDS. FOR VARIABLE LENGTH RECORDS IT CONSISTS OF
*        MAXIMUM, MODAL AND MINIMUM RECORD LENGTHS AS WELL AS
*        EXTRACTION SIZE.
*        BASED ON THE NUMBER OF SORTWK DATA SETS AND USER REQUESTED
*        TECHNIQUE THE TECHNIQUE FLAGS ARE SET FOR THE SORT. IF THE
*        USER REQUESTED TECHNIQUE IS NOT SUPPORTED BY THE NUMBER
*        OF SORTWK DATA SETS FOUND/ALLOCATED THEN THE USER SELECTION
*        IS OVERRIDDEN.
*        SEE SORT/MERGE MANUAL FOR THE RULES
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACROS USED - SMCPI
*
*        ENTRY POINTS - ENTRY FROM IERRCM
*                       CALLING SEQUENCE -
*                       L     R15,=V(IERRCN)
*                       BALR  R14,R15
*
*        INPUT - CPI FIELDS REFERENCED -
*        CPICNTL  CPIRCDL4   CPIRCDL5
*        CPIRCFL2 CPINUMCF   CPIPCF01
*
*        OUTPUT - CPI FIELDS INITIALIZED OR ALTERED - CPIBINSZ
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXIT - NORMAL - BR R14 - RETURN TO CALLER
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS -
*        WDBS12 - SAVE AREA FOR R12
*
*        NOTES -
*        THIS MODULE CALCULATES BIN SIZE FOR ALL SORTS BUT EXITS
*        IMMEDIATELY ON A MERGE ONLY
*
IERRCN   CSECT
*
         USING *,R11
         USING IERRC5,R13          CPI
*
         IERENTRY 'IERRCN &SYSDATE &SYSTIME'
*
         STM   R2,R11,0(R12)       SAVE REGISTERS 2-11
         LR    R11,R15             R15 LOADED BY CALLING ROUTINE
         CPITEST  CPIMERGO         MERGE ONLY ?
         BO    RCNEXIT1            YES, EXIT
         CPITEST  CPIFIX           FIXED LENGTH RECORDS ?
         BO    RCNFIXED            YES, BRANCH
*
*        VARIABLE LENGTH RECORD SUBROUTINE
*
         BAS   R9,RCNLPMIN         GO CALCULATE L'MIN
         LH    R2,CPIRCDL4         LOAD L MIN
         LH    R3,CPIRCDL5         LOAD L MODE
         CH    R4,KTWOHUND         COMPARE L'MIN TO 200
         BNL   RCNEXTR             L'MIN WAS = OR GREATER THAN 200
         CH    R2,KTWOHUND         COMPARE L MIN TO 200
         BH    RCNMORE             L MIN WAS GREATER THAN 200
         CH    R3,KTWOHUND         COMPARE L MODE TO 200
         BL    RCNLESS             L MODE WAS LESS THAN 200
RCNMORE  LH    R4,KTWOHUND         SET L'MIN = 200
         B     RCNEXTR             GO CHECK FOR EXTRACTING
*
RCNLESS  LR    R4,R2               SET L'MIN =L MIN
RCNEXTR  LA    R10,RCNBKEXT        SET UP RETURN REG
         CPITEST  CPIEXTRT         EXTRACT ?
         BO    RCNEXYES            YES, BRANCH
         LR    R5,R4
         LA    R5,8(,R5)           Z MIN=L'MIN+8
         LR    R6,R3
         LA    R6,11(,R6)          R6=L MODE+11
         N     R6,KDBAND           Z MODE ROUNDED FULL
         LH    R7,CPIRCDL2         LOAD L MAX
         LA    R7,11(,R7)
         N     R7,KDBAND           Z MAX=L MAX+8 ROUNDED FULL
         B     RCNCONT             ROUTINE FOR NO EXTRACTING COMPLETE
*
RCNBKEXT LR    R5,R9
         AR    R5,R4
         LA    R5,8(,R5)           Z MIN=EXT SIZE+L'MIN+8
         LR    R6,R9               CALCULATE Z MODE
         AR    R6,R3
         LA    R6,11(,R6)
         N     R6,KDBAND           Z MODE=EXT SIZE+L MODE+8 ROUNDED FUL
         LR    R7,R9               CALCULATE Z MAX
         AH    R7,CPIRCDL2
         LA    R7,11(,R7)
         N     R7,KDBAND           Z MAX=EXT SIZE+L MAX+8 ROUNDED FULL
*
*        REGISTERS R2, R3 AND R4 ARE NOW FREE SINCE L MIN, L MODE
*        AND L'MIN ARE NO LONGER NEEDED
*
RCNCONT  CH    R7,KONEHUND         COMPARE Z MAX TO 100
         BH    RCNHIMAX            Z MAX IS GREATER THAN 100
         CH    R6,KEIGHTY          COMPARE Z MODE TO 80
         BL    RCNLOMOD            Z MODE LESS THAN 80
         STH   R7,CPIBINSZ         STORE Z MAX IN BIN SIZE
         B     RCNTECH             GOTO DETERMINE SORT TECHIQUE
*
RCNHIMAX CH    R6,KEIGHTY          COMPARE Z MODE TO 80
         BH    RCNHIMOD            Z MODE IS GREATER THAN 80
RCNLOMOD STH   R6,CPIBINSZ         STORE Z MODE IN BIN SIZE
         B     RCNTECH             GOTO DETERMINE SORT TECHIQUE
*
RCNHIMOD LR    R8,R6               Z=Z MODE
         LA    R4,2                K=2
RCNRECAL LR    R3,R4               PUT K IN R3
         BCTR  R3,0                SUBTRACT 1
         SLA   R3,2                TIMES 4
         AR    R3,R6               + Z MODE
         SR    R2,R2               MAKE R2=0
         DR    R2,R4               DIVIDE BY K
         LA    R3,3(,R3)
         N     R3,KDBAND           ROUND TO FULL WORD
         LR    R10,R3              SAVE IN T
         CR    R10,R5              COMPARE T TO Z MIN
         BL    RCNSTORZ            T WAS LOWER
         CH    R10,KEIGHTY         COMPARE T TO 80
         BL    RCNSTORZ            T WAS LOWER
         BE    RCNSTORT            T=80
         LA    R4,1(,R4)           INCREMENT K BY 1
         LR    R8,R10              SET Z=T
         B     RCNRECAL            GO RECALCULATE WITH A NEW K
*
RCNSTORT STH   R10,CPIBINSZ        STORE T IN BIN SIZE
         B     RCNTECH             GOTO EXIT
*
RCNSTORZ STH   R8,CPIBINSZ         STORE Z IN BIN SIZE
*
*        SELECT THE SORTING TECHNIQUE TO BE USED ON DASD BASED
*        ON THE NUMBER OF SORTWORK AREAS AVAILABLE
*        ANY USER REQUEST WILL BE OVERRIDDEN IF THE REQUESTED
*        TECHNIQUE DOES NOT CONFORM TO THE NUMBER OF SORKWORK
*        AREAS REQUIRED TO IMPLEMENT THE TECHNIQUE
*        SEE SORT/MERGE MANUAL FOR THE RULES
*
RCNTECH  CPITEST  CPI2314          DISK SORT WORK AREAS ?
         BZ    RCNEXIT1            NO, BRANCH
         CLC   CPINWKU,KH6         SIX WORK AREAS ?
         BL    RCN300              < SIX, BRANCH
         BH    RCN400              > SIX, BRANCH
*
*        SIX SORT WORK AREAS
*        CRCX MAY BE USED IF SELECTED BY THE USER
*        DEFAULT IS BALN
*
         CPITEST  CPICRCX          CRCX REQUESTED BY USER ?
         BNO   RCN300              NO,  EXIT
         CPISETOF CPICRCX          SET OFF CRCX
         B     RCNEXIT1
*
*        LESS THAN 6 SORT WORK AREAS
*        FORCE BALN TECHNIQUE
*
RCN300   CPISETON CPIBALN          FORCE BALN TECNIQUE
         CPISETOF CPICRCX          SET OFF CRCX
         CPISETOF CPI2314
         CPISETON CPIDISK          SET IND FOR 2314
         CPISETON CPIVALCT
         B     RCNEXIT1
*
*        MORE THAN 6 SORT WORK AREAS
*        FORCE CRCX TECHNIQUE
*
RCN400   CPISETON CPICRCX
         CPISETOF CPIBALN

*        RETURN TO CALLER
*
RCNEXIT1 SR    R15,R15
         LM    R2,R11,0(R12)       RESTORE REGISTERS 2-11
         BR    R14                 EXIT
*
*        CALCULATE L'MIN THE PORTION OF THE RECORD IN WHICH ALL
*        THE CONTROL FIELDS ARE CONTAINED
*
RCNLPMIN ST    R12,WDBS12          SAVE R12
         LH    R10,CPINUMCF        GET NUMBER OF CONTROL FIELDS (Q)
         CH    R10,K12             NO OF CONTROL FIELDS > 12 ?
         BH    RCNR05              YES, BRANCH
         LA    R12,CPIPCF01-6      GET STARTING ADDR OF CONTROL FLDS
RCNDB3   SR    R4,R4               CLEAR L'MIN
RCNDB001 LA    R12,6(,R12)         AFD = AFD + 6
         SR    R3,R3               CLEAR E'
         IC    R3,4(,R12)          GET L(BITS)
         SR    R2,R2               CLEAR R2
         IC    R2,2(,R12)          GET D(BITS)
         LA    R3,7(R2,R3)         K = L(BITS) + D(BITS) + 7
         SRL   R3,3                K = K/8
         STC   R3,RCNCG029+3       PUT K IN INSTRUCTION BELOW
         CLI   3(R12),255          L(BYTES) = 255 ?
         BNE   RCNCG030            NO, BRANCH
         CLI   4(R12),0            L(BITS) = 0 ?
         BE    RCNCG030            YES, BRANCH
         SR    R3,R3               CLEAR R3
         B     RCNCG029-4          BRANCH TO GET D(BYTES)
*
RCNCG030 IC    R3,3(0,R12)         GET L(BYTES)
         LA    R3,1(,R3)           L(BYTES) = L(BYTES) + 1
         LH    R2,0(,R12)          GET D(BYTES)
RCNCG029 LA    R3,0(R2,R3)         E' = K + D(BYTES) + L(BYTES)
         CR    R3,R4               COMPARE E' TO L'MIN
         BNH   RCNDB002            IF LESS THAN OR EQUAL TAKE BRANCH
         LR    R4,R3               L'MIN = E'
RCNDB002 BCT   R10,RCNDB001        Q = Q - 1, IF NOT 0 TAKE BRANCH
         LA    R4,3(,R4)           L'MIN = L'MIN + 3
         N     R4,KDBAND           ROUND TO A FULL WORD
         L     R12,WDBS12          RESTORE REGISTER 12
         BR    R9                  RETURN
*
RCNR05   MVC   WRK+1(3),CPIADDCF
         L     R12,WRK             ACCESS CONTROL FIELD INFORMATION
         SH    R12,KH6
         B     RCNDB3              GOTO CALC L'MIN
*
*        CALCULATE THE SIZE OF THE EXTRACTED FIELD
*
RCNEXYES SR    R9,R9               CLEAR R9 FOR SIZE OF CONTROL FIELD
         LH    R7,CPINUMCF         LOAD NUMBER OF CONTROL FIELDS IN R7
         CH    R7,K12              NO CONTROL FIELDS > 12 ?
         BH    RCNR105             YES, BRANCH
         LA    R8,CPIPCF01         ADDR OF 1ST CONTROL FIELD IN R8
RCNROUT  SR    R6,R6               CLEAR R6 FOR BYTE PORTION OF LENGTH
         IC    R6,3(,R8)           BYTE PORTION OF L'CF
         CLI   5(R8),X'18'         CF UNPACKED DECIMAL ASCENDING ?
         BE    RCNR1               YES, BRANCH
         CLI   5(R8),X'1C'         CF UNPACKED DECIMAL DESCENDING ?
         BNE   RCNR2               NO, BRANCH
RCNR1    LA    R6,1(,R6)           INCREMENT BY 1 BYTE
         CLI   3(R8),16            > 16 BYTES ?
         BL    *+8                 NO, BRANCH
         LA    R6,1(,R6)           INCREMENT BY ONE BYTE
         SRL   R6,1                DIVIDE BY 2
         B     RCNSKIP             CF IS UNPACKED DECIMAL
*
RCNR105  MVC   WRK+1(3),CPIADDCF
         L     R8,WRK
         B     RCNROUT             GO CALC EXTRACT SIZE ROUTINE
*
RCNR2    SLL   R6,3                MULTIPLY BY 8
         SR    R5,R5               ZERO R5
         IC    R5,4(,R8)           BITS PORTION OF L'CF
         AR    R6,R5               TOTAL THE BITS
         IC    R5,2(,R8)           BITS PORTION OF DISPLACEMENT OF CF
         AR    R6,R5
         LA    R6,7(,R6)           ROUND OFF
         SRL   R6,3                DIVIDE BY 8
RCNSKIP  LA    R6,1(,R6)           INCR BY 1 BYTE FOR ACTUAL DISPL
         CLI   3(R8),255           LENGTH IN BYTES = 255 ?
         BNE   RCNADDEX            NO, BRANCH
         CLI   4(R8),0             YES, LENGTH IN BITS = 0 ?
         BE    RCNADDEX            YES, CF IS ACTUALLY 256 BYTES LONG
         LA    R5,256              NO, CF IS ACTUALLY LESS THAN 1 BYTE
         SR    R6,R5
RCNADDEX AR    R9,R6               INCR DISPL IN EXTRACTED PORTION LEN
         LA    R8,6(,R8)           GET NEXT CONTROL FIELD
         BCT   R7,RCNROUT          LAST CONTROL FIELD
         LA    R9,3(,R9)
         N     R9,KDBAND           ROUND TO FULL WORD
         BR    R10                 RETURN
*
*        FIXED LENGTH RECORD SUBROUTINE
*
RCNFIXED SR    R9,R9               SET PSIZE=0
         CPITEST  CPIEXTRT         EXTRACT REQUIRED ?
         BZ    RCNEXTNO            NO, BRANCH
         LA    R10,RCNEXTNO        SET UP RETURN REG
         B     RCNEXYES            BRANCH TO EXTRACT SIZE ROUTINE
*
RCNEXTNO LA    R9,4(,R9)           ADD 4 TO PSIZE
         LH    R6,CPIRCDL2         SET RCDSZ = LENGTH OF RECORD
         LA    R6,3(,R6)
         N     R6,KDBAND           ROUND TO FULL WORD
         AR    R6,R9               PSIZE + RCDSZ
         STH   R6,CPIBINSZ         STORE IN BIN SIZE
         B     RCNTECH             SET UP TO EXIT
*
*        CONSTANTS
*
KTWOHUND DC    H'200'
KONEHUND DC    H'100'
KEIGHTY  DC    H'80'
KH6      DC    H'6'
K12      DC    H'12'
         DC    0F'0'
KDBAND   DC    X'FFFFFFFC'         USED TO ROUND TO FULLWORD BOUNDARIES
WDBS12   DC    F'0'                R12 SAVE AREA
WRK      DC    A(0)                CONTROL FIELD ADDR
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMCPI
*
         END
./ ADD NAME=IERRCO   0101-20211-20211-1200-00134-00134-00000-RELEASE 00
RCO      TITLE 'IERRCO - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRCO
*
*        MODULE FUNCTION/OPERATION -
*        INITIAL SORT MODULE INVOKED VIA THE SCHEDULER (JCL) OR
*        VIA LINK/XCTL/ATTACH ISSUED BY AN EXECUTING PROGRAM.
*        IERRCO LINKS TO IERRCM FOR SORT DEFINITION AND EXITS TO
*        CALLER IF AN ERROR OCCURS. IF THE CALLER (JCL OR
*        PROGRAM) HAS REQUESTED USER MODIFICATION EXIT PROCESSING
*        AND THE EXIT(S) ARE PROVIDED VIA OBJECT DECKS THEN
*        IERRCO LINKS TO THE LINKAGE EDITOR TO CONVERT THE OBJECT
*        DECKS INTO LOAD MODULE(S) PRIOR TO EXECUTION. IERRCO
*        THEN TRANSFERS CONTROL TO THE CONTROL MODULE IERRCB
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACROS USED -
*        XCTL    LINK
*        SMCPI   GETMAIN
*
*        ENTRY POINTS - ENTRY IERRCO ENTRY FROM USER
*                       CALLING SEQUENCE -
*                       EXEC   PROC=SORT (RCO = SORT)
*                       ATTACH EP=SORT (ETC)
*                       LINK   EP=SORT (ETC)
*                       XCTL   EP=SORT (ETC)
*
*        INPUT - CPI FIELDS REFERENCED -
*                CPILINK
*
*        OUTPUT - CPI FIELDS INITIALIZED OR ALTERED -
*                 CPILINK
*
*        EXTERNAL ROUTINES - IERRCM - SORT SYSTEM DEFINITION
*                            IERRCB - SORT SYSTEM CONTROL
*
*        EXTERNAL PARAMETERS - NONE
*
*        EXITS - NORMAL
*        XCTL EP=IERRCB - SORT SYSTEM
*
*        EXITS - ERROR
*        XCTL EP=IERRCB - SORT SYSTEM
*
*        TABLES/WORK AREAS - NONE
*
*        NOTES -
*        THIS PROGRAM IS LINK EDITED WITH AN ALIAS OF SORT
*
IERRCO   CSECT
*
         USING IERRCO,R8           R8 FOR MODULE ADDRESSABLITY
*
         SAVE  (14,12),,'IERRCO &SYSDATE &SYSTIME'
*
         LR    R8,R15              SET BASE ADDR
         LA    R0,CPILEN           SET L'CPI
         LR    R3,R0               COPY L'CPI
*
         GETMAIN R,LV=(0)          GETMAIN THE CPI
*
         LR    R2,R1               R2 -> GETMAINED AREA
         SR    R15,R15             PAD CHAR AND L'SOURCE = ZERO
         MVCL  R2,R14              ZERO GETMAINED CPI
         ST    R1,8(,R13)          SAVE CALLERS SAVE AREA ADDR
         ST    R13,4(,R1)          SAVE SORT'S SAVE AREA ADDR
         LR    R13,R1              SET CPI BASE ADDR REGISTER
         USING IERRC5,R13          R13 -> CPI
         MVCIN CPIEYEC,EYECATCH+L'EYECATCH-1
*
         LINK  EP=IERRCM           LINK TO SORT DEFINITION PHASE
*
         LTR   R15,R15             ERROR DETECTED ?
         BNZ   COERROR             YES, ERROR RETURN TO USER
         TM    CPILINK+2,X'08'     LINK EDIT REQUIRED BY USER ?
         BZ    CO004               NO, SET UP FOR NORMAL RCB EXIT
*
         LINK  EP=LINKEDIT,PARAM=(CMPARM),VL=1
*
         CH    R15,=H'12'          LINKEDIT SEVERITY OK ?
         BL    CO004               YES, SET UP FOR NORMAL RCB EXIT
         OI    CPILINK+2,X'02'     SET MESSAGE REQUEST AND LET THE
*                                  TERMINATION OCCUR IN IERRCZ THAT
*                                  IS CALLED BY IERRCB
CO004    LR    R1,R13              R1 - > CPI
         L     R13,4(,R13)
         LM    R2,R12,28(R13)
         L     R14,12(,R13)        RESTORE REGS EXCEPT R0, R1, R15
*
         DROP  R8
         BASR  R15,0
         USING *,R15
*
         XCTL  EP=IERRCB           TRANSFER CONTROL TO IERRCB
*
         DROP  R15
*
         USING IERRCO,R8           RESTORE R8
*
*        ERROR RETURN
*
*        R15 - POSITIVE, RETURN CODE
*            - NEGATIVE ABEND CODE
*
COERROR  LTR   R1,R15              ABEND OR COMPLETION CODE ?
         BP    COERROR1            COMPLETION CODE, BRANCH
         LPR   R1,R1               MAKE ABEND CODE POSITIVE
*
         ABEND (1)
*
COERROR1 L     R13,4(,R13)
*
         RETURN (14,12),RC=(15)
*
EYECATCH DC    CL8'    AIPC'       CPIA EYE CATCHER FOR MVCIN
*
*        PARAMETER LIST FOR LINKAGE EDITOR
*
CMPARM   DC    AL4(L'CMPARMS)
CMPARMS  DC    C'NCAL,LET,LIST,MAP'
         DC    XL16'00'            ALLOW FOR ADDITIONAL PARMS TO BE
*                                  ZAPPED IN IF REQUIRED
         LTORG
*
*        REGISTER EQUATES
*
         IEZREGS
*
*        CPIA
*
         SMCPI LIST=Y
*
         END
./ ADD NAME=IERRCP   0101-20211-20211-1200-00310-00310-00000-RELEASE 00
RCP      TITLE 'IERRCP - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRCP
*
*        MODULE FUNCTION/OPERATION -
*        CREATE A SYSLIN LIST OF CONTROL STMTS FOR THE LINKAGE
*        EDITOR
*        IT PROCEEDS THROUGH THE MODS TABLE CHECKING FOR USER
*        MODS WHICH REQUIRE LINK EDITING AND CREATES A SERIES OF
*        CONTROL STATEMENTS WRITTEN TO DEPENDING UPON THE
*        INFORMATION OBTAINED FROM THE CONTROL AREA. THE SYSLIN
*        STATEMENTS ARE THEN PROCESSED BY THE LINKAGE EDITOR.
*        THIS MODULE IS ONLY EXECUTED IF THE USER SPECIFIES MODS
*        THAT REQUIRE LINK EDITING
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACROS USED -
*        SMCPI
*        DCB
*        WRITE
*        CHECK
*        OPEN
*        CLOSE
*
*        ENTRY POINTS - ENTRY IERRCP - ENTRY FROM - IERRCM
*                                      CALLING SEQUENCE -
*                                      L     15,V(IERRCP)
*                                      BALR  14,15
*
*        INPUT - PPI FIELDS REFERENCED -
*        CPICNTL - TEST FOR MERGE ONLY
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED - N/A
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL - IERRCM WITH ZERO IN R15
*
*        EXITS - ERROR - IERRCM WITH FOUR IN R15
*
*        TABLES/WORK AREAS -
*        CONTROL AREA CONTAINS THE MODS TABLE AS SET UP BY IERRCH
*        RCPAREA IS WRITE OUT AREA
*
*        NOTES - N/A
*
IERRCP   CSECT
*
         USING IERRC5,R13
         USING *,R11               PROGRAM BASE
*
         IERENTRY 'IERRCP &SYSDATE &SYSTIME'
*
         STM   R2,R11,0(R12)       SAVE REGISTERS 2-11
         LR    R11,R15             SET PROGRAM BASE
         ST    R12,RCPSAVE         SAVE R12
         ST    R14,RCPSAVE1        SAVE R14
*
         OPEN  (SYSLIN,(OUTPUT,REREAD))  OPEN SYSLIN FOR OUTPUT
*
*        CHECK IF THE OPEN WAS SUCCESSFUL
*
         LTR   R15,R15             OPEN SUCCESSFUL ?
         BZ    RCPINIT             YES, BRANCH
         L     R4,VIERRCU          SET ADDRESSABILITY FOR IERRCU
         USING DIERRCU,R4
         MVC   IER063A,IER063E     MOVE SYSLIN DDNAME INTO MSG
         LM    R0,R1,IER063        IER063A - OPEN ERROR
         L     R15,VGAPRT
         BASR  R14,R15             CALL PRINT MESSAGE RTN
         DROP  R4
         LA    R15,4               SET ERROR CODE IN R15
         L     R12,RCPSAVE
         L     R14,RCPSAVE1        RESTORE SAVED REGISTERS
         LM    R2,R11,0(R12)
         BR    R14                 RETURN TO IERRCM
*
*        INITIALIZE POINTERS FOR PHASE1 MODS SEARCH
*
RCPINIT  LA    R2,32               INITIALIZE INCREMENT
         L     R9,CPIACNTL         INITIALIZE CURRENT ENTRY POINTER
         LA    R3,160(,R9)         INITIALIZE PTR TO LAST PH1 ENTRY
         LA    R12,KCONST1         SET PTR TO PH1 IMAGE LIST
         MVI   RCPRESW,0           TURN RESOLVE SWITCH OFF
         BAS   R14,CPSEARCH        CALL SEARCH SUBROUTINE
*
         CPITEST  CPIMERGO         MERGE ONLY ?
         BO    RCPPH3              YES, BRANCH
*
*        INITIALIZE POINTERS FOR PHASE2 SEARCH
*
         L     R9,CPIACNTL
         LA    R9,192(,R9)         INITIALIZE CURRENT ENTRY POINTER
         LA    R3,128(,R9)         INITIALIZE PTR TO LAST PH2 ENTRY
         LA    R12,KCONST2         SET PTR TO PH2 IMAGE LIST
         MVI   RCPRESW,0           TURN RESOLVE SWITCH OFF
         BAS   R14,CPSEARCH        CALL SEARCH SUBROUTINE
*
*        INITIALIZE POINTERS FOR PHASE3 SEARCH
*
RCPPH3   L     R9,CPIACNTL
         LA    R9,352(,R9)         INITIALIZE CURRENT ENTRY POINTER
         LA    R3,128(,R9)         INITIALIZE PTR TO LAST PH3 ENTRY
         LA    R12,KCONST3         SET PTR TO PH3 IMAGE LIST
         MVI   RCPRESW,0           TURN RESOLVE SWITCH OFF
         BAS   R14,CPSEARCH        CALL SEARCH SUBROUTINE
*
*        HOUSEKEEPING BEFORE RETURNING TO IERRCM
*
         CLOSE (SYSLIN)
*
         SR    R15,R15
CPLEAVE  L     R12,RCPSAVE         RESTORE R12
         L     R14,RCPSAVE1
         LM    R2,R11,0(R12)
         BR    R14                 RETURN TO IERRCM
*
*        PERFORM MODS CHECKING TO DETERMINE IF LINK EDITING IS
*        REQUIRED. IT USES THE POINTERS PROVIDED IN THE MAIN
*        ROUTINE
*
CPSEARCH ST    R14,RCPSAVE2
CPSRCH1  CLI   7(R9),3             ACTIVE BYTE 03 (LINK EDIT
*                                  WITH OTHER 03'S IN THIS PHASE) ?
         BNE   RCP05               NO, TAKE BRANCH
         CLI   RCPRESW,1           YES, RESOLVE SWITCH ON ?
         BNE   RCPONIT             NO, BRANCH
*
RCPBYTE1 CLI   12(R9),0            FIRST BYTE OF MOD NAME ZERO
*                                  (SET BY RCH IF SAME AS OTHER MOD
*                                  IN SAME PHASE) ?
         BE    RCPEND              YES, BRANCH
         BAS   R10,RCPMOVE         NO, CALL MOVE ROUTINE
         B     RCPEND
*
RCPONIT  MVI   RCPRESW,1           TURN ON RESOLVE SWITCH
         MVC   KINCLUDE+8(32),RCPAREA+40   BLANK INCLUDE IMAGE
         MVC   KINCLUDE+9(15),31(R12)      MOVE PROPER  IEREX- INTO
*                                    INCLUDE IMAGE
         MVC   RCPAREA(40),KINCLUDE  MOVE INCLUDE IMAGE TO WRITE AREA
         BAS   R5,RCPWRITE           CALL WRITE SUBROUTINE
         B     RCPBYTE1
*
*        CHECK THE ACTIVE BYTE FOR 05 AND IF IT IS, WRITES THE
*        PROPER CONTROL IMAGES ONTO SYSLIN
*
RCP05    CLI   7(R9),X'05'         ACTIVE BYTE X'05' ?
         BNE   RCPEND              NO, BRANCH
*
         MVC   KINCLUDE+8(32),RCPAREA+40   BLANK INCLUDE IMAGE
         MVC   KINCLUDE+9(15),31(R12)    MOVE IEREX- INTO INCLUDE IMAGE
         MVC   RCPAREA(40),KINCLUDE   MOVE INCLUDE IMAGE TO WRITE AREA
         BAS   R5,RCPWRITE         CALL WRITE INCLUDE IEREX-
*
         BAS   R10,RCPMOVE         CALL MOVE AND WRITE INCLUDE MOD
*
         MVC   RCPAREA(40),RCPAREA+40   BLANK OUT WRITE AREA
         MVC   RCPAREA(13),0(R12)  MOVE ENTRY IMAGE TO WRITE AREA
         BAS   R5,RCPWRITE         WRITE ENTRY IMAGE
         MVC   RCPAREA(40),RCPAREA+40  BLANK OUT WRITE AREA
         MVC   RCPAREA(9),22(R12)  MOVE NAME IMAGE INTO WRITE AREA
         BAS   R5,RCPWRITE         WRITE NAME IMAGE
*
RCPEND   BXLE  R9,R2,CPSRCH1       END OF MODS FOR THE PHASE, NO BRANCH
*
*        CHECK E61 AND ACT ACCORDINGLY
*
         L     R9,CPIACNTL
         LA    R9,512(,R9)         SET CURRENT POINTER TO E61 ENTRY
         CLI   7(R9),X'03'         E61 TO BE LINK EDITED ?
         BNE   RCPRESOL            NO, BRANCH
         CLI   RCPRESW,X'01'       YES, RESOLVE SWITCH ON ?
         BE    RCPMV1              YES, BRANCH
         MVC   KINCLUDE+8(32),RCPAREA+40   BLANK INCLUDE IMAGE
         MVC   KINCLUDE+9(15),31(R12)   MOVE IEREX- INTO INCLUDE IMAGE
         MVC   RCPAREA(40),KINCLUDE   MOVE INCLUDE IMAGE TO WRITE AREA
         BAS   R5,RCPWRITE         CALL WRITE INCLUDE IMAGE
RCPMV1   BAS   R10,RCPMOVE         CALL MOVE AND WRITE MOD NAME
RCPWR1   MVC   RCPAREA(40),RCPAREA+40   BLANK WRITE AREA
         MVC   RCPAREA(13),0(R12)  MOVE ENTRY IMAGE TO WRITE AREA
         BAS   R5,RCPWRITE         CALL WRITE ENTRY IMAGE
         MVC   RCPAREA(40),RCPAREA+40   BLANK WRITE AREA
         MVC   RCPAREA(9),13(R12)  MOVE NAME IMAGE INTO WRITE AREA
         BAS   R5,RCPWRITE         CALL WRITE NAME IMAGE
         B     RCPRET              GOTO RETURN FROM CPSEARCH
*
RCPRESOL CLI   RCPRESW,X'01'       RESOLVE SWITCH ON ?
         BE    RCPWR1              YES, GOTO RCPWR1
RCPRET   L     R14,RCPSAVE2
         BR    R14                 NO, RETURN TO MAIN LINE
*
*        RCPMOVE
*
*        SUBROUTINE TO MOVE THE MOD NAME AND SOURCE INTO THE
*        INCLUDE IMAGE AND LINK TO THE WRITE SUBROUTINE TO WRITE
*        THE INCLUDE IMAGE
*
RCPMOVE  MVC   KINCLUDE+8(32),RCPAREA+40  BLANK INCLUDE IMAGE
*
*        SET A FIRST TIME SWITCH BY MAKING RCPSWT1 A NOP
*
         NI    RCPSWT1+1,X'0F'     SET SWITCH OFF
         LA    R8,8                SET UP COMPARAND
         LA    R5,24(,R9)          INITIALIZE PTR (R5) TO MOD SOURCE,
         LA    R6,KINCLUDE+9       AND R6 TO INCLUDE IMAGE
CPZERORG SR    R7,R7               ZERO R7
CPISITFF CLI   0(R5),X'FF'         CHAR A TERMINATING CHARACTER ?
         BE    CPMODMV             YES, BRANCH
         LA    R7,1(0,R7)          NO, ADD 1 TO CHARACTER COUNT
         CR    R7,R8               HAVE 8 CHARACTERS BEEN CHECKED ?
         BE    CPFUDGE             YES, BRANCH
         LA    R5,1(,R5)           NO, INCR CHARACTER POINTER
         B     CPISITFF            GOTO CHECK NEXT CHARACTER
*
*        MOVE THE NAMES INTO THE INCLUDE IMAGE
*
CPFUDGE  LA    R5,1(,R5)           ADD 1 TO PTR FOR 8 CHARACTER NAME
CPMODMV  SR    R5,R7               REINITIALIZE NAME POINTER
         BCTR  R7,0                STORE LENGTH INTO MOVE
         STC   R7,*+5              INSTRUCTION WHICH FOLLOWS
         MVC   0(0,R6),0(R5)       MOVE NAME INTO INCLUDE CARD IMAGE
*
*        THE FOLLOWING INSTRUCTION IS A FIRST TIME SWITCH. FIRST
*        TIME IT IS EXECUTED, IT IS A NOP. IT IS THEN CHANGED
*        TO AN UNCONDITIONAL BRANCH
*
RCPSWT1  NOP   RCPRPAR             FIRST TIME SWITCH
         LA    R6,1(R6,R7)         UPDATE IMAGE POINTER (R6)
         MVI   0(R6),C'('          MOVE RIGHT PARENT INTO INCLUDE IMAGE
         OI    RCPSWT1+1,X'F0'     SET FIRST TIME SWITCH TO
*                                  UNCONDITIONAL BRANCH
         LA    R6,1(,R6)           UPDATE IMAGE POINTER
         LA    R5,12(,R9)          SET R5 TO NAME
         B     CPZERORG            RETURN TO ZERO R7
*
RCPRPAR  LA    R6,1(R6,R7)         UPDATE IMAGE POINTER
         MVI   0(R6),C')'          MOVE RIGHT PARENT INTO IMAGE
         MVC   RCPAREA(40),KINCLUDE  MOVE INCLUDE IMAGE TO WRITE AREA
         BAS   R5,RCPWRITE         CALL WRITE INCLUDE IMAGE
         BR    R10                 RETURN TO CALLER
*
*        RCPWRITE
*
*        SUBROUTINE TO WRITE AND CHECK 80 CHARACTERS FROM
*        RCPAREA
*
RCPWRITE WRITE DECB,SF,SYSLIN,RCPAREA,80    WRITE CARD IMAGE
*
         CHECK DECB                CHECK WRITE FOR COMPLETION
*
         BR    R5                  RETURN TO CALLER
*
CPSYNAD  CLOSE (SYSLIN)
*
         LA    R15,4               SET ERROR CODE IN R15
         B     CPLEAVE             GOTO EXIT
*
*        PROGRAM CONSTANTS, DCB, AND WORKAREAS
*
SYSLIN   DCB   DSORG=PS,MACRF=(W),DDNAME=SYSLIN,LRECL=80,BLKSIZE=80,   X
               RECFM=F,SYNAD=CPSYNAD
*
RCPSAVE  DC    F'0'                R12 SAVE AREA
RCPSAVE1 DC    F'0'                R14 SAVE AREA
RCPSAVE2 DC    F'0'
*
VIERRCU  DC    V(IERRCU)
VGAPRT   DC    V(IERGAPRT)
*
RCPAREA  DC    CL80' '             I/O WRITE AREA
*
KINCLUDE DC    CL30' INCLUDE '     INCLUDE IMAGE
         DC    CL10' '
KCONST1  DC    CL13' ENTRY IEREX1'
         DC    CL9' NAME PH1'
         DC    CL9' NAME S11'
         DC    CL15'SORTLIB(IEREX1)'
KCONST2  DC    CL13' ENTRY IEREX2'
         DC    CL9' NAME PH2'
         DC    CL9' NAME S21'
         DC    CL15'SORTLIB(IEREX2)'
KCONST3  DC    CL13' ENTRY IEREX3'
         DC    CL9' NAME PH3'
         DC    CL9' NAME S31'
         DC    CL15'SORTLIB(IEREX3)'
RCPRESW  DC    X'00'               RESOLVE SWITCH
*
DIERRCU  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRCU SOURCE
*
*
*----------------------------------------------------------------------
*
         COPY IERRCUI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMCPI
*
         END
./ ADD NAME=IERRCR   0101-20211-20211-1200-00109-00109-00000-RELEASE 00
RCR      TITLE 'IERRCR - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRCR
*
*        MODULE FUNCTION -
*        IERRCR IS THE SECOND OF THREE GENERAL ASSIGNMENT
*        MODULES IN TAPE B&G. THE FUNCTION OF IERRCR IS TO
*        CALCULATE THE NUMBER OF PHASE TWO PASSES BY TECH. IT
*        WILL ATTEMPT TO OPTIMIZE ON EACH TECHNIQUE AND SELECT
*        THE MOST EFFICIENT OF THE THREE TECHNIQUES
*
*        MODULES IN WHICH THIS MODULE APPEARS AS A DSECT -
*        IERRCS
*        IERBGA
*
*        MACROS USED - NONE
*
*        ENTRY POINTS - IERRCS - ENTER FROM IERRCS VIA
*                                UNCONDITIONAL BRANCH
*
*        INPUT    - CPI FIELDS REFRENCED -
*        CPIBINSZ   CPIFILSZ   CPILAB07
*        CPIEXTSZ   CPIIPBLK   CPILAB09
*        CPICNTL    CPINWKU    CPIOPBLK
*        CPIP1RSZ   CPIP2RSZ   CPIP3RSZ
*        CPIRCDL1   CPIRCDL2   CPIRCDL3
*        CPIRCDL5   CPISRTBL   CPITAVLC
*
*
*        OUTPUT  -  CPI FIELDS INITIALIZED OR ALTERED -
*        CPIBUF1    CPIBUF23   CPILAB03
*        CPIMRGAL   CPIMRGMX   CPINMAX
*        CPIP1GC    CPIP2GC    CPIP3GC
*        CPISRTBL   CPISRTG    CPICNTL
*
*        EXTERNAL ROUTINES - IERRCU - DIAGNOSTIC AND ERROR
*                                     MESSAGES
*
*        EXTERNAL PARAMETERS - IERRCU - MESSAGES
*
*        EXITS - NORMAL - IERBGA - UNCONDITIONAL BRANCH
*
*        EXITS - ERROR - IERBGA - UNCONDITIONAL BRANCH
*
*        TABLES/WORK AREAS -
*        WORK  - WORK9
*        WFULL - WFULL4
*
*        NOTES - THIS IS RESTRICTED TO TAPE OPERATION ONLY. IT
*        CONTAINS A DSECT OF IERRCS, IERBGA, AND IERRCU
*
IERRCR   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRCR SOURCE
*
*----------------------------------------------------------------------
*
         COPY IERRCRI
*
*        MODULE NAME - IERRCS
*
IERRCS   DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRCS SOURCE
*
*----------------------------------------------------------------------
*
         COPY IERRCSI
*
*
*        MODULE NAME - IERBGA
*
*
IERBGA   DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERBGA SOURCE
*
*----------------------------------------------------------------------
*
         COPY IERBGAI
*
*
*        MODULE NAME - IERRCU
*
DIERRCU  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRCU SOURCE
*
*----------------------------------------------------------------------
*
         COPY IERRCUI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMCPI
*
         END
./ ADD NAME=IERRCRI  0101-20211-20211-1200-01080-01080-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERRCR SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERRCRI
*
         USING *,R12               BASE REGISTER FOR RCR
         USING IERRCS,R11          BASE REGISTER FOR RCS
         USING IERBGA,R7           BASE REGISTER FOR BGA
         USING IERRC5,R13          BASE REG FOR CPI DSECT
*
         IERENTRY 'IERRCR &SYSDATE &SYSTIME'
*
*
*        BEGIN PASS CALCULATION AND OPTIMIZATION FOR
*        ALL TECHNIQUES
*
RCR1901  LH    R14,WCHNIND         SET CHANNEL STATUS INDICATOR
         B     RCR1901A(R15)       GOTO PROPER TECH RTN
RCR1901A B     RCR1902             +00 BAL TECH INDICATED
         B     RCR1902             +04 POL TECH INDICATED
         B     BGA2201             +08 OSC TECH INDICATED
*
*        BALANCED TECHNIQUE OR POLYPHASE TECHNIQUE SPECIFIED
*
*        CALCULATE NUMBER OF STRINGS IN THE FILE
*
*        NO STRINGS = USER FILE SIZE
*                     ---------------
*                      G * G FACTOR
*
RCR1902  L     R4,WBALG(R15)       G
         B     RCR1903(R15)        GOTO PROPER TECH
*
RCR1903  B     RCR1903A            +00 BALANCED TECH
*                                  +04 POLY TECH
         LH    R2,WPOLMRMX         M
         LH    R3,WPOLNWKU         N
         CH    R3,K09              N >= 9  ?
         BNL   RCR1903A            YES, G FACTOR = 2
         SLL   R2,1                2M
         LH    R3,KPOLGF(R2)       LOAD G FACTOR
         SR    R2,R2
         MR    R2,R4               G * GFACTOR
         LH    R4,K100             LOAD SCALING FACTOR
         SR    R2,R2
         DR    R2,R4               SCALE DOWN NO OF STRINGS
         LR    R4,R3
         B     RCR1903B            DO NOT SET TO 2G
*
RCR1903A SLL   R4,1                2G
RCR1903B L     R3,WFILSZ           R3 = FILE SIZE
         SR    R2,R2
         DR    R2,R4               NO OF STR = FILE/G*GFACTOR
         LTR   R2,R2               A REMAINDER ?
         BZ    RCR1903C            NO
         LA    R3,1(,R3)           YES, ADD 1 TO THE STRING COUNT
RCR1903C ST    R3,WBALS1(R15)      SAVE ORIG STRING COUNT
         B     RCR1904(R15)        GOTO PROPER TECH
*
RCR1904  B     RCR1905             +00 BAL TECH INDICATED
*                                  +04 POLY TECH INDICATED
*
*        SET UP PARAMETERS FOR RCRPASS SUBROUTINE
*
         LR    R1,R3               R1 = NO OF STRINGS
         LH    R0,WPOLMRMX         R0 = MERGE ORDER
         C     R0,WBALS1(R15)      M >= NO OF STR ?
         BNL   RCR1904D            YES, BRANCH AROUND FIBS
         BAS   R6,RCRFIBX          CALL FIB ROUTINE
         AH    R0,K100             ADD PHASE 1 PHASE
         ST    R0,WPOLP1           NO OF PASSES BEFORE OPT
         LA    R1,100(,R1)         ADD PHASE 1 PASS
         ST    R1,WPOLP2           NO OF PASSES AFTER OPT
         ST    R2,WPOLS2           OPT NO OF STRINGS
         LH    R1,WPOLMRMX         M
         LH    R3,WPOLNWKU         N
         CH    R3,K09              N >= 9 ?
         BL    RCR1904A            NO, USE G FACTOR
*                                  YES, USE 2 AS G FACTOR
         BAS   R6,RCRP06           CALL RTN TO CALC NEW G
         B     RCR1904B            STORE PARMS
*
RCR1904A SLL   R1,1                2M
         MH    R2,KPOLGF(R1)       NEW NO STRINGS * GFACTOR
         LR    R3,R2               NO OF STR * G FACTOR
         SR    R2,R2
         LA    R4,100              LOAD SCALING FACTOR
         DR    R2,R4               NO OF STR * G FACTOR/100
         LR    R4,R3               R4 = NO OF STR * G FACTOR/100
         BAS   R6,RCRP06A          CALL RTN TO CALCULATE NEW G
RCR1904B ST    R2,WGCAL            NEW G
         ST    R3,WOTREE           SAVE OPT TREE
         ST    R4,WNEWGCOR         SAVE NEW COR REQ FOR NEW G
         B     RCR1906             SET PARAMETERS FOR SCN RTN
*
RCR1904D LA    R3,300              THREE PASSES
         ST    R3,WBALP1(R15)      SET TECH TO TWO PASSES
         B     RCR1906             SET PARAMS FOR SCN RTN
*
RCR1905  LR    R0,R3               R0 = NO OF STR
         LH    R1,WBALMRMX         R1 = MERGE MAX
         LH    R2,WBALMRAL         R2 = MERGE ALT
         L     R3,WFILSZ           R3 = NO OF RCDS
         BAS   R6,RCRPASS          CALC NEW G AND NUMBER OF PASSES
         ST    R2,WGCAL            NEW G
         ST    R3,WOTREE           SAVE OPT TREE
         ST    R4,WNEWGCOR         SAVE NEW COR REQ FOR NEW G
         LA    R1,1(,R1)           ADD PHASE 1 PASS
         MH    R1,K100             SCALE NO OF PASSES
         LR    R3,R1               R3 = BAL NO OF PASSES
         LA    R4,10               LOAD SCALING FACTOR
         SR    R2,R2
         DR    R2,R4               PASSES/10
         AR    R1,R3               PASSES PLUS 10%
         ST    R1,WBALP1           SAVE ORIG NO OF PASSES
         SH    R1,K100             OPT NO OF PASSES IS ONE LESS
         ST    R1,WBALP2           SAVE OPT NO OF PASSES
*
*        SET UP PARAMETERS FOR SCN ROUTINE
*
RCR1906  LH    R0,WBALNB1(R10)     R0 = TOTAL PHASE 1 BFRS
         LH    R1,WBALNB2(R10)     R1 = TOTAL PHASE 2 BFRS
         LH    R2,WBALNB3(R10)     R2 = TOTAL PHASE 3 BFRS
         LH    R3,WBSLBAL(R10)     R3 = BUFFER SIZE
         L     R4,WBALP1(R15)      R4 = ORIG NO OF PASSES
         BAS   R6,RCRSCNGN         CALL SCN ROUTINE IN IERBGA
         ST    R0,WBALSCN(R15)     SAVE SCN VALUE
         ST    R0,WBALSCN1(R15)    SAVE SCN NO
*
*        IF ONLY TWO PASSES NO OPTIMIZATION
*
RCR1907  L     R0,WBALP1(R15)      ORIG NO OF PASSES
         EX    0,RCR1907A(R15)     GOTO PROPER TECH
         CR    R0,R1               MORE THAN MIN NO OF PASSES ?
         BNH   RCR3005             NO, SKIP OPTIMIZATION
         B     RCR1908             YES, OPTIMIZE
*
RCR1907A LA    R1,220              MINIMUM NO OF BAL PASSES
         LA    R1,300              MIN NO OF POL PASSES
*
RCR1908  L     R3,WNEWGCOR         R3 = NEW G CORE
         EX    0,RCR1908A(R15)
         L     R1,WP1IPBFR         R1= INPUT BFR SIZE
         B     RCR1909(R14)        GOTO PROPER CHANNEL STATUS
*
RCR1908A L     R0,WBAL1COR         TAVLC - (RUNNING PROG + GEN CORE)
         L     R0,WPOL1COR         TAVLC - (RUNNING PROG + GEN CORE)
*
RCR1909  B     RCR1910             MPX INDICATED
         B     RCR1910             1 SELECTOR INDICATED
*
*        2 SELECTOR CHANNELS INDICATED
*
         SLL   R1,1                2(BI)
         MVI   WOINP1+3,X'02'      SET OPT NO OF INP BUFFERS
         MVI   WONB1+3,X'04'       SET OPT NO OF TOTAL BUFFERS
*
*        MPX CHANNEL INDICATED
*        1 SELECTOR CHANNEL INDICATED
*
RCR1910  AR    R1,R3               (BI CORE + NEW G CORE )
         SR    R0,R1               TOTAL AVAIL -(BI+G)
         SH    R0,K08              MINUS 8 FOR QSAM CONTROL BUFFER
         BM    RCR3005             NEW G TOO LARGE
         LH    R1,WRECINCR         (F=4, V=8 )
         B     RCR2001(R14)        GOTO OPTIMIZATION
*
RCR2001  B     RCR2003             MPX INDICATED
         B     RCR2002             1 SELECTOR INDICATED
*
*        1 OR 2 SELECTOR CHANNELS INDICATED
*
RCR2002  SLL   R1,1                (F=8, V=16 )
         SR    R0,R1
         BM    RCR3005             NO OPTIMIZATION
         SRL   R0,1                BSLNEW = R0 - 2(WRECINCR)/2
         B     RCR2004             CHECK BSL VS RCD SIZE
*
*        MPX CHANNEL INDICATED
*
RCR2003  SR    R0,R1               BSLNEW = R0 - WRECINCR
         BM    RCR3005             NO OPTIMIZATION
RCR2004  CH    R0,CPIRCDL2         BSL >=  1 RCD ?
         BL    RCR3005             NO, SKIP OPTIMIZATION
         CH    R0,K10000           BSL > 10K ?
         BH    RCR2004A            YES
         LR    R3,R0
         B     RCR2004B            NO
*
RCR2004A CLC   CPIRCDL1(2),K10000  1 RCD > 10K ?
         BH    RCR2004F            YES
         LH    R3,K10000           MAX SORT BFR SIZE
RCR2004B B     RCR2004C(R9)        GOTO PROPER ROUTINE
*
RCR2004C B     RCR2004E            VARIABLE RCDS INDICATED
*
*        FIXED LENGTH RECORDS INDICATED
*
RCR2004D LH    R4,CPIRCDL2
         SR    R2,R2
         DR    R2,R4               BS = BSL/L2
         ST    R3,WOBS             SAVE OPTIMIZED BS
         SR    R2,R2
         MR    R2,R4               BSL = (L2*BS)
         AH    R3,WRECINCR         BSL = BSL+4
         ST    R3,WOBSL            SAVE OPTIMIZED BSL
         B     RCR2005(R14)        GOTO PROPER CHAN RTN
*
*        VARIABLE LENGTH RECORDS INDICATED
*
RCR2004E ST    R3,WOBS             SAVE B
         AH    R3,WRECINCR         BSL = BSL + 8
         ST    R3,WOBSL            SAVE OPTIMIZED BSL
         B     RCR2005(R14)        GOTO PROPER CHAN STATUS RTN
*
*        ONE (1) RECORD GREATER THAN 10K
*
RCR2004F LH    R3,CPIRCDL2
         AH    R3,WRECINCR         1 RCD + INCR
         ST    R3,WOBSL            SAVE OPTIMIZED BSL
         B     RCR2004G(R9)        GOTO PROPER RCD FORMAT RTN
*
RCR2004G B     RCR2004H            VAR
*
*        FIXED LENGTH RECORDS INDICATED
*
         LA    R1,1
         ST    R1,WOBS             OPTIMIZED BS = 1
         B     RCR2005(R14)        GOTO PROPER CH AN STATUS RTN
*
RCR2004H ST    R3,WOBS             OPTIMIZED BS = BSL
         B     RCR2005(R14)        GOTO PROPER CHAN STATUS RTN
*
RCR2005  B     RCR2006             MPX INDICATED
         B     RCR2007             1 SELECTOR
         B     RCR2008A            2 SELECTORS
*
*        MPX CHANNEL INDICATED
*        SET UP PARAMETERS FOR SCN ROUTINE
*
RCR2006  LH    R0,WBALNB1(R10)     R0 = TOTAL PHASE 1 BFRS
         LH    R1,WBALNB2(R10)     R1 = TOTAL PHASE 2 BFRS
         LH    R2,WBALNB3(R10)     R2 = TOTAL PHASE 3 BFRS
         L     R4,WBALP2(R15)      R4 = OPT NO OF PASSES
         BAS   R6,RCRSCNGN         GEN SELECTION COMPARE RTN
         ST    R0,WBALSCN2(R15)    SAVE OPT SCN VALUE
         C     R0,WBALSCN1(R15)    SCN2 >= SCN1 ?
         BNL   RCR3005             YES, VOID OPTIMIZATION VALUES
         ST    R0,WBALSCN(R15)     SAVE SCN NUMBER
         B     RCR2108A            CHECK CAPACITY
*
*        1 SELECTOR CHANNEL INDICATED
*
RCR2007  L     R1,WOBSL            OPTIMIZED BSL
         L     R0,WP1IPBFR         PHASE 1 INPUT BR
         CR    R1,R0               OBSL > BI ?
         BH    RCR2009             YES
RCR2008  LA    R1,1
         ST    R1,WOINP1           OPT NO OF PHASE 1 INPUT BFRS
         LA    R1,2(,R1)           P1 TOTAL BFR = 3
         ST    R1,WONB1            OPT PHASE 1 TOTAL BFRS
RCR2008A L     R0,WOBSL            OPTIMIZED BSL
         LH    R1,WBALMRMX(R10)    M
         BAS   R6,RCRP3NBO         CALL PHASE 3 BUFFER ROUTINE
         ST    R0,WONB3            OPT NO OF PHASE 3 BFRS
         ST    R1,WOOUT3           SAVE OPT NUMBER OF OUTPUT BUFFERS
RCR2008B L     R0,WOBSL            OPTIMIZED BSL
         LH    R1,WBALMRMX(R10)    M
         EX    R0,RCR2008C(R15)
         B     RCR2008D            FIND PH2 BFRS
*
RCR2008C L     R2,WBAL2COR         BAL PHASE 2 AVAIL CORE
         L     R2,WPOL2COR         POL PHASE 2 AVAIL CORE
RCR2008D BAS   R6,RCRP2NBP         GOTO PHASE 2 BFR ROUTINE
         ST    R0,WONB2            SAVE OPT NO OF PHASE 2 BFRS
         ST    R1,WOOUT2           SAVE NO OF PHASE 2 OUTPUT BFRS
         B     RCR2108             START SCAN
*
*        OPTIMIZED BSL GREATER THAN INPUT BUFFERS (BI)
*
RCR2009  LA    R1,2                SET 2 P1 INPUT BFRS
         ST    R1,WOINP1           OPT PHASE 1 INPUT BFRS
         LA    R1,1(,R1)
         ST    R1,WONB1            OPT PHASE 1 TOTAL BFRS
         B     RCR2008A            GOTO PHASE 3 BFR ROUTINE
*
*        SET UP PARAMETERS FOR SCN ROUTINE
*
RCR2108  L     R0,WONB1            OPT PHASE 1 TOTAL BFRS
         L     R1,WONB2            OPT PHASE 2 TOTAL BFRS
         L     R2,WONB3            OPT PHASE 3 TOTAL BFRS
         L     R3,WOBSL            OPT BSL
         L     R4,WBALP2(R15)      R4 = OPT NO OF PASSES
         BAS   R6,RCRSCNGN         GEN SELECTION ROUTINE
         ST    R0,WBALSCN2(R15)    SAVE OPT SCN NO
         C     R0,WBALSCN1(R15)    SCN2 >= SCN1 ?
         BNL   RCR3005             YES, VOID OPTIMIZATION VALUES
         ST    R0,WBALSCN(R15)     SAVE SCN NUMBER
*
*        SET UP PARAMETERS FOR CAPACITY ROUTINE
*
RCR2108A L     R0,WOBS             R0 = OPT BS
         L     R1,WOBSL            R1 = OPT BSL
         LH    R2,WBREELS(R10)     R2 = OPT NO OF REELS
         BAS   R6,RCSCAP           CALL CAPACITY ROUTINE
         ST    R3,WNMXCAL          OPT NMAX
         C     R3,WFILSZ           FILE SIZE EXCEED OPT NMAX ?
         BL    RCR3005             YES, VOID OPTIMIZATION VALUES
         B     BGA2806             OPTIMIZATION WAS OK
*
*        START OF OSC TECHNIQUE SUB PASS
*        TOTAL PASS AND OPTIMIZATION ROUTINES
*
BGA2201  L     R0,WOSC1COR         TOTAL CORE LESS RUNNING PROGS & GEN
*                                  CORE
         L     R1,WP1IPBFR         INPUT BUFFER SIZE
         TM    WOSCINP1+1,X'01'    ONE (1) INPUT BUFFER ?
         BO    BGA2202             YES
         SLL   R1,1                NO
BGA2202  SR    R0,R1
         ST    R0,WNEWCOR          SAVE VALUE FOR OPTIMIZATION RTN
         MVC   WNMXCAL(4),WOSCNMAX
         MVC   WGCAL(4),WOSCG      GET PRESENT G VALUE
BGA2203  L     R3,WNMXCAL          CALCULATE PRESENT RMAX VALUE
         LH    R4,WOREELS          MAX FULL REELS FOR OSC
         SR    R2,R2
         DR    R2,R4               R3 = RMAX ( MAX RCDS PER REEL)
         LA    R3,1(R3)
         ST    R3,WRMAX            SAVE RMAX VALUE
         TM    WCSSWA,X'08'        SW 5 ON - IN OPTIMIZATION ?
         BO    BGA2204             YES
         ST    R3,WOSCRMAX         NO
         ST    R3,WRMAX1
         B     BGA2205             DO NOT STORE AN UPDATED RMAX
*
BGA2204  ST    R3,WRMAX2
BGA2205  LR    R4,R3               R4 = RMAX
         L     R3,WFILSZ           USER FILE SIZE
         SR    R2,R2
         DR    R2,R4               FILE SZ/RMAX = FULL REELS + REM
*
*        CHECK FOR NUMBER OF FULL REELS AND PARTIAL REELS
*
         TM    WCSSWA,X'08'        SW 5 ON - IN OPTIMIZATION ?
         BO    BGA2206             YES
         ST    R3,WFULL1           NO, SAVE NO FULL REELS
         ST    R3,WFULL
         LTR   R2,R2               REMAINDER ?
         BZ    BGA2206             NONE PRESENT
         ST    R2,WREM             SAVE REMAINDER
         ST    R2,WREM1
         OI    WCSSWA,X'80'        TURN ON SW1 INDICATING PARTIAL
*                                  REEL PRESENT
         LA    R2,1
         STH   R2,WDIFFCTR         INITIALIZE DIFFERENCE CTR TO 1
         B     BGA2207             DO NOT STORE FULL REEL CNT
*
BGA2206  ST    R3,WFULL2           SAVE NUMBER OF FULL REELS
         ST    R3,WFULL
         LTR   R2,R2               REMAINDER ?
         BZ    BGA2207             NONE PRESENT
         ST    R2,WREM             SAVE REMAINDER
         ST    R2,WREM2
         OI    WCSSWA,X'80'        TURN ON SW1 INDICATING PARTIAL REEL
BGA2207  LH    R0,WOSCMRMX         OSC TECH MAX MERGE ORDER
         ST    R0,WMRMXKP          SAVE VALUE FOR OPTIMIZATION RTN
         SR    R5,R5               INITIALIZE TABLE POINTER TO 0
BGA2301  CLI   WFULL+3,X'00'       ANY FULL REELS INDICATED ?
         BE    BGA2309             NO
BGA2302  L     R8,WFULL            YES, LOAD NO FULL REELS
         L     R1,WRMAX            PRESENT RMAX VALUE
         ST    R1,WGAAA
         TM    WCSSWA,X'08'        SW 5 ON - IN OPTIMIZATION RTN ?
         BO    BGA2303             YES
         AH    R3,WDIFFCTR         NO, UPDATE TOTAL PASSES VALUE
         STH   R3,WDIFFCTR
BGA2303  LR    R1,R0               MERGE MAX
         SLL   R1,1
         L     R3,WGCAL            PRESENT CALCULATED G
         LH    R4,KGFACTOR(R1)     MERGE ORDER G MULT FACTOR
         SR    R2,R2
         MR    R2,R4               R3 = G * G FACTOR
BGA2304  LR    R4,R3
         L     R3,WGAAA            PRESENT RMAX OR REMAINDER
         MH    R3,K100             MULTIPLY BY 100 SCALING FACTOR
         SR    R2,R2
         DR    R2,R4               RMAX(100)/G*G FACTOR = NO STR PER
*                                  SUB PASS
         LTR   R2,R2               REMAINDER ?
         BZ    BGA2304A            NONE PRESENT
         LA    R3,1(,R3)           REMAINDER PRESENT, ADD 1 TO STRING
*                                  COUNT
BGA2304A TM    WCSSWA,X'08'        SW 5 ON - IN OPTIMIZATION ?
         BO    BGA2305             YES
         ST    R3,WSTR1(R5)        NO, STORE NO STR IN TABLE 1
         ST    R0,WMRGMX(R5)       STORE MERGE MAX IN TABLE1
         B     BGA2305A            DO NOT STORE IN TABLE 2
*
BGA2305  ST    R3,WSTR2(R5)        STORE NO STRINGS IN TABLE 2
*
*        SET UP FOR PASS CALCULATION SUBROUTINE
*
BGA2305A LR    R1,R0               MERGE MAX
         LR    R2,R0               MERGE ALT
         LR    R0,R3               NO STRINGS
         L     R3,WGAAA            NO RCDS (RMAX OR REMAINDER)
         BAS   R6,RCRPASS1         BRANCH TO SUBRTN AND RETURN
*
*        RETURN FROM PASS SUBROUTINE
*
         TM    WCSSWA,X'08'        SW 5 ON - IN OPTIMIZATION ?
         BO    BGA2306             YES
         ST    R0,WNEWSTR(R5)      STORE NEW STRING COUNT NEEDED TO
*                                  SAVE ONE (1) PASS
         ST    R1,WSUBP1(R5)       STORE NO SUB PASSES IN TABLE
         ST    R2,WNEWG1(R5)       STORE NEW ¬ NEEDED TO SAVE 1 PASS
         ST    R3,WNEWT1(R5)       STORE NEW TREE SIZE
         ST    R4,WNP1CRQ(R5)      STORE NEW PHASE 1 CORE REQUIRED
         B     BGA2307             SKIP STORE
*
BGA2306  ST    R1,WSUBP2(R5)       STORE NO SUB PASSES IN TABLE 2
BGA2307  LR    R3,R1               NUMBER OF SUB PASSES
         L     R4,WGAAA            NO RCDS
         SR    R2,R2
         MR    R2,R4               NO RCDS PER SUB PASS * NO SUB PASS
         A     R3,WSUBTOT          UPDATE SUB PASS TOTAL
         ST    R3,WSUBTOT          SAVE UPDATED TOTAL
         L     R0,WMRMXKP          RESTORE MERGE ORDER VALUE
         BCT   R0,BGA2308          REDUCE MERGE ORDER BY 1
BGA2308  ST    R0,WMRMXKP          STORE REDUCED MERGE ORDER
         LA    R5,4(R5)            UPDATE TABLE POINTER
*
*        CHECK IF ALL FULL REELS HAVE BEEN COMPLETED
*
         BCT   R8,BGA2303          NO
*                                  YES
         TM    WCSSWA,X'80'        SW 1 ON - PARTIAL REEL PRESENT ?
         BZ    BGA2310             NO
BGA2309  NI    WCSSWA,X'7F'        YES, TURN OFF SW1
         LA    R8,1                INITIALIZE COUNT TO 1
         L     R1,WREM             LOAD REMAINDER
         ST    R1,WGAAA
         B     BGA2303             CALCULATE FOR PARTIAL REEL
*
*        CALCULATE ACTUAL NUMBER OF TIMES ENTIRE FILE WILL BE
*        PASSED
*
BGA2310  L     R3,WSUBTOT          RCD HANDLING SUB TOTAL
         MH    R3,K100             MULT BY 100 SCALING FACTOR
         L     R4,WFILSZ           USER FILE SIZE
         SR    R2,R2
         DR    R2,R4
         LA    R3,200(R3)          ADD IN PHASES 1 AND 3 PASSES
         TM    WCSSWA,X'08'        SW 5 ON - IN OPTIMIZATION ?
         BZ    BGA2311             NO, ORDER TABLES BY SIZE
         ST    R3,WOSCP2           OPTIMIZED NO PASSES
         ST    R3,WOPASS
         L     R3,WADRKP           LOAD R3 WITH RETURN ADDR
         BR    R6                  RETURN
*
BGA2311  LH    R0,WOSCNB1          TOTAL PHASE 1 BFRS UNOPTIMIZED
         LH    R1,WOSCNB2          TOTAL PHASE 2 BFRS UNOPTIMIZED
         LH    R2,WOSCNB3          TOTAL PHASE 3 BFRS UNOPTIMIZED
         ST    R3,WOSCP1           UNOPTIMIZED NO PASSES
         ST    R3,WOPASS
         LR    R4,R3               NO PASSES OF ENTIRE FILE
         LH    R3,WBSLOSC          SORT BFR SIZE - UNOPTIMIZED
         STM   R0,R4,WSCNNB1       SET UP PARAMETERS FOR SELECTION
*                                  COMPARE NUMBER ROUTINE
         BAS   R6,RCRSCNGN         CALL RTN AND RETURN
BGA2312  ST    R0,WOSCSCN          STORE SCN NUMBER
         ST    R0,WOSCSCN1
         OI    WCSSWA,X'08'        TURN ON SW 5 - START OPTIMIZATION
         SR    R0,R0
         ST    R0,WSUBTOT          CLEAR OUT SUB PASS TOTAL COUNT
*
*        PUT COMPLIED TABLES IN ORDER - HIGH TO LOW
*        FIRST ENTRY IN DIFFERENCE TABLE WILL BE THE LARGEST
*        STRING DIFFERENCE TO SAVE ONE (1) PASS, THE LAST ENTRY
*        WILL BE THE SMALLEST STRING DIFFERENCE TO SAVE ONE (1)
*        PASS
*
BGA2401  LA    R1,WNEWSTR
         ST    R1,WNEWSTRA         DIFFERENCE TABLE - 1ST ADDR
         LA    R1,4(,R1)
         ST    R1,WNEWSTRB         DIFFERENCE TABLE - 2ND ADDR
         LA    R1,WNEWG1
         ST    R1,WNEWG1A          NEW G TABLE - 1ST ADDR
         LA    R1,4(,R1)
         ST    R1,WNEWG1B          NEW G TABLE - 2ND ADDR
         LA    R1,WNEWT1
         ST    R1,WNEWT1A          NEW TREE TABLE - 1ST ADDR
         LA    R1,4(,R1)
         ST    R1,WNEWT1B          NEW TREE TABLE - 2ND ADDR
         LA    R1,WNP1CRQ
         ST    R1,WNP1CRQA         NEW REQ PHASE 1 CORE TABLE - 1ST
*                                  ADDR
         LA    R1,4(,R1)
         ST    R1,WNP1CRQB         NEW REQ PHASE 1 CORE TABLE - 2ND
*                                  ADDR
         LA    R1,WMRGMX
         ST    R1,WMRGMXA          MERGE MAX TABLE - 1ST ADDR
         LA    R1,4(,R1)
         ST    R1,WMRGMXB          MERGR MAX TABLE - 2ND ADDR
*
BGA2401A LH    R0,WDIFFCTR         NO OF ENTRIES PER TABLE
BGA2402  BCT   R0,BGA2403          BRANCH IF TABLES NOT COMPLETED
         B     BGA2501             TABLES COMPLETED
*
BGA2403  ST    R0,WLOOPCT          SAVE COUNT
         SR    R5,R5               ZERO OUT TABLE POINTER
BGA2404  LM    R1,R2,WNEWSTRA
         L     R3,0(R5,R1)         GET 1ST STRING DIFFERENCE
         L     R4,0(R5,R2)         GET 2ND STRING DIFFERENCE
         CR    R3,R4               DIFF1 > DIFF2 ?
         BH    BGA2405             YES, MAKE NO EXCHANGE
*                                  NO, EXCHANGE TABLE VALUES
         ST    R3,0(R5,R2)         EXCHANGE STRING DIFFERENCE COUNTS
         ST    R4,0(R5,R1)
         LM    R1,R2,WNEWG1A       EXCHANGE G TABLE VALUES
         BAS   R6,BGALOOP          VIA LOOP ROUTINE
         LM    R1,R2,WNEWT1A       EXCHANGE TREE TABLE VALUES
         BAS   R6,BGALOOP          VIA LOOP ROUTINE
         LM    R1,R2,WMRGMXA       EXCHANGE MERGE ORDER TABLE VALUES
         BAS   R6,BGALOOP          VIA LOOP ROUTINE
         LM    R1,R2,WNP1CRQA      EXCHANGE PHASE 1 REQ CORE TABLE
         BAS   R6,BGALOOP          VALUES
BGA2405  BCT   R0,BGA2406          BRANCH IF PASS NO COMPLETED
         L     R0,WLOOPCT
         B     BGA2402             DO NEXT TABLE
*
BGA2406  LA    R5,4(,R5)           UPDATE TABLE POINTER
         B     BGA2404             CONTINUE
*
*        LOOP ROUTINE TO EXCHANGE SPECIFIED TABLE VALUES
*
BGALOOP  L     R3,0(R5,R1)
         L     R4,0(R5,R2)
         ST    R3,0(R5,R2)
         ST    R4,0(R5,R1)
         BR    R6                  RETURN
*
*        START OF OPTIMIZATION
*        BEGIN SCANNING TABLES TO SEE IF NEW G CALCULATED TO
*        SAVE ONE (1) PASS WILL FIT IN PHASE 1 AVAILABLE CORE
*
BGA2501  LH    R2,WDIFFCTR         NO OF ENTRIES IN TABLES
         STH   R2,WDIFFSV          SAVE
BGA2502  SR    R5,R5               ZERO OUT TABLE POINTER
         STH   R5,WPTRSV           SAVE
BGA2503  L     R0,WNEWCOR          AVAILABLE PHASE 1 CORE
BGA2504  LA    R2,WNP1CRQ
         L     R1,0(R5,R2)         R1 = CORE REQ FOR NEW G
         LTR   R1,R1
         BZ    BGA2506             NO PASS CAN BE SAVED
BGA2505  CR    R0,R1               AVAILABLE CORE GREATER THAN CORE
*                                  REQUIRED FOR NEW G ?
         BC    2,BGA2509           YES
BGA2506  LH    R2,WDIFFSV          NO, UPDATE AND SAVE POINTERS
         LH    R5,WPTRSV
BGA2507  BCT   R2,BGA2508          TABLE COMPLETED ?
         B     RCR3005             GOTO TECH CTR ROUTINE
*
BGA2508  STH   R2,WDIFFSV          NO, SAVE NEW TABLE COUNT
         LA    R5,4(R5)            UPDATE TABLE POINTER
         STH   R5,WPTRSV           SAVE NEW TABLE POINTER VALUE
         B     BGA2503             TRY NEXT TABLE ENTRY
*
BGA2509  SR    R0,R1               R0 = AVAIL CORE - NEW REQ CORE
         CL    R0,WRCDPLUS         R0 >= 1 RCD + INCR ?
         BL    BGA2506             NO
BGA2510  LR    R3,R0               R3 = REMAINING AVAILABLE CORE
         LH    R4,WBALNB1(R10)     TOTAL PHASE 1 NO BFRS
         SH    R4,WBALINP1(R10)    TOTAL P1 NO BFRS - INPUT BFRS
         SR    R2,R2
         DR    R2,R4               OBSL = AVAIL CORE/NO OUTPUT BFRS
BGA2511  CL    R3,WRCDPLUS         OBSL >= 1 RCD PLUS INCREMENT ?
         BL    BGA2506             NO
         B     BGA2512(R9)         YES, GOTO PROPER RCD FORMAT RTN
*
*        CALCULATE OPTIMIZED SORT BUFFER LENGTH (OBSL) AND
*        OPTIMIZED SORT BLOCKING FACTOR (OBS)
*
BGA2512  B     BGA2514             VARIABLE LENGTH RCDS INDICATED
*
*        FIXED LENGTH RCDS INDICATED
*
BGA2513  SH    R3,K04
         LH    R4,CPIRCDL2         RECORD LENGTH
         SR    R2,R2
         DR    R2,R4               OBS = OBSL/L2
         ST    R3,WOBS             SAVE OPTIMIZED OBS VALUE
         SR    R2,R2
         MR    R2,R4               OBSL = (L2 * OBS)
         AH    R3,WRECINCR         OBSL = OBSL + 4
         ST    R3,WOBSL            SAVE OPTIMIZED OBSL VALUE
         B     BGA2515             RECALCULATE NMAX
*
*        VARIABLE LENGTH RCDS INDICATED
*
BGA2514  ST    R3,WOBS             SAVE OPTIMIZED OBS VALUE
         ST    R3,WOBSL            SAVE OPTIMIZED OBSL VALUE
*
*        CALCULATE NEW NMAX VALUE USING NEW OPTIMIZED PARAMETERS
*
BGA2515  L     R0,WOBS
         L     R1,WOBSL
         LH    R2,WOREELS
         BAS   R6,RCSCAP           CALL RTN FOR NEW NMAX
BGA2516  ST    R3,WNMXCAL          SAVE NEW NMAX VALUE
BGA2517  L     R2,WFILSZ           YES, LOAD FILE SIZE
         CR    R2,R3               NMAX EXCEEDED ?
         BH    BGA2506             YES, TRY NEXT TABLE ENTRY
BGA2518  LA    R1,WNEWG1           NO, ADDR OF NEW G TABLE
         LH    R5,WPTRSV           TABLE ENTRY POINTER
         L     R2,0(R5,R1)         R2 = NEW G VALUE
         ST    R2,WGCAL
BGA2519  LH    R1,WBALNB1(R10)     UNOPTIMIZED PHASE 1 TOTAL NO BFRS
         ST    R1,WONB1            SAVE VALUE
         LH    R1,WBALINP1(R10)    UNOPTIMIZED NO PHASE 1 INPUT BFRS
         ST    R1,WOINP1           SAVE VALUE
*
*        SET UP RETURN ADDR FOR RETURN FROM MAIN PROGRAM
*
BGA2520  LA    R6,BGA2801          RETURN POINT FROM MAIN ROUTINE
         ST    R6,WADRKP           SAVE FOR REFERENCE BY MAIN ROUTINE
         B     BGA2203             GOTO MAIN ROUTINE
*
*        RCRP3NBO
*
*        USED TO RECALCULATE TOTAL NUMBER OF PHASE 3 BUFFERS
*        AND NUMBER OF PHASE 3 OUTPUT BUFFERS USING ANY SUPPLIED
*        SORT BUFFER LENGTH (OBSL)
*
*        REGISTERS ENTERING SUBROUTINE
*        R0 = SORT BUFFER LENGTH (OBSL)
*        R1 = MAXIMUM MERGE ORDER
*        R6 = RETURN REGISTER
*
*        REGISTERS LEAVING SUBROUTINE
*        R0 = TOTAL NUMBER PHASE 3 BUFFERS
*        R1 = NUMBER OF PHASE 3 OUTPUT BUFFERS
*
RCRP3NBO STM   R0,R1,WORK1         SAVE PARAMETER REGISTERS
         B     RCR2601(R14)        GOTO PROPER CHANNEL STATUS RTN
*
RCR2601  B     RCR2614             MPX CHANNEL INDICATED
         B     RCR2601A            1 SELECTOR CHANNEL INDICATED
*
*        1 OR 2 SELECTOR CHANNELS INDICATED
*
RCR2601A LH    R0,WBALNB3(R10)     UNOPTIMIZED PHASE 3 TOTAL BFRS
         SLL   R1,1                2(M)
         LA    R1,2(R1)            2(M) + 2
RCR2602  CR    R1,R0               TOTAL NO BFRS = 2M+2 ?
         BE    RCR2613             YES
*                                  NO
         EX    0,RCR2603(R15)      PHASE 3 AVAIL CORE LESS R15 AND GC
         B     RCR2603A            FIND PH3 BFRS
*
RCR2603  L     R0,WBAL3COR
         L     R0,WPOL3COR
         L     R0,WOSC3COR
RCR2603A L     R3,WP3OPBFR         PHASE 3 OUTPUT BFR SIZE
         SR    R0,R3               R0 = WXXX3COR - 1(BO)
RCR2604  LA    R1,1                SET PHASE 3 OUTPUT BFR COUNT = 1
RCR2605  L     R4,WORK1            OBSL VALUE
         L     R3,WORK2            MERGE MAX VALUE
         SR    R2,R2
         MR    R2,R4               R3 = M(OBSL)
         SR    R0,R3               R0 = R0 - M(OBSL)
RCR2606  L     R3,WP3OPBFR         PHASE 3 OUTPUT BFR SIZE
         CR    R0,R3               ENOUGH CORE FOR A 2ND OUTPUT BFR ?
         BL    RCR2608             NO
RCR2607  SR    R0,R3               YES, ALLOCATE SECOND OUTPUT BFR
         LA    R1,2                INDICATE 2 OUTPUT BFRS
RCR2608  L     R4,WORK1            OBSL VALUE
         CR    R0,R4               ENOUGH CORE FOR ANY ADDITIONAL
*                                  PHASE 3 UNPUT BFRS ?
         BL    RCR2612             NO
RCR2609  LR    R3,R0               YES
         SR    R2,R2
         DR    R2,R4               R3 = AVAILABLE CORE/OBSL
RCR2610  L     R4,WORK2            MERGE MAX VALUE
         CR    R3,R4               ADDITIONAL INPUT BFRS > M ?
         BNH   RCR2615             NO
RCR2611  LR    R3,R4               YES, INDICATE M NO ADDITIONAL
*                                  INPUT BUFFERS
         B     RCR2615             GOTO EXIT
*
RCR2612  LA    R3,0                INDICATE NO ADDITIONAL INPUT BFRS
         B     RCR2615             GOTO EXIT
*
RCR2613  LA    R1,2                INDICATE 2 OUTPUT BFRS
         L     R3,WORK2            INDICATE M NO OF ADDITIONAL
*                                  INPUT BFRS
         B     RCR2615             GOTO EXIT
*
RCR2614  LA    R1,1                INDICATE 1 PHASE 3 OUTPUT BFR
         B     RCR2612             SET ADDITIONAL BFRS=0
*
RCR2615  L     R0,WORK2            MINIMUM NUMBER OF INPUT BFRS
         AR    R0,R3               ADD IN NUMBER OF ADDITIONAL
*                                  INPUT BFRS
         AR    R0,R1               ADD IN NUMBER OF OUTPUT BFRS
         BR    R6                  RETURN TO CALLING ROUTINE
*
*        RCRP2NB
*
*        USED TO RECALCULATE TOTAL NUMBER OF PHASE 2 BUFFERS AND
*        NUMBER OF PHASE 2 OUTPUT BUFFERS USING ANY SUPPLIED
*        SORT BUFFER LENGTH (OBSL)
*
*        REGISTERS ENTERING SUBROUTINE
*        R0 = SORT BUFFER LENGTH
*        R1 = MERGE MAX
*        R2 = BUFFER CORE AVAILABLE
*             (WXXX2COR FOR POL AND BAL TECH)
*             (NEW G CORE FOR OSC TECH)
*        R6 = RETURN REGISTER
*
*        REGISTERS LEAVING SUBROUTINE
*        R0 = TOTAL NUMBER OF PHASE 2 BUFFERS
*        R1 = NUMBER OF PHASE 2 OUTPUT BUFFERS
*
*        ENTRY POINT FROM POLYPHASE OR BALANCED TECHNIQUES
*
RCRP2NBP STM   R0,R5,WORK          SAVE PARAMETER REGISTERS
         LR    R0,R1               INITIALIZE TOTAL NO BFRS TO M
         LR    R4,R1
         LR    R5,R1
         SLL   R4,1
         LA    R4,2(,R4)           R4 = 2M+2
         LR    R2,R4
         LA    R5,2(,R5)           R5 = M+2
         LA    R1,1                INITIALIZE NO OUTPUT BFRS TO 1
         B     RCR2701             OPTIMIZE PH2 BFRS
*
*        ENTRY POINT FROM OSCILLATING TECHNIQUE
*
RCRP2NBO STM   R0,R5,WORK          SAVE PARAMETER REGISTERS
         LR    R0,R1               INITIALIZE TOTAL NO BFRS = M
         LR    R5,R1               R5 = M
         LR    R4,R1
         SLL   R4,1                R4 = 2M
         LH    R1,WOSCOUT2         NO PHASE 2 OUTPUT BFRS
         LR    R2,R4
         LA    R2,2(,R2)           R2 = 2M+2
*
*        CHECK CHANNEL CONFIGURATION
*        GOTO PROPER ROUTINE
*
RCR2701  B     RCR2701A(R14)       GOTO PROPER CHANNEL RTN
*
RCR2701A B     RCR2712             +00 MPX CHANNEL INDICATED
         B     RCR2702             +04 1 SELECTOR CHANNEL INDICATED
*
*        1 OR 2 SELECTOR CHANNELS INDICATED
*
RCR2702  LH    R3,WBALNB2(R10)     UNOPTIMIZED NO PHASE 2 TOTAL BFRS
         CR    R3,R2               P2NB = 2M+2 ?
         BE    RCR2709             YES
RCR2703  ST    R4,WORK7            NO, SAVE VALUE
         L     R3,WORK2            CORE AVAILABE FOR BUFFERS
         L     R4,WORK             OBSL
         SR    R2,R2
         DR    R2,R4               R3 = NO OF BFRS NEW CORE VALUE
*                                  WILL HOLD
         L     R4,WORK7            RESTORE R4 TO SAVED VALUE
RCR2704  CR    R3,R4               NEW NO BFRS >= 2M+2 VALUE ?
         BNL   RCR2709             YES
RCR2705  CR    R3,R5
         BL    RCR2712             LESS, BRANCH
RCR2706  B     RCR2706A(R15)       GOTO PROPER TECH ROUTINE
RCR2706A B     RCR2708             +00 BAL TECH INDICATED
         B     RCR2708             +04 POL TECH INDICATED
*
*        OSCILLATING TECHNIQUE INDICATED
*
RCR2707  SR    R3,R5               R3 = R3 - M
         B     RCR2713             OSCILLATING TECH
*
*        POLYPHASE OR BALANCED TECHNIQUE INDICATED
*
RCR2708  SR    R3,R5               R3 = R3 - (M+2)
         B     RCR2711             POLY OR BAL TECH
*
RCR2709  L     R3,WORK1            R3 = M
RCR2710  B     RCR2710A(R15)       GOTO PROPER TECH ROUTINE
RCR2710A B     RCR2711             +00 BAL TECH INDICATED
         B     RCR2711             +04 POL TECH INDICATED
         B     RCR2713             +08 OSC TECH INDICATED
*
*        POLYPHASE OR BALANCED TECHNIQUE INDICATED
*
RCR2711  LA    R1,2                SET NO PHASE 2 OUTPUT BFRS = 2
         B     RCR2713             SET TOT PH2 BUFS - EXIT
*
RCR2712  SR    R3,R3
*
*        OSCILLATING TECHNIQUE SPECIFIED
*
RCR2713  AR    R0,R3               SET UP PARAMETER REGISTERS
         AR    R0,R1               R0 = TOTAL NO PHASE 2 BFRS
         LM    R3,R5,WORK3         RESTORE ORIGINAL REGISTER SETTINGS
         BR    R6                  RETURN TO CALLING ROUTINE
*
*        COMPUTE TOTAL NUMBER OF PHASE 3 BUFFERS AND NUMBER OF
*        PHASE 3 OUTPUT BUFFERS USING OPTIMIZED SORT BUFFER
*        LENGTH (OBSL)
*
BGA2801  L     R0,WOBSL            OPTIMIZED SORT BUFFER LENGTH
         LH    R1,WBALMRMX(R10)    OSC MERGE MAX
         BAS   R6,RCRP3NBO         CALL SUBROUTINE
         ST    R0,WONB3            STORE OPTIMIZED TOTAL NO OF
*                                  PHASE 3 BUFFERS
         ST    R1,WOOUT3           STORE OPTIMIZED NO OF PHASE 3
*                                  OUTPUT BUFFERS
*
*        COMPUTE TOTAL NUMBER OF PHASE 2 BUFFERS USING OPTIMIZED
*        SORT BUFFER LENGTH (OBSL)
*
BGA2802  L     R0,WOBSL            OPTIMIZED SORT BUFFER LENGTH
         LH    R1,WBALMRMX(R10)    OSC MERGE MAX
         LH    R5,WPTRSV           TABLE POINTER
         LA    R3,WNP1CRQ
         L     R2,0(R5,R3)         CORE REQ FOR NEW G AND TREE
         LA    R4,WNEWT1
         L     R3,0(R5,R4)         CORE REQ FOR NEW TREE
         ST    R3,WOTREE           SAVE VALUE
         SR    R2,R3               R2 = CORE AVAILABLE FOR PHASE 2
*                                  INPUT BUFFERS
         BAS   R6,RCRP2NBO         CALL SUBROUTINE
BGA2803  ST    R0,WONB2            STORE OPTIMIZED TOTAL NUMBER OF
*                                  PHASE 2 BUFFERS
         ST    R1,WOOUT2           STORE OPTIMIZED NUMBER OF PHASE 2
*                                  OUTPUT BUFFERS
*
*        SET UP PARAMETERS TO GENERATE AN OPTIMIZED SELECTION
*        COMPARE NUMBER (SCN) FOR COMPARISON WITH UNOPTIMIZED SCN
*        NUMBER
*
BGA2804  LM    R0,R4,WONB1         LOAD PARAMETER REGISTERS
         STM   R0,R4,WSCNNB1
         BAS   R6,RCRSCNGN         GENERATE SCN NUMBER AND RETURN
BGA2805  ST    R0,WOSCSCN2         SAVE SCN2 NUMBER
         L     R1,WOSCSCN1         UNOPTIMIZED SCN NUMBER
         CR    R0,R1               NEW SCN NO <  OLD ONE ?
         BNL   BGA2805A            NO, NO OPTIMIZATION
         ST    R0,WOSCSCN          OPTIMIZED SCN NO
         B     BGA2806             OPTIMIZATION WAS GOOD
*
BGA2805A SR    R1,R1               NO, TRY NEXT LIST ENTRY
         ST    R1,WSUBTOT          CLEAR OUT SUBTOTAL LOCATION
         B     BGA2506             GOTO NEXT ENTRY
*
*        SECOND SCN NUMBER LOWER THAN UNOPTIMIZED ONE
*        THIS INDICATES A SUCCESSFUL OPTIMIZATION HAS BEEN
*        COMPLETED. MOVE OPTIMIZED VALUES INTO OSCILLATING
*        TECHNIQUE LOCATIONS
*
BGA2806  L     R3,WOBSL            OPTIMIZED BSL
         CH    R3,CPIBINSZ         BSL < BINSIZE ?
         BL    RCR3005             YES, TERMINATION OPTIMIZATION
         LM    R0,R3,WONB1
         B     BGA2807(R14)        GOTO CORRECT CHAN RTN
BGA2807  B     BGA2809             +00 1 MPX CHANNEL
         B     BGA2808             +04 1 SEL CHANNEL
         B     BGA2808             +08 2 SEL CHANNEL
*                                  1 OR 2 SELECTOR CHANNELS
BGA2808  STH   R0,WBALNB1(R10)     OPTIMIZED TOTAL PHASE 1 BFRS
         STH   R1,WBALNB2(R10)     OPTIMIZED TOTAL PHASE 2 BFRS
         STH   R2,WBALNB3(R10)     OPTIMIZED TOTAL PHASE 3 BFRS
         L     R3,WOINP1
         STH   R3,WBALINP1(R10)    OPTIMIZED NO OF PHASE 1 INPUT BFRS
         L     R3,WOOUT2
         STH   R3,WBALOUT2(R10)    OPTIMIZED NO OF PHASE 2 OUTPUT BFRS
         L     R3,WOOUT3
         STH   R3,WBALOUT3(R10)    OPTIMIZED NO OF PHASE 3 OUTPUT BFRS
*                                  1 MPX
BGA2809  L     R3,WOBSL
         STH   R3,WBSLBAL(R10)     OPTIMIZED BSL
         L     R3,WOBS
         STH   R3,WBALBS(R10)      OPTIMIZED BS
         L     R3,WNMXCAL
         ST    R3,WBALNMAX(R15)    OPTIMIZED NMAX
         L     R3,WGCAL
         ST    R3,WBALG(R15)       OPTIMIZED G
         L     R3,WOTREE
         ST    R3,WBALTREE(R15)    OPTIMIZED TREE
         B     RCR3005             GOTO NEXT TECHNIQUE
*
*        TERMINATION ENTRY FROM TECH NMAX EXCEEDED
*
RCRABRT1 EX    0,RCR3001(R15)      INDICATE TECH TERMINATION
         B     RCRABRT2            SET TERMINATION INDICATORS
*
RCR3001  OI    WABRTIND,X'10'      INDICATE BAL NMAX EXCEEDED
         OI    WABRTIND,X'08'      INDICATE POL NMAX EXCEEDED
         OI    WABRTIND,X'04'      INDICATE OSC NMAX EXCEEDED
*
*        TERMINATION ENTRY FROM TECHNIQUE INSUFFICIENT CORE
*
RCRABRT2 EX    0,RCR3002(R15)
         B     RCR3003             GOTO NEXT TECHNIQUE
*
RCR3002  OI    WABRTIND,X'80'      INDICATE BAL TECH TERMINATED
         OI    WABRTIND,X'40'      INDICATE POL TECH TERMINATED
         OI    WABRTIND,X'20'      INDICATE OSC TECH TERMINATED
*
RCR3003  LH    R1,WNOTERM          NO OF PREVIOUS TECH TERMINATIONS
         LA    R1,1(,R1)           UPDATE NUMBER
         STH   R1,WNOTERM          STORE UPDATE NO OF TECH TERMINATIONS
RCR3004  CH    R1,WNOTECH          ALL SPECIFIED TECHNIQUES
*                                  BEEN TERMINATED ?
         BE    RCR3015             YES, DETERMINE IF NMAX EXCEEDED OR
*                                  INSUFFICIENT CORE
RCR3005  LH    R1,WTQCTR           NO, LOAD TECHNIQUE COUNTER
         BCT   R1,RCR3006          ALL SELECTED TECHS DONE ?
         B     RCR3007             YES, SELECT WINNING TECHNIQUE
*
*        ALL SELECTED TECHNIQUES HAVE NOT BEEN COMPLETED
*        UPDATE TECH POINTERS AND CONTINUE TECHNIQUE
*        CALCULATIONS
*
RCR3006  STH   R1,WTQCTR           SAVE UPDATED TECH COUNT IN COUNTER
         SH    R15,K04             UPDATE TECHNIQUE POINTER
         STH   R15,WTQIND
         SH    R10,K02             UPDATE TECH HALFWORD POINTER
         STH   R10,WTQIND1
         B     RCS0201             BEGIN NEXT TECH CALCULATION
*
*        ALL SELECTED TECHNIQUES HAVE BEEN CALCULATED FOR AND
*        OPTIMIZED IF POSSIBLE. COMPARE TECHNIQUE SCN NUMBERS TO
*        DETERMINE WHICH TECHNIQUE IS THE MOST EFFICIENT
*
RCR3007  SR    R3,R3               SET R3 = 0
         L     R0,WBALSCN          BAL TECH SCN NO
         CR    R3,R0
         BE    RCR3009             BAL SCN = 0, ELIMINATE BAL TECH
*                                  FROM CONTENTION
         LA    R15,0               INDICATE BAL TECH IN CONTENTION
         C     R0,WPOLSCN          COMPARE BAL SCN NO TO POL SCN NO
         BE    RCR3010             EQUAL, BRANCH
         BH    RCR3011             HIGH, BRANCH
RCR3008  C     R0,WOSCSCN          COMPARE BAL/POL SCN WINNER TO THE
*                                  OSC SCN NO
         BE    RCR3012             EQUAL, BRANCH
         BH    RCR3013A            HIGH, BRANCH
         B     RCR3014             OSC TECH LOSES
*
*        BAL TECH SCN NO EQUALS 0, CHECK POL TECH SCN NO FOR A
*        NON ZERO VALUE
*
RCR3009  L     R0,WPOLSCN          POL TECH SCN NO
         CR    R3,R0
         BE    RCR3013             POL TECH SCN NO = 0 ?
*                                  OSC TECH IS THE WINNER
         LA    R15,4               INDICATE POL TECH IN CONTENTION
         B     RCR3008             COMPARE POL AND OSC SCN NUMBERS
*
*        BAL AND POL TECH SCN NUMBERS EQUAL
*        DETERMINE WINNER BY TECH
*
RCR3010  L     R1,WBALG
         C     R1,WPOLG            COMPARE BAL G VS POL G
         BH    RCR3008             BAL TECH IS WINNER
         LA    R15,4               POL TECH IS WINNER
         B     RCR3008             COMPARE POL SCN NO VS OSC SCN NO
*
*        BAL TECH SCN NO HIGHER THAN POL TECH SCN NO
*        IF POL SCN NO IS A NON ZERO VALUE POL TECH IS THE
*        WINNER
*
RCR3011  L     R1,WPOLSCN
         CR    R3,R1
         BE    RCR3008             BAL TECH WINNER, COMPARE BAL SCN
*                                  NO VS OSC SCN NO
         LR    R0,R1               POL TECH IS WINNER
         LA    R15,4               INDICATE POL TECH IN CONTENTION
         B     RCR3008             COMPARE POL SCN NO VS OSC SCN NO
*
*        BAL/POL SCN WINNER EQUAL OSC SCN NO
*        DETERMINE WINNER BY TECH WITH THE HIGHEST G VALUE
*
RCR3012  L     R1,WBALG(R15)       BAL/POL WINNER G VALUE
         C     R1,WOSCG            COMPARE WINNER G VS OSC G VALUE
         BNL   RCR3014             OSC TECH IS LOSER
RCR3013  LA    R15,8               OSC TECH IS WINNER
         B     RCR3014             GO SET POINTER
*
*        BAL/POL WINNER SCN NO HIGHER THAN OSC SCN NO
*        IF OSC SCN NO CONTAINS A NON ZERO VALUE OSC TECH IS THE
*        WINNER
*
RCR3013A L     R1,WOSCSCN          OSC SCN VALUE
         CR    R3,R1
         BE    RCR3014             OSC TECH IS LOSER
         B     RCR3013             OSC TECH IS WINNER
*
*        SET WINNING TECHNIQUE HALFWORD POINTER
*
RCR3014  LR    R10,R15
         SRL   R10,1
         B     RCRCPI              STORE RESULT
*
*        ALL SELECTED TECHNIQUES HAVE BEEN TERMINATED
*        DETERMINE IF NMAX EXCEEDED WAS THE CAUSE OF ANY OF THE
*        TECHNIQUE TERMINATIONS
*
         SPACE 2
RCR3015  TM    WABRTIND,X'1C'      ANY TECH NMAX BITS ON ?
         BNZ   RCR3016             YES, FIND HIGHEST NMAX VALUE
         B     RCRMSGA2            PRINT INSUFFICIENT CORE
*
RCR3016  LM    R0,R2,WBALNMAX      R0 = BAL TECHNIQUE NMAX
*                                  R1 = POL TECHNIQUE NMAX
*                                  R2 = OSC TECHNIQUE NMAX
         CR    R2,R1               OSC VS POL
         BNL   RCR3017             OSC GREATER
*                                  POL GREATER
         CR    R1,R0               POL VS BAL
         BNL   RCR3018             POL HIGHEST NMAX VALUE
         B     RCR3019             BAL HIGHEST NMAX VALUE
*
RCR3017  CR    R2,R0               OSC VS BAL
         BNL   RCR3020             OSC HIGHEST NMAX VALUE
         B     RCR3019             BAL HIGHEST NMAX VALUE
*
RCR3018  LR    R2,R1               R2 = POL NMAX VALUE
         B     RCR3020             STORE NMAX
*
RCR3019  LR    R2,R0               R2 = BAL NMAX VALUE
RCR3020  ST    R2,ABRTNMAX         HIGHEST NMAX TERMINATION VALUE
         B     RCR3021(R9)         GOTO PROPER FORMAT
*
RCR3021  B     RCR3022             VARIABLE LENGTH RCDS
*
*        FIXED LENGTH RCDS
*
         TM    WCSSWB,X'08'        EXACT FILE SIZE GIVEN ?
         BZ    RCR3022             NO
         B     RCRMSGA1            YES, PRINT NMAX EXCEEDED
*
RCR3022  C     R2,WBALNMAX         BAL TECH ?
         BE    RCR3023             SET BAL IND
         C     R2,WPOLNMAX         POL TECH ?
         BE    RCR3024             SET POL IND
         B     RCR3013             OSC TECH SELECTED
*
RCR3023  SR    R15,R15             BAL TECH SELECTED
         B     RCR3014             GO SET POINTER
*
RCR3024  LA    R15,4               POLY TECH SELECTED
         B     RCR3014             GO SET POINTER
*
*        ROUNDC
*
*        SUBROUTINE TO ALIGN SORT BLOCKING TO A DOUBLE WORD
*        BOUNDRY
*
ROUNDC   ST    R2,WFULL1            SAVE AREA
         NI    WFULL1+3,X'F8'       ALIGNMENT
         L     R2,WFULL1            RESTORE REGISTER
         BR    R8                   RETURN
ROUNDD   LA    R3,7(,R3)            ROUNDING UPWARD
         ST    R3,WFULL1            SAVE AREA
         NI    WFULL1+3,X'F8'       ALIGNMENT
         L     R3,WFULL1            RESTORE REGISTER
         BR    R8                   RETURN
ROUNDF   LA    R5,7(,R5)            ROUNDING UP
         ST    R5,WFULL1            SAVE AREA
         NI    WFULL1+3,X'F8'       ALIGNMENT
         L     R5,WFULL1            RESTORE REGISTER
         BR    R8                   RETURN
*
./ ADD NAME=IERRCS   0101-20211-20211-1200-00135-00135-00000-RELEASE 00
RCS      TITLE 'IERRCS - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRCS
*
*        FUNCTION -
*        TAPE B&G CONSISTS OF THREE MODULES EXECUTED AT GENERAL
*        ASSIGNMENT TIME
*
*        THESE MODULES ARE IERRCS, IERRCR, AND IERBGA. THE
*        OVERALL FUNCTION IS TO CALCULATE SORT BLOCKING, RECORD
*        STORAGE AREA, NUMBER AND SIZE OF BUFFERS BY PHASE,
*        MAXIMUM SORT CAPACITY(NMAX), AND WILL SELECT THE MOST
*        EFFICIENT TECHNIQUE. THREE DIFFERENT TECHNIQUES CAN BE
*        USED FOR SEQUENCE DISTRIBUTION ON TAPES. EACH TECHNIQUE
*        DIFFERS IN THE WAY IN WHICH SEQUENCES ARE DISTRIBUTED
*        ONTO THE INTERMEDIATE STORAGE DEVICES, AND IN THE ORDER
*        IN WHICH THE NUMBER OF INTERMEDIATE PASSES ARE REDUCED.
*        THE THREE TECHNIQUES ARE, BALANCED, POLYPHASE, AND
*        OSCILLATING TECHNIQUE THE SELECTION OF ONE OF THE THREE
*        POSSIBLE TECHNIQUES IS MADE AFTER EVALUATING THE SORT
*        PARAMETERS. TO DETERMINE THE SELECTION OF THE MOST
*        EFFICIENT OF THE THREE TECHNIQUE FILE SIZE MUST BE
*        GIVEN, OR CLOSELY ESTIMATED. IF THE FILE SIZE IS
*        OMITTED, THE BALANCED TECHNIQUE IS CHOSEN. WHENEVER
*        THREE WORK UNITS ARE SPECIFIED, ONLY THE POLYPHASE
*        TECHNIQUE WILL BE CALCULATED
*
*        IERRCS IS THE FIRST OF THREE GENERAL ASSIGNMENT MODULES
*        IN TAPE B&G. THE FUNCTION OF IERRCS IS TO CALCULATE
*        SORT BLOCKING, SORT G, NMAX, NUMBER AND SIZE OF BUFFERS
*        BY PHASE, AND GENERATED CORE BY PHASE FOR ALL THREE
*        TECHNIQUES
*
*        THE MODULE SAVES AND RESTORES ALL REGISTERS AND USES
*        ALL REGISTERS
*
*        MODULES IN WHICH THIS MODULE APPEARS AS A DSECT -
*        IERRCR
*        IERBGA
*
*        MACROS USED - NONE
*
*        ENTRY POINTS - IERRCM - ENTER FROM IERRCM VIA
*                                LOAD  R15,(VCON)
*                                BALR  R14,R15
*                       IERRCR - ENTER FROM IERRCR VIA
*                                UNCONDITIONAL BRANCH
*
*        INPUT - CPI FIELDS REFRENCED -
*        CPIBINSZ   CPIFILSZ   CPILAB07
*        CPIEXTSZ   CPIIPBLK   CPILAB09
*        CPINWKU    CPIOPBLK   CPIP1RSZ
*        CPIP2RSZ   CPIP3RSZ   CPIRCDL1
*        CPIRCDL2   CPIRCDL3   CPIRCDL5
*        CPISRTBL   CPICNTL    CPITAVLC
*
*        OUTPUT - CPI FIELDS INITIALIZED OR ALTERED -
*        CPIBUF1    CPIBUF23   CPILAB03
*        CPIMRGAL   CPIMRGMX   CPINMAX
*        CPIP1GC    CPIP2GC    CPIP3GC
*        CPISRTBL   CPISRTG    CPICNTL
*
*        EXTERNAL ROUTINES -
*        IERRCU - DIAGNOSTIC AND ERROR MESSAGES
*
*        EXTERNAL PARAMETERS - IERRCU - MESSAGES
*
*        EXITS - NORMAL - IERRCR - UNCONDITIONAL BRANCH
*
*        EXITS - ERROR - IERRCR - UNCONDITIONAL BRANCH
*
*        TABLES/WORK AREAS -
*        WORK  - WORK9
*        WFULL - WFULL4
*
*        NOTES -
*        RESTRICTED TO TAPE OPERATION ONLY. IT CONTAINS A
*        DSECT OF IERRCR, IERBGA, AND IERRCU
*
*        THIS PROGRAM HAS DEFECTIVE LOGIC IN THAT IT EXPECTS
*        THE DR INSTRUCTION TO SET THE CONDITON CODE. SEE ###
*
IERRCS   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRCS SOURCE
*
*----------------------------------------------------------------------
*
         COPY IERRCSI
*
*        MODULE NAME - IERRCR
*
IERRCR   DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRCR SOURCE
*
*----------------------------------------------------------------------
*
         COPY IERRCRI
*
*        MODULE NAME - IERBGA
*
*----------------------------------------------------------------------
*
*        INCLUDE IERBGA SOURCE
*
*----------------------------------------------------------------------
*
IERBGA   DSECT
*
         COPY IERBGAI
*
DIERRCU  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRCU SOURCE
*
*----------------------------------------------------------------------
*
         COPY IERRCUI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMCPI
*
         END
./ ADD NAME=IERRCSI  0101-20211-20211-1200-01627-01627-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERRCS SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERRCSI
*
         USING *,R11               BASE REGISTER FOR RCS CSECT
         USING IERRCR,R12          BASE REGISTER FOR RCR DSECT
         USING IERBGA,R7           BASE REGISTER FOR BGA DSECT
         USING IERRC5,R13          BASE REG FOR CPI DSECT
*
         IERENTRY 'IERRCS &SYSDATE &SYSTIME'
*
         LR    R11,R15             SET UP MODULE BASE REGISTER
         STM   R0,R15,WREGSV1      SAVE REGISTER FOR RETURN TO RCM
         L     R12,VIERRCR         LOAD BASE REG FOR RCR
         L     R7,VIERBGA          LOAD BASE REG FOR BGA
         B     RCS0101             START INIT
*
*        START INITIALIZATION - CHANNEL STATUS INDICATOR
*                               TECHNIQUE INDICATOR
*                               RECORD INDICATOR
*
*        CHECK IF A TECHNIQUE HAS BEEN SPECIFIED (FORCED)
*
RCS0101  LH    R0,CPINWKU          NO WORK UNITS AVAILABLE TO SORT
         STH   R0,WBALNWKU         UNITS AVAILABLE TO BALN TECHNIQUE
         CH    R0,K17              NO WORK UNITS > 17 ?
         BH    RCS0101A            YES
         B     RCS0101B            NO
*
*        CUT BACK NUMBER OF AVAILABLE WORK UNITS TO ALLOW FOR 16
*        WAY NETWORK FOR POLYPHASE AND OSCILLATING TECHNIQUES
*
RCS0101A LA    R0,17               SET MAX UNITS FOR POL/OSC TECHS
RCS0101B STH   R0,WPOLNWKU         STORE NO WORK UNITS - POL TECH
         STH   R0,WOSCNWKU         STORE NO WORK UNITS - OSC TECH
*
*        CHECK FILE SIZE STATUS - EXACT, ESTIMATED OR OMITTED
*
RCS0102  SR    R2,R2
         ICM   R2,B'0111',CPIFILSZ   FILE SIZE PRESENT ?
         BZ    RCS0110             NO FILE SIZE GIVEN
         ST    R2,WFILSZ           SAVE USER FILE SIZE
         OI    WCSSWB,X'20'        FILE SIZE GIVEN - SET SW 11
         CPITEST  CPIFSZE          FILE SIZE ESTIMATED ?
         BO    RCS0102A            YES, BRANCH
         OI    WCSSWB,X'08'        NO, FILE EXACT - SET SW 13
         B     RCS0103             DO NOT SET SW 12
*
RCS0102A OI    WCSSWB,X'10'        FILE ESTIMATED - SET SW 12
RCS0103  CLC   CPINWKU(2),K03      NO WORK UNITS > 3 ?
         BH    RCS0104             YES
RCS0103A OI    WOPTTECH,X'40'      SET POL TECH OPTIMIZATION INDICATOR
         B     RCS0110A            SET UP FOR POLYPHASE
*
*        CHECK IF A TECHNIQUE SPECIFIED
*
RCS0104  CPITEST  CPIBALN+CPIPOLY+CPIOSC  ANY TECHNIQUES SPECIFIED ?
         BZ    RCS0108             NO
         LA    R0,1                INDICATE ONE (1) TECH ONLY
         OI    WCSSWB,X'40'        INDICATE TECH FORCED
         CPITEST  CPIBALN+CPIPOLY  BALN OR POL TECH SPECIFIED ?
         BM    RCS0106             YES
*
*        OSC TECHNIQUE FORCED - CHECK IF PERMISSABLE
*
RCS0105  CPITEST  CPIINWRK         INPUT UNIT A WORK UNIT ?
         BO    RCS0107             YES, SWITCH TO BALANCED TECH
         OI    WCSSWC,X'04'        FORCE OSC TECH - SET SW 22
         OI    WOPTTECH,X'20'      SET OSC TECH OPTIMIZATION INDIC
         LA    R1,8                SET TECH INDIC FOR OSC TECH FIRST
         B     RCS0115             SET INDICATORS
*
RCS0106  CPITEST  CPIBALN          BALN TECHNIQUE SPECIFIED ?
         BZ    RCS0103A            NO, POL TECH SPECIFIED
*
*        BALANCED TECHNIQUE FORCED - SET UP OPTIMIZATION
*        INDICATOR
*
RCS0107  OI    WOPTTECH,X'80'      SET BALN TECH OPTIMIZATION INDIC
         B     RCS0111             SET BALN ONLY  SWITHES
*
RCS0108  CPITEST  CPIINWRK         INPUT A WORK UNIT ?
         BO    RCS0109             YES
         OI    WOPTTECH,X'E0'      NO, SET BALN, POL AND OSC TECH
*                                  OPTIMIZATION INDICATORS
         LA    R0,3                INDICATE ALL THREE TECHNIQUES TO
*                                  BE CALCULATED FOR
         LA    R1,8                INDICATE OSC FIRST TECH TO CALC FOR
         B     RCS0115             SET INDICATORS
*
RCS0109  OI    WOPTTECH,X'C0'      SET BALN AND POL TECH OPTIMIZATION
*                                  INDICATORS
         LA    R0,2                INDICATE TWO TECHNIQUES TO
*                                  CALCULATE (BALN - POL)
         LA    R1,4                INDICATE POL TECH FIRST TO CALC FOR
         B     RCS0115             SET INDICATORS
*
*        FILE SIZE OMITTED
*        CHECK WORK UNITS TO DETERMINE WHICH TECHNIQUE TO FORCE
*
RCS0110  CLC   CPINWKU(2),K03      NO WORK UNITS > 3 ?
         BH    RCS0111             YES, FORCE BALN TECH
RCS0110A OI    WCSSWB,X'40'        NO, FORCE POL TECH
         OI    WCSSWC,X'01'        INDICATE POL TECH
         LA    R0,1                INDICATE ONE (1) TECH ONLY
         ST    R0,WPOLSCN          SET A POLY SCN NO
         LA    R1,4                INDICATE POL TECH ONLY
         B     RCS0115             SET INDICATORS
*
RCS0111  OI    WCSSWB,X'40'        TECH FORCED - SET SW 10
         OI    WCSSWC,X'02'        INDICATE BALN TECH FORCED
         LA    R0,1                INDICATE ONE (1) TECH ONLY
         ST    R0,WBALSCN          SET A BALN SCN NO
         LA    R1,0                INDICATE BALN TECH ONLY
         B     RCS0115             SET INDICATORS
*
RCS0115  STH   R0,WTQCTR           STORE NO OF TECHS TO BE CALCULATED
         STH   R1,WTQIND           STORE TECHNIQUE INDICATOR
         STH   R0,WNOTECH          NO OF TECH'S TO OPTIMIZE
         STH   R1,W1STTECH         1ST TECH TO OPTIMIZE FOR
         SRL   R1,1
         STH   R1,WTQIND1          STORE TECH HALFWORD POINTER
*
*        SET INPUT RECORD FORMAT INDICATOR
*
*        WRECIND = 0 FOR VARIABLE OR 4 FOR FIXED LENGRH RECORDS
*
RCS0116  CPITEST  CPIFIX           FIXED LENGTH RECORDS ?
         BO    RCS0116A            YES
         SR    R0,R0               NO, SET VARIABLE VALUE
         LA    R1,8                SET RECORD FORMAT INCREMENT (+8)
         B     RCS0116B            STORE VALUE
*
RCS0116A LA    R0,4                SET FIXED LENGTH VALUE
         LA    R1,4                SET RECORD FORMAT INCREMENT (+4)
RCS0116B STH   R0,WRECIND          STORE RECORD INDICATOR VALUE
         STH   R1,WRECINCR         STORE RECORD INCREMENT
         AH    R1,CPIRCDL2
         ST    R1,WRCDPLUS         SIZE OF 1 RCD PLUS INCREMENT
*
*        SET CHANNEL STATUS INDICATOR
*        WCHNIND = 0 FOR MPX, 4 FOR 1 SELECTOR, 8 FOR 2
*        SELECTOR
*
RCS0117  CPITEST  CPIMPSE1         2 SELECTOR CHANNELS ?
         BO    RCS0124             YES
         CPITEST  CPIMPSE1+CPIMPSEN   MPX CHANNEL ?
         BZ    RCS0125             YES
RCS0118  TM    CPILAB09+3,X'02'    INPUT AND WORK SAME CHANNEL ?
         BZ    RCS0120             YES
*
RCS0119  OI    WCSSWB,X'02'        NO, SET SWITCH 15
RCS0120  TM    CPILAB09+3,X'01'    OUTPUT AND WORK SAME CHANNEL ?
         BZ    RCS0122             YES
RCS0121  OI    WCSSWB,X'01'        NO, SET SWITCH 16
RCS0122  CPITEST  CPITAU           TAU OR SWITCH ?
         BO    RCS0124             YES, GOTO 2 CHANNEL ROUTINE
RCS0123  LA    R0,4                SET INDIC TO 4 (1 SEL CHANNEL)
         B     RCS0126             STORE CHAN INDICATOR
*
RCS0124  LA    R0,8                SET INDIC TO 8 (2 SEL CHANNELS )
         B     RCS0126             STORE CHAN INDICATOR
*
RCS0125  LA    R0,0                SET INDIC TO 0 (1 MPX CHANNEL)
*
*        STORE CHANNEL STATUS INDICATOR VALUE FOR LATER REFERENCE
*
RCS0126  STH   R0,WCHNIND          INITIAL CHANNEL STATUS
         STH   R0,WCHNIND1         PHASE 1 CHANNEL STATUS
         STH   R0,WCHNIND2         PHASE 2 CHANNEL STATUS
         STH   R0,WCHNIND3         PHASE 3 CHANNEL STATUS
*
*        CALCULATE MERGE ORDER (M) FOR ALL THREE (3) TECHNIQUES
*
RCS0127  LH    R0,WPOLNWKU         NO WORK UNITS AVAIL TO POL/OSC
         BCT   R0,RCS0127A         (NO WORK UNITS - 1)
RCS0127A STH   R0,WPOLMRMX         POL MAX MERGE ORDER
         STH   R0,WOSCMRMX         OSC MAX MERGE ORDER
         LH    R0,WBALNWKU         NO WORK UNITS AVAIL TO BALN TECH
         SRL   R0,1                (NO WORK UNITS/2)
         STH   R0,WBALMRAL         BALN ALTERNATE MERGE ORDER
         TM    CPINWKU+1,X'01'     ODD NO OF WORK UNITS ?
         BZ    RCS0127B            NO
         AH    R0,K01              YES, INCREASE ALT MERGE ORDER
*                                  BY 1 FOR MAX MERGE ORDER
RCS0127B STH   R0,WBALMRMX         BALN MAX MERGE ORDER
         MVC   WP1IPBFR+2(2),CPILAB03       MOVE IN INPUT BUF SIZ
         MVC   WP3OPBFR+2(2),CPILAB09+2     MOVE IN OUTPUT BUF SIZ
*
*        CALCULATE MAXIMUM NUMBER OF REELS OF INPUT EACH TECHNIQUE
*        CAN HANDLE
*
*        POL TECH - 1 REEL MAX
*        BAL TECH = NWKU/2 - 1 MAX
*        OSC TECH = NWKU - 2 MAX
*
RCS0132  LA    R1,1
         STH   R1,WPREELS          POL - MAX INPUT 1 REEL
         LH    R1,WBALNWKU         BALN NO WORK UNITS
         SRL   R1,1                NWKU/2
         BCT   R1,RCS0132A         NWKU/2 - 1
RCS0132A STH   R1,WBREELS          BALN - MAX REELS OF INPUT
         LH    R1,WOSCNWKU         OSC NO WORK UNITS
         SH    R1,K02              N - 2
         STH   R1,WOREELS          OSC - MAX REELS OF INPUT
*
*        SET UP CONSTANTS TO BE USED FOR TAPE CAPACITY
*        CALCULATIONS
*
RCS0133  MVC   WDENTAPE,KBITSMAX   MAX BITS PER 2300 FT TAPE BY DEN
         MVC   WIRGTAPE,KIRG       STORE FOR CAPACITY CALCULATION RTN
*
*        CALCULATE RUNNING CORE SIZES (BALN AND POL TECHS) FOR
*        PHASES 1, 2 AND 3 AND STORE VALUES IN PROPER TECHNIQUE
*        LOCATION
*
RCS0201  LH    R15,WTQIND          SET TECHNIQUE INDICATOR
         LH    R10,WTQIND1         SET TECH HALFWORD POINTER
         SR    R0,R0
         SR    R1,R1
         SR    R2,R2
         CPITEST  CPIEXTRT         EXTRACT SPECIFIED ?
         BZ    RCS02015            NO, CHECK IF EQUALS SPECIFIED
         AH    R0,CPIEXTSZ         LOAD SIZE OF EXTRACT ROUTINE
         LR    R1,R0
         LR    R2,R0
         B     RCS0201A            START CALCULATION
*
RCS02015 CPITEST  CPIEQUAL         EQUALS SPECIFIED ?
         BZ    RCS0201A            NO, BRANCH
         LA    R0,86               LOAD SIZE OF EQUALS ROUTINE
         LR    R1,R0
         LR    R2,R0
RCS0201A B     RCS0201B(R15)       GOTO PROPER TECH ROUTINE
RCS0201B B     RCS0202             +00 BAL TECH INDICATED
         B     RCS0202             +04 POL TECH INDICATED
         B     RCS0401             +08 OSC TECH INDICATED
*
*        BAL OR POL TECHNIQUE INDICATED
*
RCS0202  LM    R3,R5,KVALUE
         BAS   R14,RCSADD1         UPDATE TOTALS AND RETURN
RCS0203  AH    R0,K720             ADD REPLACEMENT NETWORK VALUE TO
*                                  PHASE 1 CORE REQ
RCS0204  A     R0,KTAPE            LOAD TAPE CONSTANTS
         A     R1,KTAPE+4
         BAS   R14,RCS0204A        CONTINUE CALCULATING RUNNING PROGRAM
*                                  HOWEVER THE CODE IS IN BGA
*
*        CHECK FOR SINGLE OR MULTIPLE CONTROL FIELDS
*
RCS0205  CPITEST  CPIMCF           MULTIPLE CONTROL FIELDS ?
         BO    RCS0209             YES
RCS0206  LM    R3,R5,KSINGCF       NO, SINGLE CONTROL FIELD
RCS0208  BAS   R14,RCSADD1         UPDATE TOTALS AND RETURN
*
*        CHECK FOR FIXED OR VARIABLE LENGTH RECORDS
*
RCS0209  CPITEST  CPIFIX           FIXED LENGTH RECORDS ?
         BZ    RCS0211             NO
RCS0210  LM    R3,R5,KFIXLEN       YES, LOAD FIXED LENGTH VALUES
         B     RCS0212             UPDATE
*
RCS0211  LM    R3,R5,KVARLEN       LOAD VARIABLE LENGTH VALUES
RCS0212  BAS   R14,RCSADD1         UPDATE TOTALS AND RETURN
*
*        CHECK FOR USER MODIFICATION EXITS
*
RCS0213  CPITEST  CPIMODS          USER MODS PRESENT ?
         BZ    RCS0217             NO
RCS0214  LM    R3,R5,KMODS         YES, LOAD MODS CONSTANTS
RCS0215  BAS   R14,RCSADD1         UPDATE TOTALS AND RETURN
*
*        ADD IN USER MODIFICATION PROGRAM SIZES BY PHASE INTO
*        RUNNING CORE TOTALS
*
RCS0216  SR    R3,R3
         ICM   R3,B'0111',CPIP1RSZ  P1 USER MODS SIZE
         SR    R4,R4
         ICM   R4,B'0111',CPIP2RSZ  P2 USER MODS SIZE
         SR    R5,R5
         ICM   R5,B'0111',CPIP3RSZ  P3 USER MODS SIZE
         BAS   R14,RCSADD1         UPDATE TOTALS AND RETURN
RCS0217  B     RCS0301(R15)        GOTO PROPER TECH ROUTINE
RCS0301  B     RCS0308             +00 BALANCED TECHNIQUE INDICATED
*
*        POLYPHASE TECHNIQUE INDICATED
*
RCS0302  AH    R0,K740             +04 PHASE 1 CONSTANT
         LA    R1,625(,R1)         PHASE 2 CONSTANT
         LA    R2,840(,R2)         PH 3 CONSTANT FOR TAPE READ ROUTINE
*
*        CHECK FOR 8 WAY OR 16 WAY NETWORK
*
RCS0303  CLC   WPOLMRMX(2),K09     MERGE ORDER >= 9 ?
         BNL   RCS0306             YES
RCS0304  OI    WCSSWC,X'80'        SET SW 17 - POLYPHASE 8 WAY
RCS0305  LA    R1,956(,R1)         PHASE 2  - 8 WAY CONSTANT
         LA    R2,956(,R2)         PHASE 3  - 8 WAY CONSTANT
         B     RCS0307             STORE  SIZES
*
RCS0306  LA    R1,1632(,R1)        PHASE 2  - 16 WAY CONSTANT
         LA    R2,1632(,R2)        PHASE 3  - 16 WAY CONSTANT
RCS0307  STM   R0,R2,WP1POLCR      STORE POL PHASES 1 - 2 - 3
*                                  RUNNING CORE SIZES
         B     RCS0314             CONINUE INITIALIZATION
*
RCS0308  AH    R0,K725             PHASE 1 CONSTANT
         LA    R1,650(,R1)         PHASE 2 CONSTANT
         LA    R2,924(,R2)         PH 3 CONSTANT FOR TAPE READ ROUTINE
*
*        CALCULATE FOR EITHER 8 WAY OR 16 NETWORKS
*
RCS0309  CLC   WBALMRMX(2),K09     MERGE ORDER >= 9 ?
         BNL   RCS0312             YES
RCS0310  OI    WCSSWC,X'40'        SET SW 18 - BAL 8 WAY NETWORK
RCS0311  LA    R1,956(,R1)         PHASE 2  - 8 WAY CONSTANT
         LA    R2,956(,R2)         PHASE 3  - 8 WAY CONSTANT
         B     RCS0313             STORE SIZES
*
RCS0312  LA    R1,1632(,R1)        PHASE 2  - 16 WAY CONSTANT
         LA    R2,1632(,R2)        PHASE 3  - 16 WAY CONSTANT
RCS0313  STM   R0,R2,WP1BALCR      STORE BALN PHASES 1 - 2 - 3
*                                  RUNNING CORE SIZES
RCS0314  B     RCS0601             CONTINUE INITIALIZATION
*
*        OSC TECHNIQUE INDICATED
*        BEGIN CALCULATIONS FOR OSC B & G
*
RCS0401  LM    R3,R4,KVALUE1       OSCILLATING TECHNIQUE CONSTANTS
         BAS   R14,RCSADD2         UPDATE TOTALS
         AH    R0,K975             ADD REPLACEMENT NETWORK VALUE
*                                  AND INITIALIZATION RTN VALUE
         AH    R0,K2585            TAPE CONSTANTS
         LA    R1,840(,R1)
         BAS   R14,RCS0402         CONTINUE CALCULATING RUNNING PROGRAM
*                                  HOWEVER THE CODE IS IN BGA
         CPITEST  CPIMCF           MULTIPLE CONTROL FIELDS ?
         BO    RCS0403             YES
         LA    R1,75(,R1)          NO, SINGLE CONTROL FIELD
*
*        CHECK FOR FIXED OR VARIABLE LENGTH RECORDS
*
RCS0403  CPITEST  CPIFIX           FIXED LENGTH RECORDS ?
         BO    RCS0404             YES
         LM    R3,R4,KVARLEN1      NO, VARIABLE LENGTH RECORDS
         B     RCS0404A            GO UPDATE
*
RCS0404  LM    R3,R4,KFIXLEN1      FIXED LENGTH CONSTANTS
RCS0404A BAS   R14,RCSADD2         TOTAL AND RETURN
*
*        CHECK FOR USER MODIFICATION EXIT PROGRAMS
*
RCS0405  CPITEST  CPIMODS          USER MODS PRESENT ?
         BZ    RCS0502             NO
         LM    R3,R4,KMODS1        YES
         BAS   R14,RCSADD2         TOTAL AND RETURN
         MVC   WFULL+1(3),CPIP1RSZ PHASE 1 MOD SIZE
         A     R3,WFULL
         MVC   WFULL+1(3),CPIP2RSZ PHASE 2 MOD SIZE
         A     R3,WFULL
         MVC   WFULL+1(3),CPIP3RSZ PHASE 3 MOD SIZE
         A     R4,WFULL
         BAS   14,RCSADD2          TOTAL AND RETURN
*
*        CHECK FOR 8 OR 16 WAY NETWORK
*
RCS0502  CLC   WOSCMRMX(2),K09     MERGE ORDER >= 9 ?
         BNL   RCS0503             YES
         OI    WCSSWC,X'20'        SET SW 20 - OSC 8 WAY
         AH    R0,K1035            OSCL 8 WAY CONSTANT
         LA    R1,956(,R1)         PHASE 3  - 8 WAY CONSTANTS
         B     RCS0505             STORE  TOTALS
*
*        SET UP FOR 16 WAY NETWORK
*
RCS0503  AH    R0,K1670            OSCL 16 WAY CONSTANT
RCS0504  LA    R1,1632(,R1)        PHASE 3  16 WAY CONSTANTS
RCS0505  STM   R0,R1,WP12OSCR      STORE OSC P12 AND P3 RUNNING CORE
*                                  TOTAL FOR LATER REFERENCE
*
*        CALCULATE NUMBER OF INPUT AND OUTPUT BUFFERS FOR PHASE 2
*        ALL TECHNIQUES
*
RCS0601  LH    R14,WCHNIND2        PHASE 2 CHANNEL STATUS INDICATOR
         LH    R4,WBALMRMX(R10)    TECH MERGE MAX
         B     RCS0601A(R14)       GOTO PROPER CHAN STATUS RTN
RCS0601A B     RCS0602             +00 MPX CHANNEL INDICATED
         B     RCS0603             +04 1 SELECTOR CHANNEL INDICATED
         B     RCS0604             +08 2 SELECTOR CHANNELS INDICATED
*
RCS0602  LA    R4,1(,R4)           MPX STATUS - M + 1 INPUT BFRS
         LA    R5,1                1 OUTPUT BUFFER
         B     RCS0606             SAVE NO OF BFRS
*
RCS0603  LA    R4,2(0,R4)          1 SEL STATUS - M + 2 INPUT BFRS
         B     RCS0605             SAVE NO OF BFRS
*
RCS0604  SLL   R4,1                2 SELECTOR - TAU - SW
         LA    R4,2(,R4)           2M + 2 INPUT BFRS
RCS0605  LA    R5,2                2 OUTPUT BUFFERS
RCS0606  STH   R4,WBALNB2(R10)     TOTAL NO PHASE 2 BUFFERS (I/O)
         STH   R5,WBALOUT2(R10)    NO PHASE 2 OUTPUT BUFFERS
*
*        CALCULATE GENERATED CORE REQUIRED FOR PHASE 1 - ALL
*        TECHNIQUES
*
RCS0701  LH    R0,WBALNWKU(R10)    TECH NO WORK UNITS
         AH    R0,K01              NO WORK UNITS + 1
         SLL   R0,2                (M+1) * 4 = DCB ADDR TABLE CORE
*
*        CHECK IF EITHER E15 OR E16 USER EXITS ACTIVATED
*
         CPITEST  CPIME15+CPIME16  EITHER EXIT ACTIVATED ?
         BM    RCS0704A            YES, BRANCH
         B     RCS0702(R15)        GOTO PROPER TECH ROUTINE
RCS0702  B     RCS0709             +00 BALN TECHNIQUE
         B     RCS0709             +04 POL TECHNIQUE
*
*        OSC TECHNIQUE INDICATED - CHECK FOR USER EXIT E25
*
         CPITEST  CPIME25          EXIT E25 ACTIVATED ?
         BZ    RCS0703             NO
*                                  YES
         OI    WCSSWB,X'04'        TURN ON SWITCH 14
         B     RCS0704             CONTINUE
*
RCS0703  CPITEST  CPIFIX           FIXED LENGTH RECORDS ?
         BZ    RCS0710             NO
*                                  YES
RCS0704  CPITEST  CPIGT256         RCD LENGTH > 256 ?
         BZ    RCS0710             NO
         B     RCS0704B            YES
*
*        CALCULATE THE SIZE OF THE MOVE ROUTINE NEEDED
*
RCS0704A CPITEST  CPIFIX           FIXED LENGTH RECORDS ?
         BZ    RCS0710             NO
RCS0704B LH    R4,CPIRCDL2         RECORD LENGTH
         LA    R4,255(,R4)
         SRL   R4,8                L1/256 = Q1
         LR    R5,R4               SAVE Q1
         MH    R4,K06              Q1 * 6
         LA    R4,2(,R4)           Q1 * 6 + 2
         CH    R5,K16              ORIGINAL Q1 VS 16
         BL    RCS0705             BRANCH LOW
         SRL   R5,4                Q1/16
         MH    R5,K12              (Q1 / 16) * 12
         AR    R4,R5               TOTAL MOVE SIZE
RCS0705  TM    WCSSWB,X'04'        SW 14 ON, OSC E25 ACTIVE ?
         BZ    RCS0707             NO, GOTO PROPER TECH ROUTINE
*                                  YES
RCS0706  STH   R4,WMVRTSZ1         SAVE MOVE ROUTINE SIZE
         AR    R0,R4               ADD MOVE SIZE TO TOTAL CORE REQ
         B     RCS0710             CONTINUE
RCS0707  B     RCS0708(R15)        GOTO PROPER TECH ROUTINE
RCS0708  B     RCS0706             +00 BAL TECH INDICATED
         B     RCS0706             +04 POL TECH INDICATED
*
*        OSC TECHNIQUE INDICATED
*
         SLL   R4,1                IF OSC, DOUBLE MOVE ROUTINE SIZE
         B     RCS0706             AND ADD TO TOTAL
*
RCS0709  CPITEST  CPIFIX           FIXED LENGTH RECORDS ?
         BO    RCS0704             YES
*
*        ADD IN CCWS AND INPUT BUFFER ADDR TABLE VALUES
*
RCS0710  AH    R0,K40
*
*        CALCULATE CORE REQUIRED FOR ALL IOB AND ECBS
*        (ALL TECHNIQUES)
*
RCS0801  B     RCS0801A(R15)       GOTO PROPER TECH ROUTINE
RCS0801A B     RCS0801B            +00 BAL TECH SPECIFIED
         B     RCS0801B            +04 POL TECH SPECIFIED
         B     RCS0801C            +08 OSC TECH SPECIFIED
*
*        BALANCED OR POLYPHASE TECH SPECIFIED
*
RCS0801B LA    R3,40               1 IOB-ECB FOR ALL DCBS
         STH   R3,WBALIOB1(R10)    PHASE 1 IOB-ECB CORE REQUIRED
         LA    R3,112(,R3)         ADD IN RSA ADDR TABLE SIZE
         AR    R0,R3               UPDATE PHASE 1 GEN CORE TOTAL
         LH    R3,WBALMRMX(R10)    TECH MERGE MAX
         B     RCS0801D            CONTINUE
*
*        OSCILLATING TECH SPECIFIED
*
*        CALCULATE RECORD STORAGE AREA ADDRESS TABLE SIZE
*
*        RSA ADR TABLE SIZE = ( M + M+1/2 + 2 ) * 8
*
RCS0801C LH    R3,WBALMRMX(R10)    (M)
         LA    R3,1(,R3)           (M + 1)
         SRL   R3,1                (M+1/2)
         AH    R3,WBALMRMX(R10)    (M + M+1/2)
         LA    R3,2(,R3)           (M + M+1/2 + 2)
         SLL   R3,3                (M + M+1/2 + 2) * 8
         AR    R0,R3               UPDATE PHASE 1 GEN CORE TOTAL
         LH    R3,WBALNWKU(R10)    TECH NO WORK UNITS
         MH    R3,K40              (NWKU) * 40 = IOB-ECB CORE REQ
*                                  1 IOB-ECB FOR EACH DCB
         STH   R3,WBALIOB1(R10)    PHASE 1 IOB-ECB CORE REQUIRED
         AR    R0,R3               UPDATE PHASE 1 GEN CORE TOTAL
*
*        CALCULATE SIZE OF GETMAIN, SEQUENCE DISTRIBUTION AND
*        PHASE 2 INPUT BUFFER ADDRESS TABLES
*
         LH    R3,WBALNWKU(R10)    TECH NO WORK UNITS
         MH    R3,K04              SEQ DIST TABLE = NWKU * 4
         AR    R0,R3               UPDATE GEN CORE TOTAL
         LH    R3,WBALMRMX(R10)
         LR    R4,R3
         CH    R14,K04             MPX CHANNEL INDICATED ?
         BL    RCR08A              YES, M PHASE 2 INPUT BFRS
         SLL   R3,1                NO, 2M PHASE 2 INPUT BFRS
RCR08A   AR    R0,R3               UPDATE GEN CORE BY P2 INPUT BFR
*                                  ADDR TABLE SIZE
         SRL   R4,1
         LA    R4,5(,R4)
         AR    R3,R4
         SLL   R3,3
         AR    R0,R3               UPDATE GEN CORE TOTAL BY GETMAIN
*                                  TABLE SIZE
         LH    R3,WBALNWKU(R10)    TECH NO WORK UNITS
RCS0801D MH    R3,=AL2(CPIEDCBL)   EXCP DCB STORAGE REQUIRED
         LA    R3,CPIQDCBL+4(,R3)  ADD SORTIN DCB REQ
         STH   R3,WBALDCB1(R10)    PHASE 1 DCB CORE REQUIRED
         AR    R0,R3               UPDATE PHASE 1 GEN CORE TOTAL
*
*        CHECK IF EXTRACT HAS BEEN SPECIFIED
*
RCS0802  CPITEST  CPIEXTRT         EXTRACT SPECIFIED ?
         BZ    RCS0806             NO, CHECK IF EQUALS SPECIFIED
*                                  YES
RCS0803  LH    R4,CPILAB07         EXTRACTED CONTROL FLD SIZE
         LA    R4,8(,R4)
         B     RCS0804(R15)        GOTO PROPER TECH ROUTINE
RCS0804  B     RCS0804A            +00 BALN TECH SPECIFIED
         B     RCS0804B            +04 POL TECH SPECIFIED
         B     RCS0804B            +08 OSC TECH SPECIFIED
*
RCS0804A LH    R1,WBALMRMX(R10)    BALN TECH - MERGE MAX
         B     RCS0805             COMPUTE SIZE
*
RCS0804B LH    R1,WBALNWKU(R10)    POL/OSC NO WORK UNITS AVAIL
RCS0805  LA    R1,1(,R1)
         STH   R1,WORK
         MH    R4,WORK             BALN = (EXTR CF+8) * (MRG MX + 1)
*                                  POL  = (EXTR CF+8) * (NWKU + 1)
*                                  OSC  = (EXTR CF+8) * (NWKU + 1)
         STH   R4,WBALEXT1(R10)    STORE TOTAL SIZE OF EXTRACTED
*                                  CONTROL FIELDS
         B     RCS0807             CONTINUE CALCULATIONS
*
*        CHECK IF EQUALS HAS BEEN SPECIFIED
*
RCS0806  LA    R4,0                SET EXTRACTED CF SIZE TO ZERO (0)
         STH   R4,CPILAB07         CLEAR CPILAB07
RCS0807  BAS   R14,RCS0807A        CONTINUE CALCULATING GENERATED CORE
*                                  SIZE THE CODE IS IN BGA
         B     RCS0808             +00 BALN TECH SPECIFIED
         B     RCS0808             +04 POL TECH SPECIFIED
         B     RCS0901             +08 OSC TECH SPECIFIED
*
RCS0808  AH    R0,K200
         ST    R0,WBALP1GC(R15)    SAVE BALN OR POLY PH 1 GEN CORE
*                                  CALCULATED SIZE
*
*        CALCULATE BLOCK COUNTERS AND BLOCK/DEBLOCK ADDR TABLE
*        VALUES
*
RCS0901  LH    R1,WBALNWKU(R10)    TECH NO WORK UNITS
         LR    R3,R1
         LA    R3,1(R3)            (N+1)
         SLL   R3,3                (N+1)*8
         B     RCS0902(R15)        GOTO PROPER TECH ROUTINE
RCS0902  B     RCS0903             +00 BALN TECH INDICATED
         B     RCS0903             +04 POL TECH INDICATED
*
*        OSCILLATING TECHNIQUE SPECIFIED
*
         AR    R0,R4               ADD IN EXTRACT ROUTINE SIZE
         AR    R0,R3               ADD IN BLK CTRS & BLK/DEBLK TABLE
         LR    R3,R1               NO OF WORK UNITS
         SLL   R3,5                (2N*16) = MAX NO OF CCW'S
         AR    R0,R3               ADD INTO PHASE 1 TOTAL
         LR    R3,R1               NO OF WORK UNITS
         SLL   R3,2                MULT BY 4-RECORD COUNTERS
         AR    R0,R3               UPDATE TOTAL
         AH    R0,K200
         ST    R0,WOSCP1GC         STORE OSC P12 GEN CORE REQ
         B     RCS1001             GO DO PH3
*
*        BALN OR POL TECH INDICATED
*        START CALCULATING P2 GEN CORE
*
RCS0903  LH    R1,WBALMRMX(R10)    TECH MERGE MAX
         LA    R1,1(,R1)           MRG MX + 1
         LR    R0,R4               EXTRACTED CF SIZE IF ANY
         AR    R0,R3               ADD IN BLK CTRS & BLK/DEBLK TABLE
RCS0904  LH    R3,WBALMRMX(R10)    CALCULATE INPUT/OUTPUT CCW SIZE
         SLL   R3,5                (2M*16) = MAX INPUT/OUTPUT CCW'S
         AR    R0,R3               UPDATE TOTAL
         AH    R0,K32              MAX OUTPUT BFR CCW'S
*
*        CALCULATE MAX CORE REQ FOR GETMAIN, ADDR AND SIZE TABLES
*
RCS0904A LH    R3,WBALMRMX(R10)    (M)
         SLL   R3,1                (2M)
         LA    R3,3(,R3)           (2M+3)
         SLL   R3,3                (2M+3) * 8
         AR    R0,R3               UPDATE GEN CORE TOTAL
RCS0905  LR    R3,R1               CALCULATE INPUT BFR ADDR TABLE SIZE
         SLL   R3,3                2(MRG MX) * 4
         AR    R0,R3               UPDATE TOTAL
RCS0906  LR    R3,R1               CALCULATE P2 IOB-ECB CORE SIZE
         MH    R3,K40              (MRG MX + 1) * 40
         STH   R3,WBALIOB2(R10)    PHASE 2 IOB-ECB CORE REQUIRED
         AR    R0,R3               UPDATE TOTAL
RCS0907  LH    R3,WBALNWKU(R10)    NO WORK UNITS
         MH    R3,K52              R3=P2 EXCP DCB CORE REQ
         STH   R3,WBALDCB2(R10)    PHASE 2 DCB CORE REQUIRED
         AR    R0,R3               UPDATE TOTAL
RCS0908  LH    R3,WBALNWKU(R10)    CALCULATE DCB ADR TABLE CORE REQ
         LA    R3,1(,R3)
         SLL   R3,2                (NWKU + 1) * 4
         AR    R0,R3               UPDATE TOTAL
*
*        CHECK FOR FIXED LENGTH RECORDS
*
RCS0909  CPITEST  CPIFIX           FIXED LENGTH RECORDS ?
         BZ    RCS0909A            NO
*                                  YES
         CPITEST  CPIGT256         RCDS > 256 ?
         BZ    RCS0909A            NO
         AH    R0,WMVRTSZ1         YES, ADD MOVE ROUTINE SIZE
*                                  NO
RCS0909A CPITEST  CPIME25          EXIT 25 ACTIVATED ?
         BZ    RCS0911             NO
*                                  YES
RCS0910  LH    R3,WBALEXT1(R10)    TECH EXTRACTED CF SIZE
         AR    R0,R3               UPDATE TOTAL
RCS0911  AH    R0,K200
         ST    R0,WBALP2GC(R15)    STORE PH 2 GEN CORE VALUE IN
*                                  PROPER TECH LOCATION
*
*        CALCULATE PHASE 3 GENERATED CORE VALUE (ALL TECHNIQUES)
*
RCS1001  LH    R1,WBALMRMX(R10)    TECH MERGE MAX
         SR    R0,R0               RESET TOTAL FOR PHASE 3
RCS1002  LR    R3,R1
         MH    R3,=AL2(CPIEDCBL)   (MRG MX + 1) * 56 = EXCP DCB CORE
         LA    R3,CPIQDCBL+4(,R3)  ADD SORTOUT DCB REQ
         STH   R3,WBALDCB3(R10)    PHASE 3 DCB CORE REQUIRED
         AR    R0,R3               UPDATE TOTAL
RCS1002A LH    R3,WBALMRMX(R10)    TECH MRG MX
         SLL   R3,1                (2M)
         LA    R3,3(,R3)           (2M+3)
         SLL   R3,3                (2M+3) * 8
         AR    R0,R3               UPDATE GEN CORE TOTAL
RCS1003  LR    R3,R1               CALCULATE IOB-ECB CORE REQ
         MH    R3,K40              (MRG MX + 1) * 40 = IOB-ECB CORE
         STH   R3,WBALIOB3(R10)    PHASE 3 IOB-ECB CORE REQUIRED
         AR    R0,R3               UPDATE TOTAL
RCS1004  LR    R3,R1               CALCULATE CCWS FOR PHASE 2
         SLL   R3,5                (2M*16) = MAX CCW'S CORE REQ
         AR    R0,R3               UPDATE TOTAL
RCS1005  LH    R3,WBALNWKU(R10)    CALCULATE DCB ADDR TABLE, BLK CTRS,
*                                  AND BLK/DEBLK ADR TABLE SIZE
         LA    R3,1(,R3)           NO OF WORK UNITS + 1
         MH    R3,K12              (MRG MX + 1) * 12 = TABLE CORE REQ
         AR    R0,R3               UPDATE TOTAL
RCS1006  LR    R3,R1               CALCULATE INPUT BFR ADR TABLE SIZE
         SLL   R3,3                2(MRG MX + 1) * 4 = TABLE SIZE
         AR    R0,R3               UPDATE TOTAL
         BAS   R14,RCS1006A        CONTINUE CALCULATING GENERATED CORE
*                                  SIZE THE CODE IS IN BGA
*
*        CHECK IF EXTRACT HAS BEEN INDICATED
*
RCS1007  CPITEST  CPIEXTRT         EXTRACT SPECIFIED ?
         BZ    RCS1009             NO
         STH   R3,WORK
         LH    R3,WBALMRMX(R10)    TECH MERGE MAX
         LA    R3,1(,R3)           MRG MX + 1
         MH    R3,WORK             (EXTR CF + 8) * (MRG MX + 1)
         STH   R3,WBALEXT3(R10)    STORE TOTAL SIZE OF EXTRACTED
*                                  CONTROL FIELDS FOR PHASE 3
         AR    R0,R4               ADD SIZE TO PHASE 3 GEN CORE TOTAL
         LH    R3,CPILAB07         EXTRACTED CONTROL FIELD SIZE
         LA    R3,8(,R3)
RCS1009  CPITEST  CPIFIX           FIXED LENGTH RECORDS ?
         BZ    RCS1014             NO
RCS1010  CPITEST  CPIME35          EXIT E35 SPECIFIED ?
         BO    RCS1011             YES, CALCULATE PHASE 3 MOVE
         CLC   K256(2),CPIRCDL3    L3 > 256 ?
         BH    RCS1014             NO, STORE TOTALS
RCS1011  LH    R4,CPIRCDL3         OUTPUT RECORD LENGTH
         LA    R4,255(,R4)
         SRL   R4,8                L3/256 = Q1
         LR    R5,R4               SAVE Q1 VALUE
RCS1012  MH    R4,K06              Q1 * 6
         LA    R4,2(,R4)           (Q1 * 6) + 2
         CH    R5,K16              ORIGINAL Q1 VS 16
         BL    RCS1013             BRANCH LOW
         SRL   R5,4                Q1/16
         MH    R5,K12              (Q1/16) * 12
         AR    R4,R5               TOTAL MOVE SIZE
RCS1013  STH   R4,WMVRTSZ3         SAVE PHASE 3 MOVE ROUTINE SIZE
         AR    R0,R4               UPDATE PHASE 3 GEN CORE TOTAL
RCS1014  AH    R0,K200
         ST    R0,WBALP3GC(R15)    STORE PH 3 GEN TOTAL
*
*        CALCULATE PHASES 1-2-3 AVAILABLE CORE (ALL TECHNIQUES)
*
RCS1101  SR    R1,R1
         ICM   R1,B'0111',CPITAVLC  TOTAL AVAILABLE CORE
         LR    R2,R1               PHASE 2 CORE TOTAL
         LR    R3,R1               PHASE 3 CORE TOTAL
         ST    R1,WTAVLC           SAVE VALUE FOR LATER REFERENCE
         B     RCS1102(R15)        GOTO PROPER TECH ROUTINE
RCS1102  B     RCS1105             +00 BALN TECH INDICATED
         B     RCS1109             +04 POL TECH INDICATED
*
*        OSCILLATING TECHNIQUE SPECIFIED
*
RCS1103  LM    R5,R6,WP12OSCR      OSC - PHASES 12 & 3 RUNNING CORE
         A     R5,WOSCP1GC         OSC PHASE 12 GEN CORE
         A     R6,WOSCP3GC         OSC PHASE 3 GEN CORE SIZE
RCS1104  SR    R1,R5               OSC PHASE 12 AVAILABLE CORE
         SR    R2,R6               OSC PHASE 3 AVAILABLE CORE
         STM   R1,R2,WOSC1COR      STORE OSC AVAILABLE CORE VALUES
         B     RCS1201             CHECK PH1 BFRS
*
*        BALANCED TECHNIQUE INDICATED
*
RCS1105  LM    R4,R6,WP1BALCR      BALN - PHASES 1,2 & 3 RUNNING
*                                  CORE SIZES
RCS1106  A     R4,WBALP1GC         BALN - PHASE 1 GEN CORE SIZE
         A     R5,WBALP2GC         BALN - PHASE 2 GEN CORE SIZE
         A     R6,WBALP3GC         BALN - PHASE 3 GEN CORE SIZE
RCS1108  SR    R1,R4               BALN PHASE 1 AVAILABLE CORE
         SR    R2,R5               BALN PHASE 2 AVAILABLE CORE
         SR    R3,R6               BALN PHASE 3 AVAILABLE CORE
         STM   R1,R3,WBAL1COR      SAVE BALN AVAILABLE CORE VALUES
         B     RCS1201             CHECK PH1 BFRS
*
*        POLYPHASE TECHNIQUE INDICATED
*
RCS1109  LM    R4,R6,WP1POLCR      POL PHASES 1, 2 & 3 RUNNING
*                                  CORE SIZES
RCS1110  A     R4,WPOLP1GC         POL PHASE 1 GEN CORE SIZE
         A     R5,WPOLP2GC         POL PHASE 2 GEN CORE SIZE
         A     R6,WPOLP3GC         POL PHASE 3 GEN CORE SIZE
RCS1112  SR    R1,R4               POL PHASE 1 AVAILABLE CORE
         SR    R2,R5               POL PHASE 2 AVAILABLE CORE
         SR    R3,R6               POL PHASE 3 AVAILABLE CORE
         STM   R1,R3,WPOL1COR      SAVE POL AVAILABLE CORE VALUES
*
*        CALCULATE PHASE 1 AVAILABLE CORE
*        (LESS INPUT BUFFER/BUFFERS)
*
*        IF 2 SELECTOR CHANNELS ARE INDICATED, DETERMINE IF
*        PHASE 1 AVAILABLE CORE IS SUFFICIENT TO ALLOW FOR DOUBLE
*        BUFFERED INPUT. IF CORE REQUIRED FOR 2 INPUT BUFFERS IS
*        GREATER THAN THE AVAILABLE CORE, ONLY ONE INPUT BUFFER
*        WILL BE ALLOCATED
*
RCS1201  LH    R14,WCHNIND1        CHANNEL STATUS INDICATOR
         L     R4,WP1IPBFR         PHASE 1 INPUT BFR SIZE (BI)
         LR    R0,R1               SAVE PHASE 1 CORE VALUE
         B     RCS1202(R14)        GOTO PROPER CHANNEL STATUS RTN
RCS1202  B     RCS1206             +00 MPX CHANNEL INDICATED
         B     RCS1208             +04 1 SELECTOR CHANNEL INDICATED
*
*        2 SELECTOR CHANNELS INDICATED
*
RCS1204  SLL   R4,1                R4 = 2(BI)
         LA    R2,2                NO PHASE 1 INPUT BFRS
         SR    R1,R4               (P1AV/2BI)
         BP    RCS1210             YES, 2 BUFFERS WILL FIT
*
*        SET UP FOR ONE (1) INPUT BFR
*
         OI    WCSSWC,X'10'        INDICATE USER BFR SIZE TOO LARGE
*                                  FOR EFFICIENT PHASE 1 DOUBLE
*                                  BUFFERING
RCS1205  SRL   R4,1                R4 = 1(BI)
         LR    R1,R0               RESTORE ORIGINAL P1AV VALUE
RCS1206  LA    R2,1                NO PHASE 1 INPUT BFRS
RCS1207  SR    R1,R4               P1AV = P1AV - (BI CORE)
         BL    RCRABRT2            INSUFFICIENT CORE - INPUT BFR SIZE
*                                  TOO HIGH FOR AVAILABLE CORE
         B     RCS1210             STORE VALUES
*
*        1 SELECTOR CHANNEL INDICATED
*        CHECK IF INPUT AND WORK UNITS ARE ON THE SAME CHANNEL
*
RCS1208  CLI   WTQIND+1,X'08'      OSC TECH SPECIFIED ?
         BE    RCS1204             YES, TRY FOR 2 INPUT BFRS
         TM    WCSSWB,X'02'        INPUT/WORK SAME CHANNEL ?
         BO    RCS1204             NO, TRY FOR 2 INPUT BFRS
RCS1209  B     RCS1206             YES, SET UP 1 INPUT BFR
*
RCS1210  ST    R1,WBAL1AVP(R15)    STORE PHASE 1 AVAIL CORE LESS
*                                  BFR/BFRS IN PROPER TECH LOCATION
         STH   R2,WBALINP1(R10)    STORE NO PHASE 1 INPUT BFRS
         B     RCS1301(R15)        GOTO PROPER TECH ROUTINE
RCS1301  B     RCS1312             +00 BALN TECHNIQUE INDICATED
         B     RCS1313             +04 POL TECHNIQUE INDICATED
*
*        OSCILLATING TECHNIQUE SPECIFIED
*
RCS1302  LA    R2,0
RCS1303  LR    R3,R1               R3 = OSC P12 AVAILABLE CORE PRIME
*
*        CHECK FOR FIXED LENGTH RECORDS
*
RCS1304  CPITEST  CPIFIX           FIXED LENGTH RECORDS ?
         BZ    RCS1308             NO
*
*        CALCULATE G PRIME AND TREE PRIME FOR OSC FIXED LENGTH
*        RECORDS
*
RCS1305  LH    R4,CPIBINSZ
         LA    R4,7(,R4)           BIN SIZE + 7
         DR    R2,R4               G' = P12AV/BIN SZ + 7
*
*        ### DR DOES NOT SET THE COND CODE ###
*
         BM    RCRABRT2            INSUFFICIENT CORE
         ST    R3,WGPRIMEF
RCS1306  SR    R2,R2
         BCT   R3,RCS1306A         DECREMENT TO G-1
RCS1306A LA    R4,3
         DR    R2,R4               (G' - 1)/3
*
*        ### DR DOES NOT SET THE COND CODE ###
*
         BM    RCRABRT2            INSUFFICIENT CORE
RCS1307  LA    R4,20
         SR    R2,R2
         MR    R2,R4               TREE' = G'-1/3 * 20
         ST    R3,WTPRIMEF
         B     RCS1310             CHECK SIZE
*
*        CALCULATE G PRIME & TREE PRIME FOR OSC VARIABLE LENGTH
*        RECORDS
*
RCS1308  LH    R4,CPIBINSZ
         LA    R4,12(,R4)          BIN SIZE + 12
         DR    R2,R4               G' = P12AV/BIN SZ + 12
*
*        ### DR DOES NOT SET THE COND CODE ###
*
         BM    RCRABRT2            INSUFFICIENT CORE
         ST    R3,WGPRIMEV
RCS1309  SR    R2,R2
         BCT   R3,RCS1309A         DECREMENT TO G-1
RCS1309A LA    R4,12
         MR    R2,R4               TREE' = (G' - 1) * 12
         ST    R3,WTPRIMEV
*
*        SUBTRACT TREE PRIME FROM OSC PHASE 12 AVAILABLE CORE
*
RCS1310  LR    R2,R3               TREE PRIME VALUE
         LR    R3,R1               PHASE 12 AVAIL CORE
         ST    R3,WOSC2AVP         SAVE - TEST * TEST * TEST * TEST*
         SR    R3,R2               PHASE 12 AVAIL CORE LESS TREE
*                                  PRIME VALUE
RCS1311  LH    R4,WOSCNB2          OSC - TOTAL NO PHASE 2 BFRS (I/O)
         B     RCS1314             CALC BSL
*
*        BALANCED TECHNIQUE INDICATED
*
RCS1312  L     R3,WBAL2COR         BALN - PHASE 2 AVAILABLE CORE
         LH    R4,WBALNB2          BALN - TOTAL NO PHASE 2 BFRS (I/O)
         B     RCS1314             CALCULATE  BSL
*
*        POLYPHASE TECHNIQUE INDICATED
*
RCS1313  L     R3,WPOL2COR         POL - PHASE 2 AVAILABLE CORE
         LH    R4,WPOLNB2          POL - TOTAL NO PHASE 2 BFRS (I/O)
RCS1314  SR    R2,R2
         B     RCS1402             CALCULATE  BSL
*
*        CALCULATE SORT BLOCKING (BS) FOR FIXED OR VARIABLE
*        LENGTH RECORDS (ALL TECHNIQUES)
*
*        ENTRY FROM BUFFER CUT BACK ROUTINE
*
RCS1401  L     R3,WP2UPDAV(R15)    UPDATED PHASE 2 AVAILABLE CORE
         B     RCS1402A            CALCULATE  BSL
*
*        NORMAL ENTRY POINT
*
RCS1402  ST    R3,WP2UPDAV(R15)    SAVE PHASE 2 AVAILABLE VALUE
RCS1402A DR    R2,R4               P2AV/NB = BSL     (R3)
         SH    R3,WRECINCR         SORT BLOCKING - 4 OR 8
         BAS   R8,ROUNDD+4         ALIGN TO DOUBLE WORD
*
*        CHECK IF BUFFER SIZE (BSL) >= 1 RCD (+4 OR 8)
*
RCS1403  LH    R9,WRECIND          RECORD FORMAT INDICATOR
*                                  (FIXED = 4, VARIABLE = 0)
         B     RCS1403A(R9)        GOTO PROPER RCD FORMAT ROUTINE
RCS1403A B     RCS1403C            +00 VARIABLE LENGTH RECORDS IND
*
*        FIXED LENGTH RECORDS INDICATED
*
RCS1403B LH    R5,CPIRCDL2         +04 FIXED RECORD LENGTH
         LA    R5,4(,R5)           1 RECORD + 4
         B     RCS1403D            CHECK BSL VS RCD
*
*        VARIABLE LENGTH RECORDS INDICATED
*
RCS1403C LH    R5,CPIRCDL2         VARIABLE RECORD LENGTH
         LA    R5,8(,R5)           1 RECORD + 8
RCS1403D CR    R3,R5               BSL >= 1 RCD (+4 OR 8)
         BNL   RCS1404             YES
         B     RCS1517             NO, GOTO BFR CUT BACK ROUTINE
*
RCS1404  CH    R5,K10000           1 RCD (+4 OR 8) > 10K ?
         BH    RCS1405(R9)         YES, GOTO PROPER RCD FORMAT RTN
         B     RCS1408             NO
*
RCS1405  B     RCS1407             VARIABLE LENGTH RECORDS INDICATED
*
*        FIXED LENGTH RECORDS INDICATED - 1 RECORD EQUAL 10 K OR OVER
*
RCS1406  LA    R0,1                SET BS = 1
         BAS   R8,ROUNDF           ALIGN TO DOUBLE WORD
         STH   R0,WBALBS(R10)      STORE BS IN TECH LOCATION
         STH   R5,WBSLBAL(R10)     STORE BSL IN TECH LOCATION
         B     RCS1416             CHECK PH2 BFRS VS CORE
*
*        VARIABLE LENGTH RECORDS INDICATED
*        1 RECORD = 10 K OR OVER
*
RCS1407  BAS   R8,ROUNDF           DOUBLE WORD ALIGNMENT
         STH   R5,WBALBS(R10)      STORE BS IN TECH LOCATION
         STH   R5,WBSLBAL(R10)     STORE BSL IN TECH LOCA3ION
         LR    R3,R5
         B     RCS1416             CHECK PH2 BFRS VS CORE
*
*        CHECK IF BUFFER SIZE (BSL) < 10 K
*
RCS1408  CH    R3,K10000           BSL < 10K ?
         BL    RCS1410(R9)         YES, GOTO PROPER RCD FORMAT RTN
RCS1409  LH    R3,K10000           REDUCE BSL TO 10K
         B     RCS1410(R9)         GOTO PROPER RCD FORMAT ROUTINE
*
RCS1410  B     RCS1413             VARIABLE LENGTH RECORDS INDICATED
*
*        FIXED LENGTH RECORDS INDICATED - BSL < 10K
*
RCS1411  SR    R2,R2
         LH    R4,CPIRCDL2         RECORD LENGTH
         STH   R3,WBSLBAL(R10)     STORE BSL IN TECH LOCATION
         DR    R2,R4               BS = BSL/L2   (R3 = BS )
         STH   R3,WBALBS(R10)      STORE BS IN TECH LOCATION
RCS1412  MR    R2,R4               BS * L2
         LA    R3,4(,R3)           NEW BSL = (BS * L2) + 4
         BAS   R8,ROUNDD           ALIGN TO DOUBLE WORD
         STH   R3,WBSLBAL(R10)     STORE NEW BSL IN TECH LOCATION
         B     RCS1416             CHECK PH2 BFRS VS CORE
*
*        VARIABLE LENGTH RECORDS INDICATED - BSL < 10K
*
RCS1413  LR    R0,R3               SET R0 = BSL
         SR    R2,R2
         LH    R4,CPIRCDL2         MAX RECORD LENGTH
         LA    R4,8(,R4)           MAX RCD + 8
         DR    R2,R4               X = BSL/MAX RCD + 8
RCS1414  CH    R3,K01              X >= 1 RCD + 8 ?
         BNL   RCS1415             YES
         B     RCS1517             NO, GOTO BFR CUT BACK ROUTINE
*
RCS1415  AH    R0,K09              RECORD INCREMENT AND 7
         AH    R0,K06              BYTES FOR ROUNDING = 15
         N     R0,=XL4'FFFFFFF8'   FOR ALIGNMENT
         STH   R0,WBALBS(R10)      STORE BS IN TECH LOCATION
         STH   R0,WBSLBAL(R10)     STORE BSL IN TECH LOCATION
         LR    R3,R0               R3 = BSL
*
*        CHECK IF PHASE 2 AVAILABLE CORE IS LARGE ENOUGH TO HOLD
*        ALL REQUIRED PHASE 2 BUFFERS
*
RCS1416  LH    R4,WBALNB2(R10)     TECH PHASE 2 TOTAL NO BFRS (I/O)
         MR    R2,R4               BSL * NB = Z (BFR CORE REQ)
         L     R2,WP2UPDAV(R15)    UPDATED PHASE 2 AVAILABLE CORE
RCS1416A CR    R3,R2               (BSL*NB) <= PHASE 2 AVAIL ?
         BNH   RCS1501             YES
         B     RCS1416B(R9)        GOTO PROPER RCD FORMAT ROUTINE
*
RCS1416B B     RCS1419             VARIABLE LENGTH RECORDS INDICATED
*
*        FIXED LENGTH RECORDS INDICATED
*
RCS1416C LH    R2,CPIRCDL2         SORT RECORD LENGTH
         SLL   R2,1
         LA    R2,4(,R2)           2 RCDS + 4
RCS1417  CR    R3,R2               BSL >= 2 RCDS + 4 ?
         BNL   RCS1418             YES
         B     RCS1517             NO, GOTO BFR CUT BACK ROUTINE
*
RCS1418  LH    R3,WBALBS(R10)      GET OLD BS VALUE
         BCT   R3,RCS1418A         BS = BS - 1
RCS1418A STH   R3,WBALBS(R10)      STORE NEW BS VALUE IN TECH LOCATION
         LH    R4,CPIRCDL2         RECORD LENGTH
         B     RCS1412             CALCULATE NEW BSL
*
*        VARIABLE LENGTH RECORDS INDICATED
*
RCS1419  LH    R2,CPIRCDL2         SORT RECORD LENGTH
         SLL   R2,1
         LA    R2,8(,R2)           2 RCDS + 8
         CR    R3,R2               BSL >= 2 MAX RCDS + 8 ?
         BNL   RCS1419A            YES
         B     RCS1517             NO, GOTO BFR CUT BACK ROUTINE
*
*        REDUCE BUFFER SIZE (BSL) BY 1 MAX RECORD LENGTH
*
RCS1419A LH    R2,CPIRCDL2         RECORD SIZE
         LR    R3,R0               LOAD OLD BSL
         SR    R3,R2               BSL = BSL - 1 MAX RECORD
         B     RCS1413             CHECK AGAIN IN AVAILABLE CORE
*
*        CHECK IF LEFT OVER CORE (X) CAN BE USED FOR ADDITIONAL
*        PHASE 2 BUFFERS
*
RCS1501  SR    R2,R3               LEFT OVER CORE = P2AV - (BSL*NB)
RCS1502  B     RCS1502A(R9)        GOTO PROPER RCD FORMAT RTN
RCS1502A B     RCS1504             +00 VARIABLE RCDS INDICATED
*
*        FIXED LENGTH RECORDS INDICATED
*
         B     RCS1503(R14)        +04 GOTO PROPER CHANNEL STATUS RTN
*
RCS1503  B     RCS1601             +00 MPX, GOTO PHASE 3
         B     RCS1504             +04 1 SELECTOR CHANNEL INDICATED
*
*        1 OR 2 SELECTOR CHANNELS INDICATED
*
RCS1504  LR    R3,R2               R3 = LEFT OVER CORE
         LR    R0,R2               SAVE VALUE FOR LATER REFERENCE
         LH    R4,WBSLBAL(R10)     SORT BUFFER SIZE
         CR    R3,R4               LEFT OVER CORE >= BSL ?
         BNL   RCS1508             YES
RCS1505  B     RCS1505A(R9)        GOTO PROPER RCD FORMAT RTN
RCS1505A B     RCS1506             +00 VARIABLE RCDS INDICATED
         B     RCS1601             +04 FIXED RCDS INDICATED, GOTO
*                                      PHASE 3
RCS1506  LH    R4,WBALNB2(R10)     TOTAL PHASE 2 BUFFERS
         SR    R2,R2
         DR    R2,R4               W = LEFT OVER CORE/NB
RCS1507  LH    R2,WBSLBAL(R10)     VAR - TECH BSL
         CH    R2,K10000           BSL > 10000 ?
         BNL   RCS1507B            YES
         AR    R2,R3               BSL = BSL + W
         CH    R2,K10000           NEW BSL > 10000 ?
         BNL   RCS1507A            YES
RCS1507B BAS   R8,ROUNDC           ALIGN TO DOUBLE WORD
         STH   R2,WBSLBAL(R10)     STORE TECH NEW BSL
         STH   R2,WBALBS(R10)      STORE TECH NEW BS
         B     RCS1601             GOTO PHASE 3
*
RCS1507A LH    R2,K10000           LOAD MAXIMUM BSL
         LA    R2,8(R2)            ADD 8 TO BSL
         STH   R2,WBALBS(R10)      STORE NEW BS
         STH   R2,WBSLBAL(R10)     STORE NEW BSL
         B     RCS1601             GOTO PHASE - 3
*
RCS1508  SR    R2,R2
         DR    R2,R4               Z = X/BSL
RCS1509  ST    R2,WFULL4           SAVE REMAINDER
RCS1510  LH    R6,WBALNB2(R10)
         LH    R5,WBALMRMX(R10)    TECH MERGE MAX
         SLL   R5,1
         LA    R5,2(,R5)           2M+2 VALUE
         AR    R6,R3               NB = NB + Z
         CR    R6,R5               NB > 2M+2 ?
         BH    RCS1511             YES
RCS1510A STH   R6,WBALNB2(R10)     STORE NEW PHASE 2 NB
         LA    R2,2
         STH   R2,WBALOUT2(R10)    SET UP 2 PHASE 2 OUTPUT BFRS
         B     RCS1515             CONTINUE
*
RCS1511  STH   R5,WBALNB2(R10)     STORE 2M+2 IN P2NB
         LA    R2,2
         STH   R2,WBALOUT2(R10)    STORE 2 PHASE 2 OUTPUT BFRS
RCS1512  SR    R6,R5               V = (NB+Z) - (2M+2)
RCS1513  SR    R2,R2
         LR    R3,R6               R3 = V
         LH    R4,WBSLBAL(R10)     R4 = BSL VALUE
         MR    R2,R4               Y = V * BSL
RCS1514  A     R3,WFULL4           REMAINSER = REMAINDER + Y
RCS1515  B     RCS1515A(R9)        GOTO PROPER RCD FORMAT RTN
RCS1515A B     RCS1516             +00 VAR LENGTH RCDS
         B     RCS1601             +04 FIXED RCDS, GOTO PHASE 3
*
RCS1516  LH    R3,WBSLBAL(R10)     LOAD BSL
         CH    R3,K10000           BSL >= 10000 ?
         BNL   RCS1601             YES, GOTO PHASE 3
         L     R3,WFULL4           R3=REMAINDER
         B     RCS1506             UP TO MAX OR OPT AND EXIT
*
*        BUFFER CUT BACK ROUTINE
*
RCS1517  LH    R14,WCHNIND2        PHASE 2 CHANNEL STATUS
         B     RCS1517A(R14)       GOTO PROPER CHANNEL STATUS RTN
RCS1517A B     RCRABRT2            +00 INSUFFICIENT CORE, MPX IND,
*                                      ALREADY AT MINIMUM BFRS
         B     RCS1518             +04 1 SELECTOR CHANNEL INDICATED
*
*        1 OR 2 SELECTOR CHANNELS INDICATED
*
RCS1518  LH    R6,WBALNB2(R10)
         LH    R5,WBALMRMX(R10)    TECH MERGE MAX
         LA    R5,1(,R5)           M + 1
         CR    R6,R5               NB > M + 1 ?
         BL    RCRABRT2            INSUFFICIENT CORE
RCS1519  BCT   R6,RCS1520          P2NB = P2NB - 1
RCS1520  CR    R6,R5               P2NB = M + 1 ?
         BE    RCS1521             YES
         LA    R5,2                SET UP 2 PHASE 2 OUTPUT BFRS
         B     RCS1521A            STORE  VALUES
*
RCS1521  LA    R5,1                SET UP 1 PHASE 2 OUTPUT BFR
RCS1521A STH   R5,WBALOUT2(R10)    STORE NO PHASE 2 OUTPUT BFRS
         STH   R6,WBALNB2(R10)     STORE NEW TOTAL PHASE 2 BFRS
*
*        UPDATE PHASE 2 GENERATED CORE AND AVAILABLE CORE
*
RCS1522  L     R3,WP2UPDAV(R15)    PHASE 2 UPDATED AVAILABLE CORE
         LA    R3,4(,R3)
         ST    R3,WP2UPDAV(R15)    STORE NEW PHASE 2 AVAIL CORE
         EX    0,RCS1522A(R15)     EXECUTE PROPER TECH LOAD INSTR
         B     RCS1523             SKIP EXECUTED INSTRUCTION
*
RCS1522A L     R1,WBALP2GC         BALN - PHASE 2 GEN CORE
         L     R1,WPOLP2GC         POL - PHASE 2 GEN CORE
         L     R1,WOSCP1GC         OSC - PHASE 2 GEN CORE
RCS1522B ST    R1,WBALP2GC         BAL - STORE NEW P2 GEN CORE VALUE
         ST    R1,WPOLP2GC         POL - STORE NEW P2 GEN CORE VALUE
         ST    R1,WOSCP1GC         OSC - STORE NEW P2 GEN CORE VALUE
RCS1523  SH    R1,K04              REDUCE GEN CORE SIZE BY FOUR (4)
         EX    0,RCS1522B(R15)
         SR    R2,R2
         LH    R4,WBALNB2(R10)     RECALCULATE BS AND BSL
         B     RCS1401             START  AGAIN
*
*        START OF PHASE 3
*        CALCULATIONS CHECK IF PHASE 3 WILL HANDLE PHASE 2
*        CALCULATED BFR SIZE (BSL)
*
RCS1601  LH    R14,WCHNIND3        PHASE 3 CHANNEL STATUS INDICATOR
         L     R4,WP3OPBFR         PHASE 3 OUTPUT BFR SIZE
         B     RCS1602(R14)        GOTO PROPER CHANNEL STATUS
RCS1602  B     RCS1604             +00 MPX CHANNEL INDICATED
         B     RCS1604             +04 1 SELECTOR CHANNEL INDICATED
*
*        2 SELECTOR CHANNELS INDICATED
*
RCS1603  SLL   R4,1                (BO+8)*2
         LA    R1,2                NO PHASE 3 OUTPUT BFRS
         B     RCS1604A            STORE
*
*        MPX OR 1 SELECTOR CHANNEL INDICATED
*
RCS1604  LA    R1,1                NO PHASE 3 OUTPUT BFRS
RCS1604A STH   R1,WBALOUT3(R10)    STORE NO PHASE 3 OUTPUT BFRS
*
*        SUBTRACT OUTPUT BFR/BFRS FROM PHASE 3 AVAILABLE CORE
*
RCS1605  EX    0,RCS1605A(R15)     LOAD TECH AVAILABLE CORE
         B     RCS1605B            AND UPDATE
*
RCS1605A L     R3,WBAL3COR         +00 BALN - PHASE 3 AVAILABLE CORE
         L     R3,WPOL3COR         +04 POL - PHASE 3 AVAILABLE CORE
         L     R3,WOSC3COR         +08 OSC - PHASE 3 AVAILABLE CORE
RCS1605B SR    R3,R4               P3AV = P3AV - BO
         BM    RCS1605C            NEGATIVE, BRANCH
         ST    R3,WBAL3AVP(R15)    SAVE VALUE FOR LATER REFERENCE
         LR    R0,R3               SAVE AVAILABLE CORE VALUE
         B     RCS1606             CHECK INPUT BFRS VS CORE
*
RCS1605C LA    R1,1
         CH    R1,WBALOUT3(R10)    2 PHASE 3 OUTPUT BFRS ?
         BE    RCRABRT2            INSUFFICIENT CORE
         B     RCS1604             YES, CUT BACK TO 1 PHASE 3 OUTPUT
*                                  BUFFER
*
*        CHECK IF PHASE 3 AVAILABLE CORE WILL HOLD AT LEAST THE
*        MERGE ORDER (M) NUMBER OF INPUT BUFFERS
*
RCS1606  LH    R4,WBALMRMX(R10)    TECH MERGE MAX
         SR    R2,R2
         DR    R2,R4               BSL3 = P3AV/M
RCS1607  CH    R3,WBSLBAL(R10)     BSL3 >= BSL ?
         BNL   RCS1610(R14)        YES
*                                  NO, BSL GREATER THAN BSL3
RCS1608  CH    R1,K02              2 PHASE 3 OUTPUT BFRS ?
         BE    RCS1609             YES
         AR    R1,R4               NB3 = M+1
         STH   R1,WBALNB3(R10)     STORE VALUE
         LR    R6,R3               R6 = BSL3 SIZE
         LH    R3,WBSLBAL(R10)     R3 = BSL2 SIZE
         B     RCS1701             RECALCULATE BSL AND BS
*
RCS1609  L     R4,WP3OPBFR         PHASE 3 OUTPUT BFR SIZE
         B     RCS1604             REDUCE TO ONE
*
*        BSL3 GREATER THAN BSL
*        CAN ADDITIONAL CORE BE UTILIZED FOR ADDITIONAL BFRS
*
RCS1610  B     RCS1615B            MPX CHANNEL INDICATED
         B     RCS1610A            1 SELECTOR CHANNEL INDICATED
*
*        1 OR 2 SELECTOR CHANNELS INDICATED
*
RCS1610A LA    R1,2
         CH    R1,WBALOUT3(R10)    2 PHASE 3 OUTPUT BFRS ?
         BE    RCS1611             YES
*
*        CHECK IF ANOTHER OUTPUT BUFFER FOR PHASE 3 CAN BE
*        ALLOCATED
*
         L     R6,WBAL3AVP(R15)    P3AV - 1(BO)
         SR    R2,R2
         LH    R3,WBSLBAL(R10)     R3=BSL (PHASE 2 BFR SIZE)
         MR    R2,R4               BSL*M = P3 MIN CORE REQUIRED
         SR    R6,R3               P3AV = P3AV - ((M * BSL) + (BO))
         L     R4,WP3OPBFR         PHASE 3 OUTPUT BFR SIZE
         SR    R6,R4               P3AV - 2ND BO
         BM    RCS1611             NEGATIVE, BRANCH
         SR    R0,R4
         ST    R0,WBAL3AVP(R15)    STORE NEW PHASE 3 AVAILABLE CORE
*                                  TO INPUT BUFFERS
         STH   R1,WBALOUT3(R10)    STORE NEW NO PHASE 3 OUTPUT BFRS
RCS1611  LH    R1,WBALMRMX(R10)    TECH MERGE MAX
         LR    R4,R1               SAVE VALUE
         SLL   R4,1                (2 * M)
RCS1611A LR    R3,R0               R3 = PHASE 3 AVAILABLE CORE
RCS1611B SR    R2,R2
         DR    R2,R4               P3AV/2M = NEW BSL3
RCS1612  CH    R3,WBSLBAL(R10)     BSL3 >= BSL ?
         BNL   RCS1615             YES,
*                                  NO, BSL3 LESS THAN BSL
RCS1613  BCT   R4,RCS1614          REDUCE 2M VALUE (R4) BY 1
RCS1614  CR    R4,R1               R4 >= M ?
         BNL   RCS1611A            YES
*                                  NO
RCS1615  LH    R3,WBALOUT3(R10)    NO PHASE 3 OUTPUT BUFFERS
         AR    R4,R3
         STH   R4,WBALNB3(R10)     TOTAL NO PHASE 3 BUFFERS (I/O)
RCS1615A B     RCS1801             GOTO PHASE 1 CALCULATIONS
*
*        MPX CHANNEL INDICATED
*
RCS1615B LH    R4,WBALMRMX(R10)    TECH MERGE MAX
         B     RCS1615             STORE TOTAL
*
*        RECALCULATE SORT BLOCKING (BS) AND BUFFER SIZE (BSL)
*        BSL CALCULATED IN PHASE 2 WILL NOT FIT IN PHASE 3
*
RCS1701  ST    R0,WFULL1           SAVE PHASE 3 AVAILABLE CORE - RO
         LH    R0,CPIRCDL2         PHASE 2 RCD LENGTH
         LR    R5,R0               R5 = L2
RCS1702  AH    R5,WRECINCR         (F = +4, V = +8)
RCS1703  SR    R3,R0               BSL2 = BSL2 - L2
         BM    RCRABRT2            INSUFFICIENT CORE
RCS1704  CR    R6,R3               BSL3 >= BSL2 ?
         BNL   RCS1705             YES
         B     RCS1703             NO, REDUCE BSL2 AGAIN
*
RCS1705  CR    R3,R5               BSL2 >= 1 RCD (+4 OR +8) ?
         BNL   RCS1706             YES
         B     RCRABRT2            INSUFFICIENT CORE
*
RCS1706  B     RCS1706A(R9)        GOTO PROPER RCD FORMAT RTN
RCS1706A B     RCS1708             +00 VARIABLE RCDS INDICATED
*
*        FIXED LENGTH RCDS INDICATED
*
RCS1707  SR    R2,R2               +04
         LH    R4,CPIRCDL2         PHASE 2 RCD LENGTH
         DR    R2,R4               BS (NEW) = BSL2/L2
         STH   R3,WBALBS(R10)      STORE NEW BS
         SR    R2,R2
         MR    R2,R4               BSL (NEW) = BSL2 * L2
         AH    R3,WRECINCR         (F = +4, V = +8)
         BAS   R8,ROUNDD           ALIGN TO DOUBLE WORD
         STH   R3,WBSLBAL(R10)     STORE NEW BSL
         B     RCS1709             CHECK FOR EXTRA BFRS
*
*        VARIABLE LENGTH RCDS INDICATED
*
RCS1708  BAS   R8,ROUNDD           DOUBLE WORD ALIGNMENT
         STH   R3,WBALBS(R10)      STORE VARIABLE BS = BSL
         STH   R3,WBSLBAL(R10)     STORE VARIABLE BSL
*
*        CHECK PHASE 2 CHANNEL STATUS
*        NEW BS AND BSL MAY ALLOW FOR ADDITIONAL PHASE 2 BUFFERS
*
RCS1709  LH    R14,WCHNIND2        PHASE 2 CHANNEL STATUS INDICATOR
         B     RCS1709A(R14)       GOTO PROPER CHANNEL STATUS RTN
RCS1709A B     RCS1801             +00 MPX INDICATED, GOTO PHASE 1
         B     RCS1710             +04 SELECTOR CHANNEL INDICATED
*
*        1 OR 2 SELECTOR CHANNELS INDICATED
*
RCS1710  LH    R3,WBALMRMX(R10)    +08 TECH MERGE MAX
         SLL   R3,1
         LA    R3,2(,R3)
         CH    R3,WBALNB2(R10)     2M+2 PHASE 2 BFRS ?
         BE    RCS1801             YES, GOTO PHASE 1 CALCULATIONS
*
*        RECALCULATE PHASE 2 NUMBER OF BUFFERS WITH NEW BFR SIZE
*
RCS1711  SR    R2,R2
         L     R3,WP2UPDAV(R15)    PHASE 2 AVAIL BUFFER CORE
         LH    R4,WBSLBAL(R10)     NEW BFR SIZE (BSL)
         DR    R2,R4               NEW P2NB = P2AV/BSL
         STH   R3,WBALNB2(R10)     STORE NEW P2NB
         SH    R3,WBALMRMX(R10)    X = P2NB - MRG MAX
         CH    R3,K02              X >= 2 ?
         BNL   RCS1712             YES
         LA    R3,1                NO, INDICATE 1 PHASE 2 OUTPUT BFR
         B     RCS1712A            STORE
*
RCS1712  LA    R3,2                INDICATE 2 PHASE 2 OUTPUT BFRS
RCS1712A STH   R3,WBALOUT2(R10)    STORE NO PHASE 2 PUTPUT BFRS
         B     RCS1801             GOTO PHASE 1 CALCULATIONS
*
*        START OF PHASE 1 CALCULATIONS
*
*        CALCULATE CORE AVAILABLE TO PHASE 1 G AND TREE
*        CALCULATE G AND TREE FOR ALL TECHNIQUES (FIXED OR
*        VARIABLE)
*
RCS1801  LH    R14,WCHNIND1        SET PHASE 1 CHANNEL STATUS INDIC
RCS1801A L     R3,WBAL1AVP(R15)    PHASE 1 AVAILABLE CORE
RCS1802  B     RCS1802A(R14)       GOTO PROPER CHANNEL STATUS RTN
RCS1802A B     RCS1803             +00 MPX INDICATED
         B     RCS1804             +04 1 SELECTOR CHANNEL INDICATED
         B     RCS1808             +08 2 SELECTOR CHANNELS INDICATED
*
*        MPX CHANNEL INDICATED
*
RCS1803  LA    R0,1                INDICATE ONE (1) PHASE 1 INPUT BFR
         B     RCS1807             CHECK OUTPUT BFRS
*
*        1 SELECTOR CHANNEL INDICATED
*
RCS1804  TM    WCSSWB,X'02'        INPUT AND WORK SAME CHANNEL ?
         BO    RCS1808             NO
         CLI   WTQIND+1,X'08'      OSC TECHNIQUE SPECIFIED ?
         BE    RCS1808             YES, TRY FOR 2 OUTPUT BFRS
*
*        COMPARE INPUT AND SORT BUFFER SIZES
*        DOUBLE BUFFER THE SMALLER OF THE TWO BUFFERS
*
RCS1805  LH    R0,WBALBS(R10)      SORT BLOCKING
         LH    R1,CPIIPBLK         INPUT BLOCKING
         CR    R1,R0               BI >= BS ?
         BNL   RCS1808A            YES
RCS1806  S     R3,WP1IPBFR         (P1AV - 2(BI)) = P1AV
         LA    R0,2                INDICATE TWO (2) PHASE 1 INPUT BFRS
RCS1807  LH    R2,WBSLBAL(R10)     PHASE 1 OUTPUT BUFFER SIZE
         SR    R3,R2               (P1AV - 1(BSL)) = P1AV
         BM    RCRABRT2            INSUFFICIENT CORE - AVP LESS
*                                  THAN ONE OUTPUT BFR
         LA    R1,1                INDICATE ONE (1) PHASE 1 OUTPUT BFR
         B     RCS1809             AND STORE
*
*        2 SELECTOR CHANNELS INDICATED
*        CHECK INDICATOR TO SEE IF USER INPUT BUFFER SIZE WAS SO
*        LARGE THAT DOUBLE BUFFERING THE PHASE 1 INPUT RESULTS
*        IN INEFFICIENT SORT BUFFER SIZES AND VERY SMALL RECORD
*        STORAGE AREA.
*
RCS1808  TM    WCSSWC,X'10'        PHASE 1 DOUBLE BFR INPUT VOIDED ?
         BO    RCS1808A            YES, SINGLE BFR INPUT
         LA    R0,2                NO, INDICATE TWO (2) P1 INPUT BFRS
         B     RCS1808B            AND CHECK SIZE
*
RCS1808A LA    R0,1                INDICATE ONE (1) P1 INPUT BFR
RCS1808B LA    R1,2                INDICATE TWO (2) P1 OUTPUT BFRS
         LH    R2,WBSLBAL(R10)     PHASE 1 OUTPUT BUFFER SIZE
         SLL   R2,1
         SR    R3,R2               (P1AV - 2(BSL)) = P1AV ?
         BH    RCS1809             POSITIVE, KEEP BUFFERS
         LA    R14,0               CUT BACK TO MULTIPLEX
         B     RCS1801A            AND RECALCULATE
*
RCS1809  STH   R0,WBALINP1(R10)    STORE NO PHASE 1 INPUT BFRS
         AR    R1,R0               TOTAL PHASE 1 BFRS (I/O)
         STH   R1,WBALNB1(R10)     STORE TOTAL
RCS1810  ST    R3,WBALGCOR(R15)    STORE CORE AVAILABLE TO G AND TREE
         BAS   R6,RCSGCAL          CALCULATE G AND TREE AND RETURN
         B     RCS1810A            +00 NORMAL RETURN POINT FROM G CAL
         B     RCS1820A            +04 INSUFFICIENT CORE CUT BUFFERS
*
RCS1810A ST    R0,WBALG(R15)       STORE G IN TECH LOCATION
         ST    R1,WBALTREE(R15)    STORE TREE IN TECH LOCATION
         B     RCS1817             CHECK G VS BFRS
*
*        CALCULATE G AND TREE FOR ALL TECHNIQUES (FIXED OR
*        VARIABLE)
*
*        FIXED G = ((3P1AV - 68) - (3BINSZ))/(20 + 3BINSZ)
*
*        TREE = ((G - 1)/3) * 20 ROUNDED UP
*
*        VARIABLE  K = (MOD RCD LEN + LEN EXTR CF+3) / (BIN SZ-4) +1
*                  G = (3P1AV+36) - (3 BIN SZ*5) / 36 + (3 BIN SZ*K)
*
*               TREE = (G - 1) * 12
*
RCSGCAL  B     RCS1811(R9)         GOTO PROPER RCD FORMAT ROUTINE
RCS1811  B     RCS1814             +00 VARIABLE LENGTH RECORDS
*
*        FIXED LENGTH RECORDS INDICATED
*
RCS1812  LH    R4,K03              +04
         SR    R2,R2
         MR    R2,R4               (3P1AV)
         LA    R2,68               (8 FOR QSAM CONTROL, 8 FOR
*                                  ALIGNMENT) * 3 PLUS 20 FOR
*                                  WORST CASE (G = 3A+1)
         SR    R3,R2               (3P1AV-68)
         LH    R4,CPIBINSZ
         MH    R4,K03              (3*BINSZ)
         SR    R3,R4               (3P1AV-68)-(3BINSZ) = TOPLINE
         BM    4(R6)               RETURN TO TERMINATION POINT
         SR    R2,R2
         LA    R4,20(,R4)          (3BINSZ+20)
         DR    R2,R4               TOPLINE/(3BINSZ+20)
         LR    R0,R3               SET UP RETURN PARAMETERS
         CH    R0,K03              G >= 3 ?
         BL    4(R6)               NO, GOTO TERMINATION POINT
*
*        CALCULATE TREE SIZE
*
RCS1813  BCT   R3,RCS1813A         (G-1)
RCS1813A LA    R4,3
         SR    R2,R2
         DR    R2,R4               (G-1)/3
         LTR   R2,R2               REMAINDER ?
         BZ    RCS1813B            NO
         LA    R3,1(,R3)           YES, INCREMENT G VALUE BY ONE (1)
RCS1813B LA    R4,20
         MR    R2,R4               (G-1)/3 * 20
         LR    R1,R3               SET UP RETURN PARAMETERS
RCS1813C BR    R6                  RETURN TO CALLING ROUTINE
*
*        VARIABLE LENGTH RECORDS INDICATED
*        CALCULATE K VALUE
*
RCS1814  ST    R3,WFULL3           SAVE P1 AVAILABLE CORE VALUE
         LH    R3,CPIRCDL5         MODAL RECORD LENGTH
         LH    R4,CPILAB07         LENGTH OF EXTRACTED CONTROL FIELD
         LA    R4,3(,R4)           LEN EXTR CF + 3
         AR    R3,R4
         LH    R4,CPIBINSZ
         SH    R4,K04              (BINSZ-4)
         SR    R2,R2
         DR    R2,R4               MOD RCD LEN+EXTR CF+3/(BINSZ-4)
         LA    R3,1(,R3)
         STH   R3,WBALK(R10)       STORE K IN TECH LOCATION
*
*        CALCULATE VARIABLE G
*
RCS1815  L     R3,WFULL3           PHASE 1 CORE AVAILABLE TO G
         LA    R4,3
         MR    R2,R4               (3 * P1AV)
         LA    R3,36(,R3)          (3 * P1AV) + 36
         ST    R3,WFULL1
         LH    R3,CPIBINSZ
         MR    R2,R4               (3 * BINSZ)
         LH    R4,WBALK(R10)       TECH K FACTOR
         MR    R2,R4               (3 * BINSZ) * K
         LR    R4,R3
         L     R3,WFULL1
         SR    R3,R4               (3P1AV+36) - ((3BINSZ)K)
         BM    4(R6)               RETURN TO TERMINATION POINT
         LA    R4,36(,R4)          36 + ((3BINSZ)K)
         SR    R2,R2
         DR    R2,R4
         LR    R0,R3               SET UP RETURN PARAMETERS
         CH    R0,K03              G >= 3 ?
RCS1815A BM    4(R6)               NO, GOTO TERMINATION POINT
*
*        CALCULATE VARIABLE TREE
*
RCS1816  BCT   R3,RCS1816A         (G - 1)
RCS1816A SR    R2,R2
         LA    R4,12
         MR    R2,R4               (G-1) * 12
         LR    R1,R3               SET UP RETURN PARAMETERS
         CH    R1,K40              TREE < 40 ?
         BNL   RCS1816B            NO
         LA    R1,36               LOAD MINIMUM TREE SIZE
*
*        THIS CHECK IS BEING MADE TO ENSURE THAT RSA CAN CONTAIN
*        FOUR MAX. LENGTH RECORDS PLUS TREE. THIS IS NECESSARY
*        BECAUSE K IS CALCULATED BASED ON MODAL RECORD LENGTH.
*
RCS1816B LH    R3,CPIRCDL1         MAX LENGTH RECORD
         MH    R3,K04              4(MAX RCD LEN)
         AR    R3,R1               4(MAX RCD LEN) + TREE
         C     R3,WFULL3           4(MAX RCD LEN) + TREE < RSA CORE ?
         BH    RCS1820A            YES, REDUCE BUFFERS
         BR    R6                  RETURN TO CALLING ROUTINE
*
*        CHECK IF CALCULATED G VALUE IS EQUAL OR GREATER THAN BS
*        IF SMALLER AND PARTIAL OR FULL OVERLAP INDICATED, CUT
*        BACK NUMBER PHASE 1 BFRS TO INCREASE G VALUE. IF NO
*        OVERLAP INDICATED, STAY WITH PRESENT G VALUE.
*
RCS1817  B     RCS1817A(R9)        GOTO PROPER RCD FORMAT RTN
RCS1817A B     RCS1819             +00 VARIABLE LENGTH RCDS INDICATED
*
*        FIXED LENGTH RCDS INDICATED
*
RCS1818  LH    R0,WBSLBAL(R10)     +04 FIXED BSL
         LH    R3,WBALBS(R10)      FIXED BS
         B     RCS1820             GOTO COMPARE
*
*        VARIABLE LENGTH RCDS INDICATED
*
RCS1819  SR    R2,R2
         LH    R3,WBSLBAL(R10)     VARIABLE BSL
         LR    R0,R3               R0 = VARIABLE BSL
         LH    R4,CPIRCDL1         VARIABLE - MAX INPUT RCD LENGTH
         DR    R2,R4               VAR BS = BSL/L1
RCS1820  L     R4,WBALG(R15)       TECH G VALUE
         CR    R4,R3               G >= BS ?
         BNL   RCS1824             YES
RCS1820A L     R5,WP1IPBFR         R5 = PHASE1 INPUT BFR SIZE
         LH    R0,WBSLBAL(R10)     LOAD BSL
         LH    R1,WBALNB1(R10)     TOTAL NO PHASE 1 BFRS
         CH    R1,K02              TOTAL BFRS > 2 ?
         BNH   RCS1824             NO
RCS1821  CH    R1,K04              TOTAL BFRS = 4 ?
         BL    RCS1823             NO, TOTAL BFRS = 3
*
*        PHASE 1 TOTAL NO BFRS = 4
*        COMPARE INPUT BFR SIZE VS OUTPUT BFR SIZE AND STRIP OFF
*        THE LARGER OF THE 2
*
         SH    R1,K01              P1NB = P1NB - 1
         CR    R5,R0               INPUT BFR >= BSL ?
         BL    RCS1822             NO, BSL GREATER
         STH   R1,WBALNB1(R10)     STORE UPDATED P1NB TOTAL
         LA    R1,1                SET UP FOR 1 PHASE 1 INPUT BFR
         STH   R1,WBALINP1(R10)    STORE VALUV IN P1 INPUT NO
RCS1821A L     R3,WBALGCOR(R15)    CORE AVAILABLE TO G CALCULATIONS
         AR    R3,R5               ADD IN INPUT BFR SIZE
         B     RCS1810             RECALCULATE G AND TREE
*
RCS1822  STH   R1,WBALNB1(R10)     STORE UPDATED P1NB TOTAL
RCS1822A L     R3,WBALGCOR(R15)    CORE AVAILABLE TO G CALCULATIONS
         AR    R3,R0               ADD IN BSL SIZE
         B     RCS1810             RECALCULATE G AND TREE
*
*        PHASE 1 TOTAL BFRS EQUAL THREE (3)
*        STRIP OFF SINGLE OVERLAPPED BFR TO INCREASE G
*
RCS1823  SH    R1,K01              P1NB = P1NB - 1
         STH   R1,WBALNB1(R10)     STORE UPDATED P1NB TOTAL
         LH    R1,WBALINP1(R10)    NO PHASE 1 INPUT BFRS
         CH    R1,K01              2 PHASE 1 INPUT BFRS ?
         BE    RCS1822A            NO, ADD 1 BSL TO G CORE VALUE
         B     RCS1821A            YES, ADD 1 BI TO G CORE VALUE
*
RCS1824  L     R0,WBALG(R15)
         B     RCS1825(R15)        GOTO PROPER TECH
RCS1825  B     RCS1826             +00 BALN TECH
         B     RCS1826             +04 POL TECH
*
*        OSC TECH INDICATED
*
         CH    R0,K03              +08 G >= 3 ?
         BL    RCRABRT2            NO, INSUFFICIENT CORE
         LH    R0,WBSLBAL(R10)     BSL
         CH    R0,CPIBINSZ         BSL < BINSIZE ?
         BL    RCRABRT2            YES, TERMINATION, INSUFF CORE
         B     RCS1827             NO, DO NMAX
*
*        BALN OR POL TECH INDICATED
*
RCS1826  CH    R0,K02              G >= 2 ?
         BL    RCRABRT2            NO, INSUFFICIENT CORE
*
*        CALCULATE NMAX
*
RCS1827  LH    R0,WBALBS(R10)      LOAD BS FOR NMAX CAL
         LH    R1,WBSLBAL(R10)     LOAD BSL FOR NMAX CAL
         LH    R2,WBREELS(R10)     LOAD NO OF REELS FOR NMAX
         BAS   R6,RCSCAP           CALCULATE NMAX
         ST    R3,WBALNMAX(R15)    STORE NMAX IN TECH LOCATION
*
*        CAPACITY CHECK
*
         TM    WCSSWB,X'20'        FILE SIZE OMITTED ?
         BZ    RCR3005             YES
         C     R3,WFILSZ           NMAX EXCEEDED ?
         BL    RCRABRT1            YES, TERMINATE TECHNIQUE
*                                  NO
         B     RCR1901             OPTIMIZE
*
WREGSV1  DC    16F'0'              REGISTER SAVE AREA
VIERRCR  DC    V(IERRCR)
VIERBGA  DC    V(IERBGA)
*
         LTORG
*
./ ADD NAME=IERRCT   0101-20211-20211-1200-00273-00273-00000-RELEASE 00
RCT      TITLE 'IERRCT - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRCT
*
*        MODULE FUNCTION/OPERATION -
*        INTER PHASE STORAGE DELETION MODULE
*        1. FREE STORAGE OBTAINED BY THE GETMAIN MACRO
*        2. DELETE SORT RUNNING PROGRAMS AND USER PROGRAMS
*        3. CLOSE I/O DEVICES IF THE JOB IS TO BE ABNORMALLY
*           TERMINATED
*        THIS MODULE IS IN STORAGE ONLY WHEN NECESSARY.
*        GENERATED STORAGE WILL NOT BE FREED BY THIS MODULE
*        EXCEPT AT END OF TASK
*
*        MODULES IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACROS USED -
*        SMPPI   CLOSE   FREEMAIN   DELETE   DCBD
*
*        ENTRY POINTS - ENTRY FROM - IERRCV
*                       CALLING SEQUENCE -
*                       LOAD    EP=IERRCT,DCB=SORTLIB
*                       LR      R11,R0
*                       BALR    R14,R11
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPICNTL   PPIBDSVA   PPIALG   PPINDSKA
*        PPISTDCB  PPIWKARE   PPIX16
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED - NONE
*
*        EXTERNAL ROUTINES - EXTRN IERRCV - SORT SYSTEM CONTROL
*
*        EXTERNAL PARAMETERS - NONE
*
*        EXITS - NORMAL - IERRCV - SORT SYSTEM CONTROL
*
*        EXITS - ERROR - NONE
*
*        TABLES/WORK AREA -
*        GETMAIN TABLE POINTED TO BY PPIWKARE USED TO FREE STORAGE
*        GETMAIN SIZES TABLE POINTED TO BY PPIWKARE+4 USED TO
*        FREE STORAGE
*        DCB ENTRY TABLE POINTED TO BY PPISTDCB USED IN CLOSING UNITS
*        MODULE TABLE BEGINING AT PPIALG AND ENDING AT PPIX16,
*        (USED AS A LIST OF MODULES TO BE DELETED)
*
*        NOTES - CONDITION CODE IS PASSED IN R15
*                ZERO INDICATES DELETION ONLY
*                12 MEANS DELETION AND CLOSING OF OPEN DCBS
*
IERRCT   CSECT
*
         USING *,R11               R11 MODULE ADDR
         USING IHADCB,R2           R2 DCB ADDR
         USING IERRCA,R13          R13 PPI ADDR
*
         IERENTRY 'IERRCT &SYSDATE &SYSTIME',REG=R11
*
         STM   R0,R15,RCTHOLD      SAVE ALL REGS
         LTR   R15,R15             PERFORM ABNORMAL ENDING PROCEDURE ?
         BNZ   RCTC2               YES, GOTO TEST FOR MERGE RUN
         PPITEST  PPIPH3+PPIMERGO  PHASE THREE OR MERGE ONLY ?
         BNZ   RCTCHK              NO, TEST FOR CHECKPOINT OPTION
         TM    RCTB4SW+1,X'20'     IF BEFORE SWITCH IS ON CONTINUE
         BO    RCTA1               WHERE LEFT OFF
         MVI   RCTB4SW+1,X'20'     ELSE TURN BEFORE SWITCH ON
*
*        FREE STORAGE OBTAINED VIA GETMAIN
*        THE ADDR OF EACH PORTION OF STORAGE CAN BE FOUND IN A
*        TABLE POINTED TO BY PPIWKARE, AND THE SIZE OF EACH
*        PORTION CAN BE FOUND IN A TABLE POINTED TO BY
*        PPIWKARE+4. THE LAST SIZE ENTRY MUST HAVE BIT 0 = 1 TO
*        END FREEMAIN
*
         L     R9,PPISTDCB         SET DCB TABLE ADDR
         PPITEST  PPIOSC           OSCILLATING SORT ?
         BO    RCTPH               YES, BRANCH
         PPITEST  PPI2314          CRCX SORT ?
         BO    RCTPH               YES, BRANCH
         PPITEST  PPIPH2+PPIPH3+PPIMERGO  END OF PHASE 1 ?
         BNZ   RCTD1               NO, BYPASS TEST FOR SORTIN CLOSED
RCTPH    CLI   0(R9),X'80'         SORTIN CLOSED ?
         BE    RCTD1               YES, BRANCH AROUND SORTIN CLOSE
         L     R2,0(,R9)           R2 -> DCB ADDR
*
         CLOSE ((R2))              CLOSE SORTIN
*
RCTD1    MVI   0(R9),X'80'         INDICATE SORTIN CLOSED
         L     R3,PPIWKARE         R3 -> PPIWKARE ADDR TABLE
         L     R2,PPIWKARE+4       R2 -> PPIWKARE SIZE TABLE
*
*        LOOP TO FREE STORAGE
*
RCTD1A   SR    R0,R0
         ICM   R0,B'0111',1(R2)    R0 =  L'STORAGE TO FREEMAIN
         L     R1,0(,R3)           R1 -> STORAGE TO FREEMAIN
*
         FREEMAIN R,LV=(0),A=(1)   FREE GETMAINED STORAGE
*
         TM    0(R2),X'80'         BIT ZERO = 1 ? IE LIST ENDED
         BO    RCTF1               YES, BRANCH
         LA    R2,4(,R2)           SET R2 TO NEXT ENTRY LENGTH
         LA    R3,4(,R3)           SET R3 TO NEXT ENTRY ADDR
         B     RCTD1A              FREE NEXT PIECE OF STORAGE
*
RCTF1    LA    R2,PPIALG           START OF MODULES
         LA    R3,PPIOPEN          END OF MODULES STARTED BY IER
         LA    R4,PPIEOF
*
RCTF2    ICM   R0,B'1111',0(R2)    SET PARAMETER REGISTER TO AN ENTRY
         BZ    RCTF3               NULL, SKIP TO NEXT ENTRY UPDATE
RCTST    MVC   MODNAME+3(3),0(R2)  ELSE PLACE NAME IN MODNAME
         LA    R0,MODNAME          R0 -> MODNAME
*
         DELETE   EPLOC=(0)        DELETE MODULE
*
         LTR   R15,R15             DELETE ERROR ?
         BNZ   RCTJ1               YES, BRANCH
RCTF3    LA    R2,8(,R2)           UPDATE TO NEXT MODULE LIST ENTRY
         CLR   R2,R4               TEST TO SEE IF BEFORE SWITCH SHOULD
RCTB4SW  NOP   RCTA2               CAUSE A PAUSE OVER TO RCV
RCTG3    CLR   R2,R3               IF POINTER IS POINTING TO AN ENTRY
         BNH   RCTF2               IN THE TABLE, GO BACK TO DELETE
         MVI   MODNAME,C' '        CLEAR MODULE NAME AREA TO BLANKS
         MVC   MODNAME+1(7),MODNAME
         MVC   RCTST(6),RCTSTOV    OVERLAY FOR USER EXITS
         LA    R3,PPIX16           SET R3 TO END OF MODULES
         CLR   R2,R3               ALREADY FINISHED ?
         BNH   RCTF2               NO, FINISH USER EXITS
RCTJ3    LM    R0,R15,RCTHOLD      RESTORE REGISTERS
         BR    R14                 RETURN TO SORT SYSTEM CONTROL (RCV)
*
RCTA1    LM    R2,R4,REGREST
         MVI   RCTB4SW+1,X'00'     TURN OFF BEFORE SWITCH
         B     RCTF2               GOTO TEST FOR NULL ENTRY
*
RCTA2    STM   R2,R4,REGREST       SAVE R2 - R4 FOR NEXT PASS
         B     RCTJ3               RETURN TO RCV FOR CLOSE
*
*        A MODULE DELETE HAS FAILED
*
RCTJ1    L     R15,PPIADSSC
         BAS   R14,28(,R15)        CALL DELETE ERROR MESSAGE RTN
         MVI   RCTG4+1,X'00'       SET BRANCH TO RCTD1 AT RCTG4 TO NOP
         LM    R0,R14,RCTHOLD      RESTORE REGISTERS EXCEPT CC(R15)
         LA    R15,12              SET CC (R15) TO ERROR = 12
         ST    R15,RCTHOLD+60      RESET R15 TO INDICATE ERROR CODE
RCTC2    L     R3,PPISTDCB         R3 WILL BE A POINTER TO DCB ENTRIES,
         L     R2,0(,R3)           EACH CLOSED ENTRY BYTE 1 = X'80'
         PPITEST  PPIMERGO         MERGE ONLY ?
         BZ    RCTXX1              NO, SKIP MERGE SET UP
         LH    R5,PPIMRGMX
         B     RCTE3A              GOTO INCREMENT DCB PTR
*
RCTXX1   PPITEST  PPITAPE          TAPE SORT ?
         BO    RCTC2A              YES, BRANCH
         LH    R5,PPINDSKA         NO, R5 = NO DISK AREAS
         B     RCTD3               SET FROM NUMBER OF DISK AREAS
*
RCTC2A   SR    R5,R5               R5 WILL BECOME A WORK UNIT COUNTER
         IC    R5,PPIBDSVA         SET FROM TOTAL WORK UNITS FIELD
*
*        IF PHASE 1 CLOSE FIRST UNIT AS INPUT (REWIND TO LOAD
*        POINT) SET DCBOFLAGS AND CLOSE REST AS OUTPUT. IF PHASE
*        2 SET DCBOFLAGS CLOSE ALL AS OUTPUT (AT LOAD POINT). IF
*        PHASE 3 CLOSE FIRST AS OUTPUT, SET DCBOFLAGS AND CLOSE
*        REST AS OUTPUT. IF MERGE ONLY CLOSE FIRST AS OUTPUT REST
*        AS INPUT. IN ALL CASE EXIT THROUGH RCTG4 (FOR POSSIBLE
*        OVERLAY)
*
RCTD3    PPITEST  PPIPH2+PPIPH3    PHASE 2 OR 3 ?
         BZ    RCTD2               NO, MUST BE PHASE 1
         PPITEST  PPIPH3           PHASE 3 ?
         BZ    RCTD4X              NO, PHASE 2
*                                  ASSUME PHASE 3 OR MERGE ONLY
RCTE3A   LA    R3,4(,R3)           INCREMENT TO NEXT DCB POINTER
         LTR   R2,R2               ENTRY ALREADY CLOSED ? DO NOT
         BM    RCTE4               CLOSE IT AND BRANCH TO REMAINDER
         TM    DCBOFLGS,DCBOFOPN   DATASET OPEN ?
         BZ    RCTE4               NO, BYPASS CLOSE
*
         CLOSE ((R2),LEAVE)        LEAVE UNIT POSITIONED AT LOAD POINT
*
         LTR   R15,R15             CLOSE SUCCESSFULL ?
         BZ    RCTE4               YES,  BRANCH
*
         DC    H'0'                CLOSE FAILED, FORCE 0C1 FOR
*                                  DIAGNOSTIC PURPOSES
RCTE4    PPITEST  PPIMERGO         MERGE ONLY ?
         BZ    RCTD4               NO, MUST BE PHASE 3
RCTF4    ICM   R2,B'1111',0(R3)    R2 -> NEXT DCB, ALREADY CLOSED ?
         BM    RCTF4A              YES, CHECK NEXT ENTRY
         TM    DCBOFLGS,DCBOFOPN   DATASET OPEN ?
         BZ    RCTF4A              NO, BYPASS CLOSE
*
         CLOSE ((R2),REREAD)       NO, CLOSE WITH REWIND
         LTR   R15,R15             CLOSE SUCCESSFULL ?
         BZ    RCTF4A              YES,  BRANCH
*
         DC    H'0'                CLOSE FAILED, FORCE 0C1 FOR
*                                  DIAGNOSTIC PURPOSES
RCTF4A   LA    R3,4(,R3)           INCREMENT TO NEXT DCB POINTER
         BCT   R5,RCTF4            DECREMENT R5
RCTG4    B     RCTD1               THIS BRANCH MAY BECOME NOP AT RCTK1
         B     RCTJ3               ALTERNATE BRANCH POINT IF RCTG4=NOP
*
RCTD2    LA    R3,4(,R3)           INCREMENT TO FIRST WORK UNIT
         LTR   R2,R2               UNIT ALREADY CLOSED ?
         BM    RCTD4               YES, BRANCH TO REMAINDER OF UNITS
         TM    DCBOFLGS,DCBOFOPN   DATASET OPEN ?
         BZ    RCTD4               NO, BYPASS CLOSE
*
         CLOSE ((R2),REREAD)       NO, CLOSE WITH REWIND
         LTR   R15,R15             CLOSE SUCCESSFULL ?
         BZ    RCTD4               YES,  BRANCH
*
         DC    H'0'                CLOSE FAILED, FORCE 0C1 FOR
*                                  DIAGNOSTIC PURPOSES
RCTD4    ICM   R2,B'1111',0(R3)    R2 ->  NEXT DCB ADDR ENTRY, CLOSED ?
         BM    RCTD5A              YES, BRANCH TO SET UP FOR NEXT
         NI    DCBOFLGS,255-DCBOFLRB  ENSURE READ BACKWARDS BIT IS OFF
         PPITEST  PPITAPE          TAPE SORT ?
         BO    RCTCLOSE            YES, BRANCH
         XC    DCBDSORG,DCBDSORG   CLEAR DSORG FOR DIRECT ACCESS
*
RCTCLOSE CLOSE ((R2),REREAD)       CLOSE A UNIT
         LTR   R15,R15             CLOSE SUCCESSFULL ?
         BZ    RCTD5A              YES,  BRANCH
*
         DC    H'0'                CLOSE FAILED, FORCE 0C1 FOR
*                                  DIAGNOSTIC PURPOSES
RCTD5A   LA    R3,4(,R3)           INCREMENT TO NEXT DCB POINTER
         BCT   R5,RCTD4            IF UNITS REMAIN, GO BACK TO CLOSE
         B     RCTG4               ELSE GOTO SWITCH RCTG4
*
RCTSTOV  MVC   MODNAME(3),0(R2)    USED TO OVERLAY USER EXITS
RCTD4X   PPITEST  PPIOSC           OSC SORT ?
         BO    RCTD2               YES, GO INCR TO FIRST WORK UNIT
         LA    R3,4(,R3)           SKIP OVER UNUSED SORTIN/OUT SLOT
         B     RCTD4               OTHERWISE - PH 2
*
RCTCHK   PPITEST  PPICHKPT         CHECKPOINT ACTIVATED ?
         BZ    RCTD1               NO, NO CHECKPOINT TO DELETE
         LA    R0,IERCHK           R0 -> NAME OF IERCHK MODULE
*
         DELETE  EPLOC=(0)         DELETE CHECKPOINT MODULE
*
         LTR   R15,R15             DELETE ERROR ?
         BNZ   RCTJ1               YES, BRANCH TO RCTJ1
         B     RCTD1               NO ERROR, RETURN TO MAIN LINE
*
RCTHOLD  DC    16F'0'              SIXTEEN WORD SAVE AREA
REGREST  DC    3F'0'
*
MODNAME  DC    CL8'IER'
IERCHK   DC    CL8'IERCHK'
*
         PRINT NOGEN
*
         DCBD  DSORG=PS,DEVD=(TA,DA)
*
         PRINT GEN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERRCU   0101-20211-20211-1200-00044-00044-00000-RELEASE 00
RCU      TITLE 'IERRCU - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRCU
*
*        MESSAGES THAT ARE REQUIRED BY ALL THE MODULES THAT
*        COMPRISE LOAD MODULE IERRCM
*
*        THIS MODULE IS A DSECT IN -
*        IERRCM
*        IER8CM
*        IERRCK
*        IERRCS
*        IERRCL
*        IERRCJ
*        IERRCZ
*
*        ENTRY POINTS -
*
*        INPUT -
*
*        OUTPUT -
*
*        EXTERNAL ROUTINES -
*
*        EXITS - NORMAL -
*
*        EXITS - ERROR -
*
*        TABLES/WORK AREAS -
*
*        NOTES -
*
IERRCU   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRCU SOURCE
*
*----------------------------------------------------------------------
*
         COPY IERRCUI
*
*
         END
./ ADD NAME=IERRCUI  0101-20211-20211-1200-00511-00511-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERRCU SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERRCUI
*
IER000   DC    A(IER000T)
         DC    A(IER000X-IER000T)
*
IER001   DC    A(IER001T)
         DC    A(L'IER001T)
*
IER002   DC    A(IER002T)
         DC    A(L'IER002T)
*
IER003   DC    A(IER003T)
         DC    A(L'IER003T)
*
IER004   DC    A(IER004T)
         DC    A(L'IER004T)
*
IER005   DC    A(IER005T)
         DC    A(L'IER005T)
*
IER006   DC    A(IER006T)
         DC    A(L'IER006T)
*
IER007   DC    A(IER007T)
         DC    A(L'IER007T+L'IER007A+L'IER007B)
*
IER008   DC    A(IER008T)
         DC    A(L'IER008T+L'IER008A+L'IER008B)
*
IER009   DC    A(IER009T)
         DC    A(L'IER009T+L'IER009A+L'IER009B)
*
IER010   DC    A(IER010T)
         DC    A(L'IER010T)
*
IER011   DC    A(IER011T)
         DC    A(L'IER011T)
*
IER012   DC    A(IER012T)
         DC    A(L'IER012T)
*
IER013   DC    A(IER013T)
         DC    A(L'IER013T)
*
IER014   DC    A(IER014T)
         DC    A(L'IER014T)
*
IER015   DC    A(IER015T)
         DC    A(L'IER015T)
*
IER016   DC    A(IER016T)
         DC    A(L'IER016T)
*
IER017   DC    A(IER017T)
         DC    A(L'IER017T)
*
IER018   DC    A(IER018T)
         DC    A(L'IER018T)
*
IER019   DC    A(IER019T)
         DC    A(L'IER019T)
*
IER020   DC    A(IER020T)
         DC    A(L'IER020T)
*
IER021   DC    A(IER021T)
         DC    A(L'IER021T)
*
IER022   DC    A(IER022T)
         DC    A(L'IER022T)
*
IER023   DC    A(IER023T)
         DC    A(L'IER023T)
*
IER024   DC    A(IER024T)
         DC    A(L'IER024T)
*
IER025   DC    A(IER025T)
         DC    A(L'IER025T)
*
IER026   DC    A(IER026T)
         DC    A(L'IER026T)
*
IER027   DC    A(IER027T)
         DC    A(L'IER027T)
*
IER028   DC    A(IER028T)
         DC    A(L'IER028T)
*
IER029   DC    A(IER029T)
         DC    A(L'IER029T)
*
IER030   DC    A(IER030T)
         DC    A(L'IER030T)
*
IER031   DC    A(IER031T)
         DC    A(L'IER031T)
*
IER032   DC    A(IER032T)
         DC    A(L'IER032T)
*
IER033   DC    A(IER033T)
         DC    A(L'IER033T)
*
IER034   DC    A(IER034T)
         DC    A(L'IER034T)
*
IER035   DC    A(IER035T)
         DC    A(L'IER035T)
*
IER036   DC    A(IER036T)
         DC    A(L'IER036T+L'IER036A)
*
IER037   DC    A(IER037T)
         DC    A(L'IER037T+L'IER037A)
*
IER038   DC    A(IER038T)
         DC    A(L'IER038T+L'IER038A)
*
IER039   DC    A(IER039T)
         DC    A(L'IER039T)
*
IER040   DC    A(IER040T)
         DC    A(L'IER040T)
*
IER041   DC    A(IER041T)
         DC    A(L'IER041T)
*
IER042   DC    A(IER042T)
         DC    A(L'IER042T+L'IER042R)
*
IER043   DC    A(IER043T)
         DC    A(L'IER043T)
*
IER056   DC    A(IER056T)
         DC    A(L'IER056T)
*
IER057   DC    A(IER057T)
         DC    A(L'IER057T)
*
IER058   DC    A(IER058T)
         DC    A(L'IER058T)
*
IER059   DC    A(IER059T)
         DC    A(L'IER059T+L'IER059A)
*
IER060   DC    A(IER060)
         DC    A(IER060Z-IER060T)
*
IER062   DC    A(IER062T)
         DC    A(L'IER062T)
*
IER063   DC    A(IER063T)
         DC    A(L'IER063T+L'IER063A)
*
IER065   DC    A(IER065T)
         DC    A(L'IER065T)
*
IER067   DC    A(IER067T)
         DC    A(L'IER067T+L'IER067R)
*
IER070   DC    A(IER070T)
         DC    A(L'IER070T+L'IER070A)
*
IER071   DC    A(IER071T)
         DC    A(L'IER071T+L'IER071R)
*
IER072   DC    A(IER072T)
         DC    A(L'IER072T+L'IER072R)
*
IER073   DC    A(IER073T)
         DC    A(IER073X-IER073T)
*
IER074   DC    A(IER074T)
         DC    A(L'IER074T)
*
IER075   DC    A(IER075T)
         DC    A(L'IER075T)
*
IER076   DC    A(IER076T)
         DC    A(IER076X-IER076T)
*
IER900   DC    A(IER900T)
         DC    A(L'IER900T+L'IER900D)
*
IER961   DC    A(IER961T)
         DC    A(L'IER961T+L'IER961A)
*
IER962   DC    A(IER962T)
         DC    A(IER962Z-IER962T)
*
IER963   DC    A(IER963T)
         DC    A(L'IER963T+L'IER963A)
*
IER964   DC    A(IER964T)
         DC    A(IER964Z-IER964T)
*
IER965   DC    A(IER965T)
         DC    A(L'IER965T+L'IER965A)
*
IER980   DC    A(IER980T)
         DC    A(L'IER980T+L'IER980M+L'IER980R+L'IER980V)
*
IER981   DC    A(IER981T)
         DC    A(IER981X-IER981T)
*
IER985   DC    A(IER985T)
         DC    A(IER985X-IER985T)
*
IER000T  DC    C'IER000I 360S-SM-023 OS/360 Sort/Merge for MVS 3.8'
         DC    C' Version '
IER000V  DC    CL4' '              VERSION NUMBER FROM IERAM1
         DC    C' -'
IER000C  DC    XL9'4021217A21217A2121'  EDIT PATTERN FOR TIME
         DC    C' on '
IER000D  DC    CL2'DD'             DAY
         DC    C' '
IER000M  DC    CL3'MMM'            MONTH
         DC    C' '
IER000Y  DC    CL4'20YY'           YEAR
IER000X  EQU   *
*
IER001T  DC    C'IER001A Invalid label or columns 1-15 on a continuatioC
               n statement are not blank'
*
IER002T  DC    C'IER002A More than 60 Control Stmts, Duplicate Stmt fouX
               nd, or more than 1100 chars received from ATTACHing ProgX
               ram'
*
IER003T  DC    C'IER003A No Continuation statement found'
*
IER004T  DC    C'IER004A Incorrect or invalid delimiter found'
*
IER005T  DC    C'IER005A No control statement keyword found'
*
IER006T  DC    C'IER006A Operand does not start on the same record as tX
               he Operation keyword'
*
IER007T  DC    C'IER007A '
IER007A  DC    CL6' '
IER007B  DC    C' Statement syntax error'
*
IER008T  DC    C'IER008A '
IER008A  DC    CL6' '
IER008B  DC    C'Parameter or value longer than 8 characters'
*
IER009T  DC    C'IER009I Comment or excess information on '
IER009A  DC    CL6' '
IER009B  DC    C' Statement'
*
*        MESSAGE TEXT FOR IER010 - IER024 MOVED TO END OF MODULE
*        TO AVOID ADDRESSABILITY ISSUES
*
IER025T  DC    C'IER025A Record Length greater than maximum allowed'
*
IER026T  DC    C'IER026A L1 value not provided in LENGTH operand on RECC
               ORD statement'
*
IER027T  DC    C'IER027A Control Field is defined or extends past the MC
               inimum Record Length'
*
IER028T  DC    C'IER028A More than 17 Exits specified'
*
IER029T  DC    C'IER029A Invalid Exit Number or invalid usage'
*
IER030T  DC    C'IER030A Duplicate Exit definition'
*
IER031T  DC    C'IER031A Invalid character in MODS control statement'
*
IER032T  DC    C'IER032A Exit E61 required but not specified'
*
IER033T  DC    C'IER033A No E Control Field specified with E61 active'
*
IER034T  DC    C'IER034A Parameter Error on MODS control statement'
*
IER035T  DC    C'IER035A Duplicate Exit module name specified'
*
IER036T  DC    C'IER036I Blocking ='
IER036A  DC    CL6' '
*
IER037T  DC    C'IER037I Records in RSA ='
IER037A  DC    CL6' '
*
IER038T  DC    C'IER038I Estimated maximum records ='
IER038A  DC    X'40202020202020202020'  LEFT ZERO SUPPRESS EDIT PATT
*
IER039T  DC    C'IER039A Insufficient Storage'
*
IER040T  DC    C'IER040A Insufficient SortWork Units'
*
IER041T  DC    C'IER041A SIZE parameter is greater than Estimated Maxim*
               um Records'
*
IER042T  DC    C'IER042A SORTWORK Unit Error - '
IER042R  DC    C'                       '
IER042RT DC    A(IER0421)
         DC    A(IER0422)
         DC    A(IER0423)
IER0421  DC    CL(L'IER042R)'Duplicate DD Name'
IER0422  DC    CL(L'IER042R)'Unsupported Unit Type'
IER0423  DC    CL(L'IER042R)'More than one Unit Type'
*
IER043T  DC    C'IER043A Data set attributes not specified or conflict'
*
IER056T  DC    C'IER056A SORTIN or SORTOUT Data set not found'
*
IER057T  DC    C'IER057A SORTWK01 not assigned to the same Drive as SORX
               TIN'
*
IER058T  DC    C'IER058A SORTOUT assigned to the same Drive as a SORTWOX
               RK Drive'
*
IER059T  DC    C'IER059A Record Length invalid for SORTWORK device - ReX
               ason Code '
IER059A  DC    C'   '
*
IER060T  DC    C'IER060A '
IER060D  DC    CL8' '
         DC    C' DSCB not found on Volume '
IER060V  DC    CL6' '
IER060Z  EQU   *
*
IER062T  DC    C'IER062A Link Edit Error'
*
IER063T  DC    C'IER063A OPEN Error - '
IER063A  DC    CL8'       '
*
IER063B  DC    CL8'SORTLIB'
IER063C  DC    CL8'USERLIB'
IER063D  DC    CL8'SYSLMOD'
IER063E  DC    CL8'SYSLIN '
IER063F  DC    CL8'SYSIN'
IER063G  DC    CL8'SORTMODS'
*
IER065T  DC    C'IER065A SYSIN Deck structure Error'
*
IER067T  DC    C'IER067A Invalid EXEC or ATTACH Parameter - '
IER067R  DC    C'                                 '
IER067RT DC    A(IER0671)
         DC    A(IER0672)
         DC    A(IER0673)
         DC    A(IER0674)
         DC    A(IER0675)
         DC    A(IER0676)
         DC    A(IER0677)
         DC    A(IER0678)
*
IER070T  DC    C'IER070I Control Stmts '
IER070A  DC    CL72' '
*
IER071T  DC    C'IER071A OPTION Statement Error - '
IER071R  DC    CL40' '
IER071RT DC    A(IER0711)
         DC    A(IER0712)
         DC    A(IER0713)
         DC    A(IER0714)
         DC    A(IER0715)
         DC    A(IER0716)
*
IER072T  DC    C'IER072A DEBUG Statement Error - '
IER072R  DC    CL40' '
*
IER073T  DC    C'IER073A DYNALLOC Error,'
IER073A  DC    CL5'      '
         DC    C','
IER073C  DC    CL8' '
         DC    C',RC='
IER073D  DC    CL4'    '
         DC    C',S99ERROR='
IER073E  DC    CL4'    '
         DC    C',S99INFO='
IER073F  DC    CL4'    '
IER073R  DC    CL40' '
IER073X  EQU   *
IER0731  DC    CL(L'IER073R)',Invalid Device Name or Unit Type'
IER0732  DC    CL(L'IER073R)',Request to allocate xxxxx tracks failed'
IER0733  DC    CL(L'IER073R)',DDName not available '
*
IER074T  DC    C'IER074A Storage Size requested not available'
*
IER075T  DC    C'IER075A DYNALLOC Error. Less than 3 or more than 17 daX
               ta sets specified for intermediate storage'
*
IER076T  DC    C'IER076I Dynamically allocating'
IER076N  DC    X'40202020'
         DC    C' SORTWORK data sets,'
IER076C  DC    X'402020202020'
         DC    C' tracks per data set'
IER076X  EQU   *
*
IER900T  DC    C'IER900I Initial Diagnostic Options - '
IER900D  DC    C'                                                   '
*
IER961T  DC    C'IER961I Sort Technique - '
IER961A  DC    CL4'    '
*
IER962T  DC    C'IER962I Phase '
IER962A  DC    C'X'
         DC    C',Number of Buffers ='
IER962B  DC    C'    '
         DC    C',Buffer Size ='
IER962C  DC    CL6' '
IER962Z  EQU   *
*
IER963T  DC    C'IER963I Storage ='
IER963A  DC    CL8'        '
*
IER964T  DC    C'IER964I Phase '
IER964A  DC    C'0'
         DC    C' Storage ='
IER964B  DC    CL8'        '
IER964Z  EQU   *
*
IER965T  DC    C'IER965I Merge Order ='
IER965A  DC    CL4' '
*
IER980T  DC    C'IER980I Calling IER'
IER980M  DC    CL4' '
IER980R  DC    C'               '
IER980V  DC    CL4' '
IER980C  DC    C' Return Code = '
*
IER981T  DC    C'IER981I '
IER981D  DC    C'DDDDDDDD'         DDNAME
IER9811  DC    C','
IER981U  DC    CL3'UUU'            UCB NAME
IER9812  DC    C','
IER981Y  DC    C'YYYY'             DASD UNIT TYPE
IER9813  DC    C','
IER981V  DC    C'VVVVVV'           VOLSER
IER981CL DC    C' CCCCC'           CC LOWER LIMIT
         DC    C' '
IER981HL DC    C'HH'               HH LOWER LIMIT
         DC    C' -'
IER981CU DC    C' CCCCC'           CC UPPER LIMIT
         DC    C' '
IER981HU DC    C'HH'               HH UPPER LIMIT
         DC    C',Tracks ='
IER981NT DC    C' TTTTT'           NUMBER OF TRACKS IN EXTENT
IER981X  EQU   *
*
IER985T  DC    C'IER985I SORTWORK Device '
IER985A  DC    C'    '             DASD UNIT TYPE
         DC    C',Cyls per Vol ='
IER985B  DC    C'      '
         DC    C',Trks per Cyl ='
IER985C  DC    C'   '
         DC    C',Trklen ='
IER985D  DC    C'      '
IER985X  EQU   *
*
IER0671  DC    CL(L'IER067R)'Duplicate Technique Specification'
IER0672  DC    CL(L'IER067R)'Duplicate Message Specification  '
IER0673  DC    CL(L'IER067R)'Invalid Message Options          '
IER0674  DC    CL(L'IER067R)'Invalid Keyword                  '
IER0675  DC    CL(L'IER067R)'Duplicate Storage Specification  '
IER0676  DC    CL(L'IER067R)'Invalid Storage Value            '
IER0677  DC    CL(L'IER067R)'Invalid entry in ATTACH Parm List'
IER0678  DC    CL(L'IER067R)'ATTACH Parm List length error    '
*
IER0711  DC    CL(L'IER071R)'No Fields found'
IER0712  DC    CL(L'IER071R)'         Invalid Field'
IER0713  DC    CL(L'IER071R)'         Duplicate Field'
IER0714  DC    CL(L'IER071R)'         Too many parameters'
IER0715  DC    CL(L'IER071R)'         Insufficient parameters'
IER0716  DC    CL(L'IER071R)'         Invalid data'
*
IER010T  DC    C'IER010A No SORT or MERGE Control Statement found'
*
IER011T  DC    C'IER011A Too many Sort or Merge keywords'
*
IER012T  DC    C'IER012A No FIELDS defined on SORT or MERGE control staX
               tement'
*
IER013T  DC    C'IER013A Invalid keyword on SORT or MERGE control statex
               ment'
*
IER014T  DC    C'IER014A Duplicate Sort or Merge keyword'
*
IER015T  DC    C'IER015A Too many parameters on SORT or MERGE control sX
               tatement'
*
IER016T  DC    C'IER016A Invalid values in FIELDS operand'
*
IER017T  DC    C'IER017A Error in Displacement or Length value on SORT C
               or MERGE control statement'
*
IER018T  DC    C'IER018A Control Field Type Error on SORT or MERGE ContC
               rol Statement'
*
IER019T  DC    C'IER019A Incorrect numeric value for SIZE, FILSZ, SKIPRX
               EC, STOPAFT or DYNALLOC parameter'
*
IER020T  DC    C'IER020A Invalid RECORD keyword'
*
IER021T  DC    C'IER021A No TYPE definition found on RECORD statement'
*
IER022T  DC    C'IER022A Record TYPE not F or V on RECORD statement'
*
IER023T  DC    C'IER023A No LENGTH operand found on RECORD statement'
*
IER024T  DC    C'IER024A Incorrect value in LENGTH operand on RECORD stC
               atement'
*
./ ADD NAME=IERRCV   0101-20211-20211-1200-00760-00760-00000-RELEASE 00
RCV      TITLE 'IERRCV - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRCV
*
*        MODULE FUNCTION/OPERATION -
*        PROCESS ALL CONTROL LINKAGE AND MESSAGE PRINTING FROM
*        PHASE 1 TO PHASE 2 AND/OR PHASE 3
*        RECEIVES CONTROL AT ABNORMAL OR NORMAL END OF TASK.
*        THE MODULE CONTROLS THE FREEING OF STORAGE, DELETING
*        OF RUNNING PROGRAMS, AND CLOSING OF FILES. IERRCV
*        ACHIEVES THESE BY LOADING IERRCT AND THE APPROPRIATE END
*        OF PHASE ROUTINE, WHICH ACTUALLY DO THE ABOVE MENTIONED
*        FUNCTIONS OF FREEING STORAGE ETC FOR IERRCV. IERRCV
*        HAS A QSAM SYNAD (ERROR HANDLING) ENTRY
*
*        CHANGE LOG -
*        CHANGE THE MESSAGE WRITING ROUTINE IERGAPRT TO USE   REL 1.1
*        RECFM=FB TO WRITE MESSAGES TO THE MESSAGE DATA SET
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACROS USED BY MODULE -
*        LOAD
*        DELETE
*        WRITE
*        CHECK
*        PRTOV
*        WTO
*        SMPPI
*        FREEMAIN
*
*        ENTRY POINTS - ENTRY FROM IERRCB - CALLING SEQUENCE -
*                                           LOAD EP=IERRCV,DCB=(1)
*                                           LR    R15,R0
*                                           BALR  R14,R15
*
*                     - ENTRY FROM END OF TASK ROUTINE -
*                                           CALLING SEQUENCE -
*                                           L     R15,PPIADSSC
*                                           BR    R15
*
*                     - ENTRY FROM END OF PHASE ROUTINE -
*                                           CALLING SEQUENCE -
*                                           L     R15,PPIADSSC
*                                           B     4(,R15)  TO LOAD PH2
*                                           B     8(,R15)  TO LOAD PH3
*
*                     - ENTRY FROM ANY MODULE TO PRINT MESSAGE -
*                                           CALLING SEQUENCE -
*                                           L     R15,PPIADSSC
*                                           BAL   R14,12(,15)
*
*                     - ENTRY FROM MODULE WANTING TO TERMINATE SORT -
*                                           CALLING SEQUENCE -
*                                           L     R15,PPIADSSC
*                                           B     16(,R15)
*
*                     - ENTRY FROM ALGORITHM -
*                                           CALLING SEQUENCE -
*                                           L     R15,PPIADSSC
*                                           B     20(,R15)
*
*                     - ENTRY FROM QSAM ERROR ROUTINE -
*                                           CALLING SEQUENCE-
*                                        L   XX,YY (XX=ANY REGISTER AND
*                                        BR  XX     YY=A SYNAD ADDR
*                                                   IN A DCB WHICH
*                                                   CONTAINS THE SAME
*                                                   ADDR AS PPIASSC+24)
*
*                     - ENTRY FROM ANY MODULE TO PRINT THE DELETE
*                       ERROR MESSAGE
*                                           CALLING SEQUENCE -
*                                           L     R15,PPIADSSC
*                                           BAL   RO,28(,R15)
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIWKARE   PPIGETMN   PPIGETSZ
*        PPIADSSC   PPICNTL    PPISLIB
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPIWKARE   PPIADSSC
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL -
*        IERRCT                   - DELETE CLOSE FILES ROUTINE
*        MODULE SELECTION ROUTINE - AT BEGINNING OF EACH PASS
*        END OF PHASE ROUTINE     - AT END OF EACH PASS
*        IERRCB                   - TO RETURN CONTROL AFTER A
*                                   SUCCESSFUL SORT/MERGE
*        RETURN TO ANY MODULE WHICH HAS ENTERED IERRCV TO PRINT
*        A MESSAGE
*
*        EXITS - ERROR -
*        IERRCB - TO RETURN CONTROL ON A TERMINATE CONDITION
*
*        TABLES/WORK AREAS -
*        WNAME1  - 8 BYTE AREA CONTAINING IERRC6, IERRC7, IERRC8
*                  OR IERRCT FOR LOADING AND DELETING
*        WNAME2  - 8 BYTE AREA CONTAINING IERRPC, IERRPF, IERRPM,
*                  OR IER8PM FOR LOADING AND DELETING THE END
*                  OF PHASE MODULE
*        WERROR  - ERROR INDICATOR
*        WSAVE2  - ONE WORD LOCATION USED TO SAVE A CODE WHICH IS
*                  PASSED BY THE ALGORITHM AND USED IN BRANCHING
*                  TO THE END OF PHASE ROUTINE
*        WSWITCH - ONE BYTE AREA TO INDICATE END OF TASK
*        WSAVE3  - 13 WORD AREA FOR SAVING REGISTERS
*
*        NOTES - THIS MODULE IS USED FOR EVERY SORT/MERGE
*
IERRCV   CSECT                     SORT PHASE CONTROL
*
         USING *,R9                TEMPORARY BASE REGISTER
         USING IERRCA,R13          PPI BASE REGISTER
*
         IERENTRY 'IERRCV &SYSDATE &SYSTIME'
*
RCV001   LR    R9,R15              SET BASE REGISTER
         LR    R4,R14              SAVE RETURN REGISTER
         MVC   DCBLIST,0(R3)       MOVE SYSOUT AND SORTDIAG DCB ADDR
         LA    R3,WTORCV           R3 -> WTO AREA
*                                  ADD L'TEXT+TWO BYTE LENGTH FIELD
         AH    R3,WTORCV           R3 -> WTO ROUTE AND DESCR CODES
         MVC   0(4,R3),PPIWTOC     MOVE INSTALLATION CODES INTO WTO
         LA    R7,RCV002           R7 -> ENTRY JUMP TABLE
         ST    R7,PPIADSSC         INIT PPIADSSC TO VECTOR TABLE ADDR
*                                  FOR SUBSEQUENT ENTRIES
         STM   R0,R12,WSAVE3       SAVE R0 - R12
         PPITEST  PPIMERGO         MERGE ONLY ?
         BO    RCVMERG             YES, LOAD RC8
         LA    R0,IERRC6           NO, SORT, LOAD RC6
         BAS   R6,RCVLOAD          LOAD IERRC6
         B     RCVMDSEL            GO BRANCH TO RC6
*
RCVMERG  LA    R0,IERRC8
         BAS   R6,RCVLOAD          LOAD IERRC8
RCVMDSEL LR    R15,R0              LOAD R15 WITH ADDR OF MOD LOADED
         BR    R15                 BRANCH TO MODULE JUST LOADED
*
         DROP  R9
*
*---------------------------------------------------------------------
*
*        VECTOR TABLE
*
*        USED FOR ALL ENTRIES TO IERRCV EXCEPT
*        THE INITIAL ENTRY (FROM IERRCB)
*
*        THE ADDR OF THIS VECTOR TABLE IS STORED IN THE PPI
*        AT PPIADSSC
*
*        SEE COMMENTS AT THE START OF THIS MODULE FOR A
*        DESCRIPTION OF THE VARIOUS ENTRY POINTS
*
*---------------------------------------------------------------------
*
         DC    0D'0'               ALIGN VECTOR TABLE ON DWORD
*
         USING *,R15
*
RCV002   B     RCVEOT           *  +00 END OF TASK ROUTINE
         B     RCVPH2           |  +04 START PHASE 2 PASS
         B     RCVPH3           |  +08 START PHASE 3
         B     RCVPRINT         |  +12 MESSAGE WRITER
         B     RCVTERM          |  +16 EXCP ERROR/TERMINATE SORT/MERGE
         B     RCVENDPH         |  +20 END OF PASS ROUTINE
         DC    A(RCVSYNAD)      |  +24 ADDR OF QSAM SYNAD RTN
         B     RCVDELER         V  +28 PRINT A DELETE ERROR MESSAGE
*
         DROP  R15
*
*---------------------------------------------------------------------
*
*        SET UP FOR RETURN TO RCB
*
*---------------------------------------------------------------------
*
         USING IERRCV,R9           USE R9 FOR ADDRESSABILITY FOR ALL
*
RCVRETCB BAS   R3,RCVRCTDL         LINK TO DELETE RCT
RCVRTN   SR    R15,R15
         IC    R15,WERROR          RETURN VALUE OF WERROR IN R15
         LM    R0,R12,WSAVE3       RESTORE REGISTERS
         LR    R14,R4              RESTORE RETURN REGISTER
         BR    R14                 RETURN TO IERRCB WITH RC IN R15
*
         DROP  R9
*
*---------------------------------------------------------------------
*
*        RCVEOT - END OF TASK ROUTINE
*
*        +00 PPIADSSC
*
*---------------------------------------------------------------------
*
         USING RCV002,R15
*
RCVEOT   L     R9,AIERRCV          LOAD BASE REGISTER
         DROP  R15
         USING IERRCV,R9
         MVI   WSWITCH,X'01'       SET EOT SWITCH
         B     RCVENDET
*
         DROP  R9
*
*---------------------------------------------------------------------
*
*        RCVPH2 - START PHASE 2 ENTRY
*
*        +04 PPIADSSC
*
*---------------------------------------------------------------------
*
*        IT MAY BE FROM PHASE 1 OR PHASE 2 END OF PHASE ROUTINE
*
         USING RCV002,R15
*
RCVPH2   L     R9,AIERRCV          LOAD BASE REGISTER
         DROP  R15
         USING IERRCV,R9
RCVPH2A  LA    R6,RCVSKIP          SET BRANCH ADDR
RCVFRMN  L     R1,PPIGETSZ         SET SIZE OF GENERATED STORAGE VIA
         L     R5,0(,R1)           GETMAIN SIZE TABLE
         LA    R0,0(,R5)           CLEAR HIGH ORDER BYTE
         L     R1,PPIGETMN         GET ADDR OF GENERATED STORAGE VIA
         L     R1,0(,R1)           GETMAIN ADDR TABLE
*
         FREEMAIN R,LV=(0),A=(1)   FREE GENERATED STORAGE
*
         BR    R6
*
RCVSKIP  LA    R0,WNAME2           LOAD ADDR OF NAME
         BAS   R6,RCVDELE          CALL DELETE ROUTINE
         LTR   R15,R15             ERROR ?
         BZ    RCVRCT              NO, USE RCT AGAIN
         MVI   WERROR,1            SET ERROR INDICATION
         BAS   R14,RCVDELER        CALL TO PRINT MESSAGE
RCVRCT   L     R11,RCTHOLD
         BASR  R14,R11             RETURN TO RCT AGAIN
         BAS   R3,RCVRCTDL         DELETE RCT FINALLY
RCVLDRC7 MVI   WNAME1+5,C'7'  ÝMAYBE '8'¨  CHANGE NAME TO RC7
*
*        THE IMMEDIATE CHARACTER IS CHANGED TO AN 8 FOR THE PHASE
*        3 USE OF THIS ROUTINE
*
         MVI   WEOPSW,X'00'        TURN OFF EOP SWITCH
         LA    R0,WNAME1           LOAD ADDR OF RC7 NAME
         BAS   R6,RCVLOAD          CALL TO LOAD RC7
         LR    R15,R0              LOAD RC7 ADDR IN R15
         BR    R15                 BRANCH TO RC7
*
RCVRCTDL LA    R0,WNAME1           POINT TO RCT NAME
         BAS   R6,RCVDELE          CALL DELETE ROUTINE
         LTR   R15,R15             DELETE OK ?
         BZR   R3                  YES, RETURN VIA R3
         BAS   R14,RCVDELER        ELSE PRINT DELETE ERR MSG
         MVI   WERROR,1            SET ERROR INDICATOR
         B     RCVRTN              AND TERMINATE THE TASK
*
         DROP  R9
*
*---------------------------------------------------------------------
*
*        RCVPH3 - START PHASE 3 ENTRY
*
*        +08 PPIADSSC
*
*---------------------------------------------------------------------
*
*        IT MAY BE FROM PHASE 1, PHASE 2 OR OSCILLATING OR CRCX
*        END OF PHASE ROUTINE
*
         USING RCV002,R15
*
RCVPH3   L     R9,AIERRCV          LOAD BASE REGISTER
         DROP  R15
         USING IERRCV,R9
         MVI   RCVLDRC7+1,C'8'     ALTER MVI INSTRUCTION FOR RC8
         B     RCVPH2A
*
         DROP  R9
*
*---------------------------------------------------------------------
*
*        RCVTERM -
*
*        ENTRY TO TERMINATE SORT
*        IF TERMINATE REQUEST IS AS A RESULT OF AN I/O ERROR THEN
*        GENERATE EXCP SYNAD ERROR MESSAGE
*
*        +16 PPIADSSC
*
*---------------------------------------------------------------------
*
*        CHECK TO SEE IF THE PPIREADE OR THE PPIWRITE FLAGS ARE
*        SET TO SIGNAL AN I/O ERROR AND IF SET CALL SYNADAF TO
*        GENERATE MESSAGE IER061 I/O ERROR
*
         USING RCV002,R15
*
RCVTERM  STM   R0,R15,CVPSAVE      SAVE REGISTERS IF SKIP/ACCEPT
         L     R9,AIERRCV          LOAD BASE REGISTER
         DROP  R15
         USING IERRCV,R9
         PPITEST  PPIREADE+PPIWRITE  READ OR WRITE ERROR  ?
         BNZ   RCVIOERR            YES, BRANCH TO GENERATE SYNAD MSG
RCVABTX  MVI   WERROR,1            SET ERROR INDICATOR
         CLI   WEOPSW,X'04'        TERMINATION SET BY EOP RTN ?
         BNE   RCVENDET            NO, LET RCT FREE CORE AND UNITS
         BAS   R6,RCVFRMN          FREE GENERATED STORAGE
         LA    R6,RCVRETCB         SET RETURN TO RCB
         LA    R0,WNAME2
         B     RCVDELE             DELETE END OF PHASE RTN
*
*        I/O ERROR ON A SORKWKXX DATA SET
*
RCVIOERR SYNADAF  ACSMETH=EXCP
*
         MVC   IER061M(61),67(R1)  MOVE PART OF SYNAD MSG INTO IER061
*
         SYNADRLS
*
         L     R1,IER061           R1 -> MSG TEXT
         MVC   PPIABMNO,3(R1)      MOVE MSG NO INTO ABEND NO
         LM    R0,R1,IER061        LOAD ADDR OF MESSAGE
         L     R15,PPIADSSC        PRINT I/O ERR MSG AND ABEND
         BAS   R14,12(,R15)
         PPITEST  PPIREADE         READ ERROR ?
         BNO   RCVABTX             NO, BRANCH
*
*        CHECK FOR SKIP/ACCEPT
*
         C     R11,PPIRD+4         CALLED FROM READ - PH 2 AND PH3 ?
         BNE   RCVABTX             NO, TERMINATE
         PPITEST  PPIACCPT         ACCEPT/SKIP OPTION ACTIVATED ?
         BZ    RCVABTX             NO, TERMINATE
         LM    R0,R15,CVPSAVE      YES, RESTORE CALLERS REGS
         BR    R14                 RETURN TO CALLER
*
         DROP  R9
*
*---------------------------------------------------------------------
*
*        RCVENDPH - END OF PASS ROUTINE
*
*        +20 PPIADSSC
*
*---------------------------------------------------------------------
*
         USING RCV002,R15
*
RCVENDPH L     R9,AIERRCV          LOAD BASE REGISTER
         DROP  R15
         USING IERRCV,R9
         ST    R1,WSAVE2           SAVE R1 FOR BRANCH TO EOP ROUTINE
*
*        ENTRY FROM RCVTERM
*
RCVENDET L     R7,PPIGETMN         R7 -> GETMAIN LIST
         LA    R7,4(,R7)           ADD 4 TO IT (BYPASS GEN CORE ENTRY)
         ST    R7,PPIWKARE         STORE IT FOR FREEMAIN ROUTINE
         L     R7,PPIGETSZ         R7 -> GETMAIN SIZE LIST
         LA    R7,4(,R7)           ADD 4 TO IT
         ST    R7,PPIWKARE+4       STORE IT FOR FREEMAIN ROUTINE
*
RCVEOTEN MVI   WNAME1+5,C'T'       MAKE MODULE NAME IERRCT
         LA    R0,WNAME1           LOAD ADDR OF NAME
         BAS   R6,RCVLOAD          CALL LOAD ROUTINE
*
*        SET UP - CALL IERRCT
*
RCVALT   ST    R0,RCTHOLD
         LR    R11,R0
         SR    R15,R15
         IC    R15,WERROR          PASS SETTING OF WERROR TO IERRCT
         BASR  R14,R11
*
*        RCT RETURNS WITH R15 ¬= ZERO IF AN ERROR HAS OCCURRED
*        THE VALUE OF WERROR WILL BE IN R15
*
*
         LA    R6,RCVRETCB         SET UP R6 TO RETURN TO LINK TO RCB
         LTR   R15,R15             IERRCT FOUND ERROR ?
         BNZ   RCVFRMN             YES, FREE GENERATED CORE
         TM    WSWITCH,X'01'       END OF TASK ?
         BO    RCVFRMN             YES, FREE GENERATED CORE
*
*        DETERMINE THE END OF PHASE MODULE TO LOAD
*
         PPITEST  PPI2314          CRCX ?
         BO    RCV2314             YES, BRANCH
         PPITEST  PPIOSC           OSCILLATING ?
         BO    RCVOSC              YES, BRANCH
         PPITEST  PPIPH2           PHASE 2 ?
         BO    RCVPHTWO            YES, BRANCH
         MVI   WNAME2+5,C'C'       MUST BE PHASE 1 - SET UP NAME
RCVEOPH  LA    R0,WNAME2           R0 -> MODULE NAME
         BAS   R6,RCVLOAD          BRANCH AND LINK TO LOAD ROUTINE
         MVI   WEOPSW,X'04'        SET SWITCH INDICATING EOP RTN BEING
*                                  EXECUTED
         LR    R11,R0
         L     R1,WSAVE2
         B     0(R1,R11)           BRANCH TO EOP ROUTINE
*
RCV2314  MVI   WNAME2+3,C'8'       SET UP PART OF NAME FOR CRCX
RCVOSC   MVI   WNAME2+5,C'M'       SETUP OSC NAME -OR- FINISH CRCX NAME
         B     RCVEOPH             GO LOAD IT AND BRANCH TO IT
*
RCVPHTWO MVI   WNAME2+5,C'F'       SET UP NAME FOR PHASE 2
         B     RCVEOPH             GO LOAD IT AND BRANCH TO IT
*
         DROP  R9
*
*---------------------------------------------------------------------
*
*        RCVSYNAD - QSAM SYNAD FOR AN UNCORRECTABLE I/O ERROR
*
*        +24 PPIADSSC
*
*---------------------------------------------------------------------
*
RCVSYNAD L     R15,PPIADSSC        LOAD ROUTINE ADDR IN BASE REG
         USING RCV002,R15
         L     R9,AIERRCV          LOAD BASE REGISTER
         DROP  R15
         USING IERRCV,R9
*
         SYNADAF  ACSMETH=QSAM
*
         MVC   IER061M(61),67(R1)  MOVE PART OF SYNAD MSG INTO IER061
*
         SYNADRLS
*
         L     R1,IER061           R1 -> MSG TEXT
         MVC   PPIABMNO,3(R1)      MOVE MSG NO INTO ABEND NO
         LM    R0,R1,IER061        LOAD ADDR OF MESSAGE
         BAS   R14,12(,R15)        CALL PRINT MESSAGE RTN
         L     R15,PPIADSSC
         B     16(,R15)            BRANCH TO TERMINATE JOB - RCVTERM
*
         DROP  R9
*
*---------------------------------------------------------------------
*
*        RCVDELER - PRINT DELETE FAILED ERROR MESSAGE
*
*        +28 PPIADSSC
*
*---------------------------------------------------------------------
*
         USING RCV002,R15
RCVDELER STM   R0,R14,CVPSAVE1     SAVE CALLERS REGISTERS
         L     R9,AIERRCV          LOAD BASE REGISTER
         DROP  R15
         USING IERRCV,R9
         L     R1,IER064           R1 -> MSG TEXT
         MVC   PPIABMNO,3(R1)      MOVE MSG NO INTO ABEND NO
         LM    R0,R1,IER064        LOAD ADDR AND LENGTH OF MESSAGE
         L     R15,PPIADSSC        LOAD ADDR OF PRINT ROUTINE
         BAS   R14,12(,R15)        CALL PRINT RTN
         LM    R0,R14,CVPSAVE1     RESTORE REGISTERS
         BR    R14                 RETURN
*
         DROP  R9
*
*---------------------------------------------------------------------
*
*        MODULE LOADING ROUTINE
*
*---------------------------------------------------------------------
*
*        ON ENTRY -
*        R0 -> MODULE NAME
*        ON EXIT -
*        R0 -> MODULE
*
         USING IERRCV,R9
*
RCVLOAD  LR    R5,R0               R5 -> MODULE NAME
         MVC   IER988A,0(R5)       MOVE MODULE NAME INTO MSG IER988
         L     R1,PPISLIB          R1 -> SORTLIB DCB ADDR
*
         LOAD  EPLOC=(0),DCB=(1)   LOAD MODULE
*
         LR    R5,R0               SAVE MODULE LOADED ADDR
         BAS   R10,LOGGER          GENERATE MSG
         LR    R0,R5               RETURN MODULE ADDR TO CALLER IN R0
         BR    R6                  RETURN
*
*---------------------------------------------------------------------
*
*        MODULE DELETING ROUTINE
*
*---------------------------------------------------------------------
*
RCVDELE  PPITEST  PPIDIAG+PPIDSIM  GENERATE DIAGNOSTIC MESSAGES ?
         BZ    RCVDELEA            NO, BYPASS MSG GENERATION
         PPITEST  PPITMODF         MODULE FLOW DIAGNOSTICS ?
         BZ    RCVDELEA            NO, BYPASS MSG GENERATION
         LR    R5,R0               SAVE ADDR OF MODULE NAME
         MVC   IER989A,0(R5)       MOVE MODULE NAME INTO MSG
         LM    R0,R1,IER989        IER989 DELETING XXXXXXXX
         L     R15,PPIADSSC        MESSAGE WRITER RTN
         BAS   R14,12(,R15)        CALL MESSAGE WRITER
         LR    R0,R5               RESTORE CALLERS R0
*
RCVDELEA DELETE EPLOC=(0)          DELETE MODULE
*
         BR    R6                  RETURN
*
*---------------------------------------------------------------------
*
*        MODULE LOGGER ROUTINE
*
*---------------------------------------------------------------------
*
*        DIAGNOSTIC MESSAGE IER988I IERXXX LOADED AT NNNNNN
*
LOGGER   PPITEST  PPIDIAG+PPIDSIM  GENERATE DIAGNOSTIC MESSAGES ?
         BZR   R10                 NO, RETURN TO CALLER
         PPITEST  PPITMODF         MODULE FLOW DIAGNOSTICS ?
         BZR   R10                 NO, RETURN TO CALLER
         L     R15,PPICONV+4       R0 CONTAINS ADDR TO BE CONVERTED
         BAS   R14,4(,R15)         CALL CONVERT RTN - BIN TO HEX
         MVC   IER988C,2(R1)       MOVE HEX FORMATTED ADDR TO MESSAGE
LOGGERA  LM    R0,R1,IER988        IER988I IERXXX LOADED AT
         L     R15,PPIADSSC        PRINT MESSAGE
         BAS   R14,12(,R15)        CALL MESSAGE WRITER
         BR    R10                 RETURN TO CALLER
*
         DROP  R9
*
*---------------------------------------------------------------------
*
*        RCVPRINT - MESSAGE WRITER
*
*        +12 PPIADSSC
*
*---------------------------------------------------------------------
*
*        ALL REGS EXCEPT R13 ARE SAVED ON ENTRY AND RESTORED ON EXIT
*        THE SAVE AREA IN R13 IS NOT USED
*
*        ON ENTRY
*        R0  -> MSG TEXT
*        R1   = L'MSG TEXT
*
*
RCVPRINT BASR  R15,0               BRANCH ENTRY FROM VECTOR TABLE
         USING *,R15
*
GAPRT    IERENTRY 'RCVPRINT &SYSDATE &SYSTIME'
*
         STM   R14,R12,GAPRTSA+12  SAVE REGS BUT DO NOT CHAIN
         DROP  R15
         USING GAPRT,R9
         LR    R9,R15              SET BASE
         LR    R10,R0              R10 -> MSG TEXT
         LR    R11,R1              R11  = L'MSG TEXT
         L     R7,SYSOUT           R7  -> SYSOUT DCB
         CLI   3(R10),C'9'         IER9XX DIAGNOSTIC MSG ?
         BE    GAPRTD              YES, PROCESS DIAGNOSTIC MSGS
         CLC   KIER,0(R10)         MSG ID START WITH IER ?
         BNE   GAPRTD              NO, IT MUST BE A DIAGNOSTIC MSG
         CLI   6(R10),C'A'         CRITICAL MSG ?
         BNE   GAPRTI              NO, INFORMATIONAL
*
*        CRITICAL MSG PROCESSING
*
         PPITEST  PPIPCRT+PPIPALL  MESSAGES TO PRINTER ?
         BZ    GAPRT1              NO, BRANCH
         BAS   R8,GAPRTPM          YES, CALL THE PRINT RTN
GAPRT1   PPITEST  PPICCRT+PPICALL  MSGS TO THE CONSOLE ?
         BZ    GAPRT2              NO, BRANCH
         BAS   R8,GAPRTCM          CALL CONSOLE RTN
GAPRT2   B     GAPRT4              BRANCH TO LOG MSG IN SORTDIAG
*
*        INFORMATIONAL MSG PROCESSING
*
GAPRTI   PPITEST  PPIPALL          ALL MSGS TO THE PRINTER ?
         BZ    GAPRT3              NO, BRANCH
         BAS   R8,GAPRTPM          YES, CALL THE PRINT RTN
GAPRT3   PPITEST  PPICALL          ALL MSGS TO THE CONSOLE ?
         BZ    GAPRT4              NO, BRANCH
         BAS   R8,GAPRTCM          CALL CONSOLE RTN
*
*        DIAGNOSTIC MESSAGES
*
*        ALL MESSAGES FLOW THROUGH HERE SO THAT ALL NON
*        DIAGNOSTIC MESSAGES ARE PRINTED ON SORTDIAG (IF
*        REQUESTED) TO ASSIST WITH PROBLEM DIAGNOSIS. IF NON
*        DIAGNOSTIC MESSAGES HAVE ALREADY BEEN PRINTED ON SYSOUT
*        ENSURE THAT THEY ARE NOT DUPLICATED
*
*        NON DIAGNOSTIC MSG ENTRY
*
GAPRT4   PPITEST  PPIDIAG          DIAGNOSTIC MESSAGES BEING WRITTEN
*                                  TO SORTDIAG ?
         BO    GAPRTP              YES, CAPTURE THIS MESSAGE
         B     GAPRTEXT            NO, BRANCH TO EXIT, ALREADY WRITTEN
*
*        DIAGNOSTIC MSG ENTRY
*
GAPRTD   PPITEST  PPIDIAG          PRINTING DIAGNOSTIC MESSAGES ?
         BO    GAPRTP              YES, PRINT
         PPITEST  PPIDSIM          DIAGNOSTIC MESSAGES BEING WRITTEN
*                                  TO SYSOUT ?
         BZ    GAPRTEXT            NO, BRANCH TO EXIT
*                                  YES, CALL SYSOUT PRINT
         L     R7,SYSOUT           R7 -> SYSOUT DCB
         B     GAPRTPS             BRANCH TO CALL THE PRINT RTN
*
GAPRTP   L     R7,SORTDIAG         R7 -> SORTDIAG DCB
GAPRTPS  BAS   R8,GAPRTPM          CALL THE PRINT RTN
         B     GAPRTEXT            BRANCH TO EXIT
*
*        WRITE MESSAGES TO PRINTER
*
*        ON ENTRY -
*        R7  -> DCB
*        R8   = RETURN ADDR
*        R9   = BASE
*        R10 -> MESSAGE TEXT
*        R11  = L'MESSAGE TEXT
*
GAPRTPM  LA    R2,L'PRINTL-1       MAXIMUM L'PRINT LINE
         LR    R6,R11              TAKE A COPY OF L'MSG
         CR    R6,R2               L'MSG EXCEED PRINT LINE ?
         BNH   GAPRTPM1            NO, BRANCH
         LR    R6,R2               TRUNCATE MSG TO MSG AREA IN PRINTL
GAPRTPM1 BCTR  R6,0                DECR FOR EX
         EX    R6,PRINTMVC         MOVE MSG INTO PRINT LINE
*
         PUT   (R7),PRINTL         PUT PRINT LINE
*
         BR    R8                  RETURN TO CALLER
*
*        MESSAGES TO CONSOLE
*
*        ON ENTRY -
*        R8   = RETURN ADDR
*        R9   = BASE
*        R10 -> MESSAGE TEXT
*        R11  = L'MESSAGE TEXT
*
GAPRTCM  MVC   WTORCV+4(7),0(R10)  MOVE MESSAGE NO INTO MSG
         MVC   WTORCV+12(L'PPIWTOH),PPIWTOH  MOVE WTO HEADER INTO MSG
         LH    R6,WTORCV           GET L'WTO MSG AREA
         SH    R6,=AL2(4+8+L'PPIWTOH)   R6 = CURR MAX L'MSG AREA
         LR    R5,R11              R5 = CURRENT L'MSG
         SH    R5,=AL2(8)          FIRST 8 BYTES ALREADY IN MSG
         CR    R5,R6               REMAINING TEXT TOO LONG ?
         BNH   GAPRTCM1            NO, BRANCH
         LR    R5,R6               YES, TRUNCATE TO L'MAXIMUM
GAPRTCM1 BCTR  R5,0                DECR LENGTH FOR EX
         EX    R5,GAMOVE           MOVE MSG TEXT INTO WTO
*
         WTO   MF=(E,WTORCV)
*
         BR    R8                  RETURN TO CALLER
*
*        PRINT MESSAGE EXIT PROCESSING
*
GAPRTEXT LH    R1,WTORCV           GET L'MSG AREA
         LA    R0,6                SUB FOR HEADER, FIRST BYTE AND EX
         SR    R1,R0
         MVI   WTORCV+4,C' '       FIRST BLANK
         EX    R1,WTOBLANK         BLANK OUT WTO MSG AREA
         MVI   PRINTL,C' '
         MVC   PRINTL+1(L'PRINTL-1),PRINTL  BLANK PRINT LINE
         MVC   GAPRTSA+20,PPIADSSC  RESTORE CALLERS R15 VALUE
         LM    R14,R12,GAPRTSA+12   RESTORE REGS
         BR    R14                  RETURN TO CALLER
*
*        120 CHARACTER WTO
*
WTORCV   WTO   '                                                       X
                                                                       X
                        ',MF=L,ROUTCDE=11,DESC=7
*
*        PRINT LINE FOR SYSOUT AND SORTDIAG
*
         DC    0F'0'
PRINTL   DC    CL121' '            PRINT LINE
*
KIER     DC    C'IER'
*
GAMOVE   MVC   WTORCV+4+8+L'PPIWTOH(0),8(R10)  MOVE MSG INTO WTO
WTOBLANK MVC   WTORCV+5(0),WTORCV+4  BLANK MSG AREA
PRINTMVC MVC   PRINTL+1(0),0(R10)  MOVE MSG INTO PRINT LINE
*
GAPRTSA  DC    18F'0'              PRINT ROUTINE SAVE AREA
*
DCBLIST  DS    0XL8                LIST OF DCB ADDR PASSED FROM IERRCB
SYSOUT   DC    A(0)                SYSOUT DCB ADDR
SORTDIAG DC    A(0)                SORTDIAG DCB ADDR
*
CVPSAVE  DC    16F'0'              R0, R1, R2 -> R15
*
CVPSAVE1 DC    15F'0'
WSAVE3   DC    13F'0'
AIERRCV  DC    A(IERRCV)
*
*        120 CHARACTER WTO
*
MSGWTO   WTO   '                                                       X
                                                                       X
                        ',MF=L,ROUTCDE=11,DESC=7
*
WNAME1   DC    CL8'IERRCT  '       FOR LOADING AND DELETING
WNAME2   DC    CL8'IERRPC  '       FOR LOADING AND DELETING
IERRC6   DC    CL8'IERRC6  '
IERRC8   DC    CL8'IERRC8  '
RCTHOLD  DC    F'0'
WSAVE2   DC    F'0'                SAVE FOR BRANCH TO EOP
WSWITCH  DC    X'00'               SET TO 01 IF END OF TASK
WEOPSW   DC    X'00'               EOP EXECUTION SWITCH
WERROR   DC    X'00'               ERROR INDICATION - NON ZERO - ERROR
*
IER988   DC    A(IER988T)
         DC    A(IER988X-IER988T)
*
IER988T  DC    C'IER988I '
IER988A  DC    C'IERXXX'
         DC    C' Loaded at '
IER988C  DC    C'XXXXXX'
IER988X  EQU   *                   FOR L'MSG CALC
*
IER989   DC    A(IER989T)
         DC    A(L'IER989T+L'IER989A)
IER989T  DC    C'IER989I Deleting '
IER989A  DC    CL6' '
*
IER064   DC    A(IER064T)
         DC    A(L'IER064T)
IER064T  DC    C'IER064A DELETE Error'
*
IER061   DC    A(IER061T)
         DC    A(L'IER061T+L'IER061M)
IER061T  DC    C'IER061A I/O Error '
IER061M  DC    CL78' '             SYNAD ERROR MSG FROM SYNADAF
*
*        LTORG
*
         LTORG
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERRCX   0101-20211-20211-1200-00898-00898-00000-RELEASE 00
RCX      TITLE 'IERRCX - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRCX
*
*        MODULE FUNCTION/OPERATION -
*        ANALYSE INFORMATION OBTAINED FROM OPTION CONTROL
*        RECORDS AND PLACE RELEVANT INFORMATION INTO CPI FOR
*        LATER USE BY SORT DEFINITION MODULES
*
*        CHANGE LOG -
*        ENSURE MAINSIZE/CORE=MAX FLAG TURNED OFF IF          REL 1.1
*        A VALUE IS PROVIDED FOR MAINSIZE/CORE
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACROS USED -
*        SMCPI
*
*        ENTRY POINT - ENTRY CSECT NAME IERRCX - ENTRY FROM IERRCM
*                                                CALLING SEQUENCE -
*                                                L      R15,V(IERRCX)
*                                                BALR   R14,R15
*
*        INPUT - CPI FIELDS REFERENCED - CPICNTL
*
*        OUTPUT - CPI FIELDS REFERENCED -
*        CPICNTL
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL - IERRCM WITH ZERO IN R15
*
*        EXITS - ERROR - IERRCM WITH FOUR IN R15
*
*        TABLES/WORK AREAS -
*
IERRCX   CSECT
*
         USING *,R11               PROGRAM BASE
         USING IERRC5,R13          CPI BASE
*
         IERENTRY 'IERRCX &SYSDATE &SYSTIME'
*
         STM   R2,R11,0(R12)       SAVE REGS R2-R11 IN IERRCM SAVEAREA
         LR    R11,R15             SET PROGRAM BASE
         ST    R12,SAVER12         SAVE R12
         ST    R14,SAVER14         SAVE R14
         CPITEST  CPIOSTMT         OPTIONS CONTROL STMT PRESENT ?
         BZ    MODRET              NO, RETURN IMMEDIATELY
*
         LM    R3,R4,CPISOPTR      R3 = STRTOPT, R4 = ENDOPT
         L     R12,VIERRCD         GET ADDR OF SCAN ROUTINE
         LA    R1,KOPTION          IDENTIFY OPTION STMT TO SCAN ROUTINE
         BASR  R14,R12             CALL SCAN ROUTINE
         LTR   R15,R15             TEST RETURN CODE
         BNZ   MODRETE             ERROR FOUND BY SCAN, RETURN
         L     R8,CPIAFLDD         R8 -> REDUCTION AREA
         CLI   0(R8),0             ZERO OPTION FIELDS ?
         BE    RCXE001             YES, ERROR
         SR    R4,R4               CLEAR R4
         IC    R4,0(,R8)           R4 = NUMBER OF FIELDS
         LA    R8,1(,R8)           R8 -> FIRST FIELD
*
*----------------------------------------------------------------------
*
*        SCAN KEYWORDS SETUP IN REDUCTION AREA BY IERRCD
*
*----------------------------------------------------------------------
*
RCX001   LA    R9,KEYWORD          R9 -> KEYWORD TABLE
         LA    R10,((KEYWORDE-KEYWORD)/KEYWORDL)  MAX NO ENTRIES IN TAB
RCX002   CLC   0(8,R9),0(R8)       MATCHING KEYWORD ENTRY ?
         BE    RCX003              YES, BRANCH TO DEFINER CHECK
         LA    R9,KEYWORDL(,R9)    R9 -> NEXT KEYWORD ENTRY
         BCT   R10,RCX002          END OF LIST ?
         LR    R9,R8               YES, R9 -> INVALID FIELD
         B     RCXE002             ENTRY NOT FOUND IN TABLE
*
RCX003   TM    8(R9),X'01'         PREVIOUSLY DEFINED FLAG ON ?
         BO    RCXE003             YES, ERROR, DUP KEYWORD
         OI    8(R9),X'01'         SET DEFINED BIT ON
         LA    R8,8(,R8)           R8 -> SUBFIELD COUNT
         CLC   9(1,R9),0(R8)       MAXIMUM SUBFIELD COUNT EXCEEDED ?
         BL    RCXE004             YES, ERROR
         STCM  R8,B'1111',10(R9)   STORE ADDR IN KEYWORD TABLE ENTRY
         BCT   R4,RCX004           FD = FD - 1, IF ¬ 0 BRANCH
         B     RCX006              ALL FIELDS SCANNED, PROCESS FIELDS
*
RCX004   SR    R2,R2               CLEAR R2
         IC    R2,0(,R8)           R2 = SUBFIELD COUNT
         SLL   R2,3                MULT SUBFIELD COUNT BY 8
         LA    R8,1(R2,R8)         REDUCT = REDUCT + 8 * NO SUBFLDS + 1
         B     RCX001              BRANCH TO PROCESS NEXT FIELD
*
*----------------------------------------------------------------------
*
*        PROCESS CHECKPOINT KEYWORD
*
*----------------------------------------------------------------------
*
RCX006   TM    KWCKPT+8,X'01'      CKPT DEFINER PRESENT ?
         BZ    RCX007              NO, BRANCH
         CPISETON CPICHKPT         TURN ON CHECKPOINT FLAG
*
*----------------------------------------------------------------------
*
*        PROCESS DYNALLOC KEYWORD
*
*----------------------------------------------------------------------
*
*        >>--DYNALLOC=--+--OFF-----------------+--><
*                       +--NO------------------+
*                       +--device name---------+
*                       +--(device name)-------+
*                       +--(device name,n)-----+
*                       +--(,n--)--------------+
*
*                       OFF          turns off dynamic allocation
*                       device name  specifies the device name for
*                                    the dynamically allocated
*                                    SORTWKXX data sets. Group Names
*                                    may be specified but may result
*                                    in an allocation error if the
*                                    Group encompasses devices with
*                                    different geometry
*                       n            specifies the number of number
*                                    of SORTWKxx data sets to be
*                                    allocated
*
RCX007   TM    KWDYNAL+8,X'01'     DYNALLOC DEFINER PRESENT ?
         BZ    RCX008              NO, BRANCH
         LA    R9,KWDYNAL          R9 -> KEYWORD, IN CASE OF ERROR MSGS
         ICM   R8,B'1111',KWDYNAL+10  ADDR OF DYNALLOC DEFINER
         CLI   0(R8),0             NO SUBFIELDS ?
         BE    RCXE005             YES, ERROR
         CPISETON  CPIDYNA         TURN ON DYNAMIC ALLOCATION
         SR    R5,R5
         IC    R5,0(,R8)           GET SUBFIELD COUNT
         LA    R8,1(,R8)           R8 -> FIRST SUBFIELD
         BCTR  R5,0
         LTR   R5,R5
         BNZ   RCX007A             THERE ARE TWO SUBFIELDS
         CLC   KOFF,0(R8)          DYNALLOC=OFF ?
         BE    RCX007D
         CLC   KNO,0(R8)           DYNALLOC=NO ?
         BE    RCX007D
         B     RCX007A
*
RCX007D  CPISETOF  CPIDYNA         NO DYNAMIC ALLOCATION
         B     RCX008              GO PROCESS NEXT KEYWORD
*
RCX007A  CLI   0(R8),X'FF'         DEVICE NAME FIELD NULL ?
         BE    RCX007B             YES, BRANCH
*                                  NO, PROCESS DEVICE NAME FIELD
         MVC   CPIDYND,0(R8)       MOVE SUBFIELD TO CPI
*                                  REMOVE X'FF' PADDING
         LA    R2,CPIDYND+7        R2 -> LAST CHAR OF CPIDYND
         LA    R3,7
RCX007C  CLI   0(R2),X'FF'         X'FF' PADDING ?
         BNE   RCX007B             NO, BRANCH
         MVI   0(R2),C' '          YES, SET TO BLANK
         BCTR  R2,0                DECR PTR
         BCT   R3,RCX007C          LOOP TO PROCESS NEXT CHAR
RCX007B  LTR   R5,R5               ANY MORE DYNALLOC SUBPARAMETERS ?
         BZ    RCX008              NO, GO PROCESS NEXT KEYWORD
         LA    R8,8(,R8)           PROCESS SECOND SUBFIELD
         LA    R0,7(,R8)           R0 -> LAST CHAR OF FIELD
         SR    R1,R1               NO SUFFIX ALLOWED
         BAS   R14,NUMBER          EXTRACT NUMERIC FIELD
         CH    R1,=H'3'            LESS THAN 3 SORTWKXX AREAS ?
         BL    RCXEMSGD            YES, ERROR
         CH    R1,=H'17'           MORE THAN 17 SORTWKXX AREAS ?
         BH    RCXEMSGD            YES, ERROR
         STCM  R1,B'0011',CPIDYNN  SET NO OF SORKWKXX DATA SETS IN CPI
*
*----------------------------------------------------------------------
*
*        PROCESS DYNSPC KEYWORD
*
*----------------------------------------------------------------------
*
*        >>--DYNSPC=--+--N--+-----><
*
RCX008   TM    KWDYNAP+8,X'01'     DYNSPC DEFINER PRESENT ?
         BZ    RCX009              NO, BRANCH
         LA    R9,KWDYNAP          R9 -> KEYWORD, IN CASE OF ERROR MSGS
         ICM   R8,B'1111',KWDYNAP+10  ADDR OF KWDYNAP DEFINER
         LA    R0,8(,R8)           R0 -> LAST CHAR OF FIELD
         CLI   0(R8),0             NO SUBFIELD ?
         BE    RCXE005             YES, ERROR
         LA    R8,1(,R8)           R8 -> VALUE
         SR    R1,R1               NO SUFFIX ALLOWED AS IT IS MBYTE VAL
         BAS   R14,NUMBER          EXTRACT NUMERIC FIELD
         ST    R1,CPIDYNS
*
*----------------------------------------------------------------------
*
*        PROCESS DYNAPCT KEYWORD
*
*----------------------------------------------------------------------
*
*        >>--DYNAPCT=--+--N--+-----><
*
RCX009   TM    KWDYNPCT+8,X'01'    DYNAPCT DEFINER PRESENT ?
         BZ    RCX010              NO, BRANCH
         LA    R9,KWDYNPCT         R9 -> KEYWORD, IN CASE OF ERROR MSGS
         ICM   R8,B'1111',KWDYNPCT+10  ADDR OF KWDYNPCT DEFINER
         LA    R0,8(,R8)           R0 -> LAST CHAR OF FIELD
         CLI   0(R8),0             NO SUBFIELD ?
         BE    RCXE005             YES, ERROR
         LA    R8,1(,R8)           R8 -> VALUE
         SR    R1,R1               NO SUFFIX ALLOWED AS ITS A PERCENT
         BAS   R14,NUMBER          EXTRACT NUMERIC FIELD
         STCM  R1,B'0011',CPIDYNP
*
*----------------------------------------------------------------------
*
*        PROCESS EQUALS KEYWORD
*
*----------------------------------------------------------------------
*
RCX010   TM    KWEQUAL+8,X'01'     EQUALS DEFINER PRESENT ?
         BZ    RCX011              NO, BRANCH
         CPISETON CPIEQUO          TURN ON CPIEQUO FLAG
*
*----------------------------------------------------------------------
*
*        PROCESS NOEQUALS KEYWORD
*
*----------------------------------------------------------------------
*
RCX011   TM    KWNOEQU+8,X'01'     NOEQUALS DEFINER PRESENT ?
         BZ    RCX012              NO, BRANCH
         CPISETOF CPIEQUO          TURN OFF CPIEQUO FLAG
*
*----------------------------------------------------------------------
*
*        PROCESS SIZE/FILSZ KEYWORD
*
*----------------------------------------------------------------------
*
RCX012   LA    R9,KWSIZE           R9 -> KEYWORD IN CASE OF ERROR MSG
         TM    KWSIZE+8,X'01'      SIZE DEFINER PRESENT ?
         BO    RCX012A             YES, BRANCH
         TM    KWFILSZ+8,X'01'     FILSZ DEFINER PRESENT ?
         BZ    RCX013              NO, BRANCH
         ICM   R8,B'1111',KWFILSZ+10  ADDR OF SIZE DEFINER IN REDUCT
         LA    R0,8(,R8)           R0 -> LAST CHAR OF FIELD
         B     RCX012B
*
RCX012A  TM    KWFILSZ+8,X'01'     FILSZ DEFINER PRESENT ?
         BO    RCXE003             YES, ERROR, DUP KEYWORD
         ICM   R8,B'1111',KWSIZE+10  ADDR OF SIZE DEFINER IN REDUCT
         LA    R0,8(,R8)           R0 -> LAST CHAR OF FIELD
RCX012B  CLI   0(R8),0             NO SUBFIELD ?
         BE    RCXE005             YES, ERROR
         CLI   1(R8),C'E'          ESTIMATED VALUE ?
         BE    RCX012E             YES, BRANCH
         CLI   1(R8),C'U'          ESTIMATED VALUE ?
         BNE   RCX012D             NO, BRANCH
RCX012E  CPISETON  CPIFSZE         SET ON FILE SIZE ESTIMATED FLAG
         LA    R8,1(R8)            INCR PTR
RCX012D  LA    R8,1(,R8)           INCR PTR
         SR    R1,R1               NO SUFFIX ALLOWED
         BAS   R14,NUMBER          EXTRACT NUMERIC FIELD
         STCM  R1,B'0111',CPIFILSZ  STORE FILESIZE VALUE INTO CPI
*
*----------------------------------------------------------------------
*
*        PROCESS LIST KEYWORD
*
*----------------------------------------------------------------------
*
RCX013   TM    KWLIST+8,X'01'      LIST DEFINER PRESENT ?
         BZ    RCX014              NO, BRANCH
         CPISETON CPILIST          TURN ON CPILIST FLAG
*
*----------------------------------------------------------------------
*
*        PROCESS NOLIST KEYWORD
*
*----------------------------------------------------------------------
*
RCX014   TM    KWNOLIST+8,X'01'    NOLIST DEFINER PRESENT ?
         BZ    RCX015              NO, BRANCH
         CPISETOF CPILIST          TURN OFF CPILIST FLAG
*
*----------------------------------------------------------------------
*
*        PROCESS MAINSIZE/CORE KEYWORD
*
*----------------------------------------------------------------------
*
RCX015   LA    R9,KWMAINSZ         R9 -> KEYWORD IN CASE OF ERROR MSG
         TM    KWMAINSZ+8,X'01'    MAINSIZE DEFINER PRESENT ?
         BO    RCX015A             NO, BRANCH
         TM    KWCORE+8,X'01'      CORE DEFINER PRESENT ?
         BZ    RCX016              NO, BRANCH
         ICM   R8,B'1111',KWCORE+10  ADDR OF CORE DEFINER IN REDUCT
         LA    R0,8(,R8)           R0 -> LAST CHAR OF FIELD
         LA    R9,KWCORE           R9 -> KEYWORD IN CASE OF ERROR MSG
         B     RCX015B
*
RCX015A  TM    KWCORE+8,X'01'      CORE DEFINER PRESENT ?
         BO    RCXE003             YES, ERROR, DUP KEYWORD
         ICM   R8,B'1111',KWMAINSZ+10  ADDR OF MAINSIZE DEFINER
         LA    R0,8(,R8)           R0 -> LAST CHAR OF FIELD
RCX015B  CLI   0(R8),0             NO SUBFIELD ?
         BE    RCXE005             YES, ERROR
         CLC   KMAX,1(R8)          MAX VALUE CODED ?
         BNE   RCX015C             NO, BRANCH
         CPISETON  CPIMAXS         YES, SET ON MAINSIZE/CORE=MAX
         B     RCX016              PROCESS NEXT KEYWORD
*
RCX015C  LA    R8,1(,R8)           R8 -> VALUE
         LA    R1,4                SUFFIX PERMITTED
         BAS   R14,NUMBER          EXTRACT VALUE
         ST    R1,CPISTOR          SET USER REQUESTED STORAGE VALUE
         CPISETOF  CPIMAXS         SET OFF MAINSIZE/CORE=MAX IF SET
*                                  AS A VALUE HAS BEEN SET FOR STORAGE
*
*----------------------------------------------------------------------
*
*        PROCESS MSGDDN KEYWORD
*
*----------------------------------------------------------------------
*
*        >>--MSGDDN=--+--SYSOUT--+-----><
*                     +--DDNAME--+
*
RCX016   TM    KWMSGDDN+8,X'01'    MSGDDN DEFINER PRESENT ?
         BZ    RCX017              NO, BRANCH
         LA    R9,KWMSGDDN         R9 -> KEYWORD IN CASE OF ERROR MSG
         ICM   R8,B'1111',KWMSGDDN+10  ADDR OF MSGDDN DEFINER IN REDUCT
         CLI   0(R8),0             NO SUBFIELD ?
         BE    RCXE005             YES, ERROR
         MVC   CPIMDDN,BLANKS      BLANK OUT CPIMDDN
         LA    R8,1(,R8)           R8 -> DDNAME FIELD
         LR    R3,R8               TAKE A COPY
         LA    R1,CPIMDDN          R1 -> DDNAME IN CPI
         LR    R0,R1               TAKE A COPY
         LA    R2,8                PROCESS ALL 8 CHARS
RCX016A  CLI   0(R8),X'FF'         PADDING ?
         BE    RCX016B             YES, BRANCH
         MVC   0(1,R1),0(R8)       MOVE CHAR INTO CPI
         LA    R1,1(,R1)           INCR OUTPUT PTR
         LA    R8,1(,R8)           INCR INPUT PTR
         BCT   R2,RCX016A          PROCESS UP TO 8 CHARS
RCX016B  SR    R1,R0               CALC NUMBER OF CHARS MOVED
         BCTR  R1,0                DECR FOR EX
         L     R15,VDDCHECK        GET ADDR OF TRANSLATE TABLE
         TR    0(8,R3),0(R15)      TRANSLATE DDNAME TO GEN TEST CHARS
         EX    R1,EXCLC            COMPARE TEST CHARS WITH VALID CHARS
         BH    RCXE006             ERROR, BRANCH
         B     RCX017              NEXT FIELD
*
EXCLC    CLC   0(0,R3),KVALID      DDNAME VALIDITY CHECK
*
*----------------------------------------------------------------------
*
*        PROCESS MSGPRT/PRINT KEYWORD
*
*----------------------------------------------------------------------
*
*        >>--+--MSGPRT=--+--ALL-----------------+--+--><
*            |           +--NONE----------------+  |
*            |           +--CRITICAL------------+  |
*            |                                     |
*            +--PRINT=---+--ALL-----------------+--+
*                        +--NONE----------------+
*                        +--CRITICAL------------+
*
RCX017   LA    R9,KWMSGPRT         R9 -> KEYWORD IN CASE OF ERROR MSG
         TM    KWMSGPRT+8,X'01'    MSGPRT DEFINER PRESENT ?
         BO    RCX017A             NO, BRANCH
         TM    KWPRINT+8,X'01'     PRINT DEFINER PRESENT ?
         BZ    RCX018              NO, BRANCH
         ICM   R8,B'1111',KWPRINT+10  ADDR OF PRINT DEFINER IN REDUCT
         LA    R9,KWPRINT          R9 -> KEYWORD IN CASE OF ERROR MSG
         B     RCX017B
*
RCX017A  TM    KWPRINT+8,X'01'     PRINT DEFINER PRESENT ?
         BO    RCXE003             YES, ERROR, DUP KEYWORD
         ICM   R8,B'1111',KWMSGPRT+10  ADDR OF KWMSGPRT DEFINER
RCX017B  CLI   0(R8),0             NO SUBFIELD ?
         BE    RCXE005             YES, ERROR
         CLC   KALL,1(R8)          MSGPRT=ALL ?
         BNE   RCX017C             NO, BRANCH
         CPISETON  CPIPALL         SET ALL MESSAGES TO THE PRINTER
         B     RCX018
*
RCX017C  CLC   KNONE,1(R8)         MSGPRT=NONE ?
         BNE   RCX017D             NO, BRANCH
         CPISETOF  CPIPALL-CPIPCRT   YES, SET OFF ALL PRINTER MSGS
         B     RCX018
*
RCX017D  CLC   KCRIT,1(R8)         MSGPRT=CRITICAL ?
         BNE   RCXE006             NO, ERROR
         CPISETOF  CPIPALL         YES, SET OFF ALL PRINTER MSGS
         CPISETON  CPIPCRT         SET CRITICAL MESSAGES TO THE PRINTER
*
*----------------------------------------------------------------------
*
*        PROCESS RESALL KEYWORD
*
*----------------------------------------------------------------------
*
*        >>--RESALL=--+--n---+--+--><
*                     +--nK--+--+
*                     +--nM--+--+
*
RCX018   TM    KWRESALL+8,X'01'    RESALL DEFINER PRESENT ?
         BZ    RCX019              NO, BRANCH
         LA    R9,KWRESALL         R9 -> KEYWORD IN CASE OF ERROR MSG
         ICM   R8,B'1111',KWRESALL+10  ADDR OF RESALL DEFINER IN REDUCT
         LA    R0,8(,R8)           R0 -> LAST CHAR OF FIELD
         CLI   0(R8),0             NO SUBFIELD ?
         BE    RCXE005             YES, ERROR
         LA    R8,1(,R8)           R8 -> VALUE
         LA    R1,4                SUFFIX PERMITTED
         BAS   R14,NUMBER          EXTRACT VALUE
         ST    R1,CPIMAXR          RESVD STORAGE - SIZE = MAX, EXEC
*
*----------------------------------------------------------------------
*
*        PROCESS RESINV KEYWORD
*
*----------------------------------------------------------------------
*
*        >>--RESINV=--+--n---+--+ -><
*                     +--nK--+--+
*                     +--nM--+--+
*
RCX019   TM    KWRESINV+8,X'01'    RESALL DEFINER PRESENT ?
         BZ    RCX020              NO, BRANCH
         LA    R9,KWRESINV         R9 -> KEYWORD IN CASE OF ERROR MSG
         ICM   R8,B'1111',KWRESINV+10  ADDR OF RESINV DEFINER IN REDUCT
         LA    R0,8(,R8)           R0 -> LAST CHAR OF FIELD
         CLI   0(R8),0             NO SUBFIELD ?
         BE    RCXE005             YES, ERROR
         LA    R8,1(,R8)           R8 -> VALUE
         LA    R1,4                SUFFIX PERMITTED
         BAS   R14,NUMBER          EXTRACT VALUE
         ST    R1,CPIMAXRI         RESVD STORAGE - SIZE = MAX, INVOKED
*
*----------------------------------------------------------------------
*
*        PROCESS SKIPREC KEYWORD
*
*----------------------------------------------------------------------
*
RCX020   TM    KWSKIPRC+8,X'01'    SKIPREC DEFINER PRESENT ?
         BZ    RCX021              NO, BRANCH
         LA    R9,KWSKIPRC         R9 -> KEYWORD IN CASE OF ERROR MSG
         ICM   R8,B'1111',KWSKIPRC+10  ADDR OF SKIPREC DEFINER
         LA    R0,8(,R8)           R0 -> LAST CHAR OF FIELD
         CLI   0(R8),0             NO SUBFIELD ?
         BE    RCXE005             YES, ERROR
         LA    R8,1(,R8)           R8 -> VALUE
         SR    R1,R1               SUFFIX NOT PERMITTED
         BAS   R14,NUMBER          EXTRACT VALUE
         STCM  R1,B'0111',CPISKPRD  STORE SKIP RECORD VALUE
         CPISETON CPISKIP          SET SKIPREC FLAG
*
*----------------------------------------------------------------------
*
*        PROCESS SMF KEYWORD
*
*----------------------------------------------------------------------
*
*        >>--SMF=--+--NO-----+-----><
*                  +--SHORT--+
*                  +--FULL---+
*
RCX021   TM    KWSMF+8,X'01'       SMF DEFINER PRESENT ?
         BZ    RCX022              NO, BRANCH
         LA    R9,KWSMF            R9 -> KEYWORD IN CASE OF ERROR MSG
         ICM   R8,B'1111',KWSMF+10  ADDR OF SMF DEFINER
         CLI   0(R8),0             NO SUBFIELD ?
         BE    RCXE005             YES, ERROR
         CLC   KNO,1(R8)           SMF=NO ?
         BNE   RCX021A             NO, BRANCH
         CPISETOF  CPISMFR-CPISMFL
         B     RCX022
*
RCX021A  CLC   KSHORT,1(R8)        SMF=SHORT ?
         BNE   RCX021B
         CPISETON  CPISMFR
         CPISETOF  CPISMFL
         B     RCX022
*
RCX021B  CLC   KFULL,1(R8)         SMF=FULL ?
         BNE   RCXE006             NO, ERROR
         CPISETON  CPISMFR+CPISMFL
*
*----------------------------------------------------------------------
*
*        PROCESS SORTDD KEYWORD
*
*----------------------------------------------------------------------
*
*        >>--SORTDD=--+--SORT-----------+-----><
*                     +--DDNAME PREFIX--+
*
RCX022   TM    KWSORTDD+8,X'01'    SORTDD DEFINER PRESENT ?
         BZ    RCX023              NO, BRANCH
         LA    R9,KWSORTDD         R9 -> KEYWORD IN CASE OF ERROR MSG
         ICM   R8,B'1111',KWSORTDD+10  ADDR OF SORTDD DEFINER
         CLI   0(R8),0             NO SUBFIELD ?
         BE    RCXE005             YES, ERROR
         CLI   5(R8),X'FF'         4 CHARS LONG ?
         BNE   RCXE006             ERROR, BRANCH
         MVC   CPIDDSRT,1(R8)      MOVE CPIDDSRT CHARS INTO CPI
         L     R15,VDDCHECK        GET ADDR OF TRANSLATE TABLE
         TR    1(4,R8),0(R15)      TRANSLATE DDNAME TO GEN TEST CHARS
         CLC   1(4,R8),KVALID      COMPARE TEST CHARS WITH VALID CHARS
         BH    RCXE006             ERROR, BRANCH
*
*----------------------------------------------------------------------
*
*        PROCESS STOPAFT KEYWORD
*
*----------------------------------------------------------------------
*
RCX023   TM    KWSTOPA+8,X'01'     STOPAFT DEFINER PRESENT ?
         BZ    RCX024              NO, BRANCH
         LA    R9,KWSTOPA          R9 -> KEYWORD IN CASE OF ERROR MSG
         ICM   R8,B'1111',KWSTOPA+10  ADDR OF SKIPREC DEFINER
         LA    R0,8(,R8)           R0 -> LAST CHAR OF FIELD
         CLI   0(R8),0             NO SUBFIELD ?
         BE    RCXE005             YES, ERROR
         LA    R8,1(,R8)           R8 -> VALUE
         SR    R1,R1               SUFFIX NOT PERMITTED, ABS VALUE
         BAS   R14,NUMBER          EXTRACT VALUE
         STCM  R1,B'1111',CPISTOPR  STORE STOPAFT RECORD VALUE
         CPISETON  CPISTOPF        SET STOPAFT FLAG
*
*----------------------------------------------------------------------
*
*        PROCESS VERIFY KEYWORD
*
*----------------------------------------------------------------------
*
RCX024   TM    KWVERIFY+8,X'01'    VERIFY DEFINER PRESENT ?
         BZ    RCX025              NO, BRANCH
         CPISETON CPIVSEQ          TURN ON CPIVSEQ FLAG
*
*----------------------------------------------------------------------
*
*        PROCESS NOVERIFY KEYWORD
*
*----------------------------------------------------------------------
*
RCX025   TM    KWNOVER+8,X'01'     NOVERIFY DEFINER PRESENT ?
         BZ    RCX026              NO, BRANCH
         CPISETOF CPIVSEQ          TURN OFF CPIVSEQ FLAG
*
*----------------------------------------------------------------------
*
*        PROCESS CHECK KEYWORD
*
*----------------------------------------------------------------------
*
RCX026   TM    KWCHECK+8,X'01'     CHECK DEFINER PRESENT ?
         BZ    RCX027              NO, BRANCH
         CPISETON CPICHCK          TURN ON CPICHCK FLAG
*
*----------------------------------------------------------------------
*
*        PROCESS NOVERIFY KEYWORD
*
*----------------------------------------------------------------------
*
RCX027   TM    KWNOCHK+8,X'01'     NOCHECK DEFINER PRESENT ?
         BZ    MODRET              NO, BRANCH
         CPISETOF CPICHCK          TURN OFF CPICHCK FLAG
*
*----------------------------------------------------------------------
*
*        RETURN TO IERRCM
*
*----------------------------------------------------------------------
*
*
MODRET   SR    R15,R15             SET GOOD RETURN CODE
MODRETE  L     R12,SAVER12         RESTORE SAVEAREA ADDR
         L     R14,SAVER14         RESTORE R14
         LM    R2,R11,0(R12)       RESTORE R2-R11
         BR    R14                 RETURN TO IERRCM
*
*----------------------------------------------------------------------
*
*        ERROR PROCESSING
*
*----------------------------------------------------------------------
*
*        ON ENTRY
*        R9 -> KEYWORD IN ERROR (EXCEPT FOR RCXE001 AND RCXEMSGD
*
         USING DIERRCU,R8
*
RCXEMSGD L     R8,VIERRCU          R8 -> MSG CSECT
         LM    R0,R1,IER075        SETUP FOR MSG WRITER
         LR    R15,R0              R15 -> MSG ADDR
         MVC   CPIABMNO,3(R15)     MOVE MSG NUMBER INTO ABEND CODE
         B     RCXEMSGX
*
RCXE001  L     R8,VIERRCU          R8 -> MSG CSECT
         L     R1,IER071RT
         MVC   IER071R,0(R1)       IER071 OPTION ERROR - NO FIELDS
         B     RCXEMSGP            BRANCH TO MSG WRITER
*
RCXE002  LA    R1,2                INVALID OPTION FIELD
         B     RCXEMSG
*
RCXE003  LA    R1,3                DUPLICATE OPTION FIELD
         B     RCXEMSG
*
RCXE004  LA    R1,4                TOO MANY PARAMETERS
         B     RCXEMSG
*
RCXE005  LA    R1,5                INSUFFICIENT PARAMETERS
         B     RCXEMSG
*
RCXE006  LA    R1,6                INVALID DATA
*
RCXEMSG  L     R8,VIERRCU          R8 -> MSG CSECT
         BCTR  R1,0
         SLL   R1,2                CONVERT TO OFFSET INTO IER071RT
         L     R1,IER071RT(R1)     R1 -> MSG ADDR
         MVC   IER071R,0(R1)       MOVE IN MSG TEXT
         LA    R2,IER071R          R1 -> LOCATION FOR KEYWORD IN MSG
         LA    R3,8                MAXIMUM OF 8 CHARS
RCXEMSGL CLI   0(R9),X'FF'         PADDING ?
         BE    RCXEMSGP            YES, GOTO WRITE MSG
         MVC   0(1,R2),0(R9)       MOVE KEYWORD CHAR INTO MSG
         LA    R2,1(,R2)           INCR MSG PTR
         LA    R9,1(,R9)           INCR KEYWORD PTR
         BCT   R3,RCXEMSGL         LOOP UNTIL PADDING OR 8 CHARS
RCXEMSGP L     R1,IER071           R1 -> MSG TEXT
         MVC   CPIABMNO,3(R1)      MOVE MSG NUMBER INTO ABEND CODE
         LM    R0,R1,IER071        SETUP FOR MSG WRITER
RCXEMSGX L     R15,VGAPRT          R15 -> MSG WRITER
         BASR  R14,R15             CALL MSG WRITER
         LA    R15,4               SET ERROR RETURN CODE
         B     MODRETE             GOTO EXIT
*
*----------------------------------------------------------------------
*
*        EXTRACT NUMERIC DATA ROUTINE
*
*----------------------------------------------------------------------
*
*        ON ENTRY -
*        R0  -> LAST BYTE OF FIELD
*        R1  = 0, NO SUFFIX ALLOWED
*              4, SUFFIX OF K OR M VALID
*        R6, R7 WORK REGS
*        R8 -> FIELD RIGHT PADDED WITH X'FF'
*        R9 -> FIELD NAME FOR ERROR MESSAGES
*        R14 = RETURN ADDR
*        R15 = WORK REG TO APPLY K OR M SUFFIX
*
*        R1 = RESULT (WITH OPTIONAL SUFFIX APPLIED)
*
NUMBER   SR    R6,R6
         SR    R7,R7               CLEAR R6, R7
         SR    R15,R15             CLEAR K OR M SUFFIX VALUE
NUMBERA  CLI   0(R8),X'FF'         PADDING ?
         BE    NUMBERB             YES, FINISHED EXTRACTING FIELD
         CLI   0(R8),C'0'          CHAR VALUE < C'0' ?
         BL    NUMBERC(R1)         YES, CHECK FOR POSSIBLE SUFFIX
         CLI   0(R8),C'9'          CHAR VALUE > C'9' ?
         BH    RCXE006             YES, ERROR
         SLDL  R6,8                MAKE ROOM FOR CHAR
         IC    R7,0(R8)            INSERT VALID CHAR
         LA    R8,1(,R8)           INCR INPUT PTR
         CR    R8,R0               PROCESSED ALL CHARS ?
         BNH   NUMBERA             NO, LOOP
*
NUMBERB  STM   R6,R7,WORKA         SAVE EXTRACTED CHARS
         PACK  WORKB,WORKA
         CVB   R1,WORKB            GET BINARY VALUE
         SLL   R1,0(R15)           APPLY K OR M SUFFIX, IF ANY
         BR    R14                 RETURN TO CALLER
*
NUMBERC  B     RCXE006             +00 SUFFIX NOT ALLOWED
         LA    R15,10              +04 SETUP FOR MULTIPLY BY 1024 (1K)
         CLI   0(R8),C'K'          K SUFFIX ?
         BE    NUMBERS             YES, BRANCH
         CLI   0(R8),C'M'          M SUFFIX ?
         BNE   RCXE006             NO, INVALID SUFFIX
         LA    R15,20              YES, MULTIPLY BY 1048576 (1M)
NUMBERS  BCTR  R0,0                R0 -> LAST BYTE IN FIELD
         CR    R8,R0               SUFFIX LAST IN FIELD ?
         BE    NUMBERB             YES, PROCESS NUMBER
         CLI   1(R8),X'FF'         SUFFIX LAST IN FIELD ?
         BE    NUMBERB             YES, VALID
         B     RCXE006             NO, ERROR
*
*        KEYWORD TABLE
*
*        EACH KEYWORD ENTRY IS 14 BYTES IN LENGTH
*        KEYWORDS ARE PADDED OUT WITH X'FF' TO 8 BYTES IN LENGTH
*
KEYWORD  DC    0F'0'               START OF OPTION KEYWORD TABLE
KWCKPT   DC    C'CKPT',X'FFFFFFFF' KEYWORD NAME PADDED TO 8 CHARS
         DC    X'00'               PREVIOUSLY DEFINED FLAG
         DC    AL1(0)              MAXIMUM SUBFIELD COUNT PERMITTED
         DC    AL4(0)              ADDR SET BY SCAN LOOP
*
KEYWORDL EQU   *-KEYWORD           L'KEYWORD ENTRY
*
KWDYNAL  DC    C'DYNALLOC'
         DC    X'00'
         DC    AL1(2)
         DC    AL4(0)
*
KWDYNAP  DC    C'DYNSPC',X'FFFF'
         DC    X'00'
         DC    AL1(1)
         DC    AL4(0)
*
KWDYNPCT DC    C'DYNAPCT',X'FF'
         DC    X'00'
         DC    AL1(1)
         DC    AL4(0)
*
KWEQUAL  DC    C'EQUALS',X'FFFF'
         DC    X'00'
         DC    AL1(0)
         DC    AL4(0)
*
KWNOEQU  DC    C'NOEQUALS'
         DC    X'00'
         DC    AL1(0)
         DC    AL4(0)
*
KWCHECK  DC    C'CHECK',X'FFFFFF'
         DC    X'00'
         DC    AL1(0)
         DC    AL4(0)
*
KWNOCHK  DC    C'NOCHECK',X'FF'
         DC    X'00'
         DC    AL1(0)
         DC    AL4(0)
*
KWVERIFY DC    C'VERIFY',X'FFFF'
         DC    X'00'
         DC    AL1(0)
         DC    AL4(0)
*
KWNOVER  DC    C'NOVERIFY'
         DC    X'00'
         DC    AL1(0)
         DC    AL4(0)
*
KWSIZE   DC    C'SIZE',X'FFFFFFFF'
         DC    X'00'
         DC    AL1(1)
         DC    AL4(0)
*
KWFILSZ  DC    C'FILSZ',X'FFFFFF'  ALIAS OF SIZE
         DC    X'00'
         DC    AL1(1)
         DC    AL4(0)
*
KWLIST   DC    C'LIST',X'FFFFFFFF'
         DC    X'00'
         DC    AL1(0)
         DC    AL4(0)
*
KWNOLIST DC    C'NOLIST',X'FFFF'
         DC    X'00'
         DC    AL1(0)
         DC    AL4(0)
*
KWMAINSZ DC    C'MAINSIZE'
         DC    X'00'
         DC    AL1(1)
         DC    AL4(0)
*
KWCORE   DC    C'CORE',X'FFFFFFFF'  ALIAS OF MAINSIZE
         DC    X'00'
         DC    AL1(1)
         DC    AL4(0)
*
KWMSGDDN DC    C'MSGDDN',X'FFFF'
         DC    X'00'
         DC    AL1(1)
         DC    AL4(0)
*
KWPRINT  DC    C'PRINT',X'FFFFFF'   ALIAS OF MSGPRT
         DC    X'00'
         DC    AL1(1)
         DC    AL4(0)
*
KWMSGPRT DC    C'MSGPRT',X'FFFF'
         DC    X'00'
         DC    AL1(1)
         DC    AL4(0)
*
KWRESALL DC    C'RESALL',X'FFFF'
         DC    X'00'
         DC    AL1(1)
         DC    AL4(0)
*
KWRESINV DC    C'RESINV',X'FFFF'
         DC    X'00'
         DC    AL1(1)
         DC    AL4(0)
*
KWSKIPRC DC    C'SKIPREC',X'FF'
         DC    X'00'
         DC    AL1(1)
         DC    AL4(0)
*
KWSTOPA  DC    C'STOPAFT',X'FF'
         DC    X'00'
         DC    AL1(1)
         DC    AL4(0)
*
KWSMF    DC    C'SMF',X'FFFFFFFFFF'
         DC    X'00'
         DC    AL1(1)
         DC    AL4(0)
*
KWSORTDD DC    C'SORTDD',X'FFFF'
         DC    X'00'
         DC    AL1(1)
         DC    AL4(0)
*
KEYWORDE EQU   *                   END OF KEYWORD TABLE
*
*        CONSTANTS AND WORK AREA
*
WORKA    DC    D'0'
WORKB    DC    D'0'
SAVER12  DC    F'0'
SAVER14  DC    F'0'
*
VIERRCD  DC    V(IERRCD)           SCAN RTN
VGAPRT   DC    V(IERGAPRT)         MESSAGE WRITER
VIERRCU  DC    V(IERRCU)           MESSAGE TEXT MODULE
VDDCHECK DC    V(DDCHECK)          TRANSLATE TABLE FOR DDNAME VALIDITY
*
BLANKS   DC    CL8' '
KOPTION  DC    CL6'OPTION'         FOR SCAN RTN
KOFF     DC    CL8'OFF'            PAD OUT WITH X'FF'
         ORG   KOFF+3
         DC    XL5'FFFFFFFFFF'
KMAX     DC    CL8'MAX'            PAD OUT WITH X'FF'
         ORG   KMAX+3
         DC    XL5'FFFFFFFFFF'
KALL     DC    CL8'ALL'            PAD OUT WITH X'FF'
         ORG   KALL+3
         DC    XL5'FFFFFFFFFF'
KNONE    DC    CL8'NONE'           PAD OUT WITH X'FF'
         ORG   KNONE+4
         DC    XL4'FFFFFFFF'
KNO      DC    CL8'NO'             PAD OUT WITH X'FF'
         ORG   KNO+2
         DC    XL6'FFFFFFFFFFFF'
KSHORT   DC    CL8'SHORT'          PAD OUT WITH X'FF'
         ORG   KSHORT+5
         DC    XL3'FFFFFF'
KFULL    DC    CL8'FULL'           PAD OUT WITH X'FF'
         ORG   KFULL+4
         DC    XL4'FFFFFFFF'
KCRIT    DC    CL8'CRITICAL'
KVALID   DC    XL8'0001010101010101'  VALIDITY CHECK TRANSLATED DDCHARS
*
*        LTORG
*
         LTORG
*
DIERRCU  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRCU SOURCE
*
*----------------------------------------------------------------------
*
         COPY IERRCUI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMCPI
*
         END
./ ADD NAME=IERRCY   0101-20211-20211-1200-00337-00337-00000-RELEASE 00
RCY      TITLE 'IERRCY - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRCY
*
*        MODULE FUNCTION/OPERATION -
*        ANALYSE INFORMATION OBTAINED FROM DEBUG
*        CONTROL RECORDS AND PLACES RELEVANT INFORMATION INTO THE
*        CPI FOR LATER USE BY SORT DEFINITION MODULES
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACROS USED -
*        SMCPI
*
*        ENTRY POINT - ENTRY CSECT NAME IERRCY - ENTRY FROM IERRCM
*                                                CALLING SEQUENCE -
*                                                L      R15,V(IERRCY)
*                                                BASR   R14,R15
*
*        INPUT - CPI FIELDS REFERENCED - CPICNTL
*
*        OUTPUT - CPI FIELDS REFERENCED -
*        CPICNTL FLAGS
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL - IERRCM WITH ZERO IN R15
*
*        EXITS - ERROR - IERRCM WITH FOUR IN R15
*
IERRCY   CSECT
*
         USING *,R11               PROGRAM BASE
         USING IERRC5,R13          CPI BASE
*
         IERENTRY 'IERRCY &SYSDATE &SYSTIME'
*
         STM   R2,R11,0(R12)       SAVE REGS R2-R11 IN IERRCM SAVEAREA
         LA    R11,0(,R15)         SET PROGRAM BASE
         ST    R12,SAVER12         SAVE R12
         ST    R14,SAVER14         SAVE R14
         CPITEST  CPIDSTMT         DEBUG CONTROL STMT PRESENT ?
         BZ    MODRET              NO, RETURN IMMEDIATELY
*
         LM    R3,R4,CPISDEBG      R3 = STRT DEBUG, R4 = END DEBUG
         L     R12,VIERRCD         GET ADDR OF SCAN ROUTINE
         LA    R1,KDEBUG           IDENTIFY DEBUG STMT TO SCAN ROUTINE
         BASR  R14,R12             CALL SCAN ROUTINE
         LTR   R15,R15             TEST RETURN CODE
         BNZ   MODRETE             ERROR FOUND BY SCAN, RETURN
         L     R8,CPIAFLDD         R8 -> REDUCTION AREA
         CLI   0(R8),0             ZERO OPTION FIELDS ?
         BE    RCYE001             YES, ERROR
         SR    R4,R4               CLEAR R4
         IC    R4,0(,R8)           R4 = NUMBER OF FIELDS
         LA    R8,1(,R8)           R8 -> FIRST FIELD
*
*----------------------------------------------------------------------
*
*        SCAN KEYWORDS SETUP IN REDUCTION AREA BY IERRCD
*
*----------------------------------------------------------------------
*
RCY001   LA    R9,KEYWORD          R9 -> KEYWORD TABLE
         LA    R10,((KEYWORDE-KEYWORD)/KEYWORDL)  MAX NO ENTRIES IN TAB
RCY002   CLC   0(8,R9),0(R8)       MATCHING KEYWORD ENTRY ?
         BE    RCY003              YES, BRANCH TO DEFINER CHECK
         LA    R9,KEYWORDL(,R9)    R9 -> NEXT KEYWORD ENTRY
         BCT   R10,RCY002          END OF LIST ?
         LR    R9,R8               YES, R9 -> INVALID FIELD
         B     RCYE002             ENTRY NOT FOUND IN TABLE
*
RCY003   TM    8(R9),X'01'         PREVIOUSLY DEFINED FLAG ON ?
         BO    RCYE003             YES, ERROR, DUP KEYWORD
         OI    8(R9),X'01'         SET DEFINED BIT ON
         LA    R8,8(,R8)           R8 -> SUBFIELD COUNT
         CLC   9(1,R9),0(R8)       MAXIMUM SUBFIELD COUNT EXCEEDED ?
         BL    RCYE004             YES, ERROR
         STCM  R8,B'1111',10(R9)   STORE ADDR IN KEYWORD TABLE ENTRY
         BCT   R4,RCY004           FD = FD - 1, IF ¬ 0 BRANCH
         B     RCY006              ALL FIELDS SCANNED, PROCESS FIELDS
*
RCY004   SR    R2,R2               CLEAR R2
         IC    R2,0(,R8)           R2 = SUBFIELD COUNT
         SLL   R2,3                MULT SUBFIELD COUNT BY 8
         LA    R8,1(R2,R8)         REDUCT = REDUCT + 8 * NO SUBFLDS + 1
         B     RCY001              BRANCH TO PROCESS NEXT FIELD
*
*----------------------------------------------------------------------
*
*        PROCESS ABEND KEYWORD
*
*----------------------------------------------------------------------
*
RCY006   TM    KWABEND+8,X'01'     ABEND DEFINER PRESENT ?
         BZ    RCY007              NO, BRANCH
         CPISETON CPIERET          TURN ON ABEND FLAG
*
*----------------------------------------------------------------------
*
*        PROCESS NOABEND KEYWORD
*
*----------------------------------------------------------------------
*
RCY007   TM    KWNOABD+8,X'01'     NOABEND DEFINER PRESENT ?
         BZ    RCY008              NO, BRANCH
         CPISETOF CPIERET          TURN OFF ABEND FLAG
*
*----------------------------------------------------------------------
*
*        PROCESS SNAPCPI KEYWORD
*
*----------------------------------------------------------------------
*
RCY008   TM    KWSNAPCP+8,X'01'    SNAPCPI DEFINER PRESENT ?
         BZ    RCY009              NO, BRANCH
         CPISETON  CPITSCPI        TURN ON SNAP CPI FLAG
*
*----------------------------------------------------------------------
*
*        PROCESS SNAPPPI KEYWORD
*
*----------------------------------------------------------------------
*
RCY009   TM    KWSNAPPP+8,X'01'    SNAPPPI DEFINER PRESENT ?
         BZ    RCY010              NO, BRANCH
         CPISETON  CPITSPPI        TURN ON SNAP PPI FLAG
*
*----------------------------------------------------------------------
*
*        PROCESS EXECBKP KEYWORD
*
*----------------------------------------------------------------------
*
RCY010   TM    KWEXECBK+8,X'01'    EXECBKP DEFINER PRESENT ?
         BZ    RCY011              NO, BRANCH
         CPISETON  CPITBRKP        TURN ON EXECUTE BREAKPOINTS FLAG
*
*----------------------------------------------------------------------
*
*        PROCESS TRACE KEYWORD
*
*----------------------------------------------------------------------
*
RCY011   TM    KWTRACE+8,X'01'     TRACE DEFINER PRESENT ?
         BZ    RCY012              NO, BRANCH
         LA    R9,KWTRACE          R9 -> KEYWORD, IN CASE OF ERROR MSGS
         ICM   R8,B'1111',KWTRACE+10  ADDR OF TRACE DEFINER
         CLI   0(R8),0             NO SUBFIELDS ?
         BE    RCYE005             YES, ERROR
         SR    R5,R5
         IC    R5,0(,R8)           GET SUBFIELD COUNT
         LA    R8,1(,R8)           R7 -> FIRST SUBFIELD
         CH    R5,=H'1'            A SINGLE SUBFIELD
         BNE   RCY011A             NO, BRANCH
         CLC   KNO,0(R8)           TRACE=NO ?
         BNE   RCY011A             NO, BRANCH
         CPISETOF  CPITEXCP-CPITWAIT-CPITMODF  YES, TURN OFF ALL TRACES
         B     MODRET
*
RCY011A  CLC   KEXCP,0(R8)         TRACE=EXCP ?
         BNE   RCY011B             NO, BRANCH
         CPISETON  CPITEXCP        TURN ON EXCP TRACE
         B     RCY011L
*
RCY011B  CLC   KEXCPCP,0(R8)       TRACE=EXCPCOMP (I/O COMPLETE) ?
         BNE   RCY011C             NO, BRANCH
         CPISETON  CPITWAIT        TURN ON TRACE EXCP COMPLETION
         B     RCY011L
*
RCY011C  CLC   KMODFLOW,0(R8)      TRACE=MODFLOW ?
         LR    R9,R8               R9 -> BAD SUBFIELD
         BNE   RCYE006             NO, ERROR
         CPISETON  CPITMODF        TURN ON TRACE=MODFLOW
RCY011L  LA    R8,8(,R8)           INCR TO NEXT SUB KEYWORD
         BCT   R5,RCY011A          LOOP THROUGH KEYWORD TABLE
*
*----------------------------------------------------------------------
*
*        PROCESS DIAGSIM KEYWORD
*
*----------------------------------------------------------------------
*
RCY012   TM    KWDIAGS+8,X'01'     DIAGSIM DEFINER PRESENT ?
         BZ    MODRET              NO, BRANCH
         CPISETON  CPIDSIM         TURN ON DIAGNOSTICS TO SYSOUT
*
*----------------------------------------------------------------------
*
*        RESTORE REGISTERS AND RETURN
*
*----------------------------------------------------------------------
*
MODRET   SR    R15,R15             SET GOOD RETURN CODE
MODRETE  L     R12,SAVER12         RESTORE SAVEAREA ADDR
         L     R14,SAVER14         RESTORE R14
         LM    R2,R11,0(R12)       RESTORE R2-R11
         BR    R14                 RETURN TO IERRCM
*
*----------------------------------------------------------------------
*
*        ERROR PROCESSING
*
*----------------------------------------------------------------------
*
*        ON ENTRY
*        R9 -> KEYWORD IN ERROR (EXCEPT FOR RCYE001)
*
         USING DIERRCU,R8
*
RCYE001  L     R8,VIERRCU          R8 -> MSG CSECT
         L     R1,IER071RT
         MVC   IER072R,0(R1)       IER072 OPTION ERROR - NO FIELDS
         B     RCYEMSGP            BRANCH TO MSG WRITER
*
RCYE002  LA    R1,2                INVALID OPTION FIELD
         B     RCYEMSG
*
RCYE003  LA    R1,3                DUPLICATE OPTION FIELD
         B     RCYEMSG
*
RCYE004  LA    R1,4                TOO MANY PARAMETERS
         B     RCYEMSG
*
RCYE005  LA    R1,5                INSUFFICIENT PARAMETERS
         B     RCYEMSG
*
RCYE006  LA    R1,6                INVALID DATA
*
RCYEMSG  L     R8,VIERRCU          R8 -> MSG CSECT
         BCTR  R1,0
         SLL   R1,2                CONVERT TO OFFSET INTO IER071RT
         L     R1,IER071RT(R1)     R1 -> MSG ADDR
         MVC   IER072R,0(R1)       MOVE IN MSG TEXT
         LA    R2,IER072R          R1 -> LOCATION FOR KEYWORD IN MSG
         LA    R3,8                MAXIMUM OF 8 CHARS
RCYEMSGL CLI   0(R9),X'FF'         PADDING ?
         BE    RCYEMSGP            YES, GOTO WRITE MSG
         MVC   0(1,R2),0(R9)       MOVE KEYWORD CHAR INTO MSG
         LA    R2,1(,R2)           INCR MSG PTR
         LA    R9,1(,R9)           INCR KEYWORD PTR
         BCT   R3,RCYEMSGL         LOOP UNTIL PADDING OR 8 CHARS
RCYEMSGP L     R1,IER072           R1 -> MSG TEXT
         MVC   CPIABMNO,3(R1)      MOVE MSG NUMBER INTO ABEND CODE
         LM    R0,R1,IER072        SETUP FOR MSG WRITER
         L     R15,VGAPRT          R15 -> MSG WRITER
         BASR  R14,R15             CALL MSG WRITER
         LA    R15,4               SET ERROR RETURN CODE
         B     MODRETE             GOTO EXIT
*
*        KEYWORD TABLE
*
*        EACH KEYWORD ENTRY IS 14 BYTES IN LENGTH
*        KEYWORDS ARE PADDED OUT WITH X'FF' TO 8 BYTES IN LENGTH
*
KEYWORD  DC    0F'0'               START OF OPTION KEYWORD TABLE
KWABEND  DC    C'ABEND',X'FFFFFF'  KEYWORD NAME PADDED TO 8 CHARS
         DC    X'00'               PREVIOUSLY DEFINED FLAG
         DC    AL1(0)              MAXIMUM SUBFIELD COUNT PERMITTED
         DC    AL4(0)              ADDR SET BY SCAN LOOP
*
KEYWORDL EQU   *-KEYWORD           L'KEYWORD ENTRY
*
KWNOABD  DC    C'NOABEND',X'FF'
         DC    X'00'
         DC    AL1(0)
         DC    AL4(0)
*
KWSNAPCP DC    C'SNAPCPI',X'FF'
         DC    X'00'
         DC    AL1(0)
         DC    AL4(0)
*
KWSNAPPP DC    C'SNAPPPI',X'FF'
         DC    X'00'
         DC    AL1(0)
         DC    AL4(0)
*
KWEXECBK DC    C'EXECBKP',X'FF'
         DC    X'00'
         DC    AL1(0)
         DC    AL4(0)
*
KWDIAGS  DC    C'DIAGSIM',X'FF'
         DC    X'00'
         DC    AL1(0)
         DC    AL4(0)
*
KWTRACE  DC    C'TRACE',X'FFFFFF'
         DC    X'00'
         DC    AL1(3)
         DC    AL4(0)
*
KEYWORDE EQU   *                   END OF KEYWORD TABLE
*
*        CONSTANTS AND WORK AREA
*
SAVER12  DC    F'0'
SAVER14  DC    F'0'
KDEBUG   DC    CL6'DEBUG '         FOR SCAN RTN
*
KNO      DC    CL8'NO'             PAD OUT WITH X'FF'
         ORG   KNO+2
         DC    XL6'FFFFFFFFFFFF'
KMODFLOW DC    CL8'MODFLOW'        PAD OUT WITH X'FF'
         ORG   KMODFLOW+7
         DC    XL1'FF'
KEXCP    DC    CL8'EXCPREQ'        PAD OUT WITH X'FF'
         ORG   KEXCP+7
         DC    XL1'FF'
KEXCPCP  DC    CL8'EXCPCOMP'
*
VIERRCD  DC    V(IERRCD)           SCAN ROUTINE
VGAPRT   DC    V(IERGAPRT)         MESSAGE WRITER
VIERRCU  DC    V(IERRCU)           MESSAGE TEXT MODULE
*
DIERRCU  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRCU SOURCE
*
*----------------------------------------------------------------------
*
         COPY IERRCUI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMCPI
*
         END
./ ADD NAME=IERRCZ   0101-20211-20211-1200-00587-00587-00000-RELEASE 00
RCZ      TITLE ' IERRCZ - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRCZ
*
*        MODULE FUNCTION/OPERATION -
*        OPTIMIZATION PHASE SORT SYSTEM CONTROL
*        THE FUNCTION OF THIS MODULE IS TO CONTROL THE EXECUTION
*        OF THE OPTIMIZATION PHASE. ADDITIONALLY IT FREES STORAGE
*        NO LONGER NEEDED FOR CPI. IT PRINTS ANY MESSAGES
*        REQUIRED BY THE OPTIMIZATION PHASE OR IERRCO. THE ORDER
*        OF EXECUTION IS AS FOLLOWS -
*        1. RC1 - COPY CPI DATA TO THE PPI - SET PPIPH1CO FLAG
*        2. FREEMAIN THE CPI
*        3. AOL - EQUALS ASSIGNMENT ROUTINE (IF NEEDED)
*        4. AOM - EXTRACT ASSIGNMENT ROUTINE (IF NEEDED)
*        5. FREE STORAGE OBTAINED IF MORE THAN TWELVE CONTROL FIELDS
*        6. RC4 - SYSTEM SEARCH
*        7. RCJ - DISK CAPACITY ROUTINE (IF NEEDED)
*        8. AO1 - OPTIMIZE DISK UNIT ASSIGNMENT (IF NEEDED)
*        9. AO2 - OPTIMIZE TAPE UNIT ASSIGNMENT (IF NEEDED)
*
*        CHANGE LOG -
*
*        CHANGE THE MESSAGE WRITING ROUTINE IERGAPRT TO USE   REL 1.1
*        RECFM=FB TO WRITE MESSAGES TO THE MESSAGE DATA SET
*
*        REPLACE USE OF SNAP TO PRINT CONTROL BLOCKS FOR      REL 1.1
*        DIAGNOSTIC PURPOSES WITH IERFMT MODULE
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACROS USED -
*        SMPPI   FREEMAIN   GETMAIN   WTO
*        WRITE   CHECK      SMCPI
*
*        ENTRY POINTS - IERGAPRT - MESSAGE WRITER
*                       CALLING SEQUENCE -
*                             L    R15,ADCON
*                             BALR R14,R15
*                       ADCON DC  V(IERGAPRT)
*
*                     - ENTRY FROM IERRCB
*                             LINK EP=IERRCZ
*
*        INPUT -
*        PPI FIELDS REFERENCED -
*        PPIP3RSZ   PPICNTL   PPIADDCF   PPINUMCF
*        PPIEXTSZ
*
*        OUTPUT -
*        PPI FIELDS INITIALIZED OR ALTERED -
*        PPIAXERT
*
*        EXTERNAL ROUTINES -
*        IERRC1 - MOVE DATA INTO THE PPI FROM THE CPI
*        IERAOL - EQUALS ASSIGNMENT
*        IERAOM - EXTRACT ASSIGNMENT
*        IERRC4 - SYSTEM SEARCH
*        IERRCJ - DISK CAPACITY
*        IERAO1 - OPTIMIZE DISK
*        IERA02 - OPTIMIZE TAPE
*
*        EXITS - NORMAL -
*        EXTRN IERRCB - SORT SYSTEM CONTROL
*
*        EXITS - ERROR
*        EXTRN IERRCB - SORT SYSTEM CONTROL
*
*        TABLES/WORK AREAS - NONE
*
*        NOTES -
*        MESSAGE WRITER IERGAPRT IS A COMPONENT OF THIS MODULE
*
IERRCZ   CSECT
*
         ENTRY IERGAPRT
*
         USING *,R9
         USING DIERRCU,R3
         USING IERRCA,R13          PPI
         USING IERRC5,R2           CPI
*
         IERENTRY 'IERRCZ &SYSDATE &SYSTIME'
*
         LR    R9,R15              SET BASE REGISTER
         LR    R4,R14              SAVE RETURN REGISTER
         MVC   DCBLIST,0(R1)       MOVE THE DCB ADDRS PASSED BY IERRCB
         LA    R1,WTORCZ           R1 -> WTO AREA
         AH    R1,WTORCZ           R1 -> WTO ROUTE AND DESCR CODES
         MVC   0(4,R1),CPIWTOC     MOVE INSTALLATION CODES INTO WTO
         L     R3,VIERRCU          LOAD BASE REG FOR MESSAGE MODULE
         LA    R12,CZSAVE          SET SAVE AREA REGISTER
*
*        CALL IERRC1 TO COPY THE DATA FROM THE CPI TO THE PPI
*
*        NOTE THAT THE CALL TO IERRC1 IS NOT TRACED BY MSG
*        IER980 TO SORTDIAG AS THE PPI IS NOT YET ESTABLISHED
*
         L     R15,VIERRC1         GET ADDR OF PPI ESTABLISHMENT MODULE
         BASR  R14,R15             NO RETURN CODE TO CHECK
*
*        FREEMAIN CPI
*
         LR    R1,R2               R1 -> CPI
         LA    R0,CPILEN           R0  = L'CPI
*
         FREEMAIN R,LV=(0),A=(1)   FREEMAIN CPI
*
         DROP  R2                  THE CPI HAS BEEN FREEMAINED
*
*        NO MORE CPI REFERENCES AFTER THIS POINT
*
         TM    PPILINK+2,X'02'     RCO REQUEST MESSAGE AND ABEND ?
         BZ    CZ001               NO, CONTINUE TO PROCESS
         L     R1,IER062           YES, R1 -> MSG TEXT
         MVC   PPIABMNO,3(R1)      MOVE MSG NO INTO ABEND NO
         LM    R0,R1,IER062        IER062A - LINK EDIT ERROR
         LA    R15,IERGAPRT        R15 -> IERGAPRT
         BASR  R14,R15             CALL MSG PRT RTN
         B     CZEE01
*
*        OPTIONALLY PRINT THE PPI
*
CZ001    PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTICS ACTIVE ?
         BZ    CZ001B              NO, BRANCH
         PPITEST PPITSPPI          PRINT THE PPI AFTER INIT ?
         BZ    CZ001B              NO, BRANCH
         LM    R0,R1,IER987        GENERATE HEADER MESSAGE
         LA    R15,IERGAPRT
         BASR  R14,R15             CALL PRINT ROUTINE
         ST    R13,IERFMTP         R13 -> PPI
         LA    R1,PPILEN-1(,R13)   R1 -> LAST PPI BYTE
         ST    R1,IERFMTP+4        SAVE IN IERFMT PARAMETER LIST
         LA    R1,IERFMTP          R1 -> PARAMETER LIST
         L     R15,VIERFMT         R15 -> FORMAT ROUTINE
         BASR  R14,R15             CALL FORMAT ROUTINE
*
*        OPTIONALLY OPEN SORTLIB
*
CZ001B   PPITEST  PPILIBS          SORTLIB REQUIRED ?
         BO    CZTDM4              NO, BRANCH AROUND OPEN
         L     R6,SORTLIB          R6 -> SORTLIB DCB
         ST    R6,PPISLIB          SAVE IN PPISLIB
         USING IHADCB,R6
         MVC   IER063A,DCBDDNAM    IN CASE OF OPEN FAIL
*
         OPEN  ((R6),INPUT)        OPEN SORTLIB
*
         TM    DCBOFLGS,DCBOFOPN   SORTLIB FAIL TO OPEN ?
         BO    CZTDM4              NO, CONTINUE
         L     R1,IER063           YES, R1 -> MSG TEXT
         MVC   PPIABMNO,3(R1)      MOVE MSG NO INTO ABEND NO
         LM    R0,R1,IER063        IER063A - OPEN ERROR - SORTLIB
         LA    R15,IERGAPRT
         BASR  R14,R15             CALL PRINT ROUTINE
         B     CZEE01              SET ERROR CODE AND EXIT
*
*        TEST FOR DIAGNOSTIC PROCESSING, LOAD CONVERSION MODULE
*
CZTDM4   PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTICS ACTIVE ?
         BZ    CZUSER              NO, BRANCH
         L     R1,PPISLIB          R1 -> SORTLIB DCB
*
         LOAD  EP=IERDM4,DCB=(1)   GENERAL CONVERSION ROUTINE
*
         ST    R0,PPICONV+4        STORE ADDR OF IERDM4 IN PPI
*
*        OPTIONALLY LOAD AND ENABLE I/O TRACING MODULES
*
CZTEXCP  PPITEST  PPITEXCP         EXCP TRACING ?
         BNO   CZTWAIT             NO, BRANCH
         L     R1,PPISLIB
*
         LOAD  EP=IERDTE,DCB=(1)   LOAD THE I/O TRACE MODULE
*
         ST    R0,PPITDTE          STORE ADDR OF LOADED TRACING MODULE
         MVC   PPITXEP,TRACEON     OVERLAY BR R1 WITH STM R0,R15
*
CZTWAIT  PPITEST  PPITWAIT         I/O COMPLETION TRACING ?
         BNO   CZUSER              NO, BRANCH
         ICM   R1,B'1111',PPITDTE  TRACING MODULE PREVIOUSLY LOADED ?
         BNZ   CZWAITA             YES, BYPASS LOAD
         L     R1,PPISLIB
*
         LOAD  EP=IERDTE,DCB=(1)   LOAD THE DIAGNOSTIC TRACE MODULE
*
         ST    R0,PPITDTE          STORE ADDR OF LOADED TRACING MODULE
CZWAITA  MVC   PPITWAI,TRACEON     OVERLAY BR R1 WITH STM R0,R15
*
*        OPTIONALLY OPEN USERLIB AND SYSLMOD
*
CZUSER   ICM   R5,B'1111',PPISORCE  USER MODS ?
         BZ    CZLMOD              NO USER MODS, BRANCH
         L     R6,USERLIB          R6 -> USERLIB DCB
         MVC   DCBDDNAM,PPISORCE   MOVE USERLIB DDN TO DCB
         MVC   IER063A,PPISORCE    IN CASE OF OPEN FAIL
         ST    R6,PPISORCE         NOW STORE ADDR OVER USERLIB DDNAME
*
         OPEN  ((R6),INPUT)        OPEN USERLIB
*
         TM    DCBOFLGS,DCBOFOPN   USERLIB OPEN SUCCESSFULLY ?
         BO    CZLMOD              YES, CONTINUE
         L     R1,IER063           R1 -> MSG TEXT
         MVC   PPIABMNO,3(R1)      MOVE MSG NO INTO ABEND NO
         LM    R0,R1,IER063        IER063A OPEN ERROR - USERLIB
         LA    R15,IERGAPRT
         BASR  R14,R15             CALL PRINT ROUTINE
         B     CZEE01              SET ERRORCODE AND EXIT
*
CZLMOD   TM    PPILINK+2,X'08'     LINKEDIT ?
         BZ    CZ002               NO, BRANCH
         L     R6,SYSLMOD          R6 -> SYSLMOD DCB
         MVC   IER063A,DCBDDNAM    IN CASE OF OPEN FAIL
         ST    R6,PPISORCE+4       NOW SAVE SYSLMOD ADDR IN PPISORCE+4
*
         OPEN  ((R6),INPUT)        OPEN SYSLMOD
*
         TM    DCBOFLGS,DCBOFOPN   SYSLMOD OPEN SUCCESSFULLY ?
         BO    CZ002               YES, CONTINUE
         L     R1,IER063           R1 -> MSG TEXT
         MVC   PPIABMNO,3(R1)      MOVE MSG NO INTO ABEND NO
         LM    R0,R1,IER063        IER063A - OPEN ERROR - SYSLMOD
         LA    R15,IERGAPRT
         BASR  R14,R15             CALL PRINT ROUTINE
         B     CZEE01              SET ERROR CODE AND EXIT
*
*        SETUP EQUALS OPTION
*
CZ002    PPITEST  PPIEQUAL         EQUALS ?
         BZ    CZ003               NO, BRANCH
         LA    R0,96               GET LENGTH OF EQUALS ROUTINE
*
         GETMAIN R,LV=(0)          GETMAIN FOR EQUALS ROUTINE
*
         ST    R1,PPIAXERT         PUT ADDR OF EQUALS ROUTINE IN PPI
         LA    R15,VIERAOL         GET ADDR OF EQUALS ASSIGNMENT
         BAS   R7,CZLINK           BRANCH TO LINK ROUTINE
         B     CZ006               BRANCH TO TEST FOR MERGE ONLY
*
*        SETUP EXTRACT OPTION
*
CZ003    PPITEST  PPIEXTRT         EXTRACT ?
         BZ    CZ006               NO, BRANCH
         L     R0,PPIEXTSZ         GET LENGTH OF EXTRACT ROUTINE
*
         GETMAIN R,LV=(0)          GETMAIN FOR EXTRACT ROUTINE
*
         ST    R1,PPIAXERT         PUT ADDR OF EXTRACT ROUTINE IN PPI
         LA    R15,VIERAOM         GET ADDR OF EXTRACT ASSIGNMENT
         BAS   R7,CZLINK           BRANCH TO LINK ROUTINE
CZ006    ICM   R1,B'1111',PPIADDCF  MORE THAN 12 CONTROL FIELDS ?
*                                  PPIADDCF WILL CONTAIN ADDR OF
         BZ    CZ007               STORAGE AREA ALLOCATED FOR THEM
         LH    R0,PPINUMCF         LENGTH OF AREA=NUMBER OF CONTROL
         MH    R0,KH6              FIELDS * SIX
*
         FREEMAIN R,LV=(0),A=(1)   FREEMAIN FOR CONTROL FIELD INFO AREA
*
CZ007    PPITEST  PPIMERGO         MERGE ONLY ?
         BZ    CZ010               NO, BRANCH
*
*        ERROR EXIT
*
CZEE01   LA    R15,4               SET ERROR EXIT
         B     CZRETURN
*
*        RETURN TO CALLER
*
CZ004    SR    R15,R15             SET RETURN CODE OF ZERO
CZRETURN LR    R14,R4              RESTORE RETURN ADDR REGISTER
         BR    R14                 RETURN TO IERRCB
*
*        CALL SYSTEM SEARCH MODULE IERRC4
*
CZ010    LA    R15,VIERRC4         R15 -> SYSTEM SEARCH
         BAS   R7,CZLINK           CALL LINK ROUTINE
         PPITEST  PPITAPE          TAPE SORT ?
         BZ    CZ005               NO, BRANCH
*
*        TAPE ROUTINE
*
         LA    R15,VIERAO2         R15 -> TAPE OPTIMIZE ROUTINE
         BAS   R7,CZLINK           CALL LINK ROUTINE
         B     CZ004               BRANCH TO RETURN
*
*        DISK ROUTINES
*
CZ005    LA    R15,VIERRCJ         R15 -> DISK CAPACITY ROUTINE
         BAS   R7,CZLINK           CALL ROUTINE
         LA    R15,VIERAO1         R15 -> DISK OPTIMIZE ROUTINE
         BAS   R7,CZLINK           CALL ROUTINE
         B     CZ004               BRANCH TO RETURN
*
*---------------------------------------------------------------------
*
*        MODULE CALLING ROUTINE WITH DIAGNOSTIC TRACE MSG
*
*---------------------------------------------------------------------
*
CZLINK   MVC   IER980M,4(R15)      MOVE MODULE ID INTO MSG
         MVC   IER987B,4(R15)      MOVE MODULE ID INTO PRINT MSG
         PPITEST  PPITMODF         DIAGNOSTIC MODULE FLOW ?
         BZ    CZLINKA             NO, BRANCH
         PPITEST  PPIDIAG+PPIDSIM  GENERATING DIAGNOSTIC MESSAGES ?
         BZ    CZLINKA             NO, BRANCH
         LM    R0,R1,IER980
         LR    R10,R15             SAVE ADDR OF MODULE TO CALL
         LA    R15,IERGAPRT
         BASR  R14,R15             CALL THE MSG PRINT RTN
         LR    R15,R10             RESTORE THE ADDR OF MODULE TO CALL
CZLINKA  L     R15,0(,R15)         LOAD MODULE ADDR
         BASR  R14,R15             BRANCH TO SELECTED ROUTINE
         LTR   R10,R15             ERROR RETURN ?
         BZ    CZLINKB             NO, BRANCH OVER ERROR RETURN MSG
         PPITEST  PPITMODF         DIAGNOSTIC MODULE FLOW ?
         BZ    CZLINKB             NO, BRANCH
         PPITEST  PPIDIAG+PPIDSIM  GENERATING DIAGNOSTIC MESSAGES ?
         BZ    CZLINKB             NO, BRANCH
         MVC   IER980R,IER980C     MOVE IN RETURN CODE MSG
         CVD   R15,DWORD
         MVC   IER980V,EPATTERN    MOVE IN EDIT PATTERN
         ED    IER980V,DWORD+6     FORMAT RETURN CODE VALUE
         LM    R0,R1,IER980
         LA    R15,IERGAPRT
         BASR  R14,R15             CALL THE MSG PRINT RTN
         MVI   IER980R,C' '        BLANK MSG AREA
         MVC   IER980R+1(L'IER980R+L'IER980V-1),IER980R
*
CZLINKB  PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTICS ACTIVE ?
         BZ    CZLINKC             NO, BRANCH
         PPITEST PPITSPPI          PRINT THE PPI AFTER MODULE ?
         BZ    CZLINKC             NO, BRANCH AROUND PRINT
         MVC   IER987M,IER987P     UPDATE TEXT OF MSG
         LM    R0,R1,IER987        GENERATE HEADER MESSAGE
         LA    R15,IERGAPRT        NO, BRANCH
         BASR  R14,R15             CALL MESSAGE WRITER
         ST    R13,IERFMTP         R13 -> PPI
         LA    R1,PPILEN-1(,R13)   R1 -> LAST PPI BYTE
         ST    R1,IERFMTP+4
         LA    R1,IERFMTP          R1 -> IERFMT PARAMETER LIST
         L     R15,VIERFMT         R15 -> FORMATTING ROUTINE
         BASR  R14,R15
CZLINKC  LTR   R10,R10             RETURN CODE FROM MODULE ZERO ?
         BZR   R7                  YES, RETURN TO CALLER
         B     CZEE01              NO, ERROR EXIT
*
         DROP  R9
*
*---------------------------------------------------------------------
*
*        IERGAPRT - MESSAGE WRITER
*
*---------------------------------------------------------------------
*
*        ON ENTRY
*        R0  -> MSG TEXT
*        R1   = L'MSG TEXT
*
*        ALL REGISTERS ARE SAVED ON ENTRY AND RESTORED ON EXIT
*
         USING *,R15
*
IERGAPRT IERENTRY 'IERGAPRT &SYSDATE &SYSTIME'
*
         STM   R14,R12,IERGAPS+12  SAVE CALLERS REGS
         DROP  R15
         USING IERGAPRT,R9
         LR    R9,R15              SET BASE FOR MSG WRITER
         LR    R10,R0              R10 -> MSG TEXT
         LR    R11,R1              R11  = L'MSG TEXT
         L     R7,SYSOUT           R7  -> SYSOUT DCB
         CLI   3(R10),C'9'         IER9XX DIAGNOSTIC MSG ?
         BE    GAPRTD              YES, PROCESS DIAGNOSTIC MSGS
         CLC   KIER,0(R10)         MSG ID START WITH IER ?
         BNE   GAPRTD              NO, IT MUST BE A DIAGNOSTIC MSG
         CLI   6(R10),C'A'         IERXXXA CRITICAL MSG ?
         BNE   GAPRTI              NO, INFORMATIONAL
*
*        CRITICAL MSG PROCESSING
*
         PPITEST  PPIPCRT+PPIPALL  MESSAGES TO PRINTER ?
         BZ    GAPRT1              NO, BRANCH
         BAS   R8,GAPRTPM          YES, CALL THE PRINT RTN
GAPRT1   PPITEST  PPICCRT+PPICALL  MSGS TO THE CONSOLE ?
         BZ    GAPRT2              NO, BRANCH
         BAS   R8,GAPRTCM          CALL CONSOLE RTN
GAPRT2   B     GAPRT4              BRANCH TO LOG MSG IN SORTDIAG
*
*        INFORMATIONAL MSG PROCESSING
*
GAPRTI   PPITEST  PPIPALL          ALL MSGS TO THE PRINTER ?
         BZ    GAPRT3              NO, BRANCH
         BAS   R8,GAPRTPM          YES, CALL THE PRINT RTN
GAPRT3   PPITEST  PPICALL          ALL MSGS TO THE CONSOLE ?
         BZ    GAPRT4              NO, BRANCH
         BAS   R8,GAPRTCM          CALL CONSOLE RTN
*
*        DIAGNOSTIC MESSAGES
*
*        ALL MESSAGES FLOW THROUGH HERE SO THAT ALL NON
*        DIAGNOSTIC MESSAGES ARE PRINTED ON SORTDIAG (IF
*        REQUESTED) TO ASSIST WITH PROBLEM DIAGNOSIS. IF NON
*        DIAGNOSTIC MESSAGES HAVE ALREADY BEEN PRINTED ON SYSOUT
*        ENSURE THAT THEY ARE NOT DUPLICATED
*
*        NON DIAGNOSTIC MSG ENTRY
*
GAPRT4   PPITEST  PPIDIAG          DIAGNOSTIC MESSAGES BEING WRITTEN
*                                  TO SORTDIAG ?
         BO    GAPRTP              YES, CAPTURE THIS MESSAGE
         B     GAPRTEXT            NO, BRANCH TO EXIT, ALREADY WRITTEN
*
*        DIAGNOSTIC MSG ENTRY
*
GAPRTD   PPITEST  PPIDIAG          PRINTING DIAGNOSTIC MESSAGES ?
         BO    GAPRTP              YES, PRINT
         PPITEST  PPIDSIM          DIAGNOSTIC MESSAGES BEING WRITTEN
*                                  TO SYSOUT ?
         BZ    GAPRTEXT            NO, BRANCH TO EXIT
*                                  YES, CALL SYSOUT PRINT
         L     R7,SYSOUT           R7 -> SYSOUT DCB
         B     GAPRTPS             BRANCH TO CALL THE PRINT RTN
*
GAPRTP   L     R7,SORTDIAG         R7 -> SORTDIAG DCB
GAPRTPS  BAS   R8,GAPRTPM          CALL THE PRINT RTN
         B     GAPRTEXT            BRANCH TO EXIT
*
*        WRITE MESSAGES TO PRINTER
*
*        ON ENTRY -
*        R7  -> DCB
*        R8   = RETURN ADDR
*        R9   = BASE
*        R10 -> MESSAGE TEXT
*        R11  = L'MESSAGE TEXT
*
GAPRTPM  LA    R2,L'PRINTL-1       MAXIMUM L'PRINT LINE
         LR    R6,R11              TAKE A COPY OF L'MSG
         CR    R6,R2               L'MSG EXCEED PRINT LINE ?
         BNH   GAPRTPM1            NO, BRANCH
         LR    R6,R2               TRUNCATE MSG TO MSG AREA IN PRINTL
GAPRTPM1 BCTR  R6,0                DECR FOR EX
         EX    R6,PRINTMVC         MOVE MSG INTO PRINT LINE
*
         PUT   (R7),PRINTL         PUT PRINT LINE
*
         BR    R8                  RETURN TO CALLER
*
*        MESSAGES TO CONSOLE
*
*        ON ENTRY -
*        R8   = RETURN ADDR
*        R9   = BASE
*        R10 -> MESSAGE TEXT
*        R11  = L'MESSAGE TEXT
*
GAPRTCM  MVC   WTORCZ+4(7),0(R10)  MOVE MESSAGE NO INTO MSG
         MVC   WTORCZ+12(L'PPIWTOH),PPIWTOH  MOVE WTO HEADER INTO MSG
         LH    R6,WTORCZ           GET L'WTO MSG AREA
         SH    R6,=AL2(4+8+L'PPIWTOH)   R6 = CURR MAX L'MSG AREA
         LR    R5,R11              R5 = CURRENT L'MSG
         SH    R5,=AL2(8)          FIRST 8 BYTES ALREADY IN MSG
         CR    R5,R6               REMAINING TEXT TOO LONG ?
         BNH   GAPRTCM1            NO, BRANCH
         LR    R5,R6               YES, TRUNCATE TO L'MAXIMUM
GAPRTCM1 BCTR  R5,0                DECR LENGTH FOR EX
         EX    R5,GAMOVE           MOVE MSG TEXT INTO WTO
*
         WTO   MF=(E,WTORCZ)
*
         BR    R8                  RETURN TO CALLER
*
*        PRINT MESSAGE EXIT PROCESSING
*
GAPRTEXT LH    R1,WTORCZ           GET L'MSG AREA
         LA    R0,6                SUB FOR HEADER, FIRST BYTE AND EX
         SR    R1,R0
         MVI   WTORCZ+4,C' '       FIRST BLANK
         EX    R1,WTOBLANK         BLANK OUT WTO MSG AREA
         MVI   PRINTL,C' '
         MVC   PRINTL+1(L'PRINTL-1),PRINTL  BLANK PRINT LINE
         LM    R14,R12,IERGAPS+12  RESTORE CALLERS REGS
         BR    R14                 RETURN TO CALLER
*
*        120 CHARACTER WTO
*
WTORCZ   WTO   '                                                       X
                                                                       X
                        ',MF=L,ROUTCDE=11,DESC=7
*
*        PRINT LINE FOR SYSOUT AND SORTDIAG
*
         DC    0F'0'
PRINTL   DC    CL121' '            PRINT LINE
*
KIER     DC    C'IER'
*
GAMOVE   MVC   WTORCZ+4+8+L'PPIWTOH(0),8(R10)  MOVE MSG INTO WTO
WTOBLANK MVC   WTORCZ+5(0),WTORCZ+4  BLANK MSG AREA
PRINTMVC MVC   PRINTL+1(0),0(R10)  MOVE MSG INTO PRINT LINE
*
IERGAPS  DC    18F'0'              PRINT ROUTINE SAVE AREA
*
TRACEON  STM   R0,R15,PPITSAV      ACTIVATE EXCP/WAIT TRACE
*
DWORD    DC    D'0'
EPATTERN DC    XL8'4020202020202020'
*
DCBLIST  DS    0XL20               LIST OF DCB ADDR PASSED BY IERRCB
SYSOUT   DC    A(0)                +00 SYSOUT DCB ADDR
SORTDIAG DC    A(0)                +04 SORTDIAG DCB ADDR
SORTLIB  DC    A(0)                +08 SORTLIB DCB ADDR
USERLIB  DC    A(0)                +12 USERLIB DCB ADDR
SYSLMOD  DC    A(0)                +16 SYSLMOD DCB ADDR
*
KH6      DC    H'6'
*
*        DATA FOR PRINT DUMP OF PPI
*
*        PPI TITLE HEADERS
*
IER987   DC    A(IER987I)
         DC    A(IER987X-IER987I)
IER987I  DC    C'IER987I PPI - '
IER987M  DC    CL25'Initialization'
IER987X  EQU   *                   FOR L'CALC
IER987P  DC    CL(L'IER987M)' '
         ORG   IER987P
IER987A  DC    C'After IER'
IER987B  DC    CL3' '
         DC    C' Processing'
         ORG   ,
*
*        PARAMETER LIST FOR IERFMT
*
IERFMTP  DC    A(0)                START OF AREA TO PRINT
         DC    A(0)                END OF AREA TO PRINT
         DC    A(IERGAPRT)         -> PRINT ROUTINE
*
VIERFMT  DC    V(IERFMT)           -> FORMAT STORAGE ROUTINE
*
*
VIERRC1  DC    V(IERRC1),C'RC1 '   CREATE PPI, MOVE DATA FROM CPI
VIERAOL  DC    V(IERAOL),C'AOL '   MERGE SORT CNTL FLDS (EQUALS)
VIERAOM  DC    V(IERAOM),C'AOM '   GENERATE EXTRACT RTN
VIERRC4  DC    V(IERRC4),C'RC4 '   COLLECT SYSTEM INFORMATION
VIERRCJ  DC    V(IERRCJ),C'RCJ '   DETERMINE SORT CAPACITY
VIERAO1  DC    V(IERAO1),C'AO1 '   GENERAL ASSIGNMENT - DASD (OPTIONAL)
VIERAO2  DC    V(IERAO2),C'AO2 '   GENERAL ASSIGNMENT - TAPE (OPTIONAL)
*
VIERRCU  DC    V(IERRCU)           MESSAGE MODULE
*
CZSAVE   DC    18F'0'
*
         LTORG
*
         PRINT NOGEN
*
         DCBD  DSORG=(PS),DEVD=(DA,TA)
*
         PRINT GEN
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRCU SOURCE
*
*----------------------------------------------------------------------
*
DIERRCU  DSECT
*
         COPY IERRCUI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
*        PPI
*
         SMPPI
*
*        CPI
*
         SMCPI
*
         END
./ ADD NAME=IERRC1   0101-20211-20211-1200-00169-00169-00000-RELEASE 00
RC1      TITLE 'IERRC1 - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRC1
*
*        MODULE FUNCTION/OPERATION -
*        CREATE THE FULLY EXPANDED PHASE TO PHASE INFORMATION
*        AREA (IERRCA) FROM THE CONDENSED VERSION WHICH WAS USED
*        DURING DEFINITION PHASE BECAUSE OF THE POSSIBILITY OF A
*        LINKAGE EDITOR EXECUTION.
*        SETS PPICNTL FLAGS ACCORDING TO TECHNIQUE, SORT OR MERGE,
*        EXTRACTING OR NOT
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACROS USED BY MODULE -
*        SMPPI
*        SMCPI
*
*        ENTRY POINT - ENTRY FROM NETWORK
*                      CALLING SEQUENCE -
*                                L     R15,VIERRC1
*                                BALR  R14,R15
*                      VIERRC1   DC    V(IERRC1)
*
*        INPUT -
*        PPI - CPI FIELDS REFERENCED
*        THE ENTIRE CPI IS MOVED TO PPI FIELD BY FIELD
*
*        PPI FIELDS INITIALIZED OR ALTERED -
*        PPICNTL FLAGS ARE SET
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL -
*        IERRCZ - RETURN CONTROL
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS - N/A
*
*        NOTES - THIS MODULE IS USED FOR ALL SORTS OR MERGES
*
IERRC1   CSECT
*
         USING *,R15               PROGRAM BASE
         USING IERRC5,R2           CPI BASE
         USING IERRCA,R13          PPI BASE
*
         IERENTRY 'IERRC1 &SYSDATE &SYSTIME'
*
*        MOVE CPI FIELDS INTO THE CORRESPONDING FIELDS IN PPI
*
*        FIELDS ARE MOVE INDIVIDUALLY TO GENERATE PROVENANCE
*        FOR MOVEMENT OF DATA FROM THE CPI TO THE PPI
*
         MVC   PPIVER,CPIVER
         MVC   PPINUMCF(74),CPINUMCF
         MVC   PPIDD0L1(4),CPIPCF01
         MVC   PPICNTL,CPICNTL         MOVE FLAGS ACROSS
         MVC   PPILAB09(4),CPILAB09
         MVC   PPIP1GC+1(3),CPIP1RSZ   USE PH1 GOTTEN CORE TO PASS
*                                      SIZE OF USER MODS TO CORE ALLOC
         MVC   PPIIPBLK+2(2),CPIIPBLK
         MVC   PPIFFF+2(2),CPIFFF
         MVC   PPIPBUFF+2(2),CPIPBUFF
         MVC   PPIP2GC+1(3),CPIP2RSZ
         MVC   PPIP3GC+1(3),CPIP3RSZ
         MVC   PPIOPBLK,CPIOPBLK
         MVC   PPISRTBL,CPISRTBL
         MVC   PPIRCDL1(10),CPIRCDL1
         MVC   PPILAB03+2(2),CPILAB03
         MVC   PPILAB07+2(2),CPILAB07
         MVC   PPIBUF23,CPIBUF23
         MVC   PPIEXTSZ+2(2),CPIEXTSZ
         MVC   PPIBINSZ+2(2),CPIBINSZ
         MVC   PPISKPRD+1(3),CPISKPRD
         MVC   PPIATP1E+1(3),CPIATP1E
         MVC   PPIATP3E+1(3),CPIATP3E
         MVC   PPITAVLC+1(3),CPITAVLC
         MVC   PPIFILSZ+1(3),CPIFILSZ
         MVC   PPISRTG+1(3),CPISRTG
         MVC   PPINMAX+1(3),CPINMAX
         MVC   PPIBUF1+3(1),CPIBUF1
         MVC   PPIMRGMX+1(1),CPIMRGMX
         MVC   PPINDSKA,CPINWKU
         MVC   PPIMRGAL+1(1),CPIMRGAL
         MVC   PPILINK,CPILINK
         MVC   PPIADDCF+1(3),CPIADDCF
         MVC   PPISORCE,CPISORCE
         MVC   PPIDDSRT,CPIDDSRT
         MVC   PPIABC,CPIABC
         MVC   PPISTOPR,CPISTOPR
         MVC   PPIDYND,CPIDYND         DEVICE TYPE
         MVC   PPIDYNN,CPIDYNN         NUMBER OF DEVICES
         MVC   PPIDYNS,CPIDYNS         MEGABYTES OF DASD TO ALLOCATE
         MVC   PPIDYNP,CPIDYNP         % DASD UPLIFT
         MVC   PPIMDDN,CPIMDDN
         MVC   PPIPDDN,CPIPDDN
         MVC   PPISVC,CPISVC
         MVC   PPISVCE,CPISVCE
         MVC   PPIWTOC,CPIWTOC
         MVC   PPIWTOH,CPIWTOH
         MVC   PPIDVCT,CPIDVCT
         MVC   PPIBLKTB,CPIBLKTB
         MVC   PPIDIRBK,CPIDIRBK
         MVC   PPIUEXIT,CPIUEXIT
*
*        INITIALIZE PPI ADDRS FOR TTR -> MBBCCHHR AND
*        MBBCCHHR -> TTR CONVERSIONS
*
         L     R1,CVTPTR
         USING CVTMAP,R1
         MVC   PPIPCNVT,CVTPCNVT
         MVC   PPIPRLTV,CVTPRLTV
*
         DROP  R1
*
         PPISETOF PPIPH1-PPIPH2-PPIPH3      PH1,2,3 BITS
*
*        SET PPICNTL FLAGS FOR USE LATER BY THE SORT AND MERGE
*        NETWORKS, WHICH USE THEM TO DETERMING IN WHICH ORDER
*        SEQUENCES ARE TO BE HANDLED
*
         PPITEST  PPIMERGO         MERGE ONLY ?
         BO    C1EXTR              YES, BRANCH
*
         PPITEST  PPIBALN          BALANCED ?
         BZ    C1EXTR              NO
*
         PPITEST  PPITAPE          TAPE ?
         BZ    C1EXTR              NO
*
         PPITEST  PPIEXTRT         EXTRACT ?
         BZ    C1OPPOS             NO
*
         PPISETON PPIPH1CO         SET PPIPH1CO DESCENDING
*
C1LEAVE  SR    R15,R15             ZERO RETURN CODE
         BR    R14                 RETURN
*
C1EXTR   PPITEST  PPIEXTRT         EXTRACT ?
         BZ    C1LEAVE             NO
         PPISETOF PPIPH1CO         YES, PPIPH1CO ASCENDING
         B     C1LEAVE
*
C1OPPOS  PPIFLIP  PPIPH1CO
         B     C1LEAVE
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
*        IERRCA DSECT
*
         SMPPI LIST=YES            REQUEST A LISTING
*
*        IERRC5 DSECT
*
         SMCPI LIST=YES            REQUEST A LIST
*
*        CVT
*
         CVT DSECT=YES
*
         END
./ ADD NAME=IERRC2   0101-20211-20211-1200-00245-00245-00000-RELEASE 00
RC2      TITLE 'IERRC2 - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRC2
*
*        MODULE FUNCTION/OPERATION -
*        1. CALCULATION OF THE EXTRACT ROUTINE
*        2. THE DISPLACEMENT OF 'F' FIELD
*        3. DISPLACEMENT OF THE PACKING BUFFER
*        THE 3 VALUES ARE STORED IN THE CPI
*        IT ALSO CALCULATES THE EXTRACTED PORTION OF THE
*        EXTRACTED CONTROL FIELDS
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACROS USED - SMCPI
*
*        ENTRY POINTS - ENTRY IERRC2 - ENTRY FROM IERRCM
*                                      CALLING SEQUENCE
*                                      L    R12,A(SAVEAREA)
*                                      L    R13,A(PPI)
*                                      L    R15,A(IERRC2)
*                                      BALR R14,R15
*                                      RETURN
*
*        INPUT - PPI FIELDS REFERENCED -
*        CPIPCF01
*        CPINUMCF
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        CPIFFF
*        CPIPBUFF
*        CPIEXTZ
*        CPILAB07
*
*        EXTERNAL ROUTINES - IERRC5 - CPI
*
*        EXTERNAL PARAMETERS -
*
*        EXITS - NORMAL -
*
*        EXITS - ERROR
*
*        TABLES/WORK AREAS -
*
*        NOTES -
*
IERRC2   CSECT
*
         USING *,R15               ENTERING MODULE VIA R15
*
         IERENTRY 'IERRC2 &SYSDATE &SYSTIME'
*
         STM   R1,R10,0(R12)
         LR    R11,R15
         DROP  R15                 FREE R15
         USING IERRC2,R11          ESTABLISH MODULE BASE R11
         USING IERRC5,R13          ESTABLISH CPI BASE REGISTER
*
*        HOUSE KEEPING
*
         LH    R9,CPINUMCF         NUMBER OF CONTROL FIELDS
         CH    R9,K12              CONTROL FIELDS > THAN 12
         BH    JFT002              YES, BRANCH
         LA    R10,CPIPCF01        FIRST CONTROL FIELD
JFT001   LA    R6,6                INITIALIZE R6 TO 6 FOR USER ADDR
         SR    R7,R7               INIT FOR STORING MAXIMUM LENGTH
         SR    R8,R8               INIT FOR STORING PACKING BUFFER
*
*        BEGIN CALCULATION ROUTINE
*
JFTROUTN LA    R5,TBRANCHT         R5 -> BRANCH TABLE
         SR    R15,R15             INIT R15 FOR ADDR CALC
         IC    R15,5(,R10)         INSERT CHARACTER FROM CONTROL FIELD
         AR    R5,R15              ADD TO GET BRANCH TABLE ADDR
         BR    R5                  GOTO BRANCH TABLE
*
JFT002   MVC   WRK+1(3),CPIADDCF
         L     R10,WRK             ACCESS CONTROL FIELD INFORMATION
         B     JFT001
*
*        BRANCH TABLE
*
TBRANCHT B     JFTCASE1
         B     JFTCASE2
         B     JFTCASE3
         B     JFTCASE3
         B     JFTCASE5
         B     JFTCASE6
         B     JFTCASE7
         B     JFTCASE7
         B     JFTCASE9
         B     JFTCASE9
         B     JFTCAS11
         B     JFTCAS11
         B     JFTCAS13
         B     JFTCAS13
         B     JFTCAS15
         B     JFTCAS16
         B     JFTCAS17
         B     JFTCAS17
         B     JFTCAS17
         B     JFTCAS17
         B     JFTCAS17
         B     JFTCAS17
         B     JFTCAS17
         B     JFTCAS24
*
*        END OF BRANCH TABLE
*
*        VARIOUS CASE ROUTINES (CASES 1,5,13,15,17,24)
*
JFTCASE1 LA    R6,6(,R6)           ADD SIZE OF SEGMENT = 6 TO R6
         B     JFTCLOSE            GO TO NEXT CONTROL FIELD IF POSSIBLE
*
JFTCASE5 LA    R6,10(,R6)
         B     JFTCLOSE
*
JFTCAS11 LA    R6,38(,R6)
         B     JFTCLOSE
*
JFTCAS13 LA    R6,40(,R6)
         B     JFTCLOSE
*
JFTCAS15 LA    R6,22(,R6)
         B     JFTCLOSE
*
JFTCAS17 LA    R6,32(,R6)
         B     JFTCLOSE
*
JFTCAS24 LA    R6,44(,R6)
         B     JFTCLOSE
*
*        VARIOUS CASE ROUTINES FOR CASE 7 ONLY
*
JFTCASE7 LA    R6,52(,R6)          ADD SEGMENT SIZE = 52 TO R6
         LA    R8,9                PUT 9 IN R8 FOR PACKING BUFFER
         CLI   3(R10),16           MORE THAN 16 BYTES ?
         BL    *+8                 NO, BRANCH
         LA    R6,6(,R6)           SEGMENT SIZE = 58 FOR MORE THAN 16
         B     JFTMORE             GO TO CHECK LENGTH ROUTINE
*
*        VARIOUS CASE ROUTINES FOR CASES (2,3,4,6,9,16)
*
JFTCASE2 LA    R6,12(,R6)
JFTMORE  SR    R2,R2               LENGTH DETERMINATION ENERGIZED
         IC    R2,3(,R10)          GET LENGTH FROM CONTROL FIELD
         LA    R2,3(,R2)           ADD 3 BYTES TO ADJUST LENGTH FIELD
         CLR   R2,R7               COMPARE LENGTH TO MAXIMUM LENGTH
         BH    JFTOVER             BRANCH ON HIGH TO CHANGE MAXIMUM
         B     JFTCLOSE            GOTO NEXT CONTROL FIELD IF POSSIBLE
*
*        ROUTINE TO EXCHANGE LEN TO MAXIMN
*
JFTOVER  LR    R7,R2               LOAD NEW MAXIMUM LENGTH INTO R7
         B     JFTCLOSE            GO TO NEXT CONTROL FIELD CALC
*
JFTCASE3 LA    R6,28(,R6)
         B     JFTMORE
*
JFTCASE9 LA    R6,46(,R6)
         B     JFTMORE
*
JFTCASE6 LA    R6,20(,R6)
         B     JFTMORE
*
JFTCAS16 LA    R6,28(0,R6)
         B     JFTMORE
*
*        DECREMENT COUNT OF CONTROL FIELDS
*        CHECK FOR END OF MODULE
*
JFTCLOSE BCT   R9,JFTINCRE         DECREMENT AND CHECK FOR LAST FIELD
*                                  IF LAST FIELD, SAVE R6,R7,R8 IN PPI
         STH   R6,CPIFFF           SAVE DISPLACEMENT OF CONSTANTS
         AR    R6,R7
         STH   R6,CPIPBUFF         SAVE DISPLACEMENT OF PACKING BUFFERS
         AR    R6,R8
         STH   R6,CPIEXTSZ         SAVE SIZE OF EXTRACT ROUTINE
*
*        CALCULATE THE SIZE OF THE EXTRACTED PORTIONS OF THE
*        EXTRACTED CONTROL FIELDS
*
         SR    R10,R10             CLEAR  R10 FOR SIZE OF CONTROL FIELD
         LH    R9,CPINUMCF         NUMBER OF CONTROL FIELDS
         CH    R9,K12              MORE THAN 12 CONTROL FIELDS ?
         BH    JFT004              YES, BRANCH
         LA    R8,CPIPCF01         FIRST CONTROL FIELD
EXTROUT  SR    R4,R4               CLEAR R4 FOR BYTE PORTION OF LENGTH
         IC    R4,3(,R8)           BYTE PORTION OF LENGTH OF CF
         CLI   5(R8),X'18'         CF UNPACKED DECIMAL ASCENDING ?
         BE    EXTR1               YES, BRANCH
         CLI   5(R8),X'1C'         CF UNPACKED DECIMAL DESCENDING ?
         BNE   EXTR2               NO, BRANCH
EXTR1    LA    R4,1(,R4)           INCREMENT BY 1 BYTE
         CLI   3(R8),16            MORE THAN 16 BYTES ?
         BL    *+8                 NO, BRANCH
         LA    R4,1(,R4)           INCREMENT BY ONE BYTE
         SRL   R4,1                DIVIDE BY 2
         B     EXTSKIP
*
EXTR2    CLI   3(R8),255           L'BYTES = 255 ?
         BNE   EXTR21              NO, BRANCH
         CLI   4(R8),0             L'BITS  = 0 ?
         BE    EXTR21              YES, BRANCH
         SR    R4,R4               ONLY WANT THE BITS
EXTR21   SLL   R4,3                MULTIPLY BY 8
         SR    R3,R3               ZERO R3
         IC    R3,4(,R8)
         AR    R4,R3               TOTAL THE BITS
         IC    R3,2(,R8)           BITS PORTION OF DISPL OF LAST CF
         AR    R4,R3
         LA    R4,7(,R4)           ROUND OFF
         SRL   R4,3                DIVIDE BY 8
EXTSKIP  LA    R4,1(,R4)           INC BY 1 BYTE FOR ACTUAL DISPL
         LA    R3,511              CONSTANT X'01FF'
         NR    R4,R3               KEEP LAST BYTE
         AR    R10,R4              INC DISPL IN EXTRACT PORTION BY LTH
         LA    R8,6(,R8)           GET NEXT CONTROL FIELD
         BCT   R9,EXTROUT          LAST CONTROL FIELD
         LR    R9,R10              SAVE LENGTH + 4
         LA    R15,0               FOR SAFE RETURN
         STH   R10,CPILAB07        LENGTH OF EXTRACTED CONTROL FIELDS
         LM    R1,R10,0(R12)
         BR    R14                 RETURN TO CALLER
*
*        ROUTINE TO GET NEXT CONTROL FIELD
*
JFTINCRE LA    R10,6(,R10)         ADD 6 BYTES TO CONTROL FIELD
         B     JFTROUTN            BRANCH TO START OF ROUTINE
*
JFT004   L     R8,WRK
         B     EXTROUT
*
WRK      DC    A(0)
K12      DC    H'12'
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMCPI
*
         END
./ ADD NAME=IERRC4   0101-20211-20211-1200-00782-00782-00000-RELEASE 00
RC4      TITLE 'IERRC4 - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRC4
*
*        MODULE FUNCTION/OPERATION -
*        THIS MODULE GATHERS SYSTEM INFORMATION FOR SORT.
*        THE FOLLOWING IS A LIST OF THE ITEMS AND SOURCE OF EACH -
*        1. THE CHANNEL ADDR OF SORTIN (TAPE)          - UCB
*        2. THE CHANNEL ADDR OF EACH WORK UNIT OR AREA - UCB
*        3. THE STARTING AND ENDING ADDR OF EACH AREA  - DSCB
*        4. THE NUMBER OF TRACKS IN EACH DATA SET      - DSCB
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACROS USED -
*        EXTRACT
*        RDJFCB
*        OBTAIN
*        CAMLST
*        DCB
*
*        ENTRY POINT - ENTRY IERRC4
*                      ENTRY FROM - IERRCZ
*                      CALLING SEQUENCE -
*                      L      R15,=V(IERRC4)
*                      BALR   R14,R15
*
*        INPUT PPI FIELDS REFERENCED -
*        PPICNTL FOR TAPE TEST
*
*        OUTPUT PPI FIELDS INITIALIZED OR ALTERED -
*        PPIDSKED - UCB ADDR AND NO OF TRACKS FOR SORTWKXX DATA SET
*        PPISTAR  - STARTING M0000TTR FOR SORTWKXX DATA SET
*        PPIENDAR - ENDING M0000TTR FOR SORTWKXX DATA SET
*        PPITPPT  - TAPE TABLE FOR TAPE SORTS
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL -
*        IERRCZ WITH ZERO IN R15
*
*        EXITS - ERROR -
*        IERRCZ WITH FOUR IN R15
*
*        TABLES/WORK AREAS -
*        DASDTAB - ADDR TABLE FOR DIRECT ACCESS
*        TAPETAB - ADDR TABLE FOR TAPE
*
*
IERRC4   CSECT                     SYSTEM SEARCH AFTER LINKAGE EDIT
*
         USING *,R11
         USING IERRCA,R13
*
         IERENTRY 'IERRC4 &SYSDATE &SYSTIME'
*
         STM   R14,R12,12(R12)     SAVE REGS IN SAVEAREA PASSED
*                                  IN R12 FROM IERRCZ
         LR    R11,R15             SET BASE REGISTER
*
         EXTRACT TIOTADDR,'S',FIELDS=(TIOT)  GET ADDR OF TIOT
*
         L     R10,TIOTADDR        ESTABLISH BASE FOR TIOT DSECT
         USING TIOT1,R10
         PPITEST  PPITAPE          TAPE SORT ?
         BO    C4TAPE              YES, BRANCH
*
*----------------------------------------------------------------------
*
*        DISK SORTWKXX PROCESSING
*
*        LOOP THROUGH THE TIOT AND THEN FOR EACH TIOT ENTRY
*        SCAN THE UNIT TABLE FOR A MATCHING SORTWKXX ENTRY
*
*        GET THE CHANNEL ADDR AND STARTING AND ENDING ADDR
*        (CCHH) FOR EACH DISK AREA
*
*----------------------------------------------------------------------
*
C4DISK   LH    R4,PPINDSKA         SET LOOP COUNTER TO NUMBER OF DISK
*                                  AREAS PREVIOUSLY SET IN PPINDSKA
         LA    R8,DASDTAB          R8 -> DASD UNIT TABLE
         USING UTAB,R8
C4001    MVC   DDNAME(4),PPIDDSRT  MOVE USER DEFINED DDNAME INTO DDN
         CLC   TIOEDDNM,DDNAME     DDNAME A SORTWKXX ENTRY ?
         BE    C4002               YES, BRANCH TO PROCESS THIS ENTRY
         LA    R8,20(,R8)          NO, R8 -> NEXT UNIT TABLE ENTRY
         BCT   R4,C4001            LOOP TO NEXT UNIT TABLE ENTRY
         B     C4004               THIS TIOT ENTRY NOT A SORTWKXX ENTRY
*
*        FOUND A SORTWKXX ENTRY
*
C4002    LM    R4,R6,UTABDATA      GET ADDRS OF AREAS TO STORE DATA
*                                  FROM ADCONS IN DASDTAB ENTRY FOR
*                                  THIS DDNAME
         SR    R9,R9
         ICM   R9,B'0111',TIOEFSRT GET UCB ADDR
*
         USING UCB,R9
         MVC   0(2,R4),UCBCHAN     MOVE CHANNEL AND UNIT ADDR FOR
*                                  THIS SORTWKXX AREA FROM UCB
         NI    0(R4),CHANMASK      MASK OUT UCB FLAG BITS
         LA    R15,SORTDCB         R15 -> SORTDCB
         USING IHADCB,R15
         MVC   DCBDDNAM,DDNAME     MOVE DDNAME INTO SORTDCB
         DROP  R15
*
         RDJFCB (SORTDCB)          GET JFCB FOR THIS AREA
*
         OBTAIN SORTDSCB           GET DSCB FOR THIS AREA
*
         LTR   R15,R15             OBTAIN SUCCESSFULL ?
         BNZ   C4EE01              NO, ERROR BRANCH
*
*        USING TTR ADDRESSING
*
*        FIRST TRACK = 0000
*
*        GENERATE IER981 SORTWORK DASD INFORMATION MSG AND STORE
*        NO OF TRACKS IN EACH DATA SET
*
         L     R4,VIERRCU          R4 -> MSG MODULE
         USING DIERRCU,R4
*
         MVI   IER9811,C','        MOVE COMMA INTO MSG
         MVI   IER9812,C','        MOVE COMMA INTO MSG
         MVI   IER9813,C','        MOVE COMMA INTO MSG
         MVC   IER981D,TIOEDDNM    MOVE TIOEDDNM INTO MSG
         MVC   IER981U,UCBNAME     MOVE UNIT ADDR INTO MSG
         MVC   IER981V,UCBVOLI     MOVE VOLSER INTO MSG
         LA    R1,DVCTYPMK         SET R1 TO MASK TO EXTACT UNIT TYPE
         N     R1,UCBTYP           DASD UNIT TYPE NOW IN R2
         BCTR  R1,0                DECR FOR TABLE LOOKUP
         SLL   R1,2                EACH DASD DEVICE NAME IS 4 CHARS
         LA    R1,DASDNAME(R1)     R1 -> DASD DEVICE NAME FOR UCBTYP
         MVC   IER981Y,0(R1)       MOVE DASD DEVICE NAME INTO MSG
         L     R3,PPIDVCT          R3 -> DEVICE ENTRY IN IECZDTAB
         USING DVCT,R3
         LA    R2,DS1EXT1          R2 -> FIRST DATA SET EXTENT
         USING EXTDESC,R2          EXTENT DESCRIPTION DSECT
*
*        ONLY THE FIRST 3 EXTENTS AS DESCRIBED IN THE FMT 1 DSCB
*        ARE SUPPORTED
*
*        ADD ADDITIONAL CODE HERE TO DETECT AND OBTAIN A FMT 3 DSCB
*        AND PROCESS THE EXTENTS DESCRIBED BY THE FMT 3
*
         LA    R7,3                SET LOOP COUNTER FOR 3 EXTENTS
         SR    R5,R5               ZERO WORK REGS
         SR    R6,R6
*
*        LOOP THROUGH THE EXTENT(S) AND SUM THE NUMBER OF TRACKS
*        TO STORE IN THE NUMBER OF TRACKS AND THE ENDING RELATIVE
*        TRACK ADDR
*
C4003    CLI   EXTYPE,EXTNE        USED EXTENT ?
         BE    C4004               NO, END LOOP
         SR    R14,R14             YES, ZERO WORK REGS
         SR    R15,R15
         ICM   R5,B'0011',EXTCCL   R5 = START OF LOWER EXTENT CC
         CVD   R5,WORKD
         MVC   IER981CL,EPATTN6    MOVE IN ED PATTERN
         ED    IER981CL,WORKD+5    FORMAT LOWER CC EXTENT
         MVI   IER981CL,C','
         ICM   R6,B'0011',EXTHHL   R6 = START OF LOWER EXTENT HH
         CVD   R6,WORKD
         MVC   WORK4,EPATTN4       MOVE IN ED PATTERN
         ED    WORK4,WORKD+6
         MVC   IER981HL,WORK4+2    MOVE IN FORMATTED HH
         ICM   R14,B'0011',EXTCCU  R14 = START OF UPPER EXTENT CC
         CVD   R14,WORKD
         MVC   IER981CU,EPATTN6    MOVE IN ED PATTERN
         ED    IER981CU,WORKD+5    FORMAT UPPER CC EXTENT
         ICM   R15,B'0011',EXTHHU  R15 = START OF UPPER EXTENT HH
         CVD   R15,WORKD
         MVC   WORK4,EPATTN4       MOVE IN ED PATTERN
         ED    WORK4,WORKD+6
         MVC   IER981HU,WORK4+2    MOVE IN FORMATTED HH
*
*        CALCULATE NUMBER OF TRACKS IN EXTENT
*
         SR    R14,R5              SUBTRACT LOWER CC FROM UPPER CC
         MH    R14,DVCTRK          MULT CYLS BY TRKS PER CYL FOR DEVICE
         LA    R14,1(R14,R15)      ADD NUMBER OF TRACKS IN HIGH CYL + 1
         SR    R14,R6              SUBTRACT TRK NO IN LOW EXTENT
         L     R1,UCBPTR           R1 -> DISKUAXX ENTRY FOR THIS DD
         SR    R15,R15
         ICM   R15,B'0011',2(R1)   GET CURRENT TRACK COUNT
         AR    R15,R14             ADD TRACKS IN THIS EXTENT
         STH   R15,2(,R1)          SAVE TOTAL NUMBER OF TRACKS
         L     R1,ECCHHA           R1 -> DISKE01 ENTRY FOR THIS DD
         BCTR  R15,0               CONVERT NUMBER OF TRACKS TO
*                                  ENDING RELATIVE TRACK ADDR
         STH   R15,5(,R1)          STORE ENDING RELATIVE TRACK NUMBER
         PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTICS ?
         BZ    C4004A              NO, BYPASS CALL TO MSG WRITER
         CVD   R14,WORKD
         MVC   IER981NT,EPATTN6    MOVE IN ED PATTERN
         ED    IER981NT,WORKD+5    FORMAT NUMBER OF TRACKS IN EXTENT
         LM    R0,R1,IER981        IER981 SORTWORK DASD INFORMATION
         L     R15,VGAPRT          R15 -> PRINT ROUTINE
         BASR  R14,R15             CALL PRINT ROUTINE
C4004A   LA    R2,EXTDESCL(,R2)    INCREMENT TO NEXT EXTENT
         MVC   IER981D,BLANKS      BLANK OUT DDNAME, UCB, DASD AND VOL
         MVC   IER981U,BLANKS
         MVC   IER981Y,BLANKS
         BCT   R7,C4003
*
         DROP  R4
*
C4004    SR    R15,R15             PROCESS NEXT TIOT ENTRY
         IC    R15,TIOELNGH        LENGTH OF THIS TIOT ENTRY
         AR    R10,R15             INCR TO NEXT ENTRY
         CLI   TIOELNGH,0          L'NEXT TIOT ENTRY = 0 ?
         BNE   C4DISK              NO, LOOP THROUGH TABLE
*
*        ENTIRE TIOT HAS BEEN SCANNED FOR DISK SORTS
*
*        MOVE TABLE OF 17 UCB ADDRS AND STARTING AND ENDING RELATIVE
*        TTR INTO RELEVANT PPI DATA AREAS -
*        PPIDSKED
*        PPISTAR
*        PPIENDAR
*
         MVC   PPIDSKED(17*4),DISKUA01  MOVE DASD UCB ADDR TAB TO PPI
*                                       BEGINNING TT IS ALWAYS ZERO
         MVC   PPISTAR(17*8),DISKS01    MOVE DASD STARTING M0000TTR
*                                       ENDING RELATIVE TT IS IN HH
         MVC   PPIENDAR(17*8),DISKE01   MOVE DASD ENDING M0000TTR
*
*----------------------------------------------------------------------
*
*        RETURN TO CALLER
*
*----------------------------------------------------------------------
*
C4RETURN SR    R15,R15             SET RETURN CODE TO ZERO
C4RETERR L     R14,12(R12)         RESTORE REGS
         LM    R0,R12,20(R12)      RESTORE REGS
         BR    R14                 RETURN TO CALLER
*
         DROP  R8,R9,R10
*
*----------------------------------------------------------------------
*
*        TAPE SORTWKXX PROCESSING
*
*        GET THE CHANNEL ADDR FOR SORTIN AND EACH WORK UNIT
*
*----------------------------------------------------------------------
*
C4TAPE   LA    R2,33               SET LOOP COUNTER FOR 32 SORTWKXX
*                                  ENTRIES PLUS ONE FOR SORTIN
         LA    R8,TAPETAB          GET ADDR OF TAPE UNIT TABLE
         USING UTAB,R8
         L     R10,TIOTADDR        ESTABLISH BASE FOR TIOT DSECT
         USING TIOT1,R10
C4005    MVC   DDNAME(4),PPIDDSRT  MOVE USER DEFINED DDNAME INTO DDN
         CLC   TIOEDDNM,DDNAME     DDNAME A SORTIN/SORTWKXX ENTRY ?
         BE    C4006               YES, BRANCH
         LA    R8,12(,R8)          UPDATE UTAB ADDR
         BCT   R2,C4005            NO, LOOP TO NEXT UNIT TABLE ENTRY
         B     C4007               THIS TIOT ENTRY NOT SORTIN/SORTWKXX
*
C4006    L     R5,UCBPTR           GET ADDR OF UCB STORE AREA FROM UTAB
         SR    R9,R9
         ICM   R9,B'0111',TIOEFSRT GET UCB ADDR
*
         USING UCB,R9
*
         MVC   0(1,R5),UCBCHA      GET CHANNEL ADDR FOR
*                                  THIS SORTWKXX AREA FROM UCB
         NI    0(R5),CHANMASK      MASK OUT UCB FLAG BITS
C4007    SR    R15,R15
         IC    R15,TIOELNGH        LENGTH OF CURRENT TIOT ENTRY
         AR    R10,R15             INCR TO NEXT TIOT ENTRY
         CLI   TIOELNGH,0          L'NEXT TIOT ENTRY = 0 ?
         BNE   C4TAPE              NO, PROCESS NEXT TIOT ENTRY
*
*        ENTIRE TIOT HAS BEEN SCANNED FOR TAPE SORTS
*
C4007A   PPITEST  PPIBALN          BALANCED SORT ?
         BO    C4008               YES, BRANCH
         MVC   TAPEWK18+1(29),TAPEWK18  CLEAR HIGH END OF TAPE TABLE
C4008    MVC   PPITPPT,TAPEIN      MOVE TAPEIN TO PPITPPT
         MVC   PPITPTBL(64),TAPEWK01  MOVE TAPE TABLE INTO PPI
         B     C4RETURN            BRANCH TO RETURN
*
*        GENERATE ERROR MESSAGES
*
C4EE01   L     R1,VIERRCU          R1 -> IERRCU MSG MODULE
         USING DIERRCU,R1
         MVC   IER060D,TIOEDDNM    MOVE TIOEDDNM INTO MSG
         MVC   IER060V,UCBVOLI     MOVE VOLSER INTO MSG
         LA    R1,IER060           R1 -> MSG TEXT
         MVC   PPIABMNO,3(R1)      MOVE MSG NO INTO ABEND NO
         LM    R0,R1,IER060        IER060A - DSCB NOT DEFINED
         L     R15,VGAPRT          R15 -> PRINT ROUTINE
         BASR  R14,R15             CALL PRINT ROUTINE
         LA    R15,4               SET RETURN CODE
         B     C4RETERR            BRANCH TO ERROR EXIT
*
         DROP  R1
*
VIERRCU  DC    V(IERRCU)
VGAPRT   DC    V(IERGAPRT)
*
WORKD    DC    D'0'                WORK AREA
WORK4    DC    CL4' '
*
EPATTN4  DC    XL4'40212121'
EPATTN6  DC    XL6'402021212121'
BLANKS   DC    CL8' '
*
*        DASD DEVICE NAMES
*
*        USED FOR MESSAGE TEXT ONLY
*
DASDNAME DC    CL4'2311'         *
         DC    CL4'2301'         |
         DC    CL4'2303'         |
         DC    CL4'9345'         | REPURPOSED FROM 2302
         DC    CL4'2321'         |
         DC    CL4'2351'         | 2305 MOD 1
         DC    CL4'2352'         | 2305 MOD 2
         DC    CL4'2314'         |
         DC    CL4'3330'         | 3330 MOD 1
         DC    CL4'3340'         | ALL MODS INCLUDING 3344
         DC    CL4'3350'         |
         DC    CL4'3375'         |
         DC    CL4'3331'         | 3330 MOD 11
         DC    CL4'3380'         | ALL MODS
         DC    CL4'3390'         V ALL MODS
*
CHANMASK EQU   X'0F'               MASK FOR CH ADDR OF UCBCHA
*
TIOTADDR DC    F'0'
*
         DC    0F'0'               SORTDCB EXIT LIST
SORTDCBX DC    X'87'               REQUEST JFCB
         DC    AL3(JFCB)           PTR TO JBCB AREA
*
*        JFCB
*
         DC    0D'0'
JFCB     DS    0CL176
*
         PRINT NOGEN
*
         IEFJFCBN
*
*        FORMAT 1 DSCB
*
         DC    0D'0'
FMT1DSCB DC    XL140'00'
         ORG   FMT1DSCB-44         L'DS1DSNAM (FIX IECSDSL1 MAPPING)
*
         IECSDSL1 (1)              FORMAT 1 DSCB
*
         ORG   ,
*
         PRINT GEN
*
*        CAMLST ENTRY TO READ DSCB
*
SORTDSCB CAMLST SEARCH,JFCBDSNM,JFCBVOLS,FMT1DSCB
*
         PRINT NOGEN
*
*        DCB FOR RDFJCB AND DSCB
*
SORTDCB  DCB   DDNAME=SORTWK01,EXLST=SORTDCBX,DSORG=PS,MACRF=(E)
*
         PRINT GEN
*
*        DISK TABLE
*
DASDTAB  DC    0D'0'
         DC    CL8'SORTWK01'       DDNAME
         DC    A(DISKUA01)         -> LOCATION OF UCB ADDR
         DC    A(DISKS01)          -> DASD STARTING MBBCCHHR
         DC    A(DISKE01)          -> DASD ENDING   MBBCCHHR
         DC    CL8'SORTWK02'
         DC    A(DISKUA02)
         DC    A(DISKS02)
         DC    A(DISKE02)
         DC    CL8'SORTWK03'
         DC    A(DISKUA03)
         DC    A(DISKS03)
         DC    A(DISKE03)
         DC    CL8'SORTWK04'
         DC    A(DISKUA04)
         DC    A(DISKS04)
         DC    A(DISKE04)
         DC    CL8'SORTWK05'
         DC    A(DISKUA05)
         DC    A(DISKS05)
         DC    A(DISKE05)
         DC    CL8'SORTWK06'
         DC    A(DISKUA06)
         DC    A(DISKS06)
         DC    A(DISKE06)
         DC    CL8'SORTWK07'
         DC    A(DISKUA07)
         DC    A(DISKS07)
         DC    A(DISKE07)
         DC    CL8'SORTWK08'
         DC    A(DISKUA08)
         DC    A(DISKS08)
         DC    A(DISKE08)
         DC    CL8'SORTWK09'
         DC    A(DISKUA09)
         DC    A(DISKS09)
         DC    A(DISKE09)
         DC    CL8'SORTWK10'
         DC    A(DISKUA10)
         DC    A(DISKS10)
         DC    A(DISKE10)
         DC    CL8'SORTWK11'
         DC    A(DISKUA11)
         DC    A(DISKS11)
         DC    A(DISKE11)
         DC    CL8'SORTWK12'
         DC    A(DISKUA12)
         DC    A(DISKS12)
         DC    A(DISKE12)
         DC    CL8'SORTWK13'
         DC    A(DISKUA13)
         DC    A(DISKS13)
         DC    A(DISKE13)
         DC    CL8'SORTWK14'
         DC    A(DISKUA14)
         DC    A(DISKS14)
         DC    A(DISKE14)
         DC    CL8'SORTWK15'
         DC    A(DISKUA15)
         DC    A(DISKS15)
         DC    A(DISKE15)
         DC    CL8'SORTWK16'
         DC    A(DISKUA16)
         DC    A(DISKS16)
         DC    A(DISKE16)
         DC    CL8'SORTWK17'
         DC    A(DISKUA17)
         DC    A(DISKS17)
         DC    A(DISKE17)
*
*        SORTWORK AREAS UCB ADDR TABLE
*
*        THIS TABLE IS MOVED TO PPIDSKED AT THE COMPLETION OF
*        PROCESSING
*
DISKUA01 DC    XL4'00'             UCBCHA+UCBUA, NO OF TRACKS
DISKUA02 DC    XL4'00'
DISKUA03 DC    XL4'00'
DISKUA04 DC    XL4'00'
DISKUA05 DC    XL4'00'
DISKUA06 DC    XL4'00'
DISKUA07 DC    XL4'00'
DISKUA08 DC    XL4'00'
DISKUA09 DC    XL4'00'
DISKUA10 DC    XL4'00'
DISKUA11 DC    XL4'00'
DISKUA12 DC    XL4'00'
DISKUA13 DC    XL4'00'
DISKUA14 DC    XL4'00'
DISKUA15 DC    XL4'00'
DISKUA16 DC    XL4'00'
DISKUA17 DC    XL4'00'
*
*        DASD STARTING ADDR TABLE
*
*        THIS TABLE IS MOVED INTO PPISTAR AFTER THE TIOT HAS
*        BEEN SCANNED FOR DASD SORTWKXX ENTRIES
*
*        NOTE THAT THE EXTENT DESCRIPTOR M IS USED TO RELATE
*        TO THE DDNAME AND NOT A STANDARD DEB EXTENT
*
*        USING TTR RELATIVE ADDRESSING THE START ADDR IS X'0000'
*
DISKS01  DC    AL1(01)             M (DDNAME IDENTIFIER SORTWK01)
         DC    XL6'00'             0000TT FIRST TRACK IS ALWAYS 00
         DC    X'01'               R
DISKS02  DC    AL1(02)
         DC    XL6'00'
         DC    X'01'
DISKS03  DC    AL1(03)
         DC    XL6'00'
         DC    X'01'
DISKS04  DC    AL1(04)
         DC    XL6'00'
         DC    X'01'
DISKS05  DC    AL1(05)
         DC    XL6'00'
         DC    X'01'
DISKS06  DC    AL1(06)
         DC    XL6'00'
         DC    X'01'
DISKS07  DC    AL1(07)
         DC    XL6'00'
         DC    X'01'
DISKS08  DC    AL1(08)
         DC    XL6'00'
         DC    X'01'
DISKS09  DC    AL1(09)
         DC    XL6'00'
         DC    X'01'
DISKS10  DC    AL1(10)
         DC    XL6'00'
         DC    X'01'
DISKS11  DC    AL1(11)
         DC    XL6'00'
         DC    X'01'
DISKS12  DC    AL1(12)
         DC    XL6'00'
         DC    X'01'
DISKS13  DC    AL1(13)
         DC    XL6'00'
         DC    X'01'
DISKS14  DC    AL1(14)
         DC    XL6'00'
         DC    X'01'
DISKS15  DC    AL1(15)
         DC    XL6'00'
         DC    X'01'
DISKS16  DC    AL1(16)
         DC    XL6'00'
         DC    X'01'
DISKS17  DC    AL1(17)
         DC    XL6'00'
         DC    X'01'
*
*        DASD ENDING ADDR TABLE
*
*        THIS TABLE IS MOVED INTO PPIENDAR AFTER THE TIOT HAS
*        BEEN SCANNED FOR DASD SORTWKXX ENTRIES
*
DISKE01  DC    XL7'00'             M0000TT NUMBER OF TRACKS IN ALL EXT
         DC    X'01'               R
DISKE02  DC    XL7'00'
         DC    X'01'
DISKE03  DC    XL7'00'
         DC    X'01'
DISKE04  DC    XL7'00'
         DC    X'01'
DISKE05  DC    XL7'00'
         DC    X'01'
DISKE06  DC    XL7'00'
         DC    X'01'
DISKE07  DC    XL7'00'
         DC    X'01'
DISKE08  DC    XL7'00'
         DC    X'01'
DISKE09  DC    XL7'00'
         DC    X'01'
DISKE10  DC    XL7'00'
         DC    X'01'
DISKE11  DC    XL7'00'
         DC    X'01'
DISKE12  DC    XL7'00'
         DC    X'01'
DISKE13  DC    XL7'00'
         DC    X'01'
DISKE14  DC    XL7'00'
         DC    X'01'
DISKE15  DC    XL7'00'
         DC    X'01'
DISKE16  DC    XL7'00'
         DC    X'01'
DISKE17  DC    XL7'00'
         DC    X'01'
*
*        TAPE TABLE
*
TAPETAB  DC    0D'0'
         DC    CL8'SORTIN'
         DC    A(TAPEIN)
         DC    CL8'SORTWK01'
         DC    A(TAPEWK01)
         DC    CL8'SORTWK02'
         DC    A(TAPEWK02)
         DC    CL8'SORTWK03'
         DC    A(TAPEWK03)
         DC    CL8'SORTWK04'
         DC    A(TAPEWK04)
         DC    CL8'SORTWK05'
         DC    A(TAPEWK05)
         DC    CL8'SORTWK06'
         DC    A(TAPEWK06)
         DC    CL8'SORTWK07'
         DC    A(TAPEWK07)
         DC    CL8'SORTWK08'
         DC    A(TAPEWK08)
         DC    CL8'SORTWK09'
         DC    A(TAPEWK09)
         DC    CL8'SORTWK10'
         DC    A(TAPEWK10)
         DC    CL8'SORTWK11'
         DC    A(TAPEWK11)
         DC    CL8'SORTWK12'
         DC    A(TAPEWK12)
         DC    CL8'SORTWK13'
         DC    A(TAPEWK13)
         DC    CL8'SORTWK14'
         DC    A(TAPEWK14)
         DC    CL8'SORTWK15'
         DC    A(TAPEWK15)
         DC    CL8'SORTWK16'
         DC    A(TAPEWK16)
         DC    CL8'SORTWK17'
         DC    A(TAPEWK17)
         DC    CL8'SORTWK18'
         DC    A(TAPEWK18)
         DC    CL8'SORTWK19'
         DC    A(TAPEWK19)
         DC    CL8'SORTWK20'
         DC    A(TAPEWK20)
         DC    CL8'SORTWK21'
         DC    A(TAPEWK21)
         DC    CL8'SORTWK22'
         DC    A(TAPEWK22)
         DC    CL8'SORTWK23'
         DC    A(TAPEWK23)
         DC    CL8'SORTWK24'
         DC    A(TAPEWK24)
         DC    CL8'SORTWK25'
         DC    A(TAPEWK25)
         DC    CL8'SORTWK26'
         DC    A(TAPEWK26)
         DC    CL8'SORTWK27'
         DC    A(TAPEWK27)
         DC    CL8'SORTWK28'
         DC    A(TAPEWK28)
         DC    CL8'SORTWK29'
         DC    A(TAPEWK29)
         DC    CL8'SORTWK30'
         DC    A(TAPEWK30)
         DC    CL8'SORTWK31'
         DC    A(TAPEWK31)
         DC    CL8'SORTWK32'
         DC    A(TAPEWK32)
*
*        TAPEIN MOVED TO PPITPPT ON COMPLETION OF TIOT SCAN
*
TAPEIN   DC    X'00'               CHANNEL ADDR
         DC    X'FF'
         DC    X'0000'
*
*        TAPE TABLE MOVED TO PPITPTBL ON COMPLETION OF TIOT SCAN
*
TAPEWK01 DC    X'00'               CHANNEL ADDR
         DC    AL1(01)             DDNAME SUFFIX IE (SORTWK01)
TAPEWK02 DC    X'00'
         DC    AL1(02)
TAPEWK03 DC    X'00'
         DC    AL1(03)
TAPEWK04 DC    X'00'
         DC    AL1(04)
TAPEWK05 DC    X'00'
         DC    AL1(05)
TAPEWK06 DC    X'00'
         DC    AL1(06)
TAPEWK07 DC    X'00'
         DC    AL1(07)
TAPEWK08 DC    X'00'
         DC    AL1(08)
TAPEWK09 DC    X'00'
         DC    AL1(09)
TAPEWK10 DC    X'00'
         DC    AL1(10)
TAPEWK11 DC    X'00'
         DC    AL1(11)
TAPEWK12 DC    X'00'
         DC    AL1(12)
TAPEWK13 DC    X'00'
         DC    AL1(13)
TAPEWK14 DC    X'00'
         DC    AL1(14)
TAPEWK15 DC    X'00'
         DC    AL1(15)
TAPEWK16 DC    X'00'
         DC    AL1(16)
TAPEWK17 DC    X'00'
         DC    AL1(17)
TAPEWK18 DC    X'00'
         DC    AL1(18)
TAPEWK19 DC    X'00'
         DC    AL1(19)
TAPEWK20 DC    X'00'
         DC    AL1(20)
TAPEWK21 DC    X'00'
         DC    AL1(21)
TAPEWK22 DC    X'00'
         DC    AL1(22)
TAPEWK23 DC    X'00'
         DC    AL1(23)
TAPEWK24 DC    X'00'
         DC    AL1(24)
TAPEWK25 DC    X'00'
         DC    AL1(25)
TAPEWK26 DC    X'00'
         DC    AL1(26)
TAPEWK27 DC    X'00'
         DC    AL1(27)
TAPEWK28 DC    X'00'
         DC    AL1(28)
TAPEWK29 DC    X'00'
         DC    AL1(29)
TAPEWK30 DC    X'00'
         DC    AL1(30)
TAPEWK31 DC    X'00'
         DC    AL1(31)
TAPEWK32 DC    X'00'
         DC    AL1(32)
*
*        FORMAT 1 DSCB EXTENT DESCRIPTION DSECT
*
EXTDESC  DSECT
EXTYPE   DS    XL1                 EXTENT TYPE
EXTACB   EQU   X'81'               EXTENT ALLOCATED ON CYL BOUNDARIES
EXTNE    EQU   X'00'               NOT AN EXTENT
EXTSEQN  DS    XL1                 EXTENT SEQUENCE NUMBER
EXTCCL   DS    XL2                 EXTENT CC LOWER LIMIT
EXTHHL   DS    XL2                 EXTENT HH LOWER LIMIT
EXTCCU   DS    XL2                 EXTENT CC UPPER LIMIT
EXTHHU   DS    XL2                 EXTENT HH UPPER LIMIT
EXTDESCL EQU   *-EXTDESC           L'EXTENT DESCRIPTOR
*
UTAB     DSECT
DDNAME   DS    CL8
UTABDATA DS    0CL12
UCBPTR   DS    AL4
SCCHHA   DS    AL4
ECCHHA   DS    AL4
*
*        DSECT IERRCU
*
DIERRCU  DSECT
*
         COPY IERRCUI
*
         PRINT NOGEN
*
*        MAP TIOT
*
TIOT     DSECT
*
         IEFTIOT1
*
*        MAP DCB
*
         DCBD DSORG=PS,DEVD=(TA,DA)
*
*        MAP UCB
*
UCB      DSECT
*
         IEFUCBOB
*
*        IHADVCT                   MAP DEVICE CHARACTERISTICS TABLE
*
         IHADVCT
*
*        MAP CVT
*
         CVT  DSECT=YES
*
         PRINT GEN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
*        IEZBITS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERRC6   0101-20211-20211-1200-01121-01121-00000-RELEASE 00
RC6      TITLE 'IERRC6 - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRC6
*
*        MODULE FUNCTION/OPERATION -
*        SELECT THE MODULES AND USER MODIFICATION PROGRAMS THAT
*        ARE TO BE LOADED DURING PHASE 1 (PHASE 1 AND PHASE 2 OF
*        AN OSCILLATING OR CRCX SORT). THE LAST THREE CHARACTERS
*        OF EACH SELECTED RUNNING MODULE AND EACH SELECTED USER
*        PROGRAM ARE STORED IN PPI.
*        THE PHASE 2 USER PROGRAM NAMES, FOR AN OSCILLATING OR A
*        CRCX SORT, ARE ACQUIRED BY LOADING AND LINKING TO
*        IERRC7. THE LAST THREE CHARACTERS OF EACH SELECTED
*        ASSIGNMENT MODULE ARE PLACED IN A LIST WITHIN IERRC6.
*        THE ADDRESS OF THIS LIST IS PASSED TO IERRC9
*
*        MODULES IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        LIST OF MACROS USED BY MODULE -
*        SMPPI
*        LOAD
*        DELETE
*
*        ENTRY POINTS - ENTRY FROM IERRCV
*                       CALLING SEQUENCE -
*                       LOAD EP=IERRC6,DCB=(1)
*                       LR    R15,R0
*                       BR    R15    INITIAL ENTRY
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPICNTL   PPILINK   PPIATP1E
*        PPICONV   PPIADSSC
*        PPISLIB   PPIALG
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        ALL LOCATIONS FROM PPIALG THROUGH PPIX16 MAY BE LOADED
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL -
*        IERRC9 - NEXT MODULE IN SEQUENCE OF OPERATION
*
*        EXITS - ERROR -
*        IERRCV - TO TERMINATE JOB ON DELETE ERROR
*
*        TABLES/WORK AREAS -
*        PH1RTAB  - MASKS FOR ALL PHASE 1 RUNNING MODULES (ALSO
*                   OSCILLATING PHASE 2 MODULES)
*        PH1ATAB  - MASKS FOR ALL PHASE 1 ASSIGNMENT MODULES
*                   (ALSO OSCILLATING PHASE 2 MODULES)
*        WASMTLST - 60 BYTE AREA WHERE THE ASSIGNMENT MODULE
*                   LOAD LIST IS AMASSED
*        WSWITCH  - 4 BYTE AREA WHERE INFORMATION ABOUT THE SORT
*                   IS ACCUMULATED
*        WLINK    - HALF WORD AREA WHERE INFORMATION ABOUT
*                   PRE LINK EDITED USER MODS IS ACCUMULATED
*
*        NOTES -
*        THIS MODULE IS USED TO SELECT THE MODULES AND USER
*        MODIFICATION PROGRAMS FOR PHASE 1 OF ALL SORTS. IT ALSO
*        SELECTS THE MERGE PHASE MODULES FOR OSCILLATING AND
*        CRCX SORTS
*
IERRC6   CSECT
*
         USING *,R11               MODULE BASE REGISTER
         USING IERRCA,R13          PPI BASE REGISTER
*
         IERENTRY 'IERRC6 &SYSDATE &SYSTIME'
*
         LR    R11,R15             SET MODULE BASE REGISTER
*
*        COPY FLAG DATA FROM PPICNTL INTO WSWITCH
*        TO GENERATE MODULE SELECTION MASK
*
*        WSWITCH FLAG DEFINITIONS -
*
*        BITS 1-6 ARE THE SAME AS BITS 1-6 OF PPICNTL
*        BIT  7 = EITHER OSCILLATING OR CRCX
*        BITS 8-11 AND 13-24 ARE THE SAME AS BITS 8-11
*                            AND 13-24 IN PPICNTL
*        BIT 12 = NOT USED
*        BIT 13 = VAR SPANNED/UNSPANNED, FIXED INPUT
*        BIT 25 = E15 AND E16 NOT ACTIVE
*        BIT 26 = E15 OR E16 ACTIVE
*        BIT 27 = NOT POLYPHASE
*        BIT 28 = NOT OSCILLATING
*        BIT 29 = E25 NOT ACTIVE
*        BIT 30 = DRUM - FROM PPICNTL BIT 54
*        BIT 31 = E25 ACTIVE
*        BIT 32 = NOT 2314
*
RC6001   MVC   WSWITCH(3),PPICNTL  GET FIRST 3 BYTES OF PPICNTL
         PPITEST  PPI2314          CRCX ?
         BZ    RC6OSCIL            NO, GO CHECK FOR OSCILLATING
         OI    WSWITCH,X'02'       YES, TURN ON OSCIL/CRCX BIT
         OI    WSWITCH+3,X'30'     TURN ON NOT OSC / NOT POLY BITS
         B     RC6EX25             GO CHECK E25 BITS
*
RC6OSCIL OI    WSWITCH+3,X'01'     TURN ON NOT CRCX BIT
         PPITEST  PPIOSC           OSCILLATING ?
         BO    RC6NOTP             YES, IT CAN'T BE POLY
         OI    WSWITCH+3,X'10'     NO, TURN ON NOT OSCILLATING BIT
         PPITEST  PPIPOLY          POLYPHASE ?
         BO    RC6EX25             YES, GO CHECK E25 BITS
RC6NOTP  OI    WSWITCH+3,X'20'     NO, TURN ON NOT POLYPHASE BIT
RC6EX25  PPITEST  PPIME25          E25 ACTIVE ?
         BO    RC625YES            YES BRANCH
         OI    WSWITCH+3,X'08'     NO, SET E25 NOT ACTIVE BIT
         B     RC6EX15             SKIP ONE INSTRUCTION
*
RC625YES OI    WSWITCH+3,X'02'     SET E25 ACTIVE BIT
RC6EX15  PPITEST  PPIME15+PPIME16  E15 OR E16 ACTIVE ?
         BNZ   RC615YES            BRANCH IF EITHER E15 OR E16 ACTIVE
         OI    WSWITCH+3,X'80'     NO, SET E15 AND E16 NOT ACTIVE BIT
         B     RC6VBS              CHECK VBS
*
RC615YES OI    WSWITCH+3,X'40'     SET E15 OR E16 ACTIVE BIT
RC6VBS   NI    WSWITCH+1,X'E7'
         OI    WSWITCH+1,X'08'     SET BIT 13 IF NOT VBS
         LA    R3,PH1RTAB          R3 -> PHASE 1 RUNNING LIST
         LA    R5,PPIALG           R5 -> PPIALG
RC6LOOP  ICM   R4,B'1111',4(R3)    LOAD MODULE MASK FROM PH1RTAB
         BZ    RC6RNDUN            TERMINATING ENTRY ? EXIT LOOP
         O     R4,WSWITCH          OR SWITCH SETTINGS INTO IT
         X     R4,KFFFF            CHECK FOR COND MET,IE R4 = ALL ONES
         BNZ   RC6LOOPA            NO, DO NOT WANT THIS MODULE
         SR    R4,R4               YES, SELECT THIS MODULE
         IC    R4,3(,R3)           GET PPI DISPLACEMENT FROM LIST
         AR    R4,R5               ADD DISPLACEMENT INTO PPIALG
         MVC   0(3,R4),0(R3)       MOVE IN THREE CHARACTER MODULE NAME
RC6LOOPA LA    R3,8(,R3)           UP POINTER TO NEXT MODULE
         B     RC6LOOP             LOOP UNTIL END OF LIST
*
*        CHECK FOR THE PRESENCE OF USER MODS AND MAKE UP THE
*        LOAD LIST ACCORDINGLY
*
RC6RNDUN ICM   R3,B'1111',PPIATP1E  SORT INVOKED ?
         BNZ   RC6SELAS            YES, BRANCH
         NC    KMODS(2),PPICNTL+12  ANY PHASE 1 EXITS ACTIVE ?
         BZ    RC6OSCHK            NO, BRANCH
         MVC   WLINK(2),PPICNTL+12  KLINK = ACTIVE EXITS
         XC    WLINK(2),PPILINK    KLINK NOW = ACTIVE - NOT LINK EDITED
*                                  EXITS
         TM    WLINK,PPIME11       E11 ?
         BZ    RC6E15              NO, CHECK NEXT BIT
         MVC   PPIX11(3),KE11      PUT E11 ON LOAD LIST
RC6E15   TM    WLINK,PPIME15       E15 ?
         BZ    RC6E16              NO, CHECK NEXT BIT
         MVC   PPIX15(3),KE15      PUT E15 ON LOAD LIST
RC6E16   TM    WLINK,PPIME16       E16 ?
         BZ    RC6E17              NO, CHECK NEXT BIT
         MVC   PPIX16(3),KE16      PUT E16 ON LOAD LIST
RC6E17   TM    WLINK,PPIME17       E17 ?
         BZ    RC6E18              NO, CHECK NEXT BIT
         MVC   PPIX17(3),KE17      PUT E17 ON LOAD LIST
RC6E18   TM    WLINK,PPIME18       E18 ?
         BZ    RC6E19              NO, CHECK NEXT BIT
         MVC   PPIX18(3),KE18      PUT E18 ON LOAD LIST
RC6E19   TM    WLINK+1,PPIME19     E19 ?
         BZ    RC6E61              NO, CHECK NEXT BIT
         MVC   PPIX19(3),KE19      PUT E19 ON LOAD LIST
RC6E61   TM    WLINK+1,PPIME61     E61 ?
         BZ    RC6S11              NO, CHECK FOR S11
         MVC   PPIX61(3),KE61      PUT E61 ON LOAD LIST
RC6S11   TM    PPILINK+2,X'40'     S11 ON ?
         BZ    RC6PH1              NO, CHECK FOR PH1
         MVC   PPIX11(3),KS11      PUT S11 ON LOAD LIST
RC6PH1   NC    KUSER(2),PPILINK    LINK EDIT A PH1 ?
         BZ    RC6OSCHK            NO, DONE WITH PHASE 1 EXITS
         LA    R4,PPIX11           LOAD POINTER
RC6LOOP2 ICM   R5,B'1111',0(R4)    THIS LOCATION EMPTY ?
         BZ    RC6MT               YES, PUT PH1 HERE
         LA    R4,16(,R4)          UP POINTER
         LA    R5,PPIX16           LOAD END OF LIST ADDR
         CR    R4,R5               BEYOND END OF LIST ?
         BL    RC6LOOP2            NO, CONTINUE SEARCH
         MVC   PPIX16(3),KPH1      LOAD PH1 HERE - IT HAS TO BE EMPTY
         B     RC6OSCHK            DONE WITH PHASE 1 EXITS
*
RC6MT    L     R5,KPH1             GET 'PH1'
         ST    R5,0(,R4)           LOAD PH1 HERE - IT WAS EMPTY
*
*        CHECK FOR EITHER OSCILLATING OR CRCX - IF YES, LOAD
*        IERRC7 TO GET PHASE 2 USER EXIT LOAD LIST MADE UP
*
RC6OSCHK PPITEST  PPI2314          CRCX SORT ?
         BO    RC6TORC7            YES, GOTO RC7
         PPITEST  PPIOSC           OSCILLATING SORT ?
         BZ    RC6SELAS            NO, GO SELECT ASSIGNMENT MODULES
RC6TORC7 NC    KMODSPH2(2),PPICNTL+12  ANY PHASE 2 EXITS ACTIVE ?
         BZ    RC6SELAS            NO, BRANCH
         L     R1,PPISLIB          R1 -> SORTLIB
*
         LOAD  EP=IERRC7,DCB=(1)   LOAD IERRC7
*
         LR    R15,R0              R15 -> IERRC7
         BASR  R14,R15             CALL IERRC7
*
*        NOTE - RC7 MUST MAINTAIN THE INTEGRITY OF R11
*
         DELETE EP=IERRC7
*
         LTR   R15,R15             DELETE SUCCESSFUL ?
         BZ    RC6SELAS            YES, BRANCH
         L     R15,PPIADSSC        NO, LOAD PRINT ROUTINE ADDR
         BAS   R14,28(,R15)        CALL TO PRINT MESSAGE
         L     R15,PPIADSSC        LOAD ADDR FOR A TERMINATION
         BAS   R14,16(,R15)        GO TERMINATE THE JOB, NO RETURN
*
RC6SELAS LA    R2,WASMTLST         R2 -> START OF ASMT LIST
         LA    R4,PH1ATAB          R4 -> START OF MODULE MASK LIST
RC6LOOP3 ICM   R5,B'1111',4(R4)    LOAD MODULE MASK
         BZ    RC6ASDON            TERMINATING ENTRY ? EXIT LOOP
         O     R5,WSWITCH          OR IT WITH SWITCH SETTINGS
         X     R5,KFFFF            CHECK FOR COND MET, IE R5 = ALL ONES
         BNZ   RC6CONT             NO, DO NOT WANT THIS MODULE
         MVC   0(3,R2),0(R4)       MOVE THREE CHARS INTO ASMT LD LIST
         LA    R2,3(,R2)           UP WASMTLST POINTER BY THREE
RC6CONT  LA    R4,8(,R4)           UP PH1ATAB POINTER TO NEXT MODULE
         B     RC6LOOP3            LOOP UNTIL END OF ASMT LOAD LIST
*
*        LOAD IERRC9
*        IF DIAGNOSTICS ARE SPECIFIED IER988 WILL BE GENERATED
*        BEFORE BRANCHING TO IERRC9
*
RC6ASDON L     R1,PPISLIB          R1 -> SORTLIB
*
         LOAD  EP=IERRC9,DCB=(1)
*
         ST    R0,AIERRC9          SAVE ADDR OF IERRC9
         PPITEST  PPITMODF         MODULE FLOW DIAGNOSTICS ?
         BNO   RC6EXIT             NO, EXIT TO RC9
         PPITEST  PPIDIAG+PPIDSIM  GENERATE DIAGNOSTIC MESSAGES ?
         BNO   RC6EXIT             NO, EXIT TO RC9
         L     R15,PPICONV+4       LOAD CONVERT ROUTINE ADDR
         BAS   R14,4(,R15)         LINK TO CONVERT ROUTINE
         MVC   IER988B,2(R1)       MOVE HEX FORMATTED ADDR TO MESSAGE
         MVI   IER988A+2,C'9'      CHANGE NAME TO IERRC9
         LM    R0,R1,IER988        IER988I - IERRC9 AT LOC XXXXXX
         L     R15,PPIADSSC        R15 -> SSC
         BAS   R14,12(,R15)        LINK TO MSG WRITER
*
*        EXIT TO IERRC9
*
RC6EXIT  LA    R0,KIERRC6          R0 -> 'IERRC6 '
         LA    R2,WASMTLST         R2 -> ASSIGNMENT LIST
         L     R15,AIERRC9         R15 -> IERRC9
         BR    R15                 EXIT TO RC9 - IT WILL DELETE RC6
*
*        PH1RTAB
*
*        TABLE OF MASKS FOR ALL PHASE 1 RUNNING MODULES
*
*        IT ALSO CONTAINS MASKS FOR PHASE 2 RUNNING MODULES USED
*        IN AN OSCILLATING AND/OR CRCX SORT. THE FOURTH BYTE OF
*        EACH ENTRY IS THE DISPLACEMENT FROM PPIALG WHERE THE
*        LAST THREE CHARACTERS OF THAT MODULE NAME IS PLACED. ALL
*        MODULES ARE FOR PHASE 1 EXCEPT THOSE FOR THE
*        OSCILLATING AND/OR CRCX MERGE PHASES, WHICH ARE SO
*        INDICATED
*
PH1RTAB  DC    0F'0'
*
*        IERAMA - MESSAGE MODULE FOR ASSIGNMENT MODULES
*
         DC    CL3'AMA'            MODULE NAME
         DC    XL1'78'             DISPLACEMENT
         DC    XL4'FFFFFFFF'       MASK - ALWAYS LOADED
*
*        IERAP1 - ASSIGNMENT AREA FOR OPEN PARAMETER LIST
*
         DC    CL3'AP1'            MODULE NAME
         DC    XL1'88'             DISPLACEMENT
         DC    XL4'FFFFFFFF'       MASK - ALWAYS LOADED
*
*        IERRMA - MESSAGE MODULE FOR RUNNING MODULES
*
         DC    CL3'RMA'            MODULE NAME
         DC    XL1'68'             DISPLACEMENT
         DC    XL4'FFFFFFFF'       MASK - ALWAYS LOADED
*
*        IERRGA - INPUT END OF FILE MODULE
*
         DC    CL3'RGA'            MODULE NAME
         DC    XL1'60'             DISPLACEMENT
         DC    XL4'FFFFFFFF'       MASK - ALWAYS LOADED
*
*        IERROA - SORT NETWORK FOR FIXED LENGTH RECORDS
*                 MULTI CF - NOT POLYPHASE
*
         DC    CL3'ROA'            MODULE NAME
         DC    XL1'10'             DISPLACEMENT
         DC    XL4'6FFFFFDF'       MASK
*
*        IERROB - SORT NETWORK FOR FIXED LENGTH RECORDS
*                 SINGLE CF - NOT POLYPHASE
*
         DC    CL3'ROB'            MODULE NAME
         DC    XL1'10'             DISPLACEMENT
         DC    XL4'5FFFFFDF'       MASK
*
*        IERROC - SORT NETWORK FOR VARIABLE LENGTH RECORDS
*                 MULTI CF - NOT POLYPHASE
*
         DC    CL3'ROC'            MODULE NAME
         DC    XL1'10'             DISPLACEMENT
         DC    XL4'AFFFFFDF'       MASK
*
*        IERROD - SORT NETWORK FOR VARIABLE LENGTH RECORDS
*                 SINGLE CF - NOT POLYPHASE
*
         DC    CL3'ROD'            MODULE NAME
         DC    XL1'10'             DISPLACEMENT
         DC    XL4'9FFFFFDF'       MASK
*
*        IERROE - SORT NETWORK FOR FIXED LENGTH RECORDS
*                 MULTI CF - POLYPHASE
*
         DC    CL3'ROE'            MODULE NAME
         DC    XL1'10'             DISPLACEMENT
         DC    XL4'6BFFFFFF'       MASK
*
*        IERROF - SORT NETWORK FOR FIXED LENGTH RECORDS
*                 SINGLE CF - POLYPHASE
*
         DC    CL3'ROF'            MODULE NAME
         DC    XL1'10'             DISPLACEMENT
         DC    XL4'5BFFFFFF'       MASK
*
*        IERROG - SORT NETWORK FOR VARIABLE LENGTH RECORDS
*                 MULTI CF - POLYPHASE
*
         DC    CL3'ROG'            MODULE NAME
         DC    XL1'10'             DISPLACEMENT
         DC    XL4'ABFFFFFF'       MASK
*
*        IERROH - SORT NETWORK FOR VARIABLE LENGTH RECORDS
*                 SINGLE CF - POLYPHASE
*
         DC    CL3'ROH'            MODULE NAME
         DC    XL1'10'             DISPLACEMENT
         DC    XL4'9BFFFFFF'       MASK
*
*        IERROI - BALANCED TAPE SORT ALGORITHM
*
         DC    CL3'ROI'            MODULE NAME
         DC    XL1'0'              DISPLACEMENT
         DC    XL4'F7BFFFFF'       MASK
*
*        IERROJ - POLYPHASE TAPE SORT ALGORITHM
*
         DC    CL3'ROJ'            MODULE NAME
         DC    XL1'0'              DISPLACEMENT
         DC    XL4'FBBFFFFF'       MASK
*
*        IERROK - DISK BALN SORT ALGORITHM
*
         DC    CL3'ROK'            MODULE NAME
         DC    XL1'0'              DISPLACEMENT
         DC    XL4'F7DFFFFF'       MASK
*
*        IERRON - OSCILLATING SORT ALGORITHM
*
         DC    CL3'RON'            MODULE NAME
         DC    XL1'0'              DISPLACEMENT
         DC    XL4'FDFFFFFE'       MASK
*
*        IER8ON - CRCX SORT ALGORITHM
*
         DC    CL3'8ON'            MODULE NAME
         DC    XL1'0'              DISPLACEMENT
         DC    XL4'FDFFFFEF'       MASK
*
*        IERROO - DRUM SORT ALGORITHM - NOT SUPPORTED
*
*        DC    CL3'ROO'            MODULE NAME
*        DC    XL1'0'              DISPLACEMENT
*        DC    XL4'FFFFFFFB'       MASK
*
*        IERROP - MERGE NETWORK FOR MULTI CF
*                 9 TO 16 WAY OSCILLATING PHASE 2
*
         DC    CL3'ROP'            MODULE NAME
         DC    XL1'40'             DISPLACEMENT
         DC    XL4'ED7FFFFF'       MASK
*
*        IERROQ - MERGE NETWORK FOR SINGLE CF
*                 9 TO 16 WAY OSCILLATING PHASE 2
*
         DC    CL3'ROQ'            MODULE NAME
         DC    XL1'40'             DISPLACEMENT
         DC    XL4'DD7FFFFF'       MASK
*
*        IERROU - MERGE NETWORK FOR MULTI CF
*                 1 TO 8 WAY OSCILLATING PHASE 2
*
         DC    CL3'ROU'            MODULE NAME
         DC    XL1'40'             DISPLACEMENT
         DC    XL4'ECFFFFFF'       MASK
*
*        IERROV - MERGE NETWORK FOR SINGLE CF
*                 1 TO 8 WAY OSCILLATING PHASE 2
*
         DC    CL3'ROV'            MODULE NAME
         DC    XL1'40'             DISPLACEMENT
         DC    XL4'DCFFFFFF'       MASK
*
*        IERROW - INIT SORT NETWORK FIXED LENGTH RECORDS
*                 MULTI CF - OSCILLATING
*
         DC    CL3'ROW'            MODULE NAME
         DC    XL1'50'             DISPLACEMENT
         DC    XL4'6DFFFFFF'       MASK
*
*        IERROX - INIT SORT NETWORK FIXED LENGTH RECORDS
*                 SINGLE CF - OSCILLATING
*
         DC    CL3'ROX'            MODULE NAME
         DC    XL1'50'             DISPLACEMENT
         DC    XL4'5DFFFFFF'       MASK
*
*        IERROY - INIT SORT NETWORK VARIABLE LENGTH RECORDS
*                 MULTI CF - OSCILLATING
*
         DC    CL3'ROY'            MODULE NAME
         DC    XL1'50'             DISPLACEMENT
         DC    XL4'ADFFFFFF'       MASK
*
*        IERROZ - INIT SORT NETWORK VARIABLE LENGTH RECORDS
*                 SINGLE CF - OSCILLATING
*
         DC    CL3'ROZ'            MODULE NAME
         DC    XL1'50'             DISPLACEMENT
         DC    XL4'9DFFFFFF'       MASK
*
*        IERAMB - MESSAGE MODULE FOR ASSIGNMENT MODULES IN PHASE 2
*
         DC    CL3'AMB'            MODULE NAME
         DC    XL1'80'             DISPLACEMENT
         DC    XL4'FDFFFFFF'       MASK
*
*        IERRMB - MESSAGE MODULE FOR RUNNING MODULES IN PHASE 2
*
         DC    CL3'RMB'            MODULE NAME
         DC    XL1'70'             DISPLACEMENT
         DC    XL4'FDFFFFFF'       MASK
*
*        IERRDB - DEBLOCK FIXED LENGTH RECORDS < 257
*                 NOT OSCILLATING - NO EXITS ACTIVE
*
         DC    CL3'RDB'            MODULE NAME
         DC    XL1'8'              DISPLACEMENT
         DC    XL4'7FFF7F6E'       MASK
*
*        IERRDC - DEBLOCK FIXED LENGTH RECORDS > 256
*                 NOT OSCILLATING - NO EXITS ACTIVE
*
         DC    CL3'RDC'            MODULE NAME
         DC    XL1'8'              DISPLACEMENT
         DC    XL4'7FFFBF6E'       MASK
*
*        IERRDD - DEBLOCK FIXED LENGTH RECORDS
*                 NOT OSCILLATING - E15 OR E16 ACTIVE
*
         DC    CL3'RDD'            MODULE NAME
         DC    XL1'8'              DISPLACEMENT
         DC    XL4'7FFFFFAE'       MASK
*
*        IERRDE - DEBLOCK VARIABLE LENGTH RECORDS
*                 NOT OSCILLATING - E15 OR E16 ACTIVE
*
         DC    CL3'RDE'            MODULE NAME
         DC    XL1'8'              DISPLACEMENT
         DC    XL4'BFF7FFAE'       MASK
*
*        IER8DE - DEBLOCK VARIABLE LENGTH SPANNED RECORDS
*                 NOT OSCILLATING OR E16 ACTIVE
*
         DC    CL3'8DE'            MODULE NAME
         DC    XL1'8'              DISPLACEMENT
         DC    XL4'BFEFFFAE'       MASK
*
*        IERRDG - DEBLOCK VARIABLE LENGTH RECORDS
*                 NOT OSCILLATING - E15 AND E16 NOT ACTIVE
*
         DC    CL3'RDG'            MODULE NAME
         DC    XL1'8'              DISPLACEMENT
         DC    XL4'BFF7FF6E'       MASK
*
*        IER8DG - DEBLOCK VARIABLE LENGTH SPANNED RECORDS
*                 NOT OSCILLATING - E15 AND E16 NOT ACTIVE
*
         DC    CL3'8DG'            MODULE NAME
         DC    XL1'8'              DISPLACEMENT
         DC    XL4'BFEFFF6E'       MASK
*
*        IERRDP - DEBLOCK FIXED LENGTH RECORDS < 257
*                 OSCILLATING - NO EXITS ACTIVE
*
         DC    CL3'RDP'            MODULE NAME
         DC    XL1'8'              DISPLACEMENT
         DC    XL4'7DFF7F7F'       MASK
*
*        IERRDQ - DEBLOCK FIXED LENGTH RECORDS > 256
*                 OSCILLATING - NO EXITS ACTIVE
*
         DC    CL3'RDQ'            MODULE NAME
         DC    XL1'8'              DISPLACEMENT
         DC    XL4'7DFFBF7F'       MASK
*
*        IERRDR - DEBLOCK FIXED LENGTH RECORDS
*                 OSCILLATING - E15 OR E16 ACTIVE
*
         DC    CL3'RDR'            MODULE NAME
         DC    XL1'8'              DISPLACEMENT
         DC    XL4'7DFFFFBF'       MASK
*
*        IERRDS - DEBLOCK VARIABLE LENGTH RECORDS
*                 OSCILLATING - E15 OR E16 ACTIVE
*
         DC    CL3'RDS'            MODULE NAME
         DC    XL1'8'              DISPLACEMENT
         DC    XL4'BDF7FFBF'       MASK
*
*        IER8DS - DEBLOCK VARIABLE LENGTH SPANNED RECORDS
*                 OSCILLATING - E15 OR E16 ACTIVE
*
         DC    CL3'8DS'            MODULE NAME
         DC    XL1'8'              DISPLACEMENT
         DC    XL4'BDEFFFBF'       MASK
*
*        IERRDT - DEBLOCK VARIABLE LENGTH RECORDS
*                 OSCILLATING - E15 OR E16 NOT ACTIVE
*
         DC    CL3'RDT'            MODULE NAME
         DC    XL1'8'              DISPLACEMENT
         DC    XL4'BDF7FF7F'       MASK
*
*        IER8DT - DEBLOCK VARIABLE LENGTH SPANNED RECORDS
*                 OSCILLATING - E15 OR E16 NOT ACTIVE
*
         DC    CL3'8DT'            MODULE NAME
         DC    XL1'8'              DISPLACEMENT
         DC    XL4'BDEFFF7F'       MASK
*
*        IERRDL - DEBLOCK INIT MODULE FOR OSCILLATING
*
         DC    CL3'RDL'            MODULE NAME
         DC    XL1'38'             DISPLACEMENT
         DC    XL4'FDFFFFFF'       MASK
*
*        IERRBB - BLOCK MODULE FOR FIXED LENGTH RECORDS < 257
*                 NOT OSCILLATING
*
         DC    CL3'RBB'            MODULE NAME
         DC    XL1'18'             DISPLACEMENT
         DC    XL4'7FFF7FEE'       MASK
*
*        IERRBC - BLOCK MODULE FOR FIXED LENGTH RECORDS > 256
*                 NOT OSCILLATING
*
         DC    CL3'RBC'            MODULE NAME
         DC    XL1'18'             DISPLACEMENT
         DC    XL4'7FFFBFEE'       MASK
*
*        IERRBE - BLOCK MODULE FOR VARIABLE LENGTH RECORDS
*                 NOT OSCILLATING
*
         DC    CL3'RBE'            MODULE NAME
         DC    XL1'18'             DISPLACEMENT
         DC    XL4'BFFFFFEE'       MASK
*
*        IERRBF - VARIABLE LENGTH RECORD MOVE ROUTINE
*
         DC    CL3'RBF'            MODULE NAME
         DC    XL1'28'             DISPLACEMENT
         DC    XL4'BFFFFFFF'       MASK
*
*        IERRBA - BLOCK MODULE FOR VARIABLE LENGTH RECORDS
*                 OSCILLATING
*
         DC    CL3'RBA'            MODULE NAME
         DC    XL1'18'             DISPLACEMENT
         DC    XL4'BDFFFFFF'       MASK
*
*        IERRBY - BLOCK MODULE FOR FIXED LENGTH RECORDS < 257
*                 OSCILLATING
*
         DC    CL3'RBY'            MODULE NAME
         DC    XL1'18'             DISPLACEMENT
         DC    XL4'7DFF7FFF'       MASK
*
*        IERRBZ - BLOCK MODULE FOR FIXED LENGTH RECORDS > 256
*                 OSCILLATING
*
         DC    CL3'RBZ'            MODULE NAME
         DC    XL1'18'             DISPLACEMENT
         DC    XL4'7DFFBFFF'       MASK
*
*        IERRBT - BLOCK/DEBLOCK FOR FIXED LENGTH RECORDS < 257
*                 OSCILLATING - NO E25 - PHASE 2
*
         DC    CL3'RBT'            MODULE NAME
         DC    XL1'48'             DISPLACEMENT
         DC    XL4'7DFF7FF7'       MASK
*
*        IERRBU - BLOCK/DEBLOCK FOR FIXED LENGTH RECORDS < 257
*                 OSCILLATING - NO E25 - PHASE 2
*
         DC    CL3'RBU'            MODULE NAME
         DC    XL1'48'             DISPLACEMENT
         DC    XL4'7DFFBFF7'       MASK
*
*        IERRBV - BLOCK/DEBLOCK FOR VARIABLE LENGTH RECORDS
*                 OSCILLATING - NO E25 - PHASE 2
*
         DC    CL3'RBV'            MODULE NAME
         DC    XL1'48'             DISPLACEMENT
         DC    XL4'BDFFFFF7'       MASK
*
*        IERRBW - BLOCK/DEBLOCK FOR FIXED LENGTH RECORDS
*                 OSCILLATING - E25 ACTIVE - PHASE 2
*
         DC    CL3'RBW'            MODULE NAME
         DC    XL1'48'             DISPLACEMENT
         DC    XL4'7DFFFFFD'       MASK
*
*        IERRBX - BLOCK/DEBLOCK FOR VARIABLE LENGTH RECORDS
*                 OSCILLATING - E25 ACTIVE - PHASE 2
*
         DC    CL3'RBX'            MODULE NAME
         DC    XL1'48'             DISPLACEMENT
         DC    XL4'BDFFFFFD'       MASK
*
*        IERRPA - WRITE TAPE MODULE
*
         DC    CL3'RPA'            MODULE NAME
         DC    XL1'20'             DISPLACEMENT
         DC    XL4'FFBFFFFF'       MASK
*
*        IER8PA - WRITE CRCX MODULE
*
         DC    CL3'8PA'            MODULE NAME
         DC    XL1'20'             DISPLACEMENT
         DC    XL4'FDFFFFEF'       MASK
*
*        IERRPB - WRITE DISK MODULE
*
         DC    CL3'RPB'            MODULE NAME
         DC    XL1'20'             DISPLACEMENT
         DC    XL4'FFDFFFFF'       MASK
*
*        IERRPN - WRITE DRUM MODULE
*
*        DC    CL3'RPN'            MODULE NAME
*        DC    XL1'20'             DISPLACEMENT
*        DC    XL4'FFFFFFFB'       MASK
*
*        IERRGB - READ ROUTINE
*                 OSCILLATING - PHASE 2
*
         DC    CL3'RGB'            MODULE NAME
         DC    XL1'30'             DISPLACEMENT
         DC    XL4'FDFFFFFE'       MASK
*
*        IER8GB - READ ROUTINE FOR CRCX
*
         DC    CL3'8GB'            MODULE NAME
         DC    XL1'30'             DISPLACEMENT
         DC    XL4'FDFFFFEF'       MASK
*
*        PH1RTAB TERMINATING ENTRY
*
         DC    CL3'XXX'            MODULE NAME
         DC    XL1'00'             DISPLACEMENT
         DC    XL4'00000000'       MASK
*
*        PH1ATAB
*
*        TABLE OF MASKS FOR ALL PHASE 1 ASSIGNMENT MODULES
*
*        IT ALSO CONTAINS MASKS FOR PHASE 2 ASSIGNMENT MODULES
*        USED IN AN OSCILLATING AND/OR CRCX SORT. THE MODULE
*        MASKS ARE IN THE ORDER THAT THE MODULES WILL BE
*        EXECUTED
*
PH1ATAB  DC    0F'0'
*
*        IERAPG - ALLOCATE STORAGE EXCEPT FOR OSCILLATING AND CRCX
*
         DC    CL4'APG '           MODULE NAME
         DC    XL4'FFFFFFEE'       MASK
*
*        IERAPL - ALLOCATE STORAGE FOR OSCILLATING AND CRCX
*
         DC    CL4'APL '           MODULE NAME
         DC    XL4'FDFFFFFF'       MASK
*
*        IERAOA - SORT NETWORK FOR FIXED LENGTH RECORDS
*                 MULTI CF - NOT POLYPHASE
*
         DC    CL4'AOA '           MODULE NAME
         DC    XL4'6FFFFFDF'       MASK
*
*        IERAOB - SORT NETWORK FOR FIXED LENGTH RECORDS
*                 SINGLE CF - NOT POLYPHASE
*
         DC    CL4'AOB '           MODULE NAME
         DC    XL4'5FFFFFDF'       MASK
*
*        IERAOC - SORT NETWORK FOR VARIABLE LENGTH RECORDS
*                 MULTI CF - NOT POLYPHASE
*
         DC    CL4'AOC '           MODULE NAME
         DC    XL4'AFFFFFDF'       MASK
*
*        IERAOD - SORT NETWORK FOR VARIABLE LENGTH RECORDS
*                 SINGLE CF - NOT POLYPHASE
*
         DC    CL4'AOD '           MODULE NAME
         DC    XL4'9FFFFFDF'       MASK
*
*        IERAOE - SORT NETWORK FOR FIXED LENGTH RECORDS
*                 MULTI CF - POLYPHASE
*
         DC    CL4'AOE '           MODULE NAME
         DC    XL4'6BFFFFFF'       MASK
*
*        IERAOF - SORT NETWORK FOR FIXED LENGTH RECORDS
*                 SINGLE CF - POLYPHASE
*
         DC    CL4'AOF '           MODULE NAME
         DC    XL4'5BFFFFFF'       MASK
*
*        IERAOG - SORT NETWORK FOR VARIABLE LENGTH RECORDS
*                 MULTI CF - POLYPHASE
*
         DC    CL4'AOG '           MODULE NAME
         DC    XL4'ABFFFFFF'       MASK
*
*        IERAOH - SORT NETWORK FOR VARIABLE LENGTH RECORDS
*                 SINGLE CF - POLYPHASE
*
         DC    CL4'AOH '           MODULE NAME
         DC    XL4'9BFFFFFF'       MASK
*
*        IERAOW - INIT SORT NETWORK FIXED LENGTH RECORDS
*                 MULTI CF - OSCILLATING
*
         DC    CL4'AOW '           MODULE NAME
         DC    XL4'6DFFFFFF'       MASK
*
*        IERAOX - INIT SORT NETWORK FIXED LENGTH RECORDS
*                 SINGLE CF - OSCILLATING
*
         DC    CL4'AOX '           MODULE NAME
         DC    XL4'5DFFFFFF'       MASK
*
*        IERAOY - INIT SORT NETWORK VARIABLE LENGTH RECORDS
*                 MULTI CF - OSCILLATING
*
         DC    CL4'AOY '           MODULE NAME
         DC    XL4'ADFFFFFF'       MASK
*
*        IERAOZ - INIT SORT NETWORK VARIABLE LENGTH RECORDS
*                 SINGLE CF - OSCILLATING
*
         DC    CL4'AOZ '           MODULE NAME
         DC    XL4'9DFFFFFF'       MASK
*
*        IERABS - MOVE GENERATOR FOR FIXED LENGTH RECORDS
*
         DC    CL4'ABS '           MODULE NAME
         DC    XL4'7FFFFFFF'       MASK
*
*        IERABF - VARIABLE LENGTH RECORD MOVE ROUTINE
*
         DC    CL4'ABF '           MODULE NAME
         DC    XL4'BFFFFFFF'       MASK
*
*        IERABR - PHASE 2 MOVE GENERATOR FIXED LENGTH RECORDS
*                 OSCILLATING - E25 ACTIVE
*
         DC    CL4'ABR '           MODULE NAME
         DC    XL4'7DFFFFFD'       MASK
*
*        IERABR - USED IF FIXED LENGTH RECORDS > 256
*                 EVEN IF E25 IS NOT ACTIVE
*
         DC    CL4'ABR '           MODULE NAME
         DC    XL4'7DFFBFF7'       MASK
*
*        IERABB - BLOCK FIXED LENGTH RECORDS < 257
*                 NOT OSCILLATING
*
         DC    CL4'ABB '           MODULE NAME
         DC    XL4'7FFF7FEE'       MASK
*
*        IERABC - BLOCK FIXED LENGTH RECORDS > 256
*                 NOT OSCILLATING
*
         DC    CL4'ABC '           MODULE NAME
         DC    XL4'7FFFBFEE'       MASK
*
*        IERABE - BLOCK VARIABLE LENGTH RECORDS
*                 NOT OSCILLATING
*
         DC    CL4'ABE '           MODULE NAME
         DC    XL4'BFFFFFEE'       MASK
*
*        IERABZ - BLOCK FIXED LENGTH RECORDS > 256
*                 OSCILLATING
*
         DC    CL4'ABZ '           MODULE NAME
         DC    XL4'7DFFBFFF'       MASK
*
*        IERABY - BLOCK FIXED LENGTH RECORDS < 257
*                 OSCILLATING
*
         DC    CL4'ABY '           MODULE NAME
         DC    XL4'7DFF7FFF'       MASK
*
*        IERABA - BLOCK VARIABLE LENGTH RECORDS
*                 OSCILLATING
*
         DC    CL4'ABA '           MODULE NAME
         DC    XL4'BDFFFFFF'       MASK
*
*        IERAON - OSCILLATING ALGORITHM
*
         DC    CL4'AON '           MODULE NAME
         DC    XL4'FDFFFFFE'       MASK
*
*        IER9ON - CRCX ALGORITHM
*
         DC    CL4'9ON '           MODULE NAME
         DC    XL4'FDFFFFEF'       MASK
*
*        IERAOI - BALANCED TAPE ALGORITHM
*
         DC    CL4'AOI '           MODULE NAME
         DC    XL4'F7BFFFFF'       MASK
*
*        IERAOJ - POLYPHASE TAPE ALGORITHM
*
         DC    CL4'AOJ '           MODULE NAME
         DC    XL4'FBBFFFFF'       MASK
*
*        IERAOK - BALANCED DISK ALGORITHM
*
         DC    CL4'AOK '           MODULE NAME
         DC    XL4'F7DFFFFF'       MASK
*
*        IERAOO - DRUM ALGORTIHM - NOT SUPPORTED
*
*        DC    CL4'AOO '           MODULE NAME
*        DC    XL4'FFFFFFFB'       MASK
*
*        IERABT - BLOCK/DEBLOCK FIXED LENGTH RECORDS < 257
*                 OSCILLATING - E25 NOT ACTIVE
*
         DC    CL4'ABT '           MODULE NAME
         DC    XL4'7DFF7FF7'       MASK
*
*        IERABU - BLOCK/DEBLOCK FIXED LENGTH RECORDS > 256
*                 OSCILLATING - E25 NOT ACTIVE
*
         DC    CL4'ABU '           MODULE NAME
         DC    XL4'7DFFBFF7'       MASK
*
*        IERABV - BLOCK/DEBLOCK VARIABLE LENGTH RECORDS
*                 OSCILLATING - E25 NOT ACTIVE
*
         DC    CL4'ABV '           MODULE NAME
         DC    XL4'BDFFFFF7'       MASK
*
*        IERABW - BLOCK/DEBLOCK FIXED LENGTH RECORDS
*                 OSCILLATING - E25 ACTIVE
*
         DC    CL4'ABW '           MODULE NAME
         DC    XL4'7DFFFFFD'       MASK
*
*        IERABX - BLOCK/DEBLOCK VARIABLE LENGTH RECORDS
*                 OSCILLATING - E25 ACTIVE
*
         DC    CL4'ABX '           MODULE NAME
         DC    XL4'BDFFFFFD'       MASK
*
*        IERADL - DEBLOCK INITIALIZATION FOR OSCILLATING
*
         DC    CL4'ADL '           MODULE NAME
         DC    XL4'FDFFFFFF'       MASK
*
*        IERAGN - DCB GENERATION FOR OSCILLATING
*
         DC    CL4'AGN '           MODULE NAME
         DC    XL4'FDFFFFFE'       MASK
*
*        IER9GN - DCB GENERATION FOR CRCX
*
         DC    CL4'9GN '           MODULE NAME
         DC    XL4'FDFFFFEF'       MASK
*
*        IERAGA - DCB GENERATION - TAPE
*                 NOT OSCILLATING
*
         DC    CL4'AGA '           MODULE NAME
         DC    XL4'FFBFFFEF'       MASK
*
*        IERAGI - DCB GENERATION - DISK
*
         DC    CL4'AGI '           MODULE NAME
         DC    XL4'FFDFFFFF'       MASK
*
*        IERAGI - DRUM
*
*        DC    CL4'AGI '           MODULE NAME
*        DC    XL4'FFFFFFFB'       MASK
*
*        IERAPA - WRITE TAPE
*
         DC    CL4'APA '           MODULE NAME
         DC    XL4'FFBFFFFF'       MASK
*
*        IER9PA - WRITE CRCX
*
         DC    CL4'9PA '           MODULE NAME
         DC    XL4'FDFFFFEF'       MASK
*
*        IERAPB - WRITE DISK
*
         DC    CL4'APB '           MODULE NAME
         DC    XL4'FFDFFFFF'       MASK
*
*        IERAPN - WRITE DRUM
*
*        DC    CL4'APN '           MODULE NAME
*        DC    XL4'FFFFFFFB'       MASK
*
*        IERAOP - MERGE NETWORK
*                 MULTI CF 9 TO 16 WAY - OSCILLATING
*
         DC    CL4'AOP '           MODULE NAME
         DC    XL4'ED7FFFFF'       MASK
*
*        IERAOQ - MERGE NETWORK
*                 SINGLE CF 9 TO 16 WAY - OSCILLATING
*
         DC    CL4'AOQ '           MODULE NAME
         DC    XL4'DD7FFFFF'       MASK
*
*        IERAOU - MERGE NETWORK
*        MULTI CF 1 TO 8 WAY - OSCILLATING
*
         DC    CL4'AOU '           MODULE NAME
         DC    XL4'ECFFFFFF'       MASK
*
*        IERAOV - MERGE NETWORK
*        SINGLE CF 1 TO 8 WAY - OSCILLATING
*
         DC    CL4'AOV '           MODULE NAME
         DC    XL4'DCFFFFFF'       MASK
*
*        IERAGB - INITIALIZATION OF THE READ ROUTINE
*                 OSCILLATING
*
         DC    CL4'AGB '           MODULE NAME
         DC    XL4'FDFFFFFE'       MASK
*
*        IER9GB - INITIALIZATION OF THE READ ROUTINE - CRCX
*
         DC    CL4'9GB '           MODULE NAME
         DC    XL4'FDFFFFEF'       MASK
*
*        IERADB - DEBLOCK FIXED LENGTH RECORDS < 257
*                 NOT OSCILLATING NO EXITS
*
         DC    CL4'ADB '           MODULE NAME
         DC    XL4'7FFF7F6E'       MASK
*
*        IERADC - DEBLOCK FIXED LENGTH RECORDS > 256
*                 NOT OSCILLATING NO EXITS
*
         DC    CL4'ADC '           MODULE NAME
         DC    XL4'7FFFBF6E'       MASK
*
*        IERADD - DEBLOCK FIXED LENGTH RECORDS
*                 NOT OSCILLATING E15 OR E16 ACTIVE
*
         DC    CL4'ADD '           MODULE NAME
         DC    XL4'7FFFFFAE'       MASK
*
*        IERADE - DEBLOCK VARIABLE LENGTH RECORDS
*                 NOT OSCILLATING E15 OR E16 ACTIVE
*
         DC    CL4'ADE '           MODULE NAME
         DC    XL4'BFF7FFAE'       MASK
*
*        IER9DE - DEBLOCK VARIABLE LENGTH SPANNED RECORDS
*                 NOT OSCILLATING E15 OR E16 ACTIVE
*
         DC    CL4'9DE '           MODULE NAME
         DC    XL4'BFEFFFAE'       MASK
*
*        IERADG - DEBLOCK VARIABLE LENGTH RECORDS
*                 NOT OSCILLATING E15 OR E16 NOT ACTIVE
*
         DC    CL4'ADG '           MODULE NAME
         DC    XL4'BFF7FF6E'       MASK
*
*        IER9DG - DEBLOCK VARIABLE LENGTH SPANNED RECORDS
*                 NOT OSCILLATING E15 OR E16 NOT ACTIVE
*
         DC    CL4'9DG '           MODULE NAME
         DC    XL4'BFEFFF6E'       MASK
*
*        IERADP - DEBLOCK  FIXED LENGTH RECORDS < 257
*                 OSCILLATING E15 OR E16 NOT ACTIVE
*
         DC    CL4'ADP '           MODULE NAME
         DC    XL4'7DFF7F7F'       MASK
*
*        IERADQ - DEBLOCK FIXED LENGTH RECORDS > 256
*                 OSCILLATING E15 OR E16 NOT ACTIVE
*
         DC    CL4'ADQ '           MODULE NAME
         DC    XL4'7DFFBF7F'       MASK
*
*        IERADR - DEBLOCK FIXED LENGTH RECORDS
*                 OSCILLATING E15 OR E16 ACTIVE
*
         DC    CL4'ADR '           MODULE NAME
         DC    XL4'7DFFFFBF'       MASK
*
*        IERADS - DEBLOCK VARIABLE LENGTH RECORDS
*                 OSCILLATING E15 OR E16 ACTIVE
*
         DC    CL4'ADS '           MODULE NAME
         DC    XL4'BDF7FFBF'       MASK
*
*        IER9DS - DEBLOCK VARIABLE LENGTH SPANNED RECORDS
*                 OSCILLATING E15 OR E16 ACTIVE
*
         DC    CL4'9DS '           MODULE NAME
         DC    XL4'BDEFFFBF'       MASK
*
*        IERADT - DEBLOCK VARIABLE LENGTH RECORDS
*                 OSCILLATING E15 OR E16 NOT ACTIVE
*
         DC    CL4'ADT '           MODULE NAME
         DC    XL4'BDF7FF7F'       MASK
*
*        IER9DT - DEBLOCK VARIABLE LENGTH SPANNED RECORDS
*                 OSCILLATING E15 OR E16 NOT ACTIVE
*
         DC    CL4'9DT '           MODULE NAME
         DC    XL4'BDEFFF7F'       MASK
*
*        IERAPC - OPEN ROUTINE
*
         DC    CL4'APC '           MODULE NAME
         DC    XL4'FFFFFFFF'       MASK
*
*        IERADM - SKIP RECORD ROUTINE
*
         DC    CL4'ADM '           MODULE NAME
         DC    XL4'FFFFFFFF'       MASK
*
*        PH1ATAB - TERMINATING ENTRY
*
         DC    CL4'XXXX'           MODULE NAME
         DC    XL4'00000000'       MASK
*
*        END OF TABLE
*
         DC    0F'0'
KFFFF    DC    XL4'FFFFFFFF'       MASK USED FOR MODULE SELECTION
AIERRC9  DC    A(0)                ADDR OF LOADED MODULE IERRC9
KIERRC6  DC    CL8'IERRC6  '       FOR PRINTING AND FOR USE BY RC9 TO
*                                  DELETE THIS MODULE
WSWITCH  DC    F'0'                FOR PPICNTL FLAGS
*
WLINK    DC    H'0'                FOR NO LINK EDIT USER MOD INFO
*
WASMTLST DC    20XL3'FFFFFF'       FOR ASMT MODULE LIST
*
IER988   DC    A(IER988T)
         DC    A(IER988X-IER988T)
IER988T  DC    C'IER988I IER'
IER988A  DC    C'DM4'
         DC    C' Loaded at '
IER988B  DC    C'XXXXXX'
IER988X  EQU   *                   FOR L'MSG CALC
*
KPH1     DC    CL4'PH1 '
KUSER    DC    XL2'F806'           MASK FOR PHASE 1 LINK EDITS
KMODS    DC    XL2'F806'           MASK FOR PHASE 1 EXITS
KMODSPH2 DC    XL2'0785'           MASK FOR PHASE 2 EXITS
*
KE61     DC    CL3'E61'
KE19     DC    CL3'E19'
KE18     DC    CL3'E18'
KE17     DC    CL3'E17'
KE16     DC    CL3'E16'
KE15     DC    CL3'E15'
KE11     DC    CL3'E11'
KS11     DC    CL3'S11'
*
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERRC7   0101-20211-20211-1200-00595-00595-00000-RELEASE 00
RC7      TITLE 'IERRC7 - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRC7
*
*        MODULE FUNCTION/OPERATION -
*        SELECT THE MODULES AND USER MODIFICATION PROGRAMS THAT
*        ARE TO BE LOADED DURING PHASE 2.
*        THE LAST THREE CHARACTERS OF EACH SELECTED RUNNING
*        MODULE AND EACH SELECTED USER PROGRAM ARE STORED IN
*        PPI.
*        THE LAST THREE CHARACTERS OF EACH SELECTED ASSIGNMENT
*        MODULE ARE PLACED IN A LIST WITHIN IERRC7.
*        THE ADDRESS OF THIS LIST IS PASSED TO IERRC9
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACROS USED BY MODULE -
*        SMPPI   LOAD
*
*        ENTRY POINTS - ENTRY FROM IERRCV
*                       CALLING SEQUENCE -
*                       LOAD EP=IERRC7,DCB=(1)
*                       LR    R15,R0
*                       BR    R15         INITIAL ENTRY
*
*                     - ENTRY FROM IERRC6
*                       CALLING SEQUENCE -
*                       LOAD EP=IERRC7,DCB=(1)
*                       LR    R15,R0
*                       BALR  R14,R15 ENTRY FOR OSC SORT
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPICNTL   PPILINK   PPISLIB
*        PPICONV   PPIADSSC
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        ALL LOCATIONS FROM PPIALG THROUGH PPIX16, EXCEPT
*        PPICONV, ARE CLEARED TO ZERO FOR ALL SORTS NOT USING THE
*        OSCILLATING OR CRCX 2314 TECHNIQUES FOR ALL SORTS, VARIOUS
*        LOCATIONS FROM PPIALG THROUGH PPIX16 WILL BE LOADED
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL -
*        IERRCV - PRINT DIAGNOSTIC MESSAGE
*        IERRC6 - RETURN CONTROL DURING AN OSCILLATING/CRCX 2314 SORT
*        IERRC9 - NEXT MODULE IN SEQUENCE OF OPERATION
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS -
*        TABLE TBLPH2RN - MASKS FOR ALL PHASE 2 RUNNING MODULES
*        TABLE TBLPH2AS - MASKS FOR ALL PHASE 2 ASSIGNMENT MODULES
*        WASMTLST       - 60 BYTE AREA WHERE THE ASSIGNMENT MODULE
*                         LOAD LIST IS AMASSED
*        WSWITCH        - 4 BYTE AREA WHERE INFORMATION ABOUT THE SORT
*                         IS ACCUMULATED
*        WLINK          - HALFWORD AREA WHERE INFORMATION ABOUT
*                         PRE LINKEDITED USER MODS IS ACCUMULATED
*
*        NOTES -
*        THIS MODULE IS USED TO SELECT THE OTHER MODULES AND
*        USER MODIFICATION PROGRAMS FOR PHASE 2 OF ALL SORTS
*        EXCEPT THOSE USING THE OSCILLATING OR CRCX 2314 TECHNIQUES
*
IERRC7   CSECT
         USING *,R11               MODULE BASE REGISTER
         USING IERRCA,R13          PPI BASE REGISTER
*
         IERENTRY 'IERRC7 &SYSDATE &SYSTIME'
*
         LR    R10,R11             SAVE RC6 BASE REGISTER
         LR    R11,R15             LOAD MODULE BASE REGISTER
         ST    R14,RC7SAVO         SAVE R14
*
*        GENERATE OPTIONAL DIAGNOSTIC MESSAGE
*
         PPITEST  PPITMODF         MODULE FLOW DIAGNOSTICS ?
         BZ    RC7001              NO, BRANCH
         PPITEST  PPIDIAG+PPIDSIM  GENERATE DIAGNOSTIC MESSAGES ?
         BZ    RC7001              NO, BRANCH
         LR    R0,R11              R0 -> THIS MODULE
         L     R15,PPICONV+4       R15 -> CONVERT ROUTINE
         BAS   R14,4(,R15)         CALL CONVERT ROUTINE
         MVC   IER988B,2(R1)       MOVE FORMATTED ADDR TO MESSAGE
         LM    R0,R1,IER988        IER988I - IERRC7 LOADED AT
         L     R15,PPIADSSC        R15 -> PRINT ROUTINE
         BAS   R14,12(,R15)        CALL MSG WRITER
*
*        CLEAR LOAD LIST EXCEPT FOR PPICONV
*
RC7001   PPITEST  PPIOSC           OSCILLATING SORT ?
         BO    RC7OSCIL            YES, GET USER MOD LIST ONLY
         PPITEST  PPI2314          CRCX SORT ?
         BO    RC7OSCIL            YES, GET USER MOD LIST ONLY
         MVI   PPIEOF,X'00'        CLEAR ONE BYTE
*                                  ZERO FIELDS PPIEOF THRU TO PPIX16
         MVC   PPIEOF+1(PPIX16+7-PPIEOF),PPIEOF
*                                  ZERO FIELDS PPIALG THRU TO PPIINT
         MVC   PPIALG(PPIINT+7-PPIALG+1),PPIEOF
         MVC   WSWITCH(3),PPICNTL  MOVE FIRST 3 BYTES OF PPICNTL
         MVC   WSWITCH+3(1),PPICNTL+6  MOVE PPICNTL+6 INTO 4TH BYTE
         NI    WSWITCH+3,X'45'     CLEAR OUT 5 BITS
         TM    WSWITCH+3,X'40'     READ FORWARD SWITCH ON ?
         BO    RC7CHKEX            YES, BRANCH
         OI    WSWITCH+3,X'80'     NO, SET READ BACKWARD BIT
RC7CHKEX PPITEST  PPIME25          E25 EXIT ACTIVE
         BO    RC7SETAC            YES, BRANCH
         OI    WSWITCH+3,X'08'     SET E25 NOT ACTIVE BIT
         B     RC7SELRN            SKIP ONE INSTRUCTION
*
RC7SETAC OI    WSWITCH+3,X'02'     SET E25 ACTIVE BIT
*
*        WSWITCH FLAG DEFINITIONS -
*
*        BITS 1-24 ARE SAME AS BITS 1-24 OF PPICNTL
*        BIT 25 = READ BACKWARD (NORMAL)
*        BIT 26 = READ FORWARD
*        BITS 27 AND 28 = 0 (NOT USED)
*        BIT 29 = E25 NOT ACTIVE
*        BIT 30 = DRUM - FROM PPICNTL BIT 54
*        BIT 31 = E25 ACTIVE
*        BIT 32 = 0 (RESERVED)
*
RC7SELRN LA    R3,PH2RTAB          R3 -> PHASE 2 RUNNING LIST
         LA    R5,PPIALG           R5 -> PPIALG
RC7LOOP  ICM   R4,B'1111',4(R3)    LOAD MODULE SELECTION MASK
         BZ    RC7OSCIL            TERMINATING ENTRY ? EXIT LOOP
         O     R4,WSWITCH          OR SWITCH SETTINGS INTO IT
         X     R4,KFFFF            CHECK FOR COND MET IE R4 = ALL ONES
         BNZ   RC7LOOPA            NO, DO NOT WANT THIS MODULE
         SR    R4,R4               YES, SELECT THIS MODULE
         IC    R4,3(,R3)           GET PPI DISPLACEMENT FROM LIST
         AR    R4,R5               ADD DISPLACEMENT INTO PPIALG
         MVC   0(3,R4),0(R3)       MOVE IN THREE CHARACTER MODULE NAME
RC7LOOPA LA    R3,8(,R3)           UP POINTER TO NEXT MODULE
         B     RC7LOOP             LOOP UNTIL END OF LIST
*
*        CHECK FOR THE PRESENCE OF USER MODS AND MAKES UP THE
*        LOAD LIST ACCORDINGLY
*
RC7OSCIL NC    KMODS(2),PPICNTL+12  ANY PHASE 2 EXITS ACTIVE ?
         BE    RC7ENDMD            NO, BRANCH
         MVC   WLINK(2),PPICNTL+12  KLINK NOW = ACTIVE EXITS
         XC    WLINK(2),PPILINK    KLINK NOW = ACTIVE, NOT LINK EDITED
*                                  EXITS
         TM    WLINK,PPIME21       E21 BIT ON ?
         BZ    RC7E25              NO - CHECK NEXT BIT
         MVC   PPIX21(3),KE21      PUT E21 ON LOAD LIST
*
*        NOTE THAT IF THIS EXIT HAD BEEN LINK EDITED SEPARATELY
*        (S21) E21 WILL NOW BE LOADED BUT WILL BE OVERLAID WITH
*        S21 LATER
*
RC7E25   TM    WLINK,PPIME25       E25 BIT ON ?
         BZ    RC7E27              NO, CHECK NEXT BIT
         MVC   PPIX25(3),KE25      PUT E25 ON LOAD LIST
RC7E27   TM    WLINK,PPIME27       E27 BIT ON ?
         BZ    RC7E28              NO, CHECK NEXT BIT
         MVC   PPIX27(3),KE27      PUT E27 ON LOAD LIST
RC7E28   TM    WLINK+1,PPIME28     E28 BIT ON ?
         BZ    RC7E29              NO, CHECK NEXT BIT
         MVC   PPIX28(3),KE28      PUT E28 ON LOAD LIST
RC7E29   TM    WLINK+1,PPIME29     E29 BIT ON ?
         BZ    RC7E61              NO, CHECK NEXT BIT
         MVC   PPIX29(3),KE29      PUT E29 ON LOAD LIST
RC7E61   TM    WLINK+1,PPIME61     E61 BIT ON ?
         BZ    RC7S21              NO, CHECK FOR S21
         MVC   PPIX61(3),KE61      PUT E61 ON LOAD LIST
RC7S21   TM    PPILINK+2,X'20'     S21 BIT ON ?
         BZ    RC7PH2              NO, CHECK FOR PH2
         MVC   PPIX21(3),KS21      PUT S21 ON LOAD LIST
RC7PH2   NC    KUSER(2),PPILINK    LINK EDIT A PH2 ?
         BE    RC7ENDMD            NO, DONE WITH EXITS
         LA    R3,12               SET UP R3 FOR COUNTER
         LA    R4,PPIX11-8         INITIALIZE POINTER
RC7LOOP2 LA    R4,8(,R4)           UP POINTER BY 8
         SR    R5,R5
         A     R5,0(,R4)           LOCATION EMPTY ?
         BZ    RC7MT               YES, PUT PH2 HERE
         BCT   R3,RC7LOOP2         AT END OF LIST ? NO, BRANCH
         B     RC7ENDMD            END OF LIST, BRANCH
*
*        THE ONLY WAY THE LIST CAN BE FULL IS FOR AN OSCILLATING
*        SORT WITH ALL EXITS FOR PHASE 1 AND 2 ACTIVE AND E61
*        HAVING BEEN LINK EDITED, BY ITSELF, AS PH1 AND PH2. IN
*        THAT CASE PH1 IS ALREADY ON THE LIST AND DON'T NEED
*        PH2
*
RC7MT    L     R5,KPH2             GET PH2
         ST    R5,0(,R4)           LOAD PH2 HERE - IT WAS EMPTY
RC7ENDMD PPITEST  PPIOSC           OSCILLATING SORT ?
         BO    RC7EXIT6            YES, RETURN TO IERRC6
         PPITEST  PPI2314          CRCX 2314 SORT ?
         BZ    RC7SELAS            NO, BRANCH
*
*        RETURN TO IERRC6
*
RC7EXIT6 L     R14,RC7SAVO         RESTORE R14
         LR    R11,R10             RELOAD RC6 BASE REGISTER
         BR    R14                 RETURN TO RC6
*
RC7SELAS LA    R2,WASMTLST         R2 -> ASSIGNMENT LIST
         LA    R4,PH2ATAB          R4 -> PH2ATAB
RC7LOOP3 ICM   R5,B'1111',4(R4)    LOAD MODULE SELECTION MASK
         BZ    RC7ASDON            TERMINATION ENTRY ? BRANCH
         O     R5,WSWITCH          OR IT WITH SWITCH SETTINGS
         X     R5,KFFFF            CHECK FOR COND MET, IE R5 = ALL ONES
         BNZ   RC7LOOP4            NO, THIS MODULE NOT NEEDED
         MVC   0(3,R2),0(R4)       MOVE THREE CHARS INTO ASSGNMENT LIST
         LA    R2,3(,R2)           UP POINTER BY THREE
RC7LOOP4 LA    R4,8(,R4)           UP POINTER TO NEXT MODULE
         B     RC7LOOP3            LOOP UNTIL END OF ASMT LOAD LIST
*
*        LOAD IERRC9
*
*        IF DIAGNOSTICS ARE SPECIFIED IER988 WILL BE GENERATED
*        BEFORE BRANCHING TO RC9
*
RC7ASDON L     R1,PPISLIB          R1 -> SORTLIB DCB
*
         LOAD  EP=IERRC9,DCB=(1)
*
         ST    R0,AIERRC9          SAVE RC9 ADDR
         PPITEST  PPITMODF         MODULE FLOW DIAGNOSTICS ?
         BZ    RC7EXIT9            NO, EXIT TO RC9
         PPITEST  PPIDIAG+PPIDSIM  GENERATE DIAGNOSTIC MESSAGES ?
         BZ    RC7EXIT9            NO, EXIT TO RC9
         MVI   IER988A,C'9'        CHANGE NAME TO IERRC9
         L     R15,PPICONV+4       R15 -> CONVERT ROUTINE
         BAS   R14,4(,R15)         CALL CONVERT ROUTINE
         MVC   IER988B,2(R1)       MOVE FORMATTED ADDR TO MESSAGE
         LM    R0,R1,IER988        IER988I - IERRC9 LOADED AT
         L     R15,PPIADSSC        R15 -> PRINT ROUTINE
         BAS   R14,12(,R15)        CALL MSG WRITER
*
RC7EXIT9 LA    R0,CIERRC7          R0 -> C'IERRC7  '
         LA    R2,WASMTLST         R2 -> ASSIGNMENT LIST
         L     R15,AIERRC9         LOAD ADDR OF RC9
         BR    R15                 EXIT TO RC9, IT WILL DELETE RC7
*
*        PH2RTAB
*
*        TABLE OF MASKS FOR ALL PHASE 2 RUNNING MODULES. THE
*        FOURTH BYTE OF EACH ENTRY IS THE DISPLACEMENT FROM
*        PPIALG WHERE THE LAST THREE CHARACTERS OF THAT MODULE
*        NAME ARE MOVED
*
PH2RTAB  DC    0F'0'
*
*        IERRMB - MESSAGE MODULE FOR RUNNING MODULES
*
         DC    CL3'RMB'
         DC    XL1'70'
         DC    XL4'FFFFFFFF'
*
*        IERAMB - MESSAGE MODULE FOR ASSIGNMENT MODULES
*
         DC    CL3'AMB'
         DC    XL1'80'
         DC    XL4'FFFFFFFF'
*
*        IERAP2 - ASSIGNMENT AREA FOR OPEN PARAMETER LIST
*
         DC    CL3'AP2'
         DC    XL1'88'
         DC    XL4'FFFFFFFF'
*
*        IERROV - MERGE NETWORK FOR SINGLE CF - 1 TO 8 WAY MERGE
*
         DC    CL3'ROV'
         DC    XL1'40'
         DC    XL4'DEFFFFFF'
*
*        IERROU - MERGE NETWORK FOR MULTI CF - 1 TO 8 WAY MERGE
*
         DC    CL3'ROU'
         DC    XL1'40'
         DC    XL4'EEFFFFFF'
*
*        IERROP - MERGE NETWORK FOR MULTI CF - 9 TO 16 WAY MERGE
*
         DC    CL3'ROP'
         DC    XL1'40'
         DC    XL4'EF7FFFFF'
*
*        IERROQ - MERGE NETWORK FOR SINGLE CF - 9 TO 16 WAY MERGE
*
         DC    CL3'ROQ'
         DC    XL1'40'
         DC    XL4'DF7FFFFF'
*
*        IERROR - BALANCED TAPE ALGORITHM
*
         DC    CL3'ROR'
         DC    XL1'0'
         DC    XL4'F7BFFFFF'
*
*        IERROS - POLYPHASE TAPE ALGORITHM
*
         DC    CL3'ROS'
         DC    XL1'0'
         DC    XL4'FBBFFFFF'
*
*        IERROT - BALANCED DISK ALGORITHM
*
         DC    CL3'ROT'
         DC    XL1'0'
         DC    XL4'F7DFFFFF'
*
*        IERRO3 - DRUM ALGORITHM
*
*        DC    CL3'RO3'
*        DC    XL1'0'
*        DC    XL4'FFFFFFFB'
*
*        IERRDL - DEBLOCK INITIALIZATION ROUTINE
*
         DC    CL3'RDL'
         DC    XL1'38'
         DC    XL4'FFFFFFFF'
*
*        IERRBG - BLOCK/DEBLOCK FOR FIXED LEN REC - < 257 - E25 NOT
*        ACTIVE
*
         DC    CL3'RBG'
         DC    XL1'48'
         DC    XL4'7FFF7FF7'
*
*        IERRBH - BLOCK/DEBLOCK FOR FIXED LEN REC - > 256 - E25 NOT
*        ACTIVE
*
         DC    CL3'RBH'
         DC    XL1'48'
         DC    XL4'7FFFBFF7'
*
*        IERRBI - BLOCK/DEBLOCK FOR VAR LEN REC - E25 NOT ACTIVE
*
         DC    CL3'RBI'
         DC    XL1'48'
         DC    XL4'BFFFFFF7'
*
*        IERRBJ - BLOCK/DEBLOCK FOR FIXED LEN REC - E25 ACTIVE
*
         DC    CL3'RBJ'
         DC    XL1'48'
         DC    XL4'7FFFFFFD'
*
*        IERRBK - BLOCK/DEBLOCK FOR VAR LEN REC - E25 ACTIVE
*
         DC    CL3'RBK'
         DC    XL1'48'
         DC    XL4'BFFFFFFD'
*
*        IERRPE - DISK WRITE MODULE
*
         DC    CL3'RPE'
         DC    XL1'20'
         DC    XL4'FFDFFFFF'
*
*        IERRPD - TAPE WRITE MODULE
*
         DC    CL3'RPD'
         DC    XL1'20'
         DC    XL4'FFBFFFFF'
*
*        IERRPO - DRUM WRITE MODULE
*
*        DC    CL3'RPO'
*        DC    XL1'20'
*        DC    XL4'FFFFFFFB'
*
*        IERRGC - DISK READ MODULE
*
         DC    CL3'RGC'
         DC    XL1'30'
         DC    XL4'FFDFFFFF'
*
*        IERRGB - TAPE READ BACKWARD MODULE
*
         DC    CL3'RGB'
         DC    XL1'30'
         DC    XL4'FFBFFF7F'
*
*        IERRGL - TAPE READ FORWARD MODULE
*
         DC    CL3'RGL'
         DC    XL1'30'
         DC    XL4'FFBFFFBF'
*
*        IERRGO - DRUM READ MODULE
*
*        DC    CL3'RGO'
*        DC    XL1'30'
*        DC    XL4'FFFFFFFB'
*
*        PH2RTAB TERMINATING ENTRY
*
         DC    CL3'XXX'
         DC    XL1'00'
         DC    XL4'00000000'
*
*        PH2ATAB
*
*        TABLE OF MASKS FOR ALL PHASE 2 ASSIGNMENT MODULES. THEY
*        ARE IN THE ORDER OF MODULE EXECUTION
*
PH2ATAB  DC    0F'0'
*
*        IERAPH - ALLOCATING CORE STORAGE
*
         DC    CL4'APH '
         DC    XL4'FFFFFFFF'
*
*        IERAOR - BALANCED TAPE ALGORITHM
*
         DC    CL4'AOR '
         DC    XL4'F7BFFFFF'
*
*        IERAOS - POLYPHASE TAPE ALGORITHM
*
         DC    CL4'AOS '
         DC    XL4'FBBFFFFF'
*
*        IERAOT - BALANCED DISK ALGORITHM
*
         DC    CL4'AOT '
         DC    XL4'F7DFFFFF'
*
*        IERAO3 - DRUM ALGORITHM
*
*        DC    CL4'AO3 '
*        DC    XL4'FFFFFFFB'
*
*        IERABR - MOVE GENERATOR - FIXED LEN REC - E25 ACTIVE
*
         DC    CL4'ABR '
         DC    XL4'7FFFFFFD'
*
*        IERABR - SELECTED WHEN E25 NOT ACT IF FIXED LEN REC > 256
*
         DC    CL4'ABR '
         DC    XL4'7FFFBFF7'
*
*        IERABG - BLOCK/DEBLOCK-FIXED LEN REC - < 257 - E25 NOT ACTIVE
*
         DC    CL4'ABG '
         DC    XL4'7FFF7FF7'
*
*        IERABI - BLOCK/DEBLOCK-VAR LEN REC - E25 NOT ACTIVE
*
         DC    CL4'ABI '
         DC    XL4'BFFFFFF7'
*
*        IERABH - BLOCK/DEBLOCK-FIXED LEN REC - > 256 - E25 NOT ACTIVE
*
         DC    CL4'ABH '
         DC    XL4'7FFFBFF7'
*
*        IERABJ - BLOCK/DEBLOCK-FIXED LEN REC - E25 ACTIVE
*
         DC    CL4'ABJ '
         DC    XL4'7FFFFFFD'
*
*        IERABK - BLOCK/DEBLOCK-VAR LEN - E25 ACTIVE
*
         DC    CL4'ABK '
         DC    XL4'BFFFFFFD'
*
*        IERADL - DEBLOCK INITIALIZATION ROUTINE
*
         DC    CL4'ADL '
         DC    XL4'FFFFFFFF'
*
*        IERAGG - DCB GENERATION ROUTINE FOR TAPE
*
         DC    CL4'AGG '
         DC    XL4'FFBFFFFF'
*
*        IERAGJ - DCB GENERATION ROUTINE FOR DISK
*
         DC    CL4'AGJ '
         DC    XL4'FFDFFFFF'
*
*        IERAGJ - DRUM DCB GENERATION
*
*        DC    CL4'AGJ '
*        DC    XL4'FFFFFFFB'
*
*        IERAPD - TAPE WRITE MODULE
*
         DC    CL4'APD '
         DC    XL4'FFBFFFFF'
*
*        IERAPE - DISK WRITE MODULE
*
         DC    CL4'APE '
         DC    XL4'FFDFFFFF'
*
*        IERAPO - DRUM WRITE MODULE
*
*        DC    CL4'APO '
*        DC    XL4'FFFFFFFB'
*
*        IERAOV - MERGE NETWORK WITH SINGLE C.F.-1 TO 8 WAY MERGE
*
         DC    CL4'AOV '
         DC    XL4'DEFFFFFF'
*
*        IERAOQ - MERGE NETWORK WITH SINGLE CF - 9 TO 16 WAY MERGE
*
         DC    CL4'AOQ '
         DC    XL4'DF7FFFFF'
*
*        IERAOU - MERGE NETWORK WITH MULTI CF - 1 TO 8 WAY MERGE
*
         DC    CL4'AOU '
         DC    XL4'EEFFFFFF'
*
*        IERAOP - MERGE NETWORK WITH MULTI CF - 9 TO 16 WAY MERGE
*
         DC    CL4'AOP '
         DC    XL4'EF7FFFFF'
*
*        IERAPJ - OPEN ROUTINE
*
         DC    CL4'APJ '
         DC    XL4'FFFFFFFF'
*
*        IERAGB - TAPE READ BACKWARD MODULE
*
         DC    CL4'AGB '
         DC    XL4'FFBFFF7F'
*
*        IERAGC - DISK READ MODULE
*
         DC    CL4'AGC '
         DC    XL4'FFDFFFFF'
*
*        IERAGL - TAPE READ FORWARD MODULE
*
         DC    CL4'AGL '
         DC    XL4'FFBFFFBF'
*
*        IERAGO - DRUM READ MODULE
*
*        DC    CL4'AGO '
*        DC    XL4'FFFFFFFB'
*
*        PH2ATAB TERMINATING ENTRY
*
         DC    CL4'XXX '
         DC    XL4'00000000'
*
*        END OF PH2ATAB
*
WSWITCH  DC    F'0'                FOR PPICNTL BITS
WLINK    DC    H'0'                FOR NO LINK EDIT USER MOD INFO
WASMTLST DC    20XL3'FFFFFF'       FOR ASMT MODULE LIST
*
IER988   DC    A(IER988T)
         DC    A(L'IER988T+L'IER988A+L'IER988B)
IER988T  DC    C'IER988I IERRC'
IER988A  DC    C'7 Loaded at '
IER988B  DC    CL6' '
*
         DC    0F'0'
KPH2     DC    CL4'PH2 '
KUSER    DC    XL2'0785'           MASK FOR PHASE 2 LINK EDITS
KE61     DC    CL3'E61'
KE29     DC    CL3'E29'
KE28     DC    CL3'E28'
KE27     DC    CL3'E27'
KE25     DC    CL3'E25'
KE21     DC    CL3'E21'
KS21     DC    CL3'S21'
KMODS    DC    XL2'0785'           MASK FOR PHASE 2 EXITS
         DC    0F'0'
KFFFF    DC    XL4'FFFFFFFF'
AIERRC9  DC    A(0)                ADDR OF LOADED IERRC9
CIERRC7  DC    CL8'IERRC7  '       FOR USE BY RC9
RC7SAVO  DC    F'0'
*
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERRC8   0101-20211-20211-1200-00647-00647-00000-RELEASE 00
RC8      TITLE 'IERRC8 - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRC8
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 3 OR MERGE ONLY MODULE DEFINITION
*        SELECT THE MODULES AND USER MODIFICATION PROGRAMS THAT
*        ARE TO BE LOADED DURING THIS PHASE. THE LAST THREE
*        CHARACTERS OF EACH SELECTED RUNNING MODULE AND EACH
*        SELECTED USER PROGRAM ARE STORED IN PPI. THE LAST THREE
*        CHARACTERS OF EACH SELECTED ASSIGNMENT MODULE ARE PLACED
*        IN A LIST WITHIN RC8. THE ADDRESS OF THIS LIST IS
*        PASSED TO IERRC9
*
*        USED AS A DSECT IN - N/A
*
*        MACROS USED BY MODULE -
*        SMPPI
*        LOAD
*
*        ENTRY POINT - ENTRY FROM IERRCV
*                      CALLING SEQUENCE -
*                      LOAD  EP=IERRC8,DCB=(1)
*                      LR    R15,R0
*                      BR    R15         INITIAL ENTRY
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPICNTL   PPISLIB    PPILINK
*        PPICONV   PPIADSSC   PPIATP3E
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPICNTL
*        ALL LOCATIONS FROM PPIALG THROUGH PPIX16, EXCEPT THE
*        FOUR BYTES AT PPICONV+4, WILL BE CLEARED TO ZERO. THEN,
*        SOME OF THESE LOCATIONS WILL BE LOADED WITH THE LAST
*        THREE CHARACTERS OF SELECTED MODULE NAMES
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL -
*        IERRCV - PRINT DIAGNOSTIC MESSAGE
*        IERRC9 - NEXT MODULE IN SEQUENCE OF OPERATION
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS -
*        PH3RTAB  - MASKS FOR ALL PHASE 3 AND MERGE ONLY RUNNING
*                   MODULES
*        PH3ATAB  - MASKS FOR ALL PHASE 3 AND MERGE ONLY
*                   ASSIGNMENT MODULES
*        WASMTLST - 60 BYTE AREA WHERE THE ASSIGNMENT MODULE
*                   LOAD LIST IS BUILT
*        WSWITCH  - 4 BYTE AREA WHERE SORT OR MERGE INFORMATION
*                   IS ACCUMULATED
*        WUSRMOD  - 4 BYTE AREA WHERE USER MOD LINK EDIT
*                   INFORMATION IS ACCUMULATED
*
*        NOTES -
*        THIS MODULE IS USED TO SELECT THE OTHER MODULES AND USER
*        MODIFICATION PROGRAMS FOR PHASE 3 OF A SORT OR FOR A
*        MERGE ONLY
*
IERRC8   CSECT
*
         USING *,R11               MODULE BASE REGISTER
         USING IERRCA,R13          PPI BASE REGISTER
*
         IERENTRY 'IERRC8 &SYSDATE &SYSTIME'
*
         LR    R11,R15             SET PROGRAM BASE
*
*        GENERATE OPTIONAL DIAGNOSTIC MESSAGES
*
         PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTICS ?
         BZ    RC8002              NO, SKIP LOAD AND MSG GENERATION
         ICM   R0,B'1111',PPICONV+4  CONVERT RTN LOADED PREVIOUSLY ?
         BNZ   RC8001              YES, BRANCH
         L     R1,PPISLIB          R1 -> SORTLIB DCB
*
         LOAD  EP=IERDM4,DCB=(1)   LOAD CONVERT ROUTINE
*
         ST    R0,PPICONV+4        STORE ADDR OF CONVERT ROUTINE
RC8001   PPITEST  PPITMODF         MODULE FLOW DIAGNOSTICS ?
         BZ    RC8002              NO, BRANCH AROUND MSG GENERATION
         PPITEST  PPIDIAG+PPIDSIM  GENERATE DIAGNOSTIC MESSAGES ?
         BZ    RC8002              NO, BRANCH AROUND MSG GENERATION
         LR    R15,R0              R15 -> CONVERT ROUTINE
         BAS   R14,4(,R15)         CALL CONVERT ROUTINE
         MVC   IER988B,2(R1)       MOVE FORMATTED ADDR INTO MESSAGE
         LM    R0,R1,IER988        IER988I - IERDM4 LOADED AT
         L     R15,PPIADSSC        LOAD ADDR OF PRINT ROUTINE
         BAS   R14,12(,R15)        CALL PRINT RTN
*
*        MOVE DATA FROM PPICNTL INTO WSWITCH
*        GENERATE MASK USED TO SELECT MODULES
*
RC8002   CLC   PPIRCDL3,K256       OUTPUT RECORD LENGTH > 256 ?
         BH    RC8LONG             YES, BRANCH
         PPISETON PPILE256         SET SWITCHES, REPURPOSED FROM INPUT
         PPISETOF PPIGT256
RC8LONG  MVC   WSWITCH(3),PPICNTL  FIRST 3 BYTES OF PPICNTL TO WSWITCH
         SR    R5,R5
         IC    R5,PPICNTL+6        GET ANOTHER BYTE OF INFO
         STC   R5,WSWITCH+3        SAVE IT IN AREA WITH OTHER 3 BYTES
         NI    WSWITCH+3,X'C4'     CLEAR OUT 5 OF THE BITS IN WSWITCH
         SRL   R5,6                CLEAR OUT 6 BITS
         SLL   R5,4                POSITION DEB BACK AND READ FORW BITS
         LA    R5,1(,R5)           MAKE SURE R5 IS NOT ZERO
         LCR   R4,R5               LOAD THE COMPLEMENT
         STC   R4,WUSRMOD          TEMPORARY SAVE
         NI    WUSRMOD,X'30'       SAVE NORM DEB AND NORM READ BITS
         OC    WSWITCH+3(1),WUSRMOD   ADD THEM TO WSWITCH
         PPITEST  PPIME35          E35 ACTIVATED ?
         BO    RC8E35A             YES, BRANCH
         OI    WSWITCH+3,X'08'     NO, SET E35 NOT ACTIVE BIT
         B     RC8CHKMG            CHECK MERGE
*
RC8E35A  OI    WSWITCH+3,X'02'     SET E35 ACTIVE
RC8CHKMG PPITEST  PPIMERGO         MERGE ONLY ?
         BO    RC82314             YES, BRANCH
         OI    WSWITCH+2,X'04'     NO, SET PH 3 BIT
RC82314  PPITEST  PPI2314          CRCX SORT ?
         BZ    RC8VBS              NO, CHECK VBS
         OI    WSWITCH+3,X'01'     YES, SET CRCX
RC8VBS   NI    WSWITCH+1,X'E3'     ZERO BITS 12, 13 AND 14
         NI    WSWITCH+2,X'EF'     ZERO BIT 20
         PPITEST  PPIMVSI          VBS INPUT ?
         BZ    RC8NVRE1            NO, BRANCH
         OI    WSWITCH+1,X'08'     SET VBS INPUT
RC8NVRE2 PPITEST  PPIMVSO          VBS OUTPUT ?
         BZ    RC8NVRE3            NO, BRANCH
         OI    WSWITCH+1,X'10'     SET VBS OUTPUT
         B     RC8CLEAR            CLEAR LOAD LIST
*
RC8NVRE1 PPITEST  PPIMERGO         MERGE ONLY ?
         BZ    RC8NVRE2            NO, BRANCH
         OI    WSWITCH+2,X'10'     SET BIT 20 IF NOT VBS INPUT MERGE O
         B     RC8NVRE2            NO VBS
*
RC8NVRE3 OI    WSWITCH+1,X'04'     SET BIT 14 IF NOT VBS OUTPUT
*
*        WSWITCH FLAG DEFINITIONS -
*
*        BITS 1-11, 15-19 AND 21-24 ARE SAME AS 1-11,
*                                   15-19 AND 21-24 IN PPICNTL
*        BIT 12 = IS 1 IF VBS OUTPUT
*        BIT 13 = IS 1 IF VBS INPUT
*        BIT 14 = IS 1 IF NOT VBS OUTPUT
*        BIT 20 = IS 1 IF NOT VBS INPUT AND MERGE ONLY
*        BIT 25 = DEBLOCK BACKWARD - FROM PPICNTL BIT 49
*        BIT 26 = READ FORWARD - FROM PPICNTL BIT 50
*        BIT 27 = DEBLOCK FORWARD - NORMAL WAY
*        BIT 28 = READ BACKWARD - NORMAL
*        BIT 29 = E35 NOT ACTIVATED
*        BIT 30 = DRUM - FROM PPICNTL BIT 54 (NOT SUPPORTED)
*        BIT 31 = E35 ACTIVIATED - FROM PPICNTL+12
*        BIT 32 = CRCX - FROM PPICNTL BIT 55
*
*        CLEAR LOAD LIST EXCEPT FOR PPICONV
*
RC8CLEAR MVI   PPIEOF,X'00'        CLEAR ONE BYTE
*                                  ZERO FIELDS PPIEOF THRU TO PPIX16
         MVC   PPIEOF+1(PPIX16+7-PPIEOF),PPIEOF
*                                  ZERO FIELDS PPIALG THRU TO PPIINT
         MVC   PPIALG(PPIINT+7-PPIALG+1),PPIEOF
RC8SELRN LA    R2,4                SET UP FOR 4 TIME LOOP
         LA    R5,PPIALG           R5 -> PPIALG
         LA    R3,PH3RTAB          R3 -> PHASE 3 RUNNING LIST
RC8LOOP1 SR    R4,R4
         IC    R4,3(,R3)           GET PPI DISPLACEMENT FROM LIST
         AR    R4,R5               ADD DISPLACEMENT
         MVC   0(3,R4),0(R3)       MOVE THREE CHARACTERS
         LA    R3,4(,R3)           INCR POINTER TO NEXT MODULE
         BCT   R2,RC8LOOP1         LOOP 4 TIMES
RC8LOOP2 ICM   R4,B'1111',4(R3)    LOAD MODULE SELECTION MASK
         BZ    RC8RNDUN            TERMINATING ENTRY ? BRANCH
         O     R4,WSWITCH          OR IT WITH SWITCH SETTINGS
         X     R4,KFFFF            CHECK FOR COND MET, R4 = ALL ONES
         BNZ   RC8LOOP3            NO, THIS MODULE NOT REQUIRED
         SR    R4,R4               CLEAR R4
         IC    R4,3(,R3)           GET PPI DISPLACEMENT FROM LIST
         AR    R4,R5               ADD DISPLACEMENT
         MVC   0(3,R4),0(R3)       MOVE THREE CHARACTERS
RC8LOOP3 LA    R3,8(,R3)           INCR PTR TO NEXT MODULE
         B     RC8LOOP2            LOOP UNTIL END OF RUNNING LIST
*
*        CHECK FOR THE PRESENCE OF USER MODS AND MAKE UP THE
*        LOAD LIST ACCORDINGLY
*
RC8RNDUN ICM   R3,B'1111',PPIATP3E  SORT INVOKED ?
         BNZ   RC8SELAS            YES, BRANCH
         NC    KMODS,PPICNTL+13    ANY EXITS ACTIVE FOR PHASE 3 ?
         BZ    RC8SELAS            NO, BRANCH
         L     R3,PPILINK          GET LINK EDIT INFO
         N     R3,KLINK            LINK EDIT A PH3 ?
         BZ    RC8NOPH3            NO, BRANCH
         MVC   PPIX15(3),KPH3      LOAD PH3 ON LIST
RC8NOPH3 L     R4,PPICNTL+12       GET ACTIVE EXITS SWITCHES
         N     R4,KLINK            ANY BITS ON IN PPICNTL+12 EXIT CNTL?
         XR    R4,R3               FOR PHASE 3 EXITS, WITHOUT
         BZ    RC8SELAS            CORRESONDING BIT ON IN PPILINK ?
         ST    R4,WUSRMOD          YES, SAVE THE CODED WORD
         TM    WUSRMOD+1,X'40'     E31 A NO LINK EDIT ?
         BZ    RC8E35              NO
         MVC   PPIX31(3),KE31      YES, PUT E31 ON LIST
RC8E35   TM    WUSRMOD+1,X'20'     E35 A NO LINK EDIT ?
         BZ    RC8E37              NO
         MVC   PPIX35(3),KE35      YES, PUT E35 ON LIST
RC8E37   TM    WUSRMOD+1,X'10'     E37 A NO LINK EDIT ?
         BZ    RC8E38              NO
         MVC   PPIX37(3),KE37      YES, PUT E37 ON LIST
RC8E38   TM    WUSRMOD+1,X'08'     E38 A NO LINK EDIT ?
         BZ    RC8E61              NO
         MVC   PPIX38(3),KE38      YES, PUT E38 ON LIST
RC8E61   TM    WUSRMOD+1,X'04'     E61 A NO LINK EDIT ?
         BZ    RC8E39              NO
         MVC   PPIX61(3),KE61      YES, PUT E61 ON LIST
RC8E39   TM    WUSRMOD+2,X'80'     E39 A NO LINK EDIT ?
         BZ    RC8USERM            NO
         MVC   PPIX39(3),KE39      YES, PUT E39 ON LIST
RC8USERM TM    PPILINK+2,X'10'     LINK EDIT EXIT 31 BY ITSELF ?
         BZ    RC8SELAS            NO, BRANCH
         MVC   PPIX31(3),KS31      LOAD S31 ON LIST
*
*        BUILD LOAD LIST FOR SELECTED ASSIGNMENT MODULES
*
RC8SELAS LA    R2,WASMTLST         R2 -> ASSIGNMENT TABLE
         LA    R4,PH3ATAB          R4 -> MODULE MASK LIST
RC8LOOP4 ICM   R5,B'1111',4(R4)    LOAD MODULE SELECTION MASK
         BZ    RC8ASDON            TERMINATING ENTRY ? BRANCH
         O     R5,WSWITCH          OR IT WITH SWITCH SETTINGS
         X     R5,KFFFF            CHECK FOR COND MET R5 = ALL ONES
         BNZ   RC8LOOP5            NO, THIS MODULE NOT REQUIRED
         MVC   0(3,R2),0(R4)       MOVE NAME INTO ASMT LOAD LIST
         LA    R2,3(,R2)           INCR POINTER BY THREE
RC8LOOP5 LA    R4,8(,R4)           NO, INCR PTR TO NEXT MODULE
         B     RC8LOOP4            LOOP UNTIL END OF ASMT LIST
*
*        LOAD IERRC9
*        IF DIAGNOSTICS ARE SPECIFIED IER988 WILL BE GENERATED
*
RC8ASDON L     R1,PPISLIB          R1 -> SORTLIB DCB
*
         LOAD  EP=IERRC9,DCB=(1)
*
         ST    R0,AIERRC9          SAVE RC9 ADDR
         PPITEST  PPITMODF         MODULE FLOW DIAGNOSTICS ?
         BZ    RC8EXIT             NO, BRANCH AROUND MSG GENERATION
         PPITEST  PPIDIAG+PPIDSIM  GENERATE DIAGNOSTIC MESSAGES ?
         BZ    RC8EXIT             NO, BRANCH AROUND MSG GENERATION
         L     R15,PPICONV+4       R15 -> CONVERT ROUTINE
         BAS   R14,4(,R15)         CALL CONVERT ROUTINE
         MVC   IER988B,2(R1)       MOVE FORMATTED ADDR INTO MESSAGE
         MVC   IER988A,=C'RC9'     CHANGE NAME TO IERRC9
         LM    R0,R1,IER988        IER988I - IERRC9 LOADED AT XXXXXX
         L     R15,PPIADSSC        LOAD ADDR OF MSG WRITER
         BAS   R14,12(,R15)        CALL MSG WRITER
*
*        EXIT TO IERRC9
*
RC8EXIT  LA    R0,KIERRC8
         LA    R2,WASMTLST         R2 -> ASSIGNMENT TABLE
         L     R15,AIERRC9         R15 -> IERRC9
         BR    R15                 EXIT TO IERRC9
*
*        PH3RTAB
*
*        TABLE OF MASKS FOR ALL PHASE 3 AND MERGE ONLY RUNNING
*        MODULES. FIRST 4 ARE ALWAYS SELECTED HENCE NO MASK
*        NEEDED
*
PH3RTAB  DC    0F'0'
*
*        IERAP3 - ASSIGNMENT AREA FOR OPEN PARAMETER LIST
*
         DC    CL3'AP3'            LAST 3 CHARS OF MODULE NAME
         DC    XL1'88'             DISPLACEMENT FROM PPIALG
*
*        IERRPG - OPEN OUTPUT EOJ ROUTINE
*
         DC    CL3'RPG'            MOD NAME
         DC    XL1'20'             DISPLACEMENT
*
*        IERAMC - MESSAGE MODULE FOR ASSIGNMENT MODULES
*
         DC    CL3'AMC'            MOD NAME
         DC    XL1'80'             DISPLACEMENT
*
*        IERRMC - MESSAGE MODULE FOR RUNNING MODULES
*
         DC    CL3'RMC'            MOD NAME
         DC    XL1'70'             DISPLACEMENT
*
*        THE NEXT 2 ARE FOR MERGE ONLY
*
*        IERRDJ - DEBLOCK MODULE FOR MERGE ONLY RUNS WHEN NOT VBS RCDS
*
         DC    CL3'RDJ'            MOD NAME
         DC    XL1'08'             DISPLACEMENT
         DC    XL4'FFFFEDFF'       MASK
*
*        IER8DJ - DEBLOCK MODULE MERGE ONLY RUNS WHEN VBS INPUT
*
         DC    CL3'8DJ'            MOD NAME
         DC    XL1'08'             DISPLACEMENT
         DC    XL4'FFF7FDFF'       MASK
*
*        IERRGF - INPUT END OF FILE MODULE FOR ALL MERGE ONLY RUNS
*
         DC    CL3'RGF'            MOD NAME
         DC    XL1'60'             DISPLACEMENT
         DC    XL4'FFFFFDFF'       MASK
*
*        THE NEXT 9 ARE FOR PHASE 3 AND MERGE ONLY
*
*        IERROV - MERGE NETWORK FOR SINGLE CF -1 TO 8 WAY MERGE
*
         DC    CL3'ROV'            MOD NAME
         DC    XL1'10'             DISPLACEMENT
         DC    XL4'DEFFFFFF'       MASK
*
*        IERROQ - MERGE NETWORK FOR SINGLE CF - 9 TO 16 WAY MERGE
*
         DC    CL3'ROQ'            MOD NAME
         DC    XL1'10'             DISPLACEMENT
         DC    XL4'DF7FFFFF'       MASK
*
*        IERROU - MERGE NETWORK FOR MULT CF - 1 TO 8 WAY MERGE
*
         DC    CL3'ROU'            MOD NAME
         DC    XL1'10'             DISPLACEMENT
         DC    XL4'EEFFFFFF'       MASK
*
*        IERROP - MERGE NETWORK FOR MULT CF - 9 TO 16 WAY MERGE
*
         DC    CL3'ROP'            MOD NAME
         DC    XL1'10'             DISPLACEMENT
         DC    XL4'EF7FFFFF'       MASK
*
*        IERRBL - BLOCK MODULE FOR FIXED LNG RECORD < 257 WITH NO E35
*
         DC    CL3'RBL'            MOD NAME
         DC    XL1'18'             DISPLACEMENT
         DC    XL4'7FFF7FF7'       MASK
*
*        IERRBN - BLOCK MODULE FOR VAR LNG RECORD WITH NO E35
*
         DC    CL3'RBN'            MOD NAME
         DC    XL1'18'             DISPLACEMENT
         DC    XL4'BFFBFFF7'       MASK
*
*        IER8BN - BLOCK MODULE FOR VBS LNG RECORD WITH NO E35
*
         DC    CL3'8BN'            MOD NAME
         DC    XL1'18'             DISPLACEMENT
         DC    XL4'BFEFFFF7'       MASK
*
*        IERRBP - BLOCK MODULE FOR FIXED LNG RECORD > 256 WITH NO
*        E35
*
         DC    CL3'RBP'            MOD NAME
         DC    XL1'18'             DISPLACEMENT
         DC    XL4'7FFFBFF7'       MASK
*
*        IERRBM - BLOCK MODULE FOR FIXED LNG RECORD WITH E35
*
         DC    CL3'RBM'            MOD NAME
         DC    XL1'18'             DISPLACEMENT
         DC    XL4'7FFFFFFD'       MASK
*
*        IERRBO - BLOCK MODULE FOR VAR LNG RECORD WITH E35
*
         DC    CL3'RBO'            MOD NAME
         DC    XL1'18'             DISPLACEMENT
         DC    XL4'BFFBFFFD'       MASK
*
*        IER8BO - BLOCK MODULE FOR VBS LNG RECORD WITH E35
*
         DC    CL3'8BO'            MOD NAME
         DC    XL1'18'             DISPLACEMENT
         DC    XL4'BFEFFFFD'       MASK
*
*        THE NEXT 7 ARE FOR PHASE 3 ONLY
*
*        IERRDH - DEBLOCK MODULE FOR FIXED LNG RECORD - NORMAL FORWARD
*
         DC    CL3'RDH'            MOD NAME
         DC    XL1'08'             DISPLACEMENT
         DC    XL4'7FFFFBDF'       MASK
*
*        IERRDI - DEBLOCK MODULE FOR VAR LNG RECORD
*
         DC    CL3'RDI'            MOD NAME
         DC    XL1'08'             DISPLACEMENT
         DC    XL4'BFFFFBFF'       MASK
*
*        IERRDX - DEBLOCK MODULE FOR FIXED LNG RECORD - BACKWARD
*                 DEBLOCK
*
         DC    CL3'RDX'            MOD NAME
         DC    XL1'08'             DISPLACEMENT
         DC    XL4'7FFFFB7F'       MASK
*
*        IER8GC - READ CRCX MODULE
*
         DC    CL3'8GC'            MOD NAME
         DC    XL1'30'             DISPLACEMENT
         DC    XL4'FFFFFBFE'       MASK
*
*        IERRGD - READ TAPE MODULE - NORMAL READ BACKWARD
*
         DC    CL3'RGD'            MOD NAME
         DC    XL1'30'             DISPLACEMENT
         DC    XL4'FFBFFBEF'       MASK
*
*        IERRGM - READ TAPE MODULE - ABNORMAL READ FORWARD
*
         DC    CL3'RGM'            MOD NAME
         DC    XL1'30'             DISPLACEMENT
         DC    XL4'FFBFFBBF'       MASK
*
*        IERRGE - READ DISK MODULE
*
         DC    CL3'RGE'            MOD NAME
         DC    XL1'30'             DISPLACEMENT
         DC    XL4'FFDFFBFF'       MASK
*
*        IERRGP - READ DRUM MODULE (NOT SUPPORTED)
*
*        DC    CL3'RGP'            MOD NAME
*        DC    XL1'30'             DISPLACEMENT
*        DC    XL4'FFFFFBFB'       MASK
*
*        PH3RTAB TERMINATING TABLE ENTRY
*
         DC    CL3'XXX'            MOD NAME
         DC    XL1'00'             DISPLACEMENT
         DC    XL4'00000000'       MASK
*
*        TABLE OF MASKS FOR ALL PHASE 3 AND MERGE ONLY
*        ASSIGNMENT MODULES
*        THEY ARE IN THE ORDER OF EXECUTION
*
PH3ATAB  DC    0F'0'
*
*        IERAPI - ALLOCATE CORE STORAGE
*
         DC    CL4'API '           MOD NAME
         DC    XL4'FFFFFFFF'       MASK
*
*        IERAOP - MERGE NETWORK FOR MULT CF - 9 TO 16 WAY MERGE
*
         DC    CL4'AOP '           MOD NAME
         DC    XL4'EF7FFFFF'       MASK
*
*        IERAOV - MERGE NETWORK FOR SINGLE CF - 1 TO 8 WAY MERGE
*
         DC    CL4'AOV '           MOD NAME
         DC    XL4'DEFFFFFF'       MASK
*
*        IERAOU - MERGE NETWORK FOR MULT CF - 1 TO 8 WAY MERGE
*
         DC    CL4'AOU '           MOD NAME
         DC    XL4'EEFFFFFF'       MASK
*
*        IERAOQ - MERGE NETWORK FOR SINGLE CF - 9 TO 16 WAY MERGE
*
         DC    CL4'AOQ '           MOD NAME
         DC    XL4'DF7FFFFF'       MASK
*
*        IERAPF - GENERATE DCBS - MERGE ONLY
*
         DC    CL4'APF '           MOD NAME
         DC    XL4'FFFFFDFF'       MASK
*
*        IERAPK - GENERATE DCBS - TAPE - PHASE 3 ONLY
*
         DC    CL4'APK '           MOD NAME
         DC    XL4'FFBFFBFF'       MASK
*
*        IERAGK - GENERATE DCBS - DISK - PHASE 3 ONLY
*
         DC    CL4'AGK '           MOD NAME
         DC    XL4'FFDFFBFF'       MASK
*
*        IERAGK - GENERATE DCBS - DRUM - PHASE 3 ONLY (NOT SUPPORTED)
*
*        DC    CL4'AGK '           MOD NAME
*        DC    XL4'FFFFFBFB'       MASK
*
*        IERAGK - GENERATE DCBS - CRCX - PHASE 3 ONLY
*
         DC    CL4'AGK '           MOD NAME
         DC    XL4'FFFFFBFE'       MASK
*
*        IERABQ - MOVE GENERATOR
*
         DC    CL4'ABQ '           MOD NAME
         DC    XL4'FFFFFFFF'       MASK
*
*        IERABL - BLOCK - FIXED - RECORD LNG < 257 - NO E35
*
         DC    CL4'ABL '           MOD NAME
         DC    XL4'7FFF7FF7'       MASK
*
*        IERABM - BLOCK - FIXED LNG RECORDS WITH E35
*
         DC    CL4'ABM '           MOD NAME
         DC    XL4'7FFFFFFD'       MASK
*
*        IERABN - BLOCK - VAR LNG RECORD - NO E35
*
         DC    CL4'ABN '           MOD NAME
         DC    XL4'BFFBFFF7'       MASK
*
*        IER9BN - BLOCK - VBS LNG RECORD - NO E35
*
         DC    CL4'9BN '           MOD NAME
         DC    XL4'BFEFFFF7'       MASK
*
*        IERABO - BLOCK - VAR LNG RECORD - WITH E35
*
         DC    CL4'ABO '           MOD NAME
         DC    XL4'BFFBFFFD'       MASK
*
*        IER9BO - BLOCK - VRE LNG RECORD - WITH E35
*
         DC    CL4'9BO '           MOD NAME
         DC    XL4'BFEFFFFD'       MASK
*
*        IERABP - BLOCK - FIXED - RECORD LNG > 256 - NO E35
*
         DC    CL4'ABP '           MOD NAME
         DC    XL4'7FFFBFF7'       MASK
*
*        IERAGF - OPENING FILES - MERGE ONLY
*
         DC    CL4'AGF '           MOD NAME
         DC    XL4'FFFFFDFF'       MASK
*
*        IERAGH - OPENING FILES - PHASE 3 ONLY
*
         DC    CL4'AGH '           MOD NAME
         DC    XL4'FFFFFBFF'       MASK
*
*        IER9GC - CRCX READ - PHASE 3 ONLY
*
         DC    CL4'9GC '           MOD NAME
         DC    XL4'FFFFFBFE'       MASK
*
*        IERAGD - TAPE READ BACKWARD (NORMAL) - PHASE 3 ONLY
*
         DC    CL4'AGD '           MOD NAME
         DC    XL4'FFBFFBEF'       MASK
*
*        IERAGE - DISK READ - PHASE 3 ONLY
*
         DC    CL4'AGE '           MOD NAME
         DC    XL4'FFDFFBFF'       MASK
*
*        IERAGP - DRUM READ - PHASE 3 ONLY (NOT SUPPORTED)
*
*        DC    CL4'AGP '           MOD NAME
*        DC    XL4'FFFFFBFB'       MASK
*
*        IERAGM - TAPE READ FORWARD (SEQ CORR) - PHASE 3 ONLY
*
         DC    CL4'AGM '           MOD NAME
         DC    XL4'FFBFFBBF'       MASK
*
*        IERADH - DEBLOCK - FIXED - FORWARD (NORMAL) PHASE 3 ONLY
*
         DC    CL4'ADH '           MOD NAME
         DC    XL4'7FFFFBDF'       MASK
*
*        IERADJ - DEBLOCK - MERGE ONLY - NOT VBS LNG RECORD
*
         DC    CL4'ADJ '           MOD NAME
         DC    XL4'FFFFEDFF'       MASK
*
*        IER9DJ - DEBLOCK - MERGE ONLY - VBS LNG RECORD
*
         DC    CL4'9DJ '           MOD NAME
         DC    XL4'FFF7FDFF'       MASK
*
*        IERADI - DEBLOCK - VARIABLE - PHASE 3 ONLY
*
         DC    CL4'ADI '           MOD NAME
         DC    XL4'BFFFFBFF'       MASK
*
*        IERADX - DEBLOCK - FIXED - BACKWARD (SEQ CORR) PHASE 3 ONLY
*
         DC    CL4'ADX '           MOD NAME
         DC    XL4'7FFFFB7F'       MASK
*
*        PH3ATAB TERMINATING ENTRY
*
         DC    CL4'XXXX'           MOD NAME
         DC    XL4'00000000'       MASK
*
*        END OF PH3ATAB
*
WSWITCH  DC    F'0'                FOR PPICNTL BITS
*
WUSRMOD  DC    F'0'                FOR NO LINK EDIT USER MOD INFO
*
WASMTLST DC    20XL3'FFFFFF'       FOR ASMT MODULE LIST
*
IER988   DC    A(IER988T)          DIAGNOSTIC MSG
         DC    A(IER988X-IER988T)
IER988T  DC    C'IER988I IER'
IER988A  DC    C'DM4'
         DC    C' Loaded at '
IER988B  DC    CL6'XXXXXX'
IER988X  EQU   *                   FOR L'MSG
*
KIERRC8  DC    CL8'IERRC8  '
*
         DC    0F'0'
AIERRC9  DC    A(0)                -> IERRC9
KFFFF    DC    XL4'FFFFFFFF'
KLINK    DC    XL4'007C8000'
K256     DC    H'256'
KMODS    DC    XL2'7C80'
*
KS31     DC    C'S31'
KE31     DC    C'E31'
KE35     DC    C'E35'
KE37     DC    C'E37'
KE38     DC    C'E38'
KE39     DC    C'E39'
KE61     DC    C'E61'
KPH3     DC    C'PH3'
*
         LTORG
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERRC9   0101-20211-20211-1200-00437-00437-00000-RELEASE 00
RC9      TITLE 'IERRC9 - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRC9
*
*        MODULE FUNCTION/OPERATION -
*        LOAD ROUTINE FOR ALL 3 PHASES
*        THIS MODULE IS RESPONSIBLE FOR LOADING ALL RUNNING
*        PROGRAMS AND LOADING/EXECUTING/DELETING ALL ASSIGNMENT
*        PROGRAMS AS DEFINED BY THE DEFINITION ROUTINE
*        (IERRC6,- 7,-8).
*        FOR DIAGNOSTIC PURPOSES, THE MODULE ALSO PRINTS EACH
*        MODULE'S NAME AND LOCATION IN STORAGE
*
*        USED AS A DSECT IN - N/A
*
*        MACROS USED -
*        SMPPI
*        LOAD
*        DELETE
*
*        ENTRY POINT - CSECT NAME IERRC9
*                      ENTRY FROM DEFINITION ROUTINE VIA
*                         LOAD  EP=IERRC9,DCB=SORTLIB
*                         LR    LR,R0
*                         LA    R0,IERRC_   NAME OF CALLING MODULE
*                         LA    RC,TASSG    ASSIGNMENT LOAD LIST
*                         BR    R15
*                      RETURN VIA REGISTER R14 - SEE EXITS
*                      EACH ASSIGNMENT ROUTINE
*                         BR    R14
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIALG    PPISORCE
*        PPIAMA    PPICNTL
*        PPICONV   PPIX11
*        PPIADSSC  PPIWRT
*        PPISLIB
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        MODULE INTERFACE LIST - PPIALG TO PPIX16
*
*        EXTERNAL ROUTINES -
*        PPIADSSC - PRINT ROUTINE
*        PPICONV  - CONVERT ROUTINE
*
*        EXTERNAL PARAMETERS -
*               PPIADSSC- R0  -> MESSAGE
*                         R1   = L'MESSAGE
*               PPICONV - R0  -  CONTENTS TO BE CONVERTED
*                         R1  -> CONVERTED VALUE OF R0
*
*        EXITS - NORMAL - EACH ASSIGNMENT ROUTINE
*                                LOAD  EPLOC=CIERXXX,DCB=SORTLIB
*                                LR    R15,R0
*                                BALR  R14,R15
*                       CIERXXX  DC    CL8'IER___'
*                                L     R11,PPIWRT+4 FIRST RUNNING
*                                B     DISP(0,R11)
*                                WHERE  DISP = 8 FOR MERGE ONLY/PH3
*                                            = 16 FOR PH1/PH2
*
*        EXITS - ERROR -
*        PPIADSSC - ERROR HAS OCCURRED WHILE DELETING A MODULE
*
*        TABLES/WORK AREAS -
*        TASSG - LIST OF ASSG ROUTINES TO BE EXECUTED IN THE PHASE
*
*        NOTES -
*        THIS MODULE IS USED IN ALL THREE PHASES
*
IERRC9   CSECT
*
         USING *,R11               PROGRAM BASE
         USING IERRCA,R13          PPIA BASE
*
         IERENTRY 'IERRC9 &SYSDATE &SYSTIME'
*
         LR    R11,R15             SET BASE
*
*        MOVE TABLE OF ASSG NAMES PASSED FROM EITHER RC6, RC7 OR RC8
*
         MVC   TASSG(L'TASSG),0(R2)
*
*        DELETE THE CALLING ROUTINE WITH ADDR IN R0
*        IE IERRC6, RC7 OR RC8
*
         BAS   R5,DELETERS         SPECIAL ENTRY POINT INTO DELETER
*
*        LOAD OPTIONAL CHECK POINT MODULE
*
         PPITEST  PPICHKPT         CHECKPOINT ACTIVATED ?
         BZ    RC9011              NO, BYPASS LOAD
         ICM   R2,B'1111',PPICHKAD  CHECKPOINT LOADED ?
         BNZ   RC9011              CHECKPOINT IS LOADED, BRANCH
         LA    R0,CIERCHK          R0 -> IERCHK
         L     R1,PPISLIB          R1 -> SORTLIB
*
         LOAD  EPLOC=(0),DCB=(1)   LOAD CHECKPOINT MODULE
*
         ST    R0,PPICHKAD         STORE ADDR OF CHECKPOINT IN PPI
         MVC   IER988B,CIERCHK+3   MOVE MESSAGE ID INTO MESSAGE
         BAS   R10,LOGGER          LOG MODULE LOADING
*
*        LOAD ALL MODULES ACTIVATED IN PPI LIST (PPIALG TO PPIX16)
*
RC9011   LA    R2,30               R2 = NO OF POSSIBLE ENTRIES IN LIST
         LA    R3,PPIALG           R3 -> RUNNING PROGRAM LOAD LIST
         LA    R7,RUNTAB           R7 -> TABLE OF PPI NAME ENTRIES
RC9010   ICM   R4,B'1111',0(R3)    ENTRY ACTIVATED ?
         BZ    RC9020              NO, GOTO NEXT ENTRY
         CLI   0(R3),C'R'          SORT RUNNING PROGRAM ?
         BE    RC9014              YES
         CLI   0(R3),C'A'          ASSIGNMENT PROGRAM ?
         BE    RC9014              YES
         CLI   0(R3),C'9'          CRCX ASSIGNMENT PROGRAM ?
         BE    RC9014              YES
         CLI   0(R3),C'8'          CRCX RUNNING PROGRAM ?
         BNE   RC9070              NO
RC9014   MVI   IER988D+1,C'-'      MOVE IN MINUS
         MVC   IER988D+3(4),0(R7)  MOVE IN PPI NAME
         BAS   R5,LOADRUN          LOAD SORT RUNNING PROGRAM
RC9020   LA    R3,8(,R3)           UPDATE PPI LIST POINTER
         LA    R7,4(,R7)           INCR TABLE OF PPI NAME PTR
         BCT   R2,RC9010           LOOP PROCESSING LIST
*
*        LOAD THE ASSIGNMENT ROUTINES SPECIFIED IN TABLE TASSG
*
         LA    R3,TASSG            R3 -> ASSGN TABLE
RC9030   BAS   R5,LOADASS          LOAD SORT ASSIGNMENT PROGRAM
*
*        EXECUTE THE ASSIGNMENT ROUTINE
*        AS THE ASSIGNMENT ROUTINES DO NOT SAVE REGS THIS MODULE
*        MUST SAVE AND RESTORE ITS WORKING REGS ACROSS THE CALL
*        TO THE ASSIGNMENT ROUTINE
*
         PPITEST  PPITMODF         MODULE FLOW DIAGNOSTICS ?
         BZ    RC9051              NO, BRANCH
         PPITEST  PPIDIAG+PPIDSIM  GENERATE DIAGNOSTIC MESSAGES ?
         BZ    RC9051              NO, BRANCH
         MVC   IER980A,CIERXXX     MOVE MODULE NAME INTO MSG
         LM    R0,R1,IER980        IER980I CALLING XXXXXX
         L     R15,PPIADSSC        PRINT MESSAGE
         BAS   R14,12(,R15)        CALL MESSAGE WRITER
RC9051   STM   R0,R12,SAVEAREA     SAVE THE REGS
         L     R15,ADDRASSG
         DROP  R11
         BASR  R14,R15             CALL THE ASSIGNMENT ROUTINE
         USING *,R14
         LM    R0,R12,SAVEAREA     RESTORE THE REGS
         DROP  R14
         USING IERRC9,R11          RESTORE THE BASE ADDRESSABILITY
*
*        DELETE THE ASSIGNMENT ROUTINE AFTER EXECUTION
*
         BAS   R5,DELETER          DELETE THE ASSIGNMENT ROUTINE
         LA    R3,3(,R3)           UPDATE TO NEXT TABLE ENTRY
         CLI   0(R3),X'FF'         END OF LIST ?
         BNE   RC9030              NO, GET NEXT TABLE ENTRY
*
*        DELETE THOSE MODULES IN PPI LIST THAT WERE NEEDED ONLY
*        AT ASSGN TIME FOR EXAMPLE, THE ASSGN MESSAGE MODULE
*
         LA    R2,3                NO OF ENTRIES MAY DELETE
         LA    R3,PPIAMA           START OF LIST
         SR    R4,R4
RC9050   CL    R4,0(,R3)           ENTRY ACTIVATED ?
         BE    RC9060              NO, GOTO NEXT ENTRY
         MVC   CIERXXX+3(3),0(R3)  YES, MOVE MODULE ID IN CONSTANT
         BAS   R5,DELETER          DELETE THE MODULE
         ST    R4,0(,R3)           ZERO OUT NAME
RC9060   LA    R3,8(,R3)           UPDATE START POINTER
         BCT   R2,RC9050           END OF LIST CHECK
*
*        DELETE USER EXITS E11, E21, AND E31 IF THEY WERE
*        ACTIVATED AND ARE ALONE IN A LOAD MODULE
*
         MVI   CUSERXX,C' '        BLANK OUT CUSERXX
         MVC   CUSERXX+1(L'CUSERXX-1),CUSERXX
         LA    R2,2                NO OF POSSIBLE ENTRIES
         LA    R3,PPIX11           R3 -> START OF LIST
         SR    R4,R4
RC9SW090 CL    R4,0(,R3)           EXIT ACTIVATED ?
         BE    RC9SW100            NO, GO CHECK NEXT
         CLI   0(R3),C'P'          EXIT ALONE IN A LOAD MODULE ?
         BE    RC9SW100            NO, GO CHECK NEXT
         MVC   CUSERXX(3),0(R3)    MOVE MODULE ID INTO CONSTANT
         LA    R0,CUSERXX
         BAS   R5,DELETERS         DELETE USER MODULE
         ST    R4,0(,R3)           ZERO OUT NAME
RC9SW100 LA    R3,8(,R3)           UPDATE LIST POINTER
         BCT   R2,RC9SW090         END OF LIST CHECK ?
*
*        EXIT FROM ROUTINE
*
         L     R12,PPIAXERT        R12 -> EQUALS OR EXTRACT ROUTINE
         L     R11,PPIWRT+4        LINK TO FIRST RUNNING PGM
         PPITEST  PPIPH3+PPIMERGO  PH3 AND MERGE ONLY ?
         BNZ   8(,R11)             DISPLACEMENT IS = 8 - MERGE ONLY/PH3
         B     16(,R11)                             16 - PH1/PH2
*
*        DETERMINE WHERE THE USER EXIT RTNS ARE RESIDENT
*        SYSLMOD OR PRIVATE LIBRARY
*
RC9070   MVC   CUSERXX,0(R3)       MOVE MODULE NAME INTO CUSERXX
         LA    R15,CUSERXX+7       R15 -> LAST BYTE OF CUSERXX
         LA    R14,7
RC9070A  CLI   0(R15),C' '         < BLANK ?
         BNL   RC9070B
         MVI   0(R15),C' '         MAKE BLANK
RC9070B  BCTR  R15,0
         BCT   R14,RC9070A
         CLI   0(R3),C'E'          STAND ALONE USER EXIT IN PRIV LIB ?
         BE    RC9080              YES
*
*        USER EXIT RTNS ARE ON SYSLMOD
*        THEEY WERE LINK EDITED AT SORT TIME WITH IEREX_ RESOLVER
*        ROUTINE THAT MUST BE EXECUTED TO PLACE ADDRS CORRECTLY
*        INTO THE PPI
*
         L     R1,PPISORCE+4       SYSLMOD DCB ADDR
         BAS   R5,LOADEXIT         LOAD USER PROGRAMS LE WITH RESOLVE
*                                  RTN -IEREX1,-EX2,-EX3
*
*        EXECUTE THE RESOLVER ROUTINE
*
         PPITEST  PPITMODF         MODULE FLOW DIAGNOSTICS ?
         BZ    RC9071              NO, BRANCH
         PPITEST  PPIDIAG+PPIDSIM  GENERATE DIAGNOSTIC MESSAGES ?
         BZ    RC9071              NO, BRANCH
         MVC   IER980A,CUSERXX     MOVE MODULE NAME INTO MSG
         LM    R0,R1,IER980        IER980I CALLING XXXXXX
         L     R15,PPIADSSC        PRINT MESSAGE
         BAS   R14,12(,R15)        CALL MESSAGE WRITER
RC9071   STM   R0,R12,SAVEAREA     SAVE THE REGS
         L     R15,4(,R3)
         DROP  R11
         BASR  R14,R15             CALL THE ASSIGNMENT ROUTINE
         USING *,R14
         LM    R0,R12,SAVEAREA     RESTORE THE REGS
         DROP  R14
         USING IERRC9,R11          RESTORE THE BASE ADDRESSABILITY
         B     RC9020              GET NEXT ENTRY
*
*        USER EXIT RTNS ARE IN PRIVATE LIBRARY
*
RC9080   L     R1,PPISORCE         USER LIBRARY DCB ADDR
         LA    R5,RC9020           SET RETURN ADDR
         B     LOADEXIT            LOAD USER PROGRAM
*
*        DELETE ROUTINE
*
*        R0 -> SYMBOLIC NAME OF MODULE TO BE DELETED
*        R5  = RETURN ADDR
*
DELETER  LA    R0,CIERXXX
*
DELETERS EQU   *                   SPECIAL ENTRY PT FOR INITIAL DELETE
*                                  OF CALLING MODULE IERR6, 7 OR 8
         PPITEST  PPITMODF         MODULE FLOW DIAGNOSTICS ?
         BZ    DELETERN            NO, BRANCH
         PPITEST  PPIDIAG+PPIDSIM  GENERATE DIAGNOSTIC MESSAGES ?
         BZ    DELETERN            NO, BRANCH
         LR    R6,R0               SAVE CONTENTS OF R0
         MVC   IER989A,0(R6)       MOVE MODULE NAME INTO MSG
         LM    R0,R1,IER989        IER989 DELETING XXXXXXXX
         L     R15,PPIADSSC        MESSAGE WRITER RTN
         BAS   R14,12(,R15)        CALL MESSAGE WRITER
         LR    R0,R6               RESTORE CALLERS R0
*
DELETERN DELETE  EPLOC=(0)
*
         B     DELETERB(R15)       DELETE COMPLETED
*
DELETERB B     0(,R5)              +00 SUCCESSFUL COMPLETION, RETURN
*                                  +04 ERROR ON DELETING MODULE
         L     R15,PPIADSSC        PRINT DELETE ERROR
         BAS   R14,28(,R15)        MESSAGE WITH SPECIAL ENTRY
         L     R15,PPIADSSC        TERMINATE THE JOB
         BAS   R14,16(,R15)        GOTO SSC, NO RETURN
*
*        LOAD RUNNING PROGRAMS ROUTINE
*
*        R3 -> ENTRY IN PPILIST
*        R5 -> RETURN
*
LOADRUN  L     R1,PPISLIB          R1 -> SORTLIB DCB ADDR
         MVC   CIERXXX+3(3),0(R3)  MOVE MODULE ID INTO CONSTANT
         LA    R0,CIERXXX          R0 -> NAME OF MODULE TO LOAD
*
         LOAD  EPLOC=(0),DCB=(1)   LOAD MODULE
*
         ST    R0,4(,R3)           SAVE MODULE LOADED ADDR
         MVC   IER988A,=C'IER'     SET MODULE PREFIX
         MVC   IER988B,0(R3)       MOVE MODULE ID INTO MESSAGE
         BAS   R10,LOGGER          CALL MODULE LOAD LOGGER
         BR    R5                  RETURN TO CALLER
*
*        LOAD ASSIGNMENT PROGRAMS ROUTINE
*
*        R3 -> ENTRY IN ASSIGNMENT TABLE
*        R5 -> RETURN
*
LOADASS  L     R1,PPISLIB          R1 -> SORTLIB DCB ADDR
         MVC   CIERXXX+3(3),0(R3)  MOVE MODULE ID INTO CONSTANT
         LA    R0,CIERXXX          R0 -> NAME OF MODULE TO LOAD
*
         LOAD  EPLOC=(0),DCB=(1)   LOAD MODULE
*
         ST    R0,ADDRASSG         SAVE MODULE LOADED ADDR
         MVC   IER988A,=C'IER'     SET MODULE PREFIX
         MVC   IER988B,0(R3)       MOVE MODULE ID INTO MESSAGE
         BAS   R10,LOGGER          CALL MODULE LOAD LOGGER
         BR    R5                  RETURN TO CALLER
*
*        LOAD USER EXIT PROGRAMS ROUTINE
*
*        R1 -> DCB
*        R3 -> ENTRY IN PPILIST
*        R5 -> RETURN
*
LOADEXIT LA    R0,CUSERXX          R0 -> NAME OF MODULE TO LOAD
*
         LOAD  EPLOC=(0),DCB=(1)   LOAD MODULE
*
         ST    R0,4(,R3)           SAVE MODULE LOADED ADDR
         MVC   IER988A,CUSERXX     SET MODULE PREFIX
         MVC   IER988B,CUSERXX+3   MOVE MODULE ID INTO MESSAGE
         BAS   R10,LOGGER          CALL MODULE LOAD LOGGER
         BR    R5                  RETURN TO CALLER
*
*        LOGGER ROUTINE
*        DIAGNOSTIC MESSAGE IER988I IERXXX LOADED AT NNNNNNÝ- XXXX¨
*
LOGGER   PPITEST  PPIDIAG+PPIDSIM  GENERATE DIAGNOSTIC MESSAGES ?
         BZR   R10                 NO, RETURN TO CALLER
         PPITEST  PPITMODF         MODULE FLOW DIAGNOSTICS ?
         BZR   R10                 NO, RETURN TO CALLER
         L     R15,PPICONV+4       R0 CONTAINS ADDR TO BE CONVERTED
         BAS   R14,4(,R15)         CALL CONVERT RTN - BIN TO HEX
         MVC   IER988C,2(R1)       MOVE HEX FORMATTED ADDR TO MESSAGE
LOGGERA  LM    R0,R1,IER988        IER988I IERXXX LOADED AT
         L     R15,PPIADSSC        PRINT MESSAGE
         BAS   R14,12(,R15)        CALL MESSAGE WRITER
         MVI   IER988D,C' '
         MVC   IER988D+1(L'IER988D-1),IER988D  BLANK OUT PPI FIELD
         BR    R10                 RETURN TO CALLER
*
*        CONSTANTS AND WORK AREAS
*
IER980   DC    A(IER980T)
         DC    A(L'IER980T+L'IER980A)
IER980T  DC    C'IER980I Calling '
IER980A  DC    CL6' '
*
IER988   DC    A(IER988T)
         DC    A(IER988X-IER988T)
*
IER988T  DC    C'IER988I '
IER988A  DC    C'IER'
IER988B  DC    C'XXX'
         DC    C' Loaded at '
IER988C  DC    C'XXXXXX'
IER988D  DC    C' -     '          FUNCTION OF MODULE FROM PPI
IER988X  EQU   *                   FOR L'MSG CALC
*
IER989   DC    A(IER989T)
         DC    A(L'IER989T+L'IER989A)
IER989T  DC    C'IER989I Deleting '
IER989A  DC    CL6' '
*
CIERCHK  DC    CL8'IERCHK'
*
ADDRASSG DC    A(0)                ADDR OF LOADED ASSIGNMENT MODULE
SAVEAREA DC    18A(0)              SAVE AREA FOR ASSIGNMENT RTN CALLS
*
CIERXXX  DC    CL8'IERXXX  '       SORT PROGRAMS ENTRY NAME
CUSERXX  DC    CL8'PH1'            USER EXITS PROGRAM MODEL FOR
*                                  -PH1,-2,-3    ON SYSLMOD(LE)
*                                  -E11,ETC      ON USER LIBRARY
*                                  -S11,-21,-31  ON SYSLMOD(LE)
*
*        TABLES
*
*        FUNCTIONAL NAMES OF RUNNNING MODULES FOR MSG IER988
*        THIS LIST MUST MATCH THE PPI ENTRIES
*        PPIALG -  PPIX16
*
RUNTAB   DC    CL4'ALG '
         DC    CL4'DEB '
         DC    CL4'NET '
         DC    CL4'BLK '
         DC    CL4'WRT '
         DC    CL4'VMV '
         DC    CL4'RD  '
         DC    CL4'DEB2'
         DC    CL4'NETM'
         DC    CL4'BLK2'
         DC    CL4'INT '
         DC    CL4'CONV'
         DC    CL4'EOF '
         DC    CL4'RMA '
         DC    CL4'RMB '
         DC    CL4'AMA '
         DC    CL4'AMB '
         DC    CL4'OPEN'
         DC    CL4'X11 '
         DC    CL4'X21 '
         DC    CL4'X15 '
         DC    CL4'X25 '
         DC    CL4'X17 '
         DC    CL4'X27 '
         DC    CL4'X18 '
         DC    CL4'X28 '
         DC    CL4'X19 '
         DC    CL4'X29 '
         DC    CL4'X61 '
         DC    CL4'X16 '
*
TASSG    DC    XL60'00'            LIST OF ASSGN ROUTINES TO BE
*                                  EXECUTED IN THE PHASE. EACH ENTRY
*                                  IS A 3 BYTE CHARACTER ID FOR A
*                                  SPECIFIC MODULE. FOR EXAMPLE,
*                                  IERAGC'S ENTRY WOULD BE AGC
*
*        LTORG
*
         LTORG
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERRDB   0101-20211-20211-1200-00102-00102-00000-RELEASE 00
RDB      TITLE 'IERRDB - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRDB
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 1 RUNNING MODULE - FIXED LENGTH SORT W/O E15
*        THE FUNCTION OF THIS MODULE IS TO HANDLE FIXED LENGTH
*        RECORDS USING THE GET LOCATE MACRO. THERE IS NO DATA
*        CHAINING. SORT RECORD LENGTH IS <= 256 BYTES. THIS
*        MODULE CONTAINS ONE INLINE MOVE INSTRUCTION TO MOVE THE
*        RECORD INTO RSA. THIS MODULE HANDLES UP TO 5 NON
*        CONTIGUOUS RSA'S. THE MODULE THEN PASSES TO THE
*        REPLACEMENT NETWORK THE RECORDS LOCATION IN RSA
*
*        INITIALLY FLOW IS BETWEEN DEBLOCK AND THE REPLACEMENT
*        NETWORK. AFTER G RECORDS ARE IN RSA THE NETWORK RETURNS
*        TO DEBLOCK FOR THE G+1 RCD TO FORCE A WINNER AND ALLOW
*        DEBLOCK TO MODIFY ITSELF FOR NORMAL FLOW. WHEN DEBLOCK
*
*        RETURNS TO THE NETWORK WITH THE G+1 RECORD A WINNER IS
*        GIVEN TO BLOCK. THE NORMAL FLOW THEN IS DEBLOCK NETWORK
*        BLOCK. AT EOF DEBLOCK IS MODIFIED TO BRANCH DIRECTLY TO
*        THE NETWORK AS SOON AS IT IS ENTERED BY BLOCK SO THAT
*        THE TREE MAY BE FLUSHED
*
*        MODULES IN WHICH THIS MODULE APPEARS AS A DSECT - IERADB
*
*        MACROS USED BY MODULE -
*        SMPPI
*        GET
*
*        ENTRY POINTS -  ENTRY FROM NETWORK
*                          CALLING SEQUENCE -
*                            L    R11,PPIDEB+4
*                            B    0(R11)     AFTER G RCDS
*                            B    8(R11)     FILL TREE
*                        ENTRY FROM EOF
*                          CALLING SEQUENCE -
*                            L    R11,PPIDEB+4
*                            B    4(R11)     EOF
*                        ENTRY FROM BLOCK OR ALGORITHM
*                          CALLING SEQUENCE -
*                            L    R11,PPIDEB+4
*                            B    8(R11)     BLK=NRML,ALG=EOS
*                        ENTRY FROM GET
*                          CALLING SEQUENCE -
*                            BR   14         RETURN REG
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPINET     PPISTOPF   PPISTOPR
*        PPIBINSZ
*        ADDR OF NETWORK, SIZE OF A BIN IN RSA
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPICOUNT   PPISTOPR
*        UPDATE RECORD COUNTER
*
*        EXTERNAL ROUTINES - NONE
*
*        EXTERNAL PARAMETERS - SEE REGISTERS
*
*        EXITS - NORMAL - EXIT TO NETWORK
*                           CALLING SEQUENCE -
*                             L    R11,PPINET+4
*                             B    4(R11)     FILL TREE
*                             B    8(R11)     ON EOF
*                             B    12(R11)    NORMAL
*                             B    16(R11)    FLUSH TREE
*                         EXIT TO GET
*                           CALLING SEQUENCE -
*                             GET (R6)
*
*        EXITS - ERROR - NONE
*
*        TABLES/WORK AREAS -
*        TABLRSA - TABLE CONSISTING OF UP TO 5 NON CONTIGUOUS
*        RSA AREA ENTRIES WITH 8 BYTE ENTRIES FOR EACH RSA AREA
*
*        NOTES -
*        THIS MODULE WILL EXECUTE FOR FIXED LENGTH SORTS HAVING
*        RECORD LENGTHS <= 256 BYTES AND W/O EXITS E15 OR E16
*
IERRDB   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRDB SOURCE
*
*----------------------------------------------------------------------
*
         COPY IERRDBI
*
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERRDBI  0101-20211-20211-1200-00141-00141-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERRDB SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERRBDI
*
         USING *,R11               THIS MODULE BASE REG
         USING IERRCA,R13          PPI ADDR
*
IERDD1   B     RDB1050             +00 ENTRY FROM SORT NETWORK G RCDS
*                                      ARE IN THE TREE (ONCE ONLY)
         B     RDB1060             +04 ENTRY FROM EOF ROUTINE
*
*        NORMAL ENTRY FROM NETWORK WHILE FILLING TREE
*        ENTRY FROM ALGORITHM ON OUTPUT EOS
*        NORMAL ENTRY FROM BLOCK WHILE RUNNING
*
RDB1010  L     R7,ADCONPTR         +08 LOAD RSA TABLE POINTER
*                                  WILL BE OVERLAYED BY B RDB1020 AFTER
*                                  RSA IS FILLED WITH G+1 RCDS AND
*                                  BY A BR TO THE NETWORK AFTER EOF
         LM    R3,R4,0(R7)         R3 -> START OF RSA RCD
*                                  R4 THIS RSA REMAINING BYTE COUNT
RDB1020  L     R6,KADCB            ADDR OF THE INPUT DCB
         PPITEST PPISTOPF          STOP AFTER XXX RECORDS VALUE SET ?
         BZ    RDB102A             NO, BRANCH
         L     R15,DCBEODAD-IHADCB(R6)  R15 -> DCB EOD RTN
         ICM   R14,B'1111',PPISTOPR  R14 = STOP AFTER RECORD COUNT
         BZR   R15                 READ ENOUGH RECORDS, TRIGGER
*                                  DCB EOD EXIT ROUTINE
         BCTR  R14,0               DECR COUNT
         STCM  R14,B'1111',PPISTOPR  STORE DECREMENTED COUNT
*
RDB102A  GET   (R6)                ON RETURN R1 -> NEXT RECORD
*
RDBRTRN  S     R4,PPIBINSZ         SUBTRACT BINSIZE FROM RSA BYTE COUNT
*                                  WILL BE B RDLOADRC AFTER G+1 RCDS
         BM    RDNEWRSA            MINUS BRANCH (RECORD CAN'T FIT IN
*                                  THIS RSA)
RDBOVLAY NOP   RDBLAST             WILL BE A BR AFTER TREE HAS G RCDS
*
*        MOVE RECORD FROM INPUT BUFFER TO RSA
*
RDLOADRC LR    R2,R1               INPUT RCD ADDR FOR EXTRACT RTN
RDB1030  MVC   0(1,R3),0(R2)       MOVE RCD FROM INPUT BFR TO RSA
*                                  LENGTH SET BY AP
*
*        UPDATE RECORD COUNTER
*
         L     R6,PPICOUNT
         LA    R6,1(,R6)           INCR RCD COUNT BY 1
         ST    R6,PPICOUNT
*
*        UPDATE RSA TABLE PARAMETERS
*
RDB1040  LR    R5,R3               WILL BE OVLAYED BY BR TO NETWORK
*                                  AFTER G+1 RCDS
         A     R5,PPIBINSZ         UPDATE RSA ADDR TO NEXT BIN
         ST    R5,0(,R7)           STORE IN RSA TABLE
         ST    R4,4(,R7)           STORE THIS RSA REMAINING BYTE COUNT
*
*        INTERFACE WITH SORT NETWORK DURING FILL OF TREE
*
         L     R11,PPINET+4        ADDR OF NETWORK
         B     4(R11)              BR TO FILL TREE
*
*        UPDATE POINTER TO NEXT RSA TABLE ENTRY (NEXT RSA AREA)
*
RDNEWRSA LA    R7,8(,R7)           UPDATE PTR
         ST    R7,ADCONPTR         SAVE UPDATED PTR TO THE TABLE
         LM    R3,R4,0(R7)         NEW RSA PARAMETERS
         B     RDBRTRN             GO PROCESS THIS INPUT RCD
*
*        SORT TREE HAS BEEN FILLED
*        THE NEXT DEBLOCKED RECORD IS MOVED TO THE NEXT SPACE IN
*        RSA. IN ALL SUBSEQUENT ENTRIES TO THIS MODULE, R3 WILL
*        POINT TO THE WINNER RECORD IN RSA. THE DEBLOCKED RECORD
*        MUST BE MOVED TO THE LOCATION INDICATED BY R3. THIS
*        MODULE MUST NOW ENTER THE SORT NETWORK AT ITS NORMAL
*        ENTRY POINT. THE FOLLOWING CODE MODIFIES THIS MODULE TO
*        EFFECT THESE NEW REQUIREMENTS
*
RDB1050  MVI   RDBOVLAY+1,X'F0'    MAKE THE INSTR A DIRECT BRANCH
         B     RDB1010             GO PROCESS THE G+1 RECORD
*
RDBLAST  MVC   RDB1010(4),KMOD1
         MVC   RDBRTRN(4),KMOD2
         MVC   RDB1040(8),KMOD3
         B     RDLOADRC            MOVE THIS INPUT RCD TO RSA(G+1 RCD)
*
*        WHEN EOF HAS BEEN REACHED THERE ARE NO MORE RECORDS TO
*        BE DEBLOCKED BUT THE SORT NETWORK MUST EMPTY ITS TREE.
*        FUTURE ENTRIES TO THIS MODULE DO NO PROCESSING, BUT
*        MERELY EXIT TO THE SORT NETWORK AT ITS EMPTYING ENTRY.
*        THE FOLLOWING CODING MODIFIES THE PRESENT ENTRY POINT TO
*        EFFECT THIS CHANGE AND THEN EXITS TO THE SORT NETWORK
*        AT ITS EOF ENTRY
*
RDB1060  MVC   RDB1010(8),KMOD4    GO DIRECTLY TO SORT NETWORK
*
*        INTERFACE TO SORT NETWORK ON EOF
*
         L     R11,PPINET+4        ADDR OF SORT NETWORK
         B     8(R11)
*
*        ADCONS
*
ADCONPTR DC    A(TABLRSA)
*
*        CONSTANTS
*
KMOD1    B     RDB1020             OVERLAY RDB1010 AFTER G+1 RCDS
KMOD2    B     RDLOADRC            OVERLAY RDBRTRN AFTER G+1 RCDS
KMOD3    L     R11,PPINET+4        OVERLAY RDB1040 AFTER G+1 RCDS
         B     12(,R11)            NORMAL BRANCH TO NETWORK
KMOD4    L     R11,PPINET+4        OVERLAY RDB1010 AFTER EOF
         B     16(,R11)            FLUSH BRANCH TO NETWORK
*
KADCB    DC    F'0'                INPUT DCB ADDR LOADED BY AP
*
*        WORK AREAS/TABLES
*
TABLRSA  DC    5D'0'               SPACE AVAILABLE FOR 5 NON CONTIGUOUS
*                                  RSA ENTRIES EACH ENTRY 8 BYTES
*                                  4 BYTES ADDR IN BIN TO MOVE RCD
*                                  4 BYTES REMAINING BYTE COUNT OF
*                                  THIS RSA
*                                  INITIALIZED BY AP
*
*        DCB DSECT
*
         PRINT NOGEN
*
         DCBD  DSORG=PS,DEVD=(DA,TA)
*
         PRINT GEN
*
*
./ ADD NAME=IERRDC   0101-20211-20211-1200-00116-00116-00000-RELEASE 00
RDC      TITLE 'IERRDC - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRDC
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 1 RUNNING MODULE - FIXED LENGTH SORT W/O E15
*        THIS MODULE HANDLES FIXED LENGTH RECORDS USING THE GET
*        LOCATE MACRO. THERE IS NO DATA CHAINING. SORT RECORD
*        LENGTH IS GREATER THAN 256 BYTES SO THIS MODULE BRANCHES
*        TO A MOVE ROUTINE IN GENERATED CORE TO MOVE THE RECORD
*        INTO RSA. THIS MODULE HANDLES UP TO 5 NONCONTIGUOUS
*        RSA'S. THE MODULE PASSES TO THE REPLACEMENT NETWORK THE
*        RECORD'S LOCATION IN RSA
*
*        INITIALLY FLOW IS BETWEEN DEBLOCK AND THE REPLACEMENT
*        NETWORK. AFTER G RECORDS ARE IN RSA THE NETWORK RETURNS
*        TO DEBLOCK FOR THE G+1 RCD TO FORCE THE WINNER OUT OF
*        THE TREE AND ALSO ALLOWING DEBLOCK TO MODIFY ITSELF FOR
*        NORMAL FLOW. WHEN DEBLOCK RETURNS TO THE NETWORK WITH
*        THE G+1 RECORD THE WINNER IS GIVEN TO BLOCK BY THE
*        NETWORK. THE NORMAL FLOW THEN IS DEBLOCK NETWORK BLOCK
*        DEBLOCK ETC. AT EOF DEBLOCK IS MODIFIED TO BRANCH
*        DIRECTLY TO THE NETWORK AS SOON AS IT IS ENTERED BY
*        BLOCK SO THAT THE TREE MAY BE FLUSHED
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - IERADC
*
*        MACROS USED BY MODULE -
*        SMPPI
*        GET
*
*        ENTRY POINTS - ENTRY FROM NETWORK
*                       CALLING SEQUENCE -
*                           L    R11,PPIDEB+4
*                           B    0(R11)     AFTER G RCDS
*                           B    8(R11)     FILL TREE
*
*                       ENTRY FROM EOF
*                       CALLING SEQUENCE -
*                           L    R11,PPIDEB+4
*                           B    4(R11)     EOF
*
*                       ENTRY FROM BLOCK OR ALGORITHM
*                       CALLING SEQUENCE -
*                           L    R11,PPIDEB+4
*                           B    8(R11)     BLK=NRML,ALG=EOS
*
*                       ENTRY FROM GET OR MOVE RTN
*                       CALLING SEQUENCE
*                           BR   14         RETURN REG
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPINET    PPISTOPF  PPISTOPR
*        PPIBDSVA
*        PPIBINSZ
*
*        ADDR OF NETWORK MOVE ROUTINE
*        SIZE OF A BIN USED TO UPDATE RSA POINTER
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPICOUNT  PPISTOPR
*        UPDATE RECORD COUNTER
*
*        EXTERNAL ROUTINES -
*        MOVE ROUTINE IN GENERATED STORAGE TO MOVE RECORD FROM INPUT
*        BUFFER TO RSA
*
*        EXTERNAL PARAMETERS - SEE REGISTERS
*
*        EXITS - NORMAL - EXIT TO NETWORK
*                         CALLING SEQUENCE -
*                             L    R11,PPINET+4
*                             B    4(R11)     FILL TREE
*                             B    8(R11)     ON INPUT EOF
*                             B    12(R11)    NORMAL RUNNING
*                             B    16(R11)    FLUSH TREE
*
*                         EXIT TO GET
*                         CALLING SEQUENCE -
*                             GET(R6)
*
*                         EXIT TO MOVE RTN
*                         CALLING SEQUENCE -
*                             L    R15,PPIBDSVA+4 MOVE RTN ADDR
*                             BALR R14,R15
*
*        EXITS - ERROR - NONE
*
*        TABLES/WORK AREAS -
*        TABLRSA - TABLE CONSISTING OF UP TO 5 ENTRIES. AN 8
*        BYTE ENTRY FOR EACH NONCONTIGUOUS RSA
*
*        NOTES -
*        THIS MODULE WILL EXECUTE FOR FIXED LENGTH SORTS HAVING
*        RECORD LENGTHS GREATER THAN 256 BYTES AND W/O EXITS E15
*        OR E16
*
IERRDC   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRDC SOURCE
*
*----------------------------------------------------------------------
*
         COPY IERRDCI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERRDCI  0101-20211-20211-1200-00153-00153-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERRDC SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERRDCI
*
         USING *,R11               BASE REG
         USING IERRCA,R13
*
IERDD1   B     RDC1050             ENTRY FROM SORT NETWORK. G RECORDS
*                                  ARE IN THE TREE (ONCE ONLY)
         B     RDC1060             ENTRY FROM EOF ROUTINE
*
*        NORMAL ENTRY FROM NETWORK WHILE FILLING TREE
*        ENTRY FROM ALGORITHM ON OUTPUT EOS, NORMAL ENTRY FROM
*        BLOCK WHILE RUNNING
*
RDC1010  L     R7,ADCONPTR         LOAD RSA TABLE POINTER. THIS INSTR
*                                  WILL BE OVLAYED BY B RDB1020 AFTER
*                                  RSA IS FILLED WITH G+1 RCDS AND
*                                  BY A BR TO THE NTWK AFTER EOF
         L     R3,0(,R7)           ADDR OF AREA IN RSA FOR INPUT RCD
         L     R8,4(,R7)           REMAINING BYTE COUNT OF RSA
RDC1020  L     R6,KADCB            ADDR OF THE INPUT DCB
         PPITEST PPISTOPF          STOP AFTER XXX RECORDS VALUE SET ?
         BZ    RDC102A             NO, BRANCH
         L     R15,DCBEODAD-IHADCB(R6)  R15 -> DCB EOD RTN
         ICM   R14,B'1111',PPISTOPR  R14 = STOP AFTER RECORD COUNT
         BZR   R15                 READ ENOUGH RECORDS, TRIGGER
*                                  DCB EOD EXIT ROUTINE
         BCTR  R14,0               DECR COUNT
         STCM  R14,B'1111',PPISTOPR  STORE DECREMENTED COUNT
*
RDC102A  GET   (R6)
*
*        GET RETURNS ADDR OF RECORD IN INPUT BUFFER IN R1
*
RDCRTRN  S     R8,PPIBINSZ         SUBTRACT BINSIZE FROM RSA BYTE COUNT
*                                  THIS WILL BE OVLAYED BY B RDLOADRC
*                                  AFTER G+1 RCDS
         BM    RDNEWRSA            MINUS, RCD CANT FIT IN THIS RSA
RDCOVLAY NOP   RDCLAST             WILL BE A BR AFTER TREE HAS G RCDS
*
*        LINK TO MOVE LIST WHICH MOVES THE RECORD FROM THE INPUT
*        BUFFER TO RSA
*        R4 -> INPUT BUFFER RCD
*        R5 -> RSA RCD
*
RDLOADRF LR    R5,R3               ADDR IN RSA TO MOVE INPUT RCD
         LR    R4,R1               INPUT RCD ADDR
         L     R15,PPIBDSVA+4      ADDR OF MOVE LIST
         BASR  R14,R15
*
*        UPDATE RECORD COUNTER
*        LOAD R2 IN CASE OF EXTRACT ROUTINE
*
         LR    R2,R1               ADDR OF RECORD IN INPUT BUFFER
         L     R6,PPICOUNT
         LA    R6,1(,R6)           INCR RECORD COUNT BY 1
         ST    R6,PPICOUNT
*
*        UPDATE RSA TABLE PARAMETERS
*
RDC1040  LR    R5,R3               ADDR OF RCD IN RSA. WILL BE OVLAYED
*                                  BY BR TO NETWORK AFTER G+1 RCDS
         A     R5,PPIBINSZ         UPDATE RSA ADDR TO NEXT BIN
         ST    R5,0(,R7)           STORE IN RSA TABLE
         ST    R8,4(,R7)           STORE THIS RSA REMAINING BYTE COUNT
*
*        INTERFACE WITH SORT NETWORK DURING FILL OF TREE
*
         L     R11,PPINET+4        ADDR OF NETWORK
         B     4(,R11)             BR TO FILL TREE
*
*        UPDATE POINTER TO NEXT ENTRY IN RSA TABLE
*        (EQUALS NEXT RSA AREA)
*
RDNEWRSA LA    R7,8(,R7)           UPDATE PTR
         ST    R7,ADCONPTR         SAVE UPDATED PTR
         L     R3,0(,R7)           NEW RSA RCD ADDR
         L     R8,4(,R7)           COUNT OF THIS NEW RSA
         B     RDCRTRN             BR TO PROCESS THE INPUT RCD
*
*        SORT TREE HAS BEEN FILLED
*
*        IN FUTURE ENTRIES TO THIS MODULE, R3 WILL POINT TO THE
*        WINNER RECORD IN RSA. THE NEW RECORD WHICH HAS BEEN
*        DEBLOCKED MUST BE MOVED TO THE LOCATION IN RSA INDICATED
*        BY R3
*
*        THIS MODULE MUST NOW ENTER THE SORT NETWORK AT 12(R11).
*        THE FOLLOWING CODE MODIFIES THIS MODULE TO EFFECT THESE
*        NEW REQUIREMENTS
*
RDC1050  MVI   RDCOVLAY+1,X'F0'    MAKE THE INSTR A DIRECT BRANCH
         B     RDC1010             BR TO PROCESS THE G+1 RCD
*
RDCLAST  MVC   RDC1010(4),KMOD1
         MVC   RDCRTRN(4),KMOD2
         MVC   RDC1040(8),KMOD3
         B     RDLOADRF            BR TO MOVE G+1 RECORD TO RSA
*
*        WHEN EOF HAS BEEN REACHED, THERE ARE NO MORE RECORDS TO
*        BE DEBLOCKED BUT THE SORT NETWORK MUST EMPTY ITS TREE.
*        FUTURE ENTRIES TO THIS MODULE DO NO PROCESSING, BUT
*        MERELY EXIT TO THE SORT NETWORK AT 16(R11). THE
*        FOLLOWING CODING MODIFIES THE PRESENT ENTRY POINT TO
*        EFFECT THIS CHANGE AND THEN EXITS TO THE SORT NETWORK AT
*        8(R11), THE EOF ENTRY
*
RDC1060  MVC   RDC1010(8),KMOD4    BR DIRECTLY TO SORT NETWORK
*
*
*        INTERFACE TO SORT NETWORK ON EOF
*
         L     R11,PPINET+4        ADDR OF SORT NETWORK
         B     8(R11)
*
*        ADCONS
*
ADCONPTR DC    A(TABLRSA)
*
*        CONSTANTS
*
KMOD1    B     RDC1020             OVERLAY RDC1010 AFTER G+1 RCDS
KMOD2    B     RDLOADRF            OVERLAY RDCRTRN AFTER G+1 RCDS
KMOD3    L     R11,PPINET+4        OVERLAY RDC1040 AFTER G+1 RCDS
         B     12(,R11)            NORMAL BR TO THE NETWORK
KMOD4    L     R11,PPINET+4        OVERLAY RDC1010 AFTER INPUT EOF
         B     16(,R11)            FLUSH BRANCH TO NETWORK
*
KADCB    DC    F'0'                INPUT DCB ADDR LOADED BY AP
*
*        WORK AREAS/TABLES
*
TABLRSA  DC    5D'0'               SPACE AVAILABLE FOR 5 NON CONTIGUOUS
*                                  RSA ENTRIES EACH ENTRY 8 BYTES
*                                  4 BYTES - ADDR IN BIN TO MOVE RECORD
*                                  4 BYTES - REMAINING BYTE COUNT OF
*                                            THIS RSA
*                                  THIS TABLE INITIALIZED BY IERADC
*
*        DCB DSECT
*
         PRINT NOGEN
*
         DCBD  DSORG=PS,DEVD=(DA,TA)
*
         PRINT GEN
*
./ ADD NAME=IERRDD   0101-20211-20211-1200-00163-00163-00000-RELEASE 00
RDD      TITLE 'IERRDD - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRDD
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 1 RUNNING MODULE - FIXED LENGTH WITH E15 AND/OR E16
*        THE FUNCTION OF THIS MODULE IS TO DEBLOCK FIXED
*        LENGTH RECORDS USING THE GET MACRO AND CONTAINS LINKAGE TO
*        THE USER MODIFICATION PROGRAMS VIA THE CALL MACRO
*        EXPANSION INSTRUCTIONS.
*        THE INPUT RECORDS ARE LOCATED IN AN INPUT BUFFER.
*        BEFORE MOVING THE RECORD TO THE WORK AREA CALLED RSA,
*        RECORD STORAGE AREA, THE MODULE BRANCHES TO THE USER
*        ROUTTINE THAT MAY -
*        1 - DELETE
*        2 - INSERT OR
*        3 - ALTER, LENGTHEN, SHORTEN, OR DO NOTHING TO THE RECORD
*        THE ADDR OF THE RECORD IN THE INPUT AREA IS PASSED
*        THE USER. THE USER RETURNS VIA BRANCH REGISTER AND
*        PROPER DISPLACEMENTS
*
*        THIS MODULE KEEPS TRACK OF THE MAXIMUM AMOUNT OF
*        RECORDS THAT THE SORT CAN HANDLE AT ANY ONE TIME, NMAX.
*        IT CHECKS TO SEE IF NMAX IS REACHED, AND WHEN IT IS
*        REACHED IT BRANCHES TO THE USER EXIT THAT MAY -
*        1 - SORT CURRENT NO
*        2 - IGNORE NMAX
*        3 - TERMINATE THE JOB
*        THE USER RETURNS VIA BRANCH REG AND PROPER
*        DISPLACEMENTS
*
*        THE MODULE MOVES THE RECORD TO RSA AND PASSES THE
*        RECORD'S LOCATION IN RSA TO THE REPLACEMENT SORT. THIS
*        MODULE HANDLES UP TO 5 NON CONTIGUOUS RSA AREAS
*
*        CHANGE LOG -
*        CORRECT IMPLEMENTATION OF STOPAFT PARAMETER          REL 1.1
*
*        MODULES IN WHICH THIS MODULE APPEARS AS A DSECT -
*        IERADD
*
*        MACROS USED BY MODULE -
*        SMPPI
*        GET
*
*        ENTRY POINTS - ENTRY FROM NETWORK
*                       CALLING SEQUENCE -
*                           L    R11,PPIDEB+4
*                           B    0(R11)     AFTER G RCDS
*                           B    8(R11)     FILL TREE
*
*                       ENTRY FROM EOF
*                       CALLING SEQUENCE -
*                           L    R11,PPIDEB+4
*                           B    4(R11)     EOF
*
*                       ENTRY FROM BLOCK OR ALGORITHM
*                       CALLING SEQUENCE -
*                           L    R11,PPIDEB+4
*                           B    8(R11)     BLK=NRML,ALG=EOS
*
*                       ENTRY FROM GET, MOVE RTN, E15, E16, SSC
*                       CALLING SEQUENCE -
*                           BR   14         RETURN REG
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPINET    PPIADSSC    PPIX16  PPISTOPF
*        PPIBDSVA  PPICNTL     PPIRMA  PPISTOPR
*        PPIBINSZ  PPIX15
*
*        ADDR OF NETWORK, MOVE RTN, EXITS, SORT SYSTEM CONTROL,
*        MESSAGE MODULE, AND BINSIZE TO UPDATE RSA POINTER
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        UPDATE RECORD, DELETE, AND INSERT COUNTERS
*        PPICOUNT  PPISTOPR
*        PPIDELCT
*        PPIINSCT
*
*        EXTERNAL ROUTINES -
*        MOVE ROUTINE TO MOVE RECORD FROM THE BUFFER TO RSA
*
*        EXTERNAL PARAMETERS - SEE REGISTERS
*
*        EXITS - NORMAL - EXIT TO NETWORK
*                         CALLING SEQUENCE -
*                             L    R11,PPINET+4
*                             B    4(R11)     FILL TREE
*                             B    8(R11)     ON INPUT EOF
*                             B    12(R11)    NORMAL RUNNING
*                             B    16(R11)    FLUSH TREE
*
*                         EXIT TO GET
*                         CALLING SEQUENCE -
*                             GET(R6)         R6=ADDR OF DCB
*
*                         EXIT TO MOVE RTN
*                         CALLING SEQUENCE -
*                             L    R15,PPIBDSVA+4 MOVE RTN ADDR
*                             BALR R14,R15
*
*                         EXIT TO E15 (OR ATTACHED EXIT)
*                         CALLING SEQUENCE -
*                             L    R15,PPIX15+4
*                             BALR R14,R15
*
*                         EXIT TO SSC
*                         CALLING SEQUENCE -
*                             L    R15,PPIADSSC
*                             BALR R14,R15
*
*        EXITS - ERROR - TO NMAX EXIT
*                        EXIT TO E16 CALLING SEQUENCE -
*                        L R15,PPIX16+4
*                        BALR R14,R15
*
*        TABLES/WORK AREAS -
*        WSW1     - SWITCH IN THE INSERT RTN
*        WINSRTSW - INSERT SWITCH
*        WUSREOF  - USER END OF FILE SWITCH (DO NOT RETURN TO E15)
*        WSYSEOF  - SYTEM END OF FILE SWITCH - (INPUT END OF FILE)
*        WINNER   - SAVE AREA FOR ADDR IN RSA THAT THE WINNER JUST
*                   VACATED
*        WNMAX    - NMAX COUNTER
*        WDCB     - ADDR OF INPUT FILE'S DCB
*        WRJ      - 2 FULL WORDS REGISTER SAVE AREA
*        WINPTRCD - ADDR OF RCD IN INPUT AREA
*        TABLRSA  - UP TO 5 ENTRIES (8 BYTES/ENTRY) FOR 5 NON
*                   CONTIGUOUS RSA'S
*
*        NOTES -
*        THIS MODULE WILL EXECUTE FOR ANY FIXED LENGTH SORT
*        HAVING USER EXITS E15 AND/OR E16, OR ATTACHED
*
IERRDD   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRDD SOURCE
*
*----------------------------------------------------------------------
*
         COPY IERRDDI
*
*
*        MODULE NAME - IERRMA
*
*        THIS MODULE CONTAINS ALL OF THE MESSAGES THAT ARE
*        REQUIRED FOR PHASE 1 RUNNING PROGRAM
*
IERRMA   DSECT
*
         COPY  RMAMAIN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERRDDI  0101-20211-20211-1200-00299-00299-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERRDD SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERRDDI
*
         USING *,R11               MODULE BASE REG LOADED EXTERNALLY
         USING IERRCA,R13          R13 -> PPI
         USING IERRMA,R14          MESSAGE MODULE ADDR
*
*        ENTER BRANCH TABLE FROM -
*        REPLACEMENT SORT                     - 0(R11)
*        FROM READ MOD                        - 4(R11) OR
*        FROM REPLACEMENT SORT (INITIALLY TO FILL TREE)
*        ALGORITHM (AT THE END OF A SEQUENCE)
*        BLOCK MODULE (AFTER FILLING TREE)    - 8(R11)
*
IERDD1   B     RDOVLAYF            FROM REPL SORT, FINISHD FILLING TREE
         B     RDSETSW             FROM READ MOD (GET,ON EOF)
*
*        FROM REPLACEMT SORT BLOCK MOD, OR ALGORITHM
*
RDNORMAL ST    R3,WINNER           ADDR OF A FREE AREA IN RSA LAST WNR
RDLDCTRS STM   R9,R10,WRJ          SAVE TRANSPARENT REGS
         LM    R6,R8,PPICOUNT      RESTORE COUNTERS
         L     R10,WDCB            RESTORE DCB ADDR
         ICM   R9,B'1111',PPINMAX  RESTORE NMAX
         BP    RDTSTISW            NMAX PLUS, CONTINUE
         LA    R9,1                NMAX MUST BE 1
RDTSTISW TM    WINSRTSW,X'01'      INSERT SW ON ? WILL BE OVLAYED BY
*                                  AP IF ATTACHED, OR BY RP ON
*                                  SYSTEM EOF, WITH B RDUSREXT
         BO    RDUSREXT            ON, BRANCH TO USER EXIT
*
RDGET    PPITEST PPISTOPF          STOP AFTER XXX RECORDS VALUE SET ?
         BZ    RDGETA              NO, BRANCH
         L     R15,DCBEODAD-IHADCB(R10)  R15 -> DCB EOD RTN
         ICM   R14,B'1111',PPISTOPR  R14 = STOP AFTER RECORD COUNT
         BZR   R15                 READ ENOUGH RECORDS, TRIGGER
*                                  DCB EOD EXIT ROUTINE
         BCTR  R14,0               DECR COUNT
         STCM  R14,B'1111',PPISTOPR  STORE DECREMENTED COUNT
*
RDGETA   GET   (R10)               ON RETURN R1 -> NEXT RECORD
*
         LA    R6,1(,R6)           INCR RECORD CTR
         ST    R1,WINPTRCD         SAVE ADDR OF RCD THATS IN INPUT BLK
*
*        EXIT E15
*
*        USING CALL MACRO EXPANSION INSTRUCTIONS
*        PASS ADDR OF PARAMETER LIST (ADDR OF INPUT RECORD) IN R1
*
RDUSREXT LA    R1,WINPTRCD         ADDR OF PARAMETER LIST IF E15 NOT
*                                  ACTIVATED, OR IF ACTIVATED AND HIT
*                                  USER EOF, THIS INSTR WILL BE OVLAYED
*                                  BY B RDALSHNO
         MVC   UEXIT,PPIUEXIT      SETUP PARAMETER LIST
         L     R15,PPIX15+4        ADDR OF USER EXIT E15. IF ATTACHED
*                                  AP WILL LOAD PPIX15 WITH ADDR IN
*                                  PPIATP1E
         BASR  R14,R15             CALL USER EXIT E15
         MVC   PPIUEXIT,UEXIT      SAVE VALUE FOR NEXT CALL
*
*        USER RETURNS TO MODULE VIA R14 WITH RETURN CODE IN R15
*
*        USER PASSES ADDR OF RECORD TO BE INSERTED OR ADDR OF
*        WORK AREA IF THE EXIT ALTERS, LENGTHENS, OR SHORTENS A
*        RCD IN R1
*
         B     RDOVLAY4(R15)
RDOVLAY4 B     RDALSHNO        +00 ALTER, LENGTHEN, SHORTN, DO NOTHING
*                                  WILL BE OVERLAYED BY K4 IF, WHEN
*                                  REACH NMAX IT IS IGNORED, OR BY
*                                  AP WITH K4 IF EXIT NOT ACTIVE
         B     RDDELETE        +04 DELETE A RCD
         B     RDUSREOF        +08 USER END OF FILE
*
*        INSERT A RECORD
*
RDTSTNMX BCT   R9,RDISWON      +12 DECR NMAX CTR BY ONE AND TEST TO
*                                  SEE IF REACHED NMAX
*                                  WILL BE OVERLAYED BY K3 IF, WHEN
*                                  REACH NMAX IT IS IGNORED, OR BY
*                                  AP WITH K3 IF EXIT NOT ACTIVE
         B     RDWSW1ON            YES, BR TO NMAX USER EXIT E16, SW ON
*
*        SYSTEM END OF FILE ROUTINE
*
RDSETSW  OI    WSYSEOF,X'01'       SET SYSTEM EOF SWITCH
         SR    R1,R1               CLEAR INPUT RCD PARAM REG
         MVC   RDTSTISW,K5         TO BYPASS GOING TO GET AFTER SYS EOF
         TM    WUSREOF,X'01'       USER EOF SWITCH ON ?
         BO    RDCNTSRT            YES, BRANCH TO EOF FLUSH RTN
         B     RDUSREXT-4          NO, BRANCH TO USER
*
*        USER END OF FILE ROUTINE
*
RDUSREOF OI    WUSREOF,X'01'       SET USER EOF SWITCH
         MVC   RDUSREXT,RDOVLAY4   OVLAY USER EXIT BYPASS EXIT E15
         TM    WSYSEOF,X'01'       SYSTEM EOF SWITCH ON ?
         BO    RDCNTSRT            YES, BRANCH TO EOF FLUSH RTN
         L     R1,WINPTRCD         RESTORE ADDR OF RCD IN INPUT BLK
         B     RDALSHNO            BRANCH TO SORT THIS RCD
*
RDISWON  OI    WINSRTSW,X'01'      TURN INSERT SWITCH ON
         LA    R8,1(,R8)           INCR INSERT CTR BY ONE
RDSTM    STM   R6,R8,PPICOUNT      SAVE COUNTERS
         ST    R9,PPINMAX          SAVE NMAX CTR
*
*        INITALIZE AND BRANCH TO MOVE RTN TO MOVE NEXT INPUT RCD
*        TO RSA
*
RDOVLAY5 B     RDDLDRSA            BR TO GET ADDR IN RSA TO MOVE RCD
*                                  WILL BE OVLAYED BY L R5,WINNER
*                                  AFTER G+1 RECORDS
RDDLDRE  LR    R4,R1               R4 -> RECORD IN INPUT BUFFER OR
*                                  FROM USER'S WORK AREA
         L     R15,PPIBDSVA+4      R15 -> MOVE RTN IN GENERATED CORE
         BASR  R14,R15             CALL MOVE RTN MOVE RCD TO RSA
RDOVLAY6 B     RDFILLTR            BR TO SORT NETWORK FILLING TREE RTN
*                                  WILL BE OVLAYED BY NOP AFTER
*                                  TREE IS INITIALLY FILLED
*
*        NORMAL EXIT TO SORT NETWORK AFTER PREVIOUS INSTR IS
*        OVERLAYED BY NOP
*
         LR    R2,R1               ADDR OF RCD IN INPUT BUFFER
         L     R3,WINNER
         L     R11,PPINET+4        ADDR OF SORT NETWORK
         B     12(,R11)            BRANCH TO SORT NETWORK NORMAL RTN
*
*        EXIT TO SORT NETWORK WHILE FILLING TREE
*
RDFILLTR LR    R2,R1               ADDR OF RCD IN INPUT BUFFER
         A     R3,PPIBINSZ         UPDATE TO NEXT BIN IN THIS RSA
         ST    R3,0(,R10)          SAVE IN RSA TABLE
         S     R3,PPIBINSZ         RESTORE FOR NETWORK, ADDR OF THIS
*                                  RCD IN RSA
         L     R11,PPINET+4        ADDR OF NETWORK
         B     4(,R11)             BRANCH TO SORT NETWORK FILL TREE RTN
*
*        FINISHED FILLING TREE RTN - ONE TIME RTN
*
RDOVLAYF NI    RDOVLAY6+1,X'00'    NOP THE BR INSTR TO THE FILLING EXIT
         MVI   RDDOVLAY+1,X'F0'    OVLAY INSTR IN RSA TABLE ROUTINE
         B     RDLDCTRS            BRANCH TO GET G+1 RECORD
*
*        RSA TABLE ROUTINE USED DURING FILLING OF TREE
*        ENTER HERE ONLY THROUGH G+1 RECORDS
*
RDDLDRSA L     R10,ADCONPTR        RSA TABLE PTR
RDDRTRN  LM    R3,R4,0(R10)        R3 = ADDR IN THIS RSA, R4=REMAINING
*                                  BYTE COUNT OF THIS RSA
         S     R4,PPIBINSZ         SUBTR SIZE OF THIS RCD
         BM    RDNEWRSA            MINUS, RECORD CANT FIT IN THIS RSA
RDDOVLAY NOP   RDDLAST             WILL BE A BR AFTER RSA HAS G RCDS
         ST    R4,4(,R10)          SAVE REMAING BYTE COUNT OF THIS RSA
         LR    R5,R3               ADDR IN RSA TO MOVE THE RCD
         B     RDDLDRE             BRANCH TO MOVE RCD TO RSA
*
RDNEWRSA LA    R10,8(,R10)         UPDATE RSA TABLE PTR TO NEXT RSA
*                                  ENTRY (NEXT NON CONTIGUOUS RSA)
         ST    R10,ADCONPTR        SAVE UPDATED PTR
         B     RDDRTRN             BRANCH TO USE THIS RSA
*
*
*        PROCESS THE G+1 RECORD
*
RDDLAST  ST    R3,WINNER           ADDR IN RSA TO MOVE RCD
         MVC   RDOVLAY5(4),K1      OVLAY BRANCH INSTR TO RSA TABLE RTN
         B     RDOVLAY5            BRANCH TO MOVE G+1 RCD TO RSA
*
*        FROM USER, ON NMAX RETURN, TO SORT CURRENT NO OF RCDS
*        ONLY
*
RDSETPPI PPISETON PPIFSZE          TURN ESTIMATED FILE SWITCH ON
         TM    WSYSEOF,X'01'       SYSTEM EOF REACHED ?
         BO    RDCNTSRT            YES,BR AROUND NEXT INSTRS FLUSH TREE
         BCTR  R6,0                DECR PPICOUNT BY ONE
*
*        FROM GET ON END OF FILE
*
RDCNTSRT MVC   RDNORMAL,K2         OVERLAY DEBLOCK MODULE
         STM   R6,R8,PPICOUNT      SAVE COUNTERS
         L     R11,PPINET+4        ADDR OF NTWK
         B     8(,R11)             BRANCH TO NETWORK TO EMPTY TREE
*
RDEMPTYT L     R11,PPINET+4        ADDR OF NETWORK
         B     16(,R11)            BR TO SORT TO CONTINUE EMPTYING TREE
*
*        WRITE MESSAGE NMAX EXCEEDED
*
RDWSW1ON OI    WSW1,X'01'          TURN SWITCH 1 ON
RDMSGS   L     R14,PPIRMA+4        ADDR OF MESSAGE MODULE
         LR    R4,R1               SAVE ADDR OF NMAX+1 RCD
         LM    R0,R1,IER048        IER048I ESTIMATED MAXIMUM RECORD
         L     R15,PPIADSSC        R15 -> PRINT RTN ADDR
         BAS   R14,12(,R15)        CALL PRINT RTN
*
*        EXIT E16
*        SORT CAPACITY NMAX HAS BEEN REACHED
*        CALL MACRO INSTRUCTION EXPANSION
*
         LR    R1,R4               RESTORE ADDR OF NMAX+1 RCD
         L     R15,PPIX16+4        ADDR OF NMAX EXIT
         BASR  R14,R15             CALL USER EXIT E16
*
*        USER RETURNS TO MODULE VIA R15 AND PROPER DISPLACEMENTS
*
         B     *+4(15)
         B     RDSETPPI            +00 SORT CURRENT NO OF RCDS ONLY
         B     RDIGNORE            +04 IGNORE NMAX AND CONTINUE TO SORT
*
*        TERMINATE THE JOB
*        SET UP ABNORMAL END INDICATION FOR SORT SYSTEM CONTROL
*
         MVC   PPIABMNO,IERZ800    +08 SET ABEND CODE
         L     R15,PPIADSSC
         BAS   R14,16(,R15)        BRANCH TO SORT SYSTEM CONTROL
*                                  NO RETURN
IERZ800  DC    C'800'              USER EXIT REQUESTED ABEND
*
*        IGNORE NMAX
*        OVERLAY NMAX TEST WITH A BYPASS BRANCH INSTR
*
RDIGNORE MVC   RDTSTNMX(4),K3      OVERLAY NMAX TEST, INSERT RTN
         CLC   RDUSREXT,RDOVLAY4   USER EXIT CODE BEEN OVERLAID ?
         BNE   *+10                NO, BRANCH AROUND NEXT INSTRUCTION
         MVC   RDUSREXT,K4         CHANGE OVERLAID INSTRUCTION
         MVC   RDOVLAY4(4),K4      OVERLAY NMAX TEST,DO NOTHG,ALTER RTN
         TM    WSW1,X'01'          SWITCH 1 ON ?
         BO    RDISWON             ON, BRANCH TO TURN INSERT SWITCH ON
         B     RDISWOFF            BRANCH TO TURN INSERT SWITCH OFF
*
*        DO NOTHING, ALTER, LENGTHEN, SHORTEN A RECORD
*        R1 -> INPUT RECORD
*
RDALSHNO BCT   R9,RDISWOFF         DECR NMAX CTR BY ONE AND TEST TO SEE
*                                  IF REACHED NMAX
         B     RDMSGS              YES, BRANCH TO NMAX USER EXIT E16
*
RDISWOFF NI    WINSRTSW,X'00'      TURN OFF INSERT SWITCH
         B     RDSTM               BR TO LOAD ADDR OF FREE AREA IN RSA
*
*        DELETE A RECORD
*
RDDELETE NI    WINSRTSW,X'00'      TURN OFF INSERT SWITCH
         LA    R7,1(,R7)           INCR DELETE CTR
         B     RDGET               BRANCH TO GET ANOTHER RECORD
*
*        ADCONS
*
ADCONPTR DC    A(TABLRSA)          ADDR OF RSA TABLE
*
*        CONSTANTS
*
K1       L     R5,WINNER           OVERLAY WHEN FINISHED FILLING TREE
K2       B     RDEMPTYT            OVERLAY TO EMPTYTREE ON GET EOF
K3       B     RDISWON             BYPASS NMAX TEST IN INSERT RTN
K4       B     RDISWOFF            BYPASS NMAX TEST IN DO NOTHG,ETC RTN
K5       B     RDUSREXT            OVERLAY INSERT SW TEST BY AP IF
*                                  ATTACHED
*
*        WORK AREAS
*
WSW1     DC    X'00'               SWITCH 1 IN INSERT RTN
WINSRTSW DC    X'00'               INSERT SWITCH
WUSREOF  DC    X'00'               USER END OF FILE SW. SET BY AP IF
*                                  EXIT E15 IS INACTIVE
WSYSEOF  DC    X'00'               SYSTEM END OF FILE SWITCH
WINNER   DC    F'0'                SORT WINNER RCD ADDR
WDCB     DC    F'0'                CONTAINS ADDR OF DCB FOR INPUT FILE
*                                  LOADED BY ASSIGNMENT ROUTINE
WRJ      DC    2F'0'               SAVE TRANPARENT REGS
*
*        PARAMETER LIST PASSED TO E15 EXIT
*
WINPTRCD DC    F'0'                -> RECORD IN INPUT AREA
UEXIT    DC    F'0'                USER EXIT ADDR WORD
*
TABLRSA  DC    5D'0'               SPACE AVAILABLE FOR 5 NON CONTIGUOUS
*                                  RSA ENTRIES EACH ENTRY 8 BYTES
*                                  4 BYTES - ADDR IN BIN TO MOVE RCD
*                                  4 BYTES - REMAINING BYTE COUNT OF
*                                            THIS RSA
*                                  THIS TABLE INITIALIZED BY IERADD
*
*        DCB DSECT
*
         PRINT NOGEN
*
         DCBD  DSORG=PS,DEVD=(DA,TA)
*
         PRINT GEN
*
./ ADD NAME=IERRDE   0101-20211-20211-1200-00131-00131-00000-RELEASE 00
RDE      TITLE 'IERRDE - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRDE
*
*        MODULE FUNCTION/OPERATION -
*        IERRDE IS A DEBLOCK MODULE WHICH HANDLES VARIABLE
*        LENGTH RECORDS BY WAY OF THE QSAM GET MACRO AND CONTAINS
*        LINKAGE TO THE USER MODIFICATION PROGRAMS VIA THE CALL
*        MACRO EXPANSION INSTRUCTIONS. THE INPUT RECORDS ARE
*        LOCATED IN AN INPUT BUFFER. BEFORE MOVING THE RECORD TO
*        THE WORK AREA, RSA, THE MODULE BRANCHES TO THE USER E15
*        ROUTINE WHICH MAY -
*        1. DELETE
*        2. INSERT OR
*        3. ALTER (LENGTHEN, SHORTEN OR DO NOTHING TO THE RECORD)
*        THE ADDRESS OF THE RECORD IN THE INPUT AREA IS PASSED
*        TO THE USER. THE USER RETURNS VIA BRANCH REGISTER AND
*        PROPER DISPLACEMENTS. THIS MODULE KEEPS TRACK OF THE
*        MAXIMUM AMOUNT OF RECORDS THAT THE SORT CAN HANDLE AT
*        ANY ONE TIME (NMAX). IT CHECKS TO SEE IF NMAX IS REACHED
*        AND IF IT IS REACHED, IT BRANCHES TO THE USER ROUTINE
*        WHICH MAY -
*        1. SORT CURRENT NUMBER
*        2. IGNORE NMAX OR
*        3. TERMINATE JOB
*        THE USER RETURNS VIA BRANCH REGISTER AND PROPER
*        DISPLACEMENTS. THE MODULE BRANCHES TO THE MOVE MODULE
*        (IERRBF) WHICH MOVES THE RECORD INTO RSA. IERRDE THEN
*        PASSES THE RECORD'S LOCATION IN RSA TO THE REPLACEMENT
*        SORT. USER EXITS E15 AND E16 ARE AVAILABLE IN THIS
*        MODULE
*
*        CHANGE LOG -
*        CORRECT IMPLEMENTATION OF STOPAFT PARAMETER          REL 1.1
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - IERADE
*
*        MACROS USED BY MODULE -
*        SMPPI
*        GET
*
*        ENTRY POINTS - ENTRY FROM NETWORK
*                       CALLING SEQUENCE -
*                           L     R11,PPIDEB+4
*                           B     8(,R11)    DURING TREE FILL
*
*                           L     R11,PPIDEB+4
*                           BR    R11        ONCE WHEN TREE FULL
*
*                     - ENTRY FROM BLOCK
*                       CALLING SEQUENCE -
*                           L     R11,PPIDEB+4
*                                 B     8(,R11)
*
*                     - ENTRY FROM EOF ROUTINE
*                       CALLING SEQUENCE -
*                           L     R11,PPIDEB+4
*                                 B     4(,R11)
*
*                     - ENTRY FROM E15
*                       CALLING SEQUENCE -
*                           BR    R14
*
*                     - ENTRY FROM E16
*                       CALLING SEQUENCE -
*                           BR    R14
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIBDSVA  PPINET     PPIX15
*        PPIX16    PPISTDCB   PPICOUNT
*        PPINSCT   PPIDELCT   PPIRMA
*        PPIADSSC  PPISTOPF   PPISTOPR
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPIBDSVA  PPICOUNT   PPIINSCT
*        PPIDELCT  PPICNTL    PPISTOPR
*
*        EXTERNAL ROUTINES -
*        EXTRN IERRMA - ERROR MESSAGE PRINT ROUTINE
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL -
*        E15     - PHASE 1 RECORD MODIFICATION EXIT
*        E16     - PHASE 1 NMAX EXIT
*        NETWORK - PASS ADDRESS OF EACH INCOMING RECORD
*
*        EXITS - ERROR -
*        PPIADSSC - PRINT NMAX REACHED MESSAGE
*
*        TABLES/WORK AREAS -
*        WORK AREA AT WSAVE IS A 3 WORD AREA TO SAVE REGISTER
*        INFORMATION FOR MOVE ROUTINE WHEN ONLY A PORTION OF A
*        RECORD FITS IN RSA. WORK AREA AT WNMAX IS WHERE A
*        RUNNING COUNT OF RECORDS IS KEPT SO IT CAN BE DETERMINED
*        WHEN NMAX HAS BEEN REACHED. WORK AREAS WUSREOF, WINPEOF
*        AND WINSALT ARE SWITCHES FOR USER END OF FILE, INPUT
*        END OF FILE AND INSERT ALTER RECORD RESPECTIVELY
*        WORK AREA WSAVAIL IS A SAVE AREA FOR THE RSA ADDRESS OF
*        THE RECORD CURRENTLY BEING MOVED NOTES -
*        THIS MODULE IS USED FOR VARIABLE LENGTH RECORD SORTS
*        WHICH HAVE EXITS 15 OR 16 ACTIVATED
*
IERRDE   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRDE SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRDEI
*
*        MODULE NAME - IERRMA
*
*        THIS MODULE CONTAINS ALL OF THE MESSAGES THAT ARE
*        REQUIRED FOR PHASE 1 RUNNING PROGRAM
*
IERRMA   DSECT
*
         COPY  RMAMAIN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERRDEI  0101-20211-20211-1200-00268-00268-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERRDE SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERRDEI
*
         USING *,R11
         USING IERRCA,R13
         USING IERRMA,R14          MESSAGE MODULE ADDR
*
IERDD1   B     RDEOLAY             +00 GOTO OVERLAY EXITS
         B     RDEEOF              +04 GOTO EOF ROUTINE
RDENTER  CLI   NOFITSW,X'01'       +08 CHECK NO FIT SWITCH
         BL    RDENORM             NO FIT SWITCH OFF
         BH    RDESPEC             NO OF BINS WAS=0
         ICM   R4,B'1111',PPIBDSVA+8
         BZ    RDEBINZ             BIN COUNT STILL=0
         L     R0,WSAVE
         L     R4,WSAVE+4          RELOAD REGS TO CONTINUE MOVE
         L     R2,WSAVE+8          LOC FOR CHAIN ADDR USED
*                                  AFTER PARTIAL
         L     R3,PPIBDSVA+4       ADDR OF NEXT AVAIL BIN
         ST    R3,0(,R2)           INSERT CHAIN ADDR
         LA    R1,8                INDICATE DEBLOCK WITH NOFIT PREVIOUS
         L     R5,PPIBDSVA+4       LOAD ADDR OF NEXT BIN IN RSA
RDEMOVE  L     R15,PPIBDSVA+12     R15 -> MOVE ROUTINE
         BASR  R14,R15             CALL MOVE ROUTINE
         B     RDENOTF             +00 RECORD DIDN'T FIT
*
*        RECORD FIT ROUTINE
*
         CLI   NOFITSW,X'01'       +04 CHECK NO FIT SWITCH
         BNE   RDEUSUAL            LAST MOVE WAS NOT A NO FIT
         L     R3,WSAVAIL          GET RSA STARTING ADDR OF RECORD
         SR    R2,R2
         ST    R2,WSAVAIL          ZERO OUT WSAVAIL
         B     RDEUSUAL+4          R3 ALREADY LOADED
*
RDEUSUAL L     R3,PPIBDSVA+4       BEGIN ADDR OF RCD JUST MOVED
         AH    R3,EXPLFOUR         ADD EXT SIZE & 4
         L     R2,ADRHOLDB         LOAD BUFFER ADDRESS
         L     R4,PPIBDSVA+8
         SR    R4,R1
         ST    R4,PPIBDSVA+8       UPDATE BIN COUNT
         L     R4,0(,R5)
         ST    R4,PPIBDSVA+4       UPDATE AVAIL
         NI    NOFITSW,X'00'       TURN OFF NO FIT SWITCH
         L     R11,PPINET+4
RDEFIT   B     4(,R11)             EXIT TO SORT ON RECORD FIT CONDITION
*
*        RECORD NO FIT ROUTINE
*
RDENOTF  ST    R0,WSAVE
         STM   R4,R5,WSAVE+4       SAVE INFO FOR NEXT MOVE
         SR    R3,R3
         ST    R3,PPIBDSVA+8       BINS AVAIL = 0
         OI    NOFITSW,X'01'       SET NOFITSW = 01
         A     R3,WSAVAIL
         BNZ   RDEBINZ             MORE THAN ONE NO FIT ON SAME RECORD
         L     R3,PPIBDSVA+4
         ST    R3,WSAVAIL          SAVE RSA ADDR OF START OF RECORD
RDEBINZ  L     R11,PPINET+4
         B     24(,R11)            EXIT TO SORT ON RECORD NO FIT
*
RDESPEC  SR    R4,R4
         A     R4,PPIBDSVA+8       CHECK BIN COUNT
         BZ    RDEBINZ             BIN COUNT STILL ZERO
         NI    NOFITSW,X'00'       ZERO NOFITSW-BIN COUNT NO LONGER 0
         L     R4,ADRHOLDA         RELOAD BUFFER ADDR
RDEPTB   L     R5,PPIBDSVA+4
         AH    R5,EXPLFOUR         ADD EXT SIZE & 4 TO AVAIL ADDR
         ST    R4,ADRHOLDB         SAVE BUFFER ADDR
         SR    R1,R1               INDICATE DEBLOCK TO MOVE ROUTINE
         B     RDEMOVE             CONTINUE PREP FOR MOVE
*
RDENORM  CLI   INSERTSW,X'00'
         BH    RDEISWON
RDEGET   NOP   0                   ÝOVERLAID INST¨
         LM    R0,R1,KAWORK        DCB ADDR AND/OR VBS WORK ADDR
         PPITEST PPISTOPF          STOP AFTER XXX RECORDS VALUE SET ?
         BZ    RDGETA              NO, BRANCH
         L     R15,DCBEODAD-IHADCB(R1)  R15 -> DCB EOD RTN
         ICM   R14,B'1111',PPISTOPR  R14 = STOP AFTER RECORD COUNT
         BZR   R15                 READ ENOUGH RECORDS ? TRIGGER
*                                  DCB EOD EXIT ROUTINE
         BCTR  R14,0               DECR COUNT
         STCM  R14,B'1111',PPISTOPR  STORE DECREMENTED COUNT
*
RDGETA   GET   (1),(0)             GET RECORD GL OR GM
*
         L     R9,PPICOUNT
         LA    R9,1(,R9)
         ST    R9,PPICOUNT         ADD 1 TO RECORD COUNT
         ST    R1,ADRHOLD
RDEISWON LA    R1,ADRHOLD          SET UP PARAMETER FOR USER MOD
*                                  WILL BE L R1,ADRHOLD ON USER EOF
         L     R9,PPINMAX          RESTORE NMAX REG
         LTR   R9,R9               0 OR NMAX ?
         BP    RDEUEXIT            NMAX PLUS EXIT
         LA    R9,1                NMAX MUST BE AT LEAST 1
*
*        CALL USER MOD EXIT E15
*        R1 -> INPUT RECORD
*
RDEUEXIT L     R15,PPIX15+4        OVERLAYED IF THIS EXIT NOT ACTIVE
*                                  OR IF USER EOF REACHED
         MVC   UEXIT,PPIUEXIT      SETUP USER EXIT WORD
         BASR  R14,R15             CALL USER
         MVC   PPIUEXIT,UEXIT      SAVE USER EXIT WORD FOR NEXT CALL
*
*        USER RETURNS VIA R14 WITH PROPER DISPLACEMENT IN R15
*        RETURN IN REG R1, THE ADDR OF THE RECORD TO BE INSERTED
*        OR THE ADDR OF THE WORK AREA IF THE USER HAS ALTERED
*        THE RECORD
*
         B     *+4(R15)
         B     RDEDONO             +00 ALTER OR DO NOTHING
         B     RDELETE             +04 DELETE A RECORD
         B     RDEUEOF             +08 USER END OF FILE
*
*        INSERT A RECORD
*
RDEMAXCK BCT   R9,RDEINSRT         +12 CHECK FOR NMAX AND DECREMENT
         B     RDEMSG              NMAX RCHD GOTO OUTPUT MESS AND E16
*
RDEINSRT OI    INSERTSW,X'01'      SET INSERT SWITCH
         L     R5,PPIINSCT
         LA    R5,1(,R5)
         ST    R5,PPIINSCT         ADD 1 TO INSERT COUNT
RDETSTBC LR    R4,R1               SET UP BUFF ADDR FOR MOVE
         ST    R9,PPINMAX          SAVE NMAX REG
         SR    R5,R5
         A     R5,PPIBDSVA+8       TEST BIN COUNT
         BNZ   RDEPTB              BIN COUNT ¬= 0, BRANCH
         ST    R4,ADRHOLDA         SAVE RCD ADDR UNTIL BIN IS AVAILABLE
         OI    NOFITSW,X'03'       SET NO FIT SWITCH = 11
         B     RDEBINZ             GOTO NO FIT EXIT
*
RDEDONO  BCT   R9,RDENOTM          CHECK FOR NMAX AND DECREMENT
         B     RDEMSG              NMAX RCHD GOTO OUTPUT MESS AND E16
*
RDENOTM  NI    INSERTSW,X'00'      ZERO INSERT SWITCH
         B     RDETSTBC            GO CHECK BIN COUNT
*
RDELETE  NI    INSERTSW,X'00'      ZERO INSERT SWITCH
         L     R5,PPIDELCT
         LA    R5,1(,R5)
         ST    R5,PPIDELCT         ADD 1 TO DELETE COUNT
         B     RDEGET              GO GET ANOTHER RECORD
*
RDEMSG   STH   R15,WINSALT         SAVE INSERT ALTER CONDITION
         L     R14,PPIRMA+4        MESSAGE MODULE ADDR
         LR    R4,R1               SAVE BUFF ADDR
         LM    R0,R1,IER048        IER048I ESTIMATED MAXIMUM RECORD
         L     R15,PPIADSSC        LOAD PRINT RTN ADDR
         BAS   R14,12(,R15)        CALL PRINT RTN
*
*        USER EXIT E16
*        SORT CAPACITY NMAX HAS BEEN REACHED
*
         LR    R1,R4               RESTORE BUFF ADDR
         L     R15,PPIX16+4        NMAX EXIT ADDR
         BASR  R14,R15             CALL USER RTN
*
*        USER RETURNS TO MODULE VIA R14 WITH PROPER DISPLACEMENT
*        IN R15
*
         B     *+4(15)
         B     RDSETPPI            +00 SORT CURRENT NO OF RCDS ONLY
         B     RDEIGNOR            +04 IGNORE NMAX CONTINUE SORT
*
*        TERMINATE THE JOB
*
         MVC   PPIABMNO,IERZ800    +08
         L     R15,PPIADSSC
         BAS   R14,16(,R15)        EXIT TO SORT SYSTEM CONTROL
*                                  NO RETURN
*
IERZ800  DC    C'800'
*
RDESRTCR MVC   RDENTER(4),K1       OVERLAY ENTRANCE
         L     R11,PPINET+4
         B     8(,R11)             BRANCH TO SORT TO EMPTY TREE
*
RDEMPTYT L     R11,PPINET+4
         B     16(,R11)            BRANCH TO SORT TO CONT EMPTY TREE
*
*        FROM USER ON NMAX RETURN TO SORT CURRENT NO OF RCDS ONLY
*
RDSETPPI PPISETON PPIFSZE          TURN ESTIMATED FILE SWITCH ON IN PPI
         CLI   WINPEOF,X'00'       SYSTEM INPUT EOF REACHED ?
         BE    RDESRTCR            YES, DO NOT DECR PPICOUNT FLUSH TREE
         L     R4,PPICOUNT         RCD IN INPUT BFR WILL NOT BE SORTED
         BCTR  R4,0                DECR PPICOUNT BY ONE
         ST    R4,PPICOUNT         RESTORE PPICOUNT
         B     RDESRTCR            BRANCH TO FLUSH TREE
*
*        IGNORE NMAX OVERLAY NMAX TEST WITH A BRANCH
*
RDEIGNOR MVC   RDEMAXCK(4),K2      OVERLAY NMAX CK IN INSERT LEG
         MVC   RDEDONO(4),K3       OVERLAY NMAX CK IN ALTER LEG
         SR    R5,R5
         AH    R5,WINSALT
         BZ    RDENOTM             RESUME WITH INPUT RECORD
         B     RDEINSRT            RESUME WITH INSERT RECORD
*
RDEOLAY  LA    R4,12
         STC   R4,RDEFIT+3         OVERLAY FILLING FIT EXIT
         LA    R4,28
         STC   R4,RDESPEC-1        OVERLAY FILLING NO FIT EXIT
         B     RDENTER             BRANCH TO NORMAL ENTRANCE
*
RDEUEOF  CLI   WINPEOF,X'00'       INPUT EOF ?
         BE    RDESRTCR            YES, GO EMPTY TREE
         SR    R5,R5
         STC   R5,WUSREOF          INDICATE USER EOF
         MVC   RDEUEXIT(4),K4      OVERLAY AFTER USER EOF
         MVC   RDEMSG,K6
         L     R1,ADRHOLD          RESTORE ADDR OF RCD IN INPUT BLK
         MVI   RDEISWON,X'58'      CHANGE LA INSTRUCTION TO L
         B     RDENOTM             BRANCH TO MOVE INPUT RECORD
*
RDEEOF   CLI   WUSREOF,X'00'       USER REACHED EOF ?
         BE    RDESRTCR            YES, GO OVERLAY ENTRANCE
         SR    R5,R5
         STC   R5,WINPEOF          INDICATE INPUT EOF
         MVC   RDEGET(4),K5        OVERLAY AFTER INPUT EOF
         SR    R1,R1
         ST    R1,ADRHOLD          INPUT EOF INDICATION TO USER
         B     RDEISWON            GOTO SET UP FOR BRANCH TO USER
*
NOFITSW  DC    X'00'
INSERTSW DC    X'00'
EXPLFOUR DC    H'0'
WSAVE    DC    3F'0'               FOR MOVE RTN
*
*        PARAMETER LIST PASSED TO E15 EXIT
*
ADRHOLD  DC    A(0)           *    FOR BUFFER ADDR
UEXIT    DC    F'0'           V    USER EXIT WORD
*
ADRHOLDA DC    A(0)                RECORD ADDR WHEN BIN COUNT=0
ADRHOLDB DC    A(0)                RECORD ADDR FOR MOVE RTN
*                                  AND SORT RTN
WUSREOF  DC    X'01'               USER EOF SWITCH
WINPEOF  DC    X'01'               INPUT EOF SWITCH
WINSALT  DC    H'0'                INSERT ALTER SWITCH
WSAVAIL  DC    F'0'                SAVE AREA FOR RSA RECORD ADDRESS
*
K1       B     RDEMPTYT            OVERLAY TO EMPTY TREE
K2       B     RDEINSRT            OVERLAY IN INSERT LEG
K3       B     RDENOTM             OVERLAY IN ALTER LEG
K4       B     RDEDONO             OVERLAY AFTER USER EOF
K5       B     RDEISWON            OVLY AFTER INPUT EOF
K6       NOP   0
KAWORK   DC    2F'0'               FOR DCB AND VBS WORK ADDR
*
*        DCB DSECT
*
         PRINT NOGEN
*
         DCBD  DSORG=PS,DEVD=(DA,TA)
*
         PRINT GEN
*
./ ADD NAME=IERRDG   0101-20211-20211-1200-00083-00083-00000-RELEASE 00
RDG      TITLE 'IERRDG - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRDG
*
*        MODULE FUNCTION/OPERATION -
*        IERRDG IS A DEBLOCK MODULE WHICH HANDLES VARIABLE
*        LENGTH RECORDS BY WAY OF THE QSAM GET MACRO. THERE ARE
*        NO USER MODIFICATIONS. THE MODULE LINKS TO THE VARIABLE
*        MOVE ROUTINE IERRBF WHICH MOVES THE VARIABLE LENGTH
*        RECORD FROM THE INPUT BUFFER INTO RSA BIN(S). UPON
*        RETURN FROM THE MOVE ROUTINE, THE MODULE PASSES ON TO
*        THE REPLACEMENT SORT THE RECORDS LOCATION IN RSA
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - IERADG
*
*        MACROS USED BY MODULE -
*        SMPPI
*        GET
*
*        ENTRY POINTS - ENTRY FROM NETWORK
*                       CALLING SEQUENCE -
*                           L     R11,PPIDEB+4
*                           B     8(,R11)    DURING TREE FILL
*
*                           L     R11,PPIDEB+4
*                           BR    R11        ONCE - WHEN TREE FULL
*
*                     - ENTRY FROM BLOCK
*                       CALLING SEQUENCE -
*                           L     R11,PPIDEB+4
*                           B     8(,R11)
*
*                     - ENTRY FROM EOF ROUTINE
*                       CALLING SEQUENCE -
*                           L     R11,PPIDEB+4
*                           B     4(,R11)
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIBDSVA   PPINET    PPISTOPF
*        PPISTDCB   PPICOUNT  PPISTOPR
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPIBDSVA   PPICOUNT  PPISTOPR
*
*        EXTERNAL ROUTINES - IERRBF
*        USED TO MOVE RECORDS FROM INPUT BUFFER TO RSA
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL -
*        NETWORK - PASS ADDR OF EACH INCOMING RECORD
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS -
*        WSAVE   - SAVE 3 REGISTERS OF INFORMATION GIVEN BY THE
*                  MOVE MODULE IERRBF
*        WSAVAIL - ADDR OF THE RECORD CURRENTLY BEING MOVED INTO
*                  RSA
*
*        NOTES -
*        THIS MODULE IS USED FOR ALL VARIABLE LENGTH RECORD SORTS
*        EXCEPT THOSE WHICH HAVE EXITS 15 OR 16 ACTIVATED
*
IERRDG   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRDG SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRDGI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERRDGI  0101-20211-20211-1200-00137-00137-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERRDG SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERRDGI
*
         USING *,R11
         USING IERRCA,R13
*
IERDD1   B     RDGOLAY             +00 OVERLAY EXITS
         B     RDGEOF              +04 EOF ROUTINE
RDGBEGIN CLI   NOFITSW,X'01'       +08 CHECK NO FIT SWITCH
         BL    RDGNORM             NO FIT SWITCH OFF
         BH    RDGSPEC             NO OF BINS = 0 DURING FILL
         SR    R4,R4
         A     R4,PPIBDSVA+8
         BZ    RDGNOFIT
         L     R0,WSAVE
         L     R4,WSAVE+4
         L     R2,WSAVE+8          LOC FOR CHAIN ADDR-USED AFTER PART
         L     R3,PPIBDSVA+4       ADDR OF NEXT AVAIL BIN
         ST    R3,0(,R2)           INSERT CHAIN ADDR
         L     R1,KEIGHT           INDICATE DEBLOCK WITH NOFIT PREV
RDGBINS  L     R5,PPIBDSVA+4       LOAD ADDR OF NEXT BIN IN RSA
         L     R15,PPIBDSVA+12     LOAD ADDR OF MOVE ROUTINE
         BASR  R14,R15             CALL MOVE ROUTINE
         B     RDGNOTF             +00 RECORD DIDN'T FIT
*
*        RECORD FIT ROUTINE
*
         CLI   NOFITSW,X'01'       +04 CHECK NO FIT SWITCH
         BNE   RDGUSUAL            LAST MOVE WAS NOT A NO FIT
         L     R3,WSAVAIL          GET RSA STARTING ADDR OF RECORD
         SR    R2,R2
         ST    R2,WSAVAIL          ZERO OUT WSAVAIL
         B     RDGUSUAL+4          R3 ALREADY LOADED
*
RDGUSUAL L     R3,PPIBDSVA+4       BEGIN ADDR OF RECORD JUST MOVED
         AH    R3,EXPLFOUR         ADD EXT SIZE + 4
         L     R2,ADRHOLD          LOAD BUFFER ADDR
         L     R4,PPIBDSVA+8
         SR    R4,R1
         ST    R4,PPIBDSVA+8       UPDATE BIN COUNT
         L     R4,0(,R5)
         ST    R4,PPIBDSVA+4       UPDATE AVAIL
         NI    NOFITSW,X'00'       TURN OFF NO FIT SWITCH
         L     R11,PPINET+4
RDGFIT   B     4(,R11)             EXIT TO SORT ON RECORD FIT CONDITION
*
*        RECORD NOFIT ROUTINE
*
RDGNOTF  ST    R0,WSAVE
         STM   R4,R5,WSAVE+4       SAVE INFO FOR NEXT MOVE
         SR    R3,R3
         ST    R3,PPIBDSVA+8       BINS AVAIL=0
         OI    NOFITSW,X'01'
         A     R3,WSAVAIL
         BNZ   RDGNOFIT            SECOND NOFIT ON SAME RECORD
         L     R3,PPIBDSVA+4
         ST    R3,WSAVAIL          SAVE RSA ADDR OF START OF RECORD
RDGNOFIT L     R11,PPINET+4
         B     24(,R11)            EXIT TO SORT ON RECORD NO FIT
*
RDGNORM  NOP   0    ÝOVERLAID INSTRUCTION¨
         PPITEST PPISTOPF          STOP AFTER XXX RECORDS VALUE SET ?
         BZ    RDGNORMA            NO, BRANCH
         L     R15,DCBEODAD-IHADCB(R6)  R15 -> DCB EOD RTN
         ICM   R14,B'1111',PPISTOPR  R14 = STOP AFTER RECORD COUNT
         BZR   R15                 READ ENOUGH RECORDS, TRIGGER
*                                  DCB EOD EXIT ROUTINE
         BCTR  R14,0               DECR COUNT
         STCM  R14,B'1111',PPISTOPR  STORE DECREMENTED COUNT
RDGNORMA LM    R0,R1,KAWORK        DCB ADDR AND/OR VBS WORK
*
         GET   (1),(0)
*
RDGGOT   ST    R1,ADRHOLD          SAVE ADDR OF RECORD
         L     R4,PPICOUNT
         LA    R4,1(,R4)
         ST    R4,PPICOUNT         ADD ONE TO RECORD COUNT
         LR    R4,R1               SET UP BUFFER ADDR FOR MOVE RTN
         SR    R1,R1               INDICATE DEBLOCK TO MOVE ROUTINE
         SR    R3,R3
         A     R3,PPIBDSVA+8
         BNZ   RDGMOVE             BRANCH UNLESS BIN COUNT=0
         OI    NOFITSW,X'03'
         B     RDGNOFIT            SPECIAL NO FIT CONDITION
*
*        OVERLAY EXITS TO REPLACEMENT - CHANGE FROM FILLING TO
*        NORMAL
*
RDGOLAY  LA    R4,12
         STC   R4,RDGFIT+3         OVERLAY EXIT TO SORT RECORD FIT
         LA    R4,28
         STC   R4,RDGNORM-1        OVERLAY EXIT TO SORT RECORD NO FIT
         B     RDGBEGIN            BRANCH TO NORMAL ENTRY
*
*        EOF - SET UP UNCONDITIONAL RETURN TO REPLACEMENT FOR
*        FUTURE USE
*
RDGEOF   MVC   RDGBEGIN(4),RDGFIT-4
         MVC   RDGBEGIN+4(4),KBRANCH    OVERLAY ENTRY WITH UNCOND EXIT
         L     R11,PPINET+4
         B     8(,R11)             ONE TIME EXIT AT EOF
*
RDGSPEC  SR    R4,R4
         A     R4,PPIBDSVA+8
         BZ    RDGNOFIT
         NI    NOFITSW,X'00'       ZERO NOFITSW - SPEC CONDITION
         SR    R1,R1               INDICATE DEBLOCK TO MOVE
         L     R4,ADRHOLD          LOAD BUFFER ADDR
RDGMOVE  L     R5,PPIBDSVA+4
         AH    R5,EXPLFOUR         ADD EXT SIZE + 4 TO AVAIL ADDR
         B     RDGBINS+4           CONTINUE PREP FOR MOVE
*
KBRANCH  B     16(,R11)
*
NOFITSW  DC    X'00'
ADRHOLD  DC    F'0'
KEIGHT   DC    F'8'
WSAVE    DC    3F'0'
WSAVAIL  DC    F'0'                SAVE AREA FOR RSA RECORD ADDR
EXPLFOUR DC    H'0'                EXTRACT SIZE + 4
KAWORK   DC    2F'0'               DCB AND/OR VBS WORK ADDR
*                                  SET BY IERADG
*
*        DCB DSECT
*
         PRINT NOGEN
*
         DCBD  DSORG=PS,DEVD=(DA,TA)
*
         PRINT GEN
*
./ ADD NAME=IERRDH   0101-20211-20211-1200-00061-00061-00000-RELEASE 00
RDH      TITLE 'IERRDH - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRDH
*
*        MODULE FUNCTION/OPERATION -
*        THIS MODULE HANDLES FIXED LENGTH RECORDS. THE MODULE
*        DEBLOCKS THE INPUT BUFFERS AND THEN IT PASSES AN INPUT
*        RECORD ADDRESS TO THE MERGE NETWORK. THE ROUTINE
*        INTERFACES WITH THE READ MODULE WHEN THE INPUT BUFFER IS
*        EMPTY.
*
*        USED AS A DSECT IN - N/A
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM BLOCK ROUTINE
*                       CALLING SEQUENCE -
*                           L    R11,=V(IERRDH)
*                           B    R11
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIRCDL2
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPISBLCT
*
*        EXTERNAL ROUTINES -
*        PPINET+4 - MERGE NETWORK
*        PPIRD+4  - READ ROUTINE
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL -
*        CSECT NAME - EXIT TO MERGE NETWORK
*        CSECT NAME - EXIT TO READ ROUTINE
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS - N/A
*
*        NOTES - NONE
*
IERRDH   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRDH SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRDHI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERRDHI  0101-20211-20211-1200-00051-00051-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERRDH SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERRDHI
*
         USING *,R11
         USING IERRCA,R13          PPI DSECT
*
IERDD34  B     RDHDB020            +00 ENTRY POINT FOR READ RTN
         LR    R6,R3               +04 ENTRY POINT FOR BLOCK RTN
         SRL   R3,24               OBTAIN INCR
         L     R4,PPISBLCT
         L     R5,0(R4,R3)         LOAD APPROPRIATE BLOCK COUNT
         S     R5,KONE             DECREMENT BLOCK COUNT BY ONE
         BNP   RDHDB010            BUFFER EMPTY, BRANCH
         ST    R5,0(R4,R3)         SAVE ADJUSTED BLOCK COUNT
         LR    R3,R6               RESTORE R3
         AH    R3,PPIRCDL2         OBTAIN NEW INPUT RECORD'S ADDR
         L     R11,PPINET+4        RETURN AN INPUT RECORD TO THE
         B     8(,R11)             MERGE NETWORK
*
RDHDB010 L     R6,IERDBLSV
         L     R2,0(R6,R3)         LOAD APPROPRIATE BUFFER'S STARTING
*                                  ADDR
*
*        LINK TO THE READ ROUTINE
*
         L     R11,PPIRD+4
         B     4(,R11)             OBTAIN FULL INPUT BUFFER FROM THE
*                                  READ ROUTINE
RDHDB020 L     R5,PPISBLCT
         ST    R1,0(R5,R3)         STORE NEW BUFFER'S BLOCK COUNT IN
*                                  ITS APPROPRIATE POSITION VIA INCR
         LR    R15,R3
         SLL   R3,24               REPOSITION INCR
         AR    R3,R2
*
*        STORE STARTING ADDR OF BUFFER IN ITS APPROPRIATE
*        POSITION VIA INCR
*
         ST    R4,0(R6,R15)
         L     R11,PPINET+4        PASS RECORD ADDR TO MERGE NETWORK
         B     8(,R11)             RETURN CONTROL TO THE MERGE
*
IERDBLSV DC    F'0'                ADDR OF DEBLAREA
KONE     DC    F'1'
*
./ ADD NAME=IERRDI   0101-20211-20211-1200-00066-00066-00000-RELEASE 00
RDI      TITLE 'IERRDI - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRDI
*
*        MODULE FUNCTION/OPERATION -
*        THE MODULE HANDLES VARIABLE LENGTH RECORDS BY WAY OF
*        THE IOS MACROS. THE MODULE MAINTAINS THE BLOCKING SCHEME
*        IE IT DOES THE DEBLOCKING. IT PASSES THE INPUT RECORD
*        ADDRESS TO THE MERGE PHASE
*
*        MODULE WHICH THIS MODULE APPEARS AS A DSECT - IERADI
*
*        MACROS USED BY MODULE - SMPPI
*
*        ENTRY POINTS - ENTRY FROM READ
*                       CALLING SEQUENCE
*                           L     R11,PPIDEB+4
*                           BR    R11
*
*                     - ENTRY FROM BLOCK
*                       CALLING SEQUENCE
*                           L     R11,PPIDEB+4
*                           B     4(,R11)
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPISBLCT   PPINETM
*        PPIBDSVA   PPIRD
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED - N/A
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL -
*        MERGE NETWORK
*        READ
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS -
*        KRECLEN - TEMPORARY STORAGE FOR RECORD LENGTH
*
*        NOTES -
*        THIS MODULE IS USED FOR ALL VARIABLE LENGTH RECORD
*        SORTS
*
IERRDI   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRDI SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRDII
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERRDII  0101-20211-20211-1200-00058-00058-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERRDI SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERRDII
*
         USING *,R11
         USING IERRCA,R13
*
IERDD34  B     RDI34020            +00 ENTRY FROM READ
         LR    R4,R3               +04 ENTRY FROM BLOCK, SAVE WINNER
         MVC   KRECLEN(2),0(R4)    PUT RCD LENGTH IN KRECLEN
         SRL   R3,24               ACCESS INCREMENT
         L     R7,PPISBLCT         ACCESS BLOCK COUNT FOR THIS BUFFER
         L     R6,0(R3,R7)
         SH    R6,KRECLEN          DECREMENT BY RECORD LENGTH
*                                  BLOCK COUNT ZERO ?
         BNP   RDI34010            YES, BRANCH
         ST    R6,0(R3,R7)         NO, SAVE NEW BLOCK COUNT
         LR    R3,R4               RESTORE WINNER
         AH    R3,KRECLEN          INCREMENT TO GET NEXT RECORD
         L     R11,PPINET+4
         B     8(,R11)             EXIT TO MERGE
*
*        BUFFER IS EMPTY - CALL READ ROUTINE TO GET NEW BUFFER
*
*        READ ROUTINE REQUIRES INCREMENT IN R3 AND BUFFER ADDR
*        (FOR READING) IN R2
*
RDI34010 L     R7,PPIBDSVA         ACCESS BUFFER TABLE ADDR
         L     R2,0(R3,R7)         SET R2 = BUFFER ADDR
         L     R11,PPIRD+4         EXIT TO READ
         B     4(,R11)
*
*        RETURN FROM READ ROUTINE
*        R1  = BLOCK COUNT (INCLUDES BCC BUT NOT EOS INDICATION)
*        R2 -> BUFFER FOR DEBLOCK (POINTS TO BCC)
*        R3  = INCREMENT
*        R4 -> BUFFER FOR READING
*
RDI34020 SH    R1,K4               DECREMENT BLOCK COUNT BY 4 FOR BCC
         L     R7,PPISBLCT         STORE NEW BLOCK COUNT IN BLOCK COUNT
         ST    R1,0(R3,R7)         TABLE
         L     R6,PPIBDSVA         STORE NEW BUFFER ADDR IN
         ST    R4,0(R3,R6)         BUFFER TABLE
         SLL   R3,24               REPLACE INCREMENT
         AR    R3,R2               ADD INCR TO NEXT RCD FOR MERGE
         L     R11,PPINET+4        EXIT TO MERGE
         B     8(,R11)
*
*        CONSTANTS
*
KRECLEN  DC    H'0'                TEMP STORAGE FOR RCD LENGTH
K4       DC    H'4'
*
./ ADD NAME=IERRDJ   0101-20211-20211-1200-00056-00056-00000-RELEASE 00
RDJ      TITLE 'IERRDJ - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRDJ
*
*        MODULE FUNCTION/OPERATION -
*        THE MODULE HANDLES FIXED LENGTH RECORDS BY WAY OF THE
*        IOS GET MACRO. IT THEN PASSES THE INPUT RECORD ADDR TO
*        THE MERGE PHASE
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - IERABJ
*
*        MACROS USED BY MODULE - GET
*
*        ENTRY POINTS - ENTRY FROM BLOCK
*                       CALLING SEQUENCE -
*                           L     R11,PPIDEB+4
*                           B     4(,R11)
*
*        INPUT - PPI FIELDS REFERENCED - NONE
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED - NONE
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL - MERGE NETWORK
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS -
*        KADCBTAB -> DCB TABLE
*
*        NOTES -
*        THIS MODULE IS USED FOR FIXED LENGTH RECORDS ON MERGE
*        ONLY RUN
*
IERRDJ   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRDJ SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRDJI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERRDJI  0101-20211-20211-1200-00028-00028-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERRDJ SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERRDJI
*
         USING *,R11
         USING IERRCA,R13          PPI BASE REGISTER
*
IERDD34  B     *                   +00 DUMMY ENTRY, NOT USED
         L     R6,KADCBTAB         +04 R6 -> DCB TABLE
         SRL   R3,24               ACCESS INCREMENT
         L     R5,0(R3,R6)         R5 -> APPROPRIATE DCB
*
         GET   (R5)                ON RETURN R1 -> NEXT RECORD
*
         SLL   R3,24               SET WINNER ADDR IN R3 AND PLACE
         AR    R3,R1               INCREMENT IN HIGH ORDER BYTE
         L     R11,PPINET+4        EXIT TO MERGE
         B     8(,R11)
*
*        CONSTANTS
*
KADCBTAB DC    A(0)                ADDR OF DCB TABLE
*
./ ADD NAME=IERRDL   0101-20211-20211-1200-00057-00057-00000-RELEASE 00
RDL      TITLE 'IERRDL - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRDL
*
*        MODULE DEFINITION -
*        BUILD A TABLE OF INPUT BUFFER ADDRESSES FOR THE
*        INTERMEDIATE MERGE PHASE.
*        A RUNNING PROGRAM, IT IS EXECUTED ONCE PER PASS OR
*        SUBPASS
*
*        USED AS A DSECT IN - N/A
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM READ ROUTINE
*                       CALLING SEQUENCE -
*                       L   R11,PPIDEB2+4
*                       BR  R11
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIBDSVA   PPIMRGMX
*        PPIPDWA    PPIRCL2
*        PPISBLCT
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED - NONE
*
*        EXTERNAL ROUTINES - NONE
*
*        EXTERNAL PARAMETERS - NONE
*
*        EXITS - NORMAL - MERGE NETWORK
*
*        EXITS - ERROR - NONE
*
*        TABLES/WORK AREAS - PPI ONLY
*
*        NOTES - NONE
*
IERRDL   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRDL SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRDLI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERRDLI  0101-20211-20211-1200-00083-00083-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERRDL SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERRDLI
*
         USING *,R11               MODULE BASE REG LOADED EXTERNALLY
         USING IERRCA,R13          R13 -> PPI
*
         SR    R8,R8               CLEAR PRIME AREA INDEX REG
         LH    R4,PPIMRGMX         LOAD M FROM PPI
RDBRDISK B     RDDISK              BRANCH TO DISK RTN (OVERLAYED WITH
*                                  NOP BY AP IF TAPE SORT)
*
*        TAPE - UPDATE INPUT BUFFER ADDR TABLE IN GENERATED STORAGE
*
RDTAPE   L     R5,PPIPDWA(R8)      LOAD INCR + ADDR OF AN INPUT BUFFER
         SRL   R5,24               INCR NOW IN PROPER POSITION 1ST BYTE
         L     R6,PPISBLCT         LOAD ADDR OF BLOCK COUNT TABLE
         L     R7,0(R5,R6)         LOAD BLOCK COUNT INDEXED BY INCR
RDBRFIXL B     RDFIXL              BRANCH TO FIXED LENGTH RTN OVERLAYED
*                                  BY NOP BY AP IF VAR LENGTH RCDS
         SH    R7,KFOUR            PRIME BFR ADDR PTS TO FIRST RCD IN
*                                  BUFFER SUBTR 4 BYTES TAKEN UP
*                                  BY RDW AND SYSTEM CHECK BYTES
         ST    R7,0(R5,R6)         UPDATED CHAR CNT FOR DEBLOCK MOD USE
RDSUBONE BCTR  R7,0                DECREMENT BLOCK SIZE BY ONE
         A     R7,PPIPDWA(R8)      ADD PRIME BFR ADDR (INCR IGNORED)
RDSTOADR L     R6,PPIBDSVA         LOAD ADDR OF BUFFER ADDR TABLE
         ST    R7,0(R5,R6)         STORE ADDR OF INPUT BFR WITH INCR IN
*                                  FIRST BYTE IN INDEXED TABLE GEN CORE
         BCT   R4,RDINCRRI         DECR M BY ONE BRANCH IF NOT ZERO
*
*        INTERFACE TO NEXT MODULE
*
RDNXTMOD L     R11,PPINETM+4
         BR    R11
*
RDINCRRI LA    R8,4(,R8)           INCR PRIME ADDR AREA INDEX REG BY 4
RDOVLAY  B     RDTAPE              BR TO LOAD NEXT ADDR WILL BE OVER-
*                                  LAYED BY AP TO BR TO DISK RTN
*                                  IF THIS MODULE IS FOR DISK RTN
*
*        FIXED LENGTH MULTIPLY RTN TO CALC LENGTH OF BLOCK IN
*        TOTAL BYTES
*
RDFIXL   MH    R7,PPIRCDL2         MPY BLOCK CNT BY SORT RECORD LENGTH,
*                                  EQUALS SIZE OF INPUT AREA
         AH    R7,KBYTES           ALSO INCLUDE ROUND OFF BYTES IF ANY
         B     RDSUBONE
*
*        DISK ROUTINE TO UPDATE INPUT BUFFER ADDR TABLE IN
*        GENERATED STORAGE
*
RDDISK   L     R5,PPIPDWA(R8)      LOAD INCR AND ADDR OF FIRST RECORD
*                                  IN AN INPUT BUFFER
         SRL   R5,24               INCR NOW IN PROPER POSITION 1ST BYTE
         L     R6,PPISBLCT         LOAD ADDR OF BLOCK COUNT TABLE
         L     R7,0(R5,R6)         LOAD BLOCK COUNT INDEXED BY INCR
RDDISKV  SH    R7,KFOUR            DECR 4 FOR RDW
*                                  AP WILL NOP THIS INSTR FOR FIXED
*                                  LENGTH RECORDS
         ST    R7,0(R5,R6)         UPDATED CHAR CNT FOR DEBLOCK MOD USE
         L     R7,PPIPDWA(R8)      LOAD INCR AND ADDR OF FIRST RECORD
*                                  IN AN INPUT BUFFER
         SH    R7,KEIGHT           R7 POINTS TO STRTG ADDR OF INPUT BFR
*                                  SUBTRACT 4 IF DISK, FIXED LGTH RCDS
*                                  FOR CRCX, KEIGHT =12 FOR FIXED RCDS
*                                                   =16 FOR VAR RCDS
         B     RDSTOADR            BR TO STORE ADDR IN TABLE
*
*        CONSTANTS
*
KFOUR    DC    H'4'                UPDATED BY IERADL
KEIGHT   DC    H'8'                USUALLY  = 8 FOR VAR RCDS
*                                           = 4 FOR FIXED RCDS
*                                  FOR CRCX =16 FOR VAR RCDS
*                                            12 FOR FIXED RCDS
KBYTES   DC    H'0'                BUFFER SIZE ROUND OFF BYTES
*
./ ADD NAME=IERRDP   0101-20211-20211-1200-00125-00125-00000-RELEASE 00
RDP      TITLE 'IERRDP - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRDP
*
*        MODULE FUNCTION -
*        OSCL/CRCX SORT DEBLOCK FOR FIXED LENGTH RECORDS W/O
*        USER EXIT E15
*
*        THE FUNCTION OF THIS MODULE IS TO HANDLE FIXED LENGTH
*        RECORDS USING THE GET LOCATE MACRO. THERE IS NO DATA
*        CHAINING. SORT RECORD LENGTH IS LESS THAN OR EQUAL TO
*        256 BYTES, SO THIS MODULE CONTAINS ONE INLINE MOVE
*        INSTRUCTION TO MOVE THE RECORD INTO RSA. THIS MODULE
*        HANDLES UP TO 5 NONCONTIGUOUS RSA'S. THE MODULE THEN
*        PASSES TO THE REPLACEMENT NETWORK THE RECORDS LOCATION
*        IN RSA
*
*        INITIALLY FLOW IS BETWEEN DEBLOCK AND THE REPLACEMENT
*        NETWORK. AFTER G RECORDS ARE IN RSA THE NETWORK RETURNS
*        TO DEBLOCK FOR THE G+1 RCD TO FORCE A WINNER AND ALLOW
*        DEBLOCK TO MODIFY ITSELF FOR NORMAL FLOW. WHEN DEBLOCK
*        RETURNS TO THE NETWORK WITH THE G+1 RECORD A WINNER IS
*        GIVEN TO BLOCK. THE NORMAL FLOW THEN IS DEBLOCK-NETWORK-
*        BLOCK. AT EOF OR ON THE (M-1)TH SEQUENCE OR WHEN RMAX (=
*        THE MAXIMUM RECORDS B&G HAS DECIDED CAN BE CONTAINED ON
*        ONE REEL OF TAPE) HAS BEEN REACHED, DEBLOCK IS MODIFIED
*        TO BRANCH DIRECTLY TO THE NETWORK AS SOON AS IT IS
*        ENTERED BY BLOCK SO THAT THE TREE MAY BE FLUSHED
*
*        SINCE RSA MUST BE REFILLED, THE ROUTINE ALSO HAS A
*        REINITIALIZATION ENTRY WITH WHICH IT REINITIALIZES
*        ITSELF TO BEGIN FILLING THE TREE AGAIN
*
*        IF THE CRCX TECHNIQUE IS USED THE RMAX CHECK AT RDP1035
*        IS BYPASSED. THIS BECOMES AN UNCONDITIONAL BRANCH TO
*        RDP1030-2
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - IERADP
*
*        MACROS USED BY MODULE -
*        SMPPI
*        GET
*
*        ENTRY POINTS - ENTRY FROM NETWORK
*                       CALLING SEQUENCE -
*                           L    R11,PPIDEB+4
*                           B    0(,R11)     AFTER G RCDS
*                           B    8(,R11)     FILL TREE
*
*                     - ENTRY FROM EOF
*                       CALLING SEQUENCE -
*
*                     - ENTRY FROM BLOCK OR ALGORITHM
*                       CALLING SEQUENCE -
*                           L    R11,PPIDEB+4
*                           B    8(,R11)     BLK=NRML,ALG=EOS
*
*                     - ENTRY FROM INITILIZATION ROUTINE
*                       CALLING SEQUENCE -
*                           L     R11,PPIDEB+4
*                           B     12(,R11)
*
*                     - ENTRY FROM GET
*                       CALLING SEQUENCE -
*                           BR   14         RETURN REG
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPINET   PPIBINSZ  PPISTOPF  PPISTOPR
*        PPIRMAXR
*        ADDR OF NETWORK, SIZE OF A BIN IN RSA
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        UPDATE RECORD COUNTER
*        PPICOUNT PPICNTL   PPISTOPR
*
*        EXTERNAL ROUTINES - NONE
*
*        EXTERNAL PARAMETERS - SEE REGISTERS
*
*        EXITS - NORMAL - EXIT TO NETWORK
*                         CALLING SEQUENCE -
*                             L    R11,PPINET+4
*                             B    4(,R11)     FILL TREE
*                             B    8(,R11)     ON EOF
*                             B    12(,R11)    NORMAL
*                             B    16(,R11)    FLUSH TREE
*
*                       - EXIT TO GET
*                         CALLING SEQUENCE -
*                             GET (R6)
*
*        EXITS - ERROR - NONE
*
*        TABLES/WORK AREAS -
*        TABLRSA  - TABLE CONSISTING OF UP TO 5 NONCONTIGUOUS RSA
*                   AREA ENTRIES WITH 8 BYTE ENTRIES FOR EACH RSA AREA
*        WADDRESS - ADDR OF RECORD WHICH LAST GET RETURNED IN R1
*        WRMAX    - COUNT OF RECORDS USED TO COMPARE WITH PPIRMAX
*        WADDRSA  - UPDATED ADDR OF NEXT FREE AREA IN RSA
*        WBYTECNT - COUNT OF REMAINING BYTES IN THIS RSA CHUNK
*
*        NOTES -
*        THIS MODULE WILL EXECUTE FOR FIXED LENGTH SORTS HAVING
*        RECORD LENGTHS LESS THAN OR EQUAL TO 256 BYTES AND W/O
*        EXITS E15 OR E16
*
IERRDP   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRDP SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRDPI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERRDPI  0101-20211-20211-1200-00165-00165-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERRDP SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERRDPI
*
         USING *,R11               THIS MODULE BASE REG
         USING IERRCA,R13          PPI ADDR
*
IERDD1   B     RDP1050             +00 FROM SORT NETWORK. G RECORDS
*                                      ARE IN THE TREE (ONCE ONLY)
         B     RDP1060             +04 FROM EOF ROUTINE
         B     RDP1010             +08 NORMAL ENTRY WHILE FILLING TREE
*                                      WILL BE OVERLAID BY -
*                                   B  RDP1020 WHEN RSA HAS BEEN FILLD
*                                   B  RDP1065 AFTER INPUT EOF
*
*        ENTRY TO REINITIALIZE IN ORDER TO BEGIN FILLING TREE
*
         MVC   RDP1040(8),KMOD5    REOVERLAY OVERLAID INSTRUCTIONS
         MVC   IERDD1+8(4),KMOD2
         L     R7,PPILAB08         LOAD ADDR OF RSA PARM TABLE
         ST    R7,ADCONPTR         STORE
         MVC   WADDRSA(8),0(R7)    MOVE NEW PARMS INTO WORK AREA
*                                  FIRST WORD  = ADDR NEXT RSA BIN
*                                  SECOND WORD = BIN BYTE COUNT MINUS
*                                                ONE RECORD LENGTH
         L     R1,WADDRESS         LOAD REGISTER FOR MOVE INSTRUCTION
         L     R3,WADDRSA          TO MOVE SAVED RECORD INTO RSA
         B     RDP1035             BRANCH TO MOVE RECORD
*
*        NORMAL ENTRY FROM NETWORK WHILE FILLING TREE
*        ENTRY FROM ALGORITHM ON OUTPUT EOS, NORMAL ENTRY FROM
*        BLOCK WHILE RUNNING
*
RDP1010  L     R3,WADDRSA          LOAD UPDATED ADDR OF RSA
RDP1020  NOP   0
         PPITEST PPISTOPF          STOP AFTER XXX RECORDS VALUE SET ?
         BZ    RDP102A             NO, BRANCH
         L     R15,DCBEODAD-IHADCB(R6)  R15 -> DCB EOD RTN
         ICM   R14,B'1111',PPISTOPR  R14 = STOP AFTER RECORD COUNT
         BZR   R15                 READ ENOUGH RECORDS, TRIGGER
*                                  DCB EOD EXIT ROUTINE
         BCTR  R14,0               DECR COUNT
         STCM  R14,B'1111',PPISTOPR  STORE DECREMENTED COUNT
RDP102A  L     R6,KADCB            ADDR OF THE INPUT DCB
*
         GET   (R6)                ON RETURN R1 -> INPUT RECORD
*
         ST    R1,WADDRESS         SAVE ADDR OF RECORD IN BUFFER
*
*        UPDATE RECORD COUNTER
*
         L     R6,PPICOUNT
         LA    R6,1(,R6)           INCR RCD COUNT BY 1
         ST    R6,PPICOUNT
RDP1035  L     R6,WRMAX            INCREMENT COUNTER FOR RMAX RMAX =
         LA    R6,1(,R6)           MAX NO OF RECORDS ON 1 REEL TAPE
         ST    R6,WRMAX            SAVE
         C     R6,PPIRMAX          RMAX RECORDS BEEN EXCEEDED ?
         BH    RDP1055             YES, BRANCH
*
*        MOVE RECORD FROM INPUT BUFFER TO RSA
*
         LR    R2,R1               LOAD PARM REG FOR SORT NETWORK
RDP1030  MVC   0(1,R3),0(R2)       MOVE RCD FROM INPUT BUFFER TO RSA
*                                  LENGTH SET BY ASSIGNMENT ROUTINE
*
*        UPDATE RSA TABLE PARAMETERS
*
RDP1040  LR    R5,R3               WILL BE OVLAYED BY BR TO NETWORK
*                                  AFTER G+1 RCDS
         A     R5,PPIBINSZ         UPDATE RSA ADDR TO NEXT BIN
         ST    R5,WADDRSA          STORE
         L     R4,WBYTECNT         LOAD REMAINING BYTES IN RSA CHUNK
         S     R4,PPIBINSZ         SUBTRACT LENGTH OF NEXT RECORD
         BM    RDP1045             BRANCH ON MINUS RESULT TO UPDATE PTR
         ST    R4,WBYTECNT         OTHERWISE STORE
*
*        INTERFACE WITH SORT NETWORK DURING FILL OF TREE
*
         L     R11,PPINET+4        ADDR OF NETWORK
         B     4(,R11)             BRANCH TO FILL TREE
*
*        UPDATE POINTER TO NEXT RSA TABLE ENTRY (NEXT RSA AREA)
*
RDP1045  L     R7,ADCONPTR         LOAD ADDR IN RSA PARAM TABLE
         LA    R7,8(,R7)           UPDATE TO NEXT TABLE ENTRY
         ST    R7,ADCONPTR         SAVE UPDATED POINTER TO TABLE
         MVC   WADDRSA(8),0(R7)    MOVE NEW PARMS INTO WORK AREA
*                                  FIRST WORD  = ADDR NEXT RSA BIN
*                                  SECOND WORD = BIN BYTE COUNT MINUS
*                                                ONE RECORD LENGTH
         L     R11,PPINET+4        ADDR OF SORT NETWORK
         B     4(,R11)             BRANCH TO FILL TREE
*
*        SORT TREE HAS BEEN FILLED
*        THE NEXT DEBLOCKED RECORD IS MOVED TO THE NEXT SPACE IN
*        RSA. IN ALL SUBSEQUENT ENTRIES TO THIS MODULE, R3 WILL
*        POINT TO THE WINNER RECORD IN RSA. THE DEBLOCKED RECORD
*        MUST BE MOVED TO THE LOCATION INDICATED BY R3. THIS
*        MODULE MUST NOW ENTER THE SORT NETWORK AT ITS NORMAL
*        ENTRY POINT. THE FOLLOWING CODE MODIFIES THIS MODULE TO
*        EFFECT THESE NEW REQUIREMENTS
*
RDP1050  MVC   IERDD1+8(4),KMOD1   MODIFY ENTRY BRANCH ADDR
         MVC   RDP1040(8),KMOD3    MODIFY EXIT ADDR
         B     RDP1010             RETURN TO GET NEXT RECORD
*
RDP1055  SR    R4,R4               RMAX COUNT HAS BEEN EXCEEDED
         ST    R4,WRMAX            ZERO OUT COUNT FOR RMAX IN PROGRAM
         PPISETON PPIRMAXR         SET RMAX BIT IN PPI
*
*        WHEN EOF HAS BEEN REACHED, THERE ARE NO MORE RECORDS TO
*        BE DEBLOCKED BUT THE SORT NETWORK MUST EMPTY ITS TREE.
*        FUTURE ENTRIES TO THIS MODULE DO NO PROCESSING, BUT
*        MERELY EXIT TO THE SORT NETWORK AT ITS EMPTYING ENTRY.
*        THE FOLLOWING CODING MODIFIES THE PRESENT ENTRY POINT TO
*        EFFECT THIS CHANGE AND THEN EXITS TO THE SORT NETWORK
*        AT ITS EOF ENTRY
*
RDP1060  MVC   IERDD1+8(4),KMOD4   BRANCH DIRECTLY TO SORT NETWORK
*
*        INTERFACE TO SORT NETWORK ON EOF
*
         L     R11,PPINET+4        ADDR OF SORT NETWORK
         B     8(,R11)
*
*        INTERFACE TO SORT NETWORK TO FLUSH TREE
*
RDP1065  L     R11,PPINET+4        BRANCH IMMEDIATELY BACK TO NETWORK
         B     16(,R11)            AFTER INPUT EOF
*
*        CONSTANTS
*
KMOD1    B     RDP1020             OVERLAY RDP1010 AFTER G+1 RCDS
KMOD2    B     RDP1010             TO RESTORE NETWORK ENTRY FOR FILLING
KMOD3    L     R11,PPINET+4        OVERLAY RDP1040 AFTER G+1 RCDS
         B     12(,R11)            NORMAL BRANCH TO NETWORK
KMOD4    B     RDP1065             RETURN TO NETWORK AFTER INPUT EOF
KMOD5    LR    R5,R3               TO RESTORE INSTRUCTIONS OVERLAID
         A     R5,PPIBINSZ         BY BRANCH TO NETWORK AFTER TREE
         ST    R5,WADDRSA          IS FILLED
*
KADCB    DC    F'0'                INPUT DCB ADDR LOADED BY AP
*
*        WORK AREAS/TABLES
*
WADDRESS DC    F'0'                ADDR OF RECORD FROM LAST GET
WRMAX    DC    F'0'                COUNT TO COMPARE AGAINST PPIRMAX
WADDRSA  DC    F'0'                UPDATED ADDR OF RSA
WBYTECNT DC    F'0'                REMAINING BYTE COUNT IN RSA CHUNK
ADCONPTR DS    F'0'
*
*        DCB DSECT
*
         PRINT NOGEN
*
         DCBD  DSORG=PS,DEVD=(DA,TA)
*
         PRINT GEN
*
./ ADD NAME=IERRDQ   0101-20211-20211-1200-00134-00134-00000-RELEASE 00
RDQ      TITLE 'IERRDQ - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRDQ
*
*        MODULE FUNCTION -
*        OSCL/CRCX SORT DEBLOCK FOR FIXED LENGTH RECORDS
*        WITHOUT USER EXIT E15
*        THE FUNCTION OF THIS MODULE IS TO HANDLE FIXED LENGTH
*        RECORDS USING THE GET LOCATE MACRO. THERE IS NO DATA
*        CHAINING. SORT RECORD LENGTH IS GREATER THAN 256 BYTES
*        SO THIS MODULE BRANCHES TO A MOVE ROUTINE IN GENERATED
*        CORE TO MOVE THE RECORD INTO RSA. THIS MODULE HANDLES UP
*        TO 5 NONCONTIGUOUS RSA'S. THE MODULE PASSES TO THE
*        REPLACEMENT NETWORK THE RECORD'S LOCATION IN RSA
*
*        INITIALLY FLOW IS BETWEEN DEBLOCK AND THE REPLACEMENT
*        NETWORK. AFTER G RECORDS ARE IN RSA THE NETWORK RETURNS
*        TO DEBLOCK FOR THE G+1 RECORD TO FORCE THE WINNER OUT OF
*        THE TREE AND ALSO ALLOWING DEBLOCK TO MODIFY ITSELF FOR
*        NORMAL FLOW. WHEN DEBLOCK RETURNS TO THE NETWORK WITH
*        THE G+1 RECORD THE WINNER IS GIVEN TO BLOCK BY THE
*        NETWORK. THE NORMAL FLOW THEN IS DEBLOCK-NETWORK-BLOCK-
*        DEBLOCK ETC. AT EOF OR ON THE (M-1)TH SEQUENCE OR WHEN
*        RMAX (= THE MAXIMUM RECORDS B&G HAS DECIDED CAN BE
*        CONTAINED ON ONE REEL OF TAPE) HAS BEEN REACHED, DEBLOCK
*        IS MODIFIED TO BRANCH DIRECTLY TO THE NETWORK AS SOON
*        AS IT IS ENTERED BY BLOCK SO THAT THE TREE MAY BE
*        FLUSHED
*
*        SINCE RSA MUST BE REFILLED, THE ROUTINE ALSO HAS A
*        REINITIALIZATION ENTRY WITH WHICH IT REINITIALIZES
*        ITSELF TO BEGIN FILLING THE TREE AGAIN
*
*        IF THE CRCX TECHNIQUE IS USED THE RMAX CHECK AT RDQ1035
*        IS BYPASSED
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - IERADQ
*
*        MACROS USED BY MODULE -
*        SMPPI
*        GET
*
*        ENTRY POINTS - ENTRY FROM NETWORK
*                       CALLING SEQUENCE -
*                           L    R11,PPIDEB+4
*                           B    0(,R11)     AFTER G RCDS
*                           B    8(,R11)     FILL TREE
*
*                     - ENTRY FROM EOF
*                       CALLING SEQUENCE -
*                           L    R11,PPIDEB+4
*                           B    4(,R11)     EOF
*
*                     - ENTRY FROM BLOCK OR ALGORITHM
*                       CALLING SEQUENCE -
*                           L    R11,PPIDEB+4
*                           B    8(,R11)     BLK=NRML,ALG=EOS
*
*                     - ENTRY FROM INITILIZATION ROUTINE
*                       CALLING SEQUENCE -
*                           L     R11,PPIDEB+4
*                           B     12(,R11)
*
*                     - ENTRY FROM GET OR MOVE RTN
*                       CALLING SEQUENCE -
*                           BR   14         RETURN REG
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPINET     PPIBDSVA   PPISTOPF  PPISTOPR
*        PPIBINSZ   PPIRMAXR
*        ADDR OF NETWORK, MOVE ROUTINE
*        SIZE OF A BIN USED TO UPDATE RSA POINTER
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPICOUNT   PPICNTL    PPISTOPR
*        UPDATE RECORD COUNTER
*
*        EXTERNAL ROUTINES -
*        MOVE ROUTINE IN GENERATED CORE TO MOVE RCD FROM INPUT
*        BUFFER TO RSA
*
*        EXTERNAL PARAMETERS - SEE REGISTERS
*
*        EXITS - NORMAL - EXIT TO NETWORK
*                         CALLING SEQUENCE -
*                             L    R11,PPINET+4
*                             B    4(,R11)     FILL TREE
*                             B    8(,R11)     ON INPUT EOF
*                             B    12(,R11)    NORMAL RUNNING
*                             B    16(,R11)    FLUSH TREE
*
*                       - EXIT TO GET
*                         CALLING SEQUENCE -
*                             GET  (R6)
*
*                       - EXIT TO MOVE RTN
*                         CALLING SEQUENCE -
*                             L    R15,PPIBDSVA+4 MOVE RTN ADDR
*                             BALR R14,R15
*
*        EXITS - ERROR - NONE
*
*        TABLES/WORK AREAS -
*        TABLRSA  - TABLE CONSISTING OF UP TO 5 ENTRIES . AN 8
*                   BYTE ENTRY FOR EACH NONCONTIGUOUS RSA
*        WADDRESS - ADDR OF RECORD WHICH LAST GET RETURNED IN R1
*        WRMAX    - COUNT OF RECORDS USED TO COMPARE WITH PPIRMAX
*        WADDRSA  - UPDATED ADDR OF NEXT FREE AREA IN RSA
*        WBYTECNT - COUNT OF REMAINING BYTES IN THIS RSA CHUNK
*
*        NOTES -
*        THIS MODULE WILL EXECUTE FOR FIXED LENGTH SORTS HAVING
*        RECORD LENGTHS GREATER THAN 256 BYTES AND W/O EXITS E15
*        OR E16
*
IERRDQ   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRDQ SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRDQI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERRDQI  0101-20211-20211-1200-00171-00171-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERRDQ SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERRDQI
*
         USING *,R11               MODULE BASE REGISTER
         USING IERRCA,R13
*
IERDD1   B     RDQ1050             +00 FROM SORT NETWORK G RECORDS
*                                      ARE IN THE TREE (ONCE ONLY)
         B     RDQ1060             +04 FROM EOF ROUTINE
*                                      ON EOF MODIFIED TO
*                                      B DRDQ1065
         B     RDQ1010             +08 NORMAL ENTRY WHILE FILLING TREE
*                                      WILL BE OVERLAID BY B RDQ1020
*                                      WHEN RSA HAS BEEN FILLED
*
*        ENTRY TO REINITIALIZE IN ORDER TO BEGIN FILLING TREE
*
         MVC   RDQ1040(8),KMOD5    +12 REOVERLAY OVERLAID INSTRUCTIONS
         MVC   IERDD1+8(4),KMOD2
         L     R7,PPILAB08         LOAD ADDR OF RSA PARAM TABLE
         ST    R7,ADCONPTR         STORE
         MVC   WADDRSA(8),0(R7)    MOVE NEW PARMS INTO WORK AREA
*                                  FIRST WORD  = ADDR NEXT RSA BIN
*                                  SECOND WORD = BIN BYTE COUNT MINUS
*                                                ONE RECORD LENGTH
         L     R1,WADDRESS         LOAD REGISTER FOR MOVE INSTRUCTION
         LR    R2,R1               INITIALIZE R2 IN CASE OF EXTRACT
         L     R3,WADDRSA          TO MOVE SAVED RECORD INTO RSA
         B     RDQ1035             BRANCH TO MOVE RECORD
*
*        NORMAL ENTRY FROM NETWORK WHILE FILLING TREE
*        ENTRY FROM ALGORITHM ON OUTPUT EOS
*        NORMAL ENTRY FROM BLOCK WHILE RUNNING
*
RDQ1010  L     R3,WADDRSA          LOAD UPDATED ADDR OF RSA
RDQ1020  L     R6,KADCB            R6 -> DCB
         PPITEST PPISTOPF          STOP AFTER XXX RECORDS VALUE SET ?
         BZ    RDQ102A             NO, BRANCH
         L     R15,DCBEODAD-IHADCB(R6)  R15 -> DCB EOD RTN
         ICM   R14,B'1111',PPISTOPR  R14 = STOP AFTER RECORD COUNT
         BZR   R15                 READ ENOUGH RECORDS, TRIGGER
*                                  DCB EOD EXIT ROUTINE
         BCTR  R14,0               DECR COUNT
         STCM  R14,B'1111',PPISTOPR  STORE DECREMENTED COUNT
*
RDQ102A  GET   (R6)                ON RETURN R1 -> NEXT RECORD
*
         ST    R1,WADDRESS         SAVE ADDR OF RECORD IN BUFFER
         LR    R2,R1               INITIALIZE R2 IN CASE OF EXTRACT
*
*        UPDATE RECORD COUNTER
*
         L     R6,PPICOUNT
         LA    R6,1(,R6)           INCR RECORD COUNT BY 1
         ST    R6,PPICOUNT
RDQ1035  L     R6,WRMAX            INCREMENT COUNTER FOR RMAX RMAX =
         LA    R6,1(,R6)           MAX NO OF RECORDS ON 1 REEL TAPE
         C     R6,PPIRMAX          RMAX RECORDS BEEN EXCEEDED ?
         BH    RDQ1055             YES, BRANCH
         ST    R6,WRMAX            SAVE
*
*        LINK TO MOVE LIST WHICH MOVES THE RECORD FROM THE INPUT
*        BUFFER TO RSA
*        R4 -> INPUT BUFFER RECORD
*        R5 -> RSA RECORD
*
RDQ1038  LR    R5,R3               ADDR IN RSA TO MOVE INPUT RECORD
         LR    R4,R1               INPUT RECORD ADDR
         L     R15,PPIBDSVA+4      R15 -> MOVE LIST
         BASR  R14,R15
*
*        UPDATE RSA TABLE PARAMETERS
*
RDQ1040  LR    R5,R3               ADDR OF RCD IN RSA WILL BE OVLAYED
*                                  BY BRANCH TO NETWORK AFTER G+1 RCDS
         A     R5,PPIBINSZ         UPDATE RSA ADDR TO NEXT BIN
         ST    R5,WADDRSA          STORE
         L     R4,WBYTECNT         LOAD REMAINING BYTES IN RSA CHUNK
         S     R4,PPIBINSZ         SUBTRACT LENGTH OF NEXT RECORD
         BM    RDQ1045             BRANCH ON MINUS RESULT TO UPDATE PTR
         ST    R4,WBYTECNT         OTHERWISE STORE
*
*        INTERFACE WITH SORT NETWORK DURING FILL OF TREE
*
         L     R11,PPINET+4        ADDR OF NETWORK
         B     4(,R11)             BRANCH TO FILL TREE
*
*        UPDATE POINTER TO NEXT ENTRY IN RSA TABLE
*        EQUALS NEXT RSA AREA
*
RDQ1045  L     R7,ADCONPTR         LOAD ADDR IN RSA PARM TABLE
         LA    R7,8(R7)            UPDATE TO NEXT TABLE ENTRY
         ST    R7,ADCONPTR         SAVE UPDATED POINTER TO TABLE
         MVC   WADDRSA(8),0(R7)    MOVE NEW PARMS INTO WORK AREA
*                                  FIRST WORD  = ADDR NEXT RSA BIN
*                                  SECOND WORD = BIN BYTE COUNT MINUS
*                                                ONE RECORD LENGTH
         L     R11,PPINET+4        ADDR OF SORT NETWORK
         B     4(,R11)             BRANCH TO FILL TREE
*
*        SORT TREE HAS BEEN FILLED
*        IN FUTURE ENTRIES TO THIS MODULE R3 -> WINNER RECORD IN
*        RSA. THE NEW RECORD WHICH HAS BEEN DEBLOCKED MUST BE
*        MOVED TO THE LOCATION IN RSA INDICATED BY R3
*        THIS MODULE MUST NOW ENTER THE SORT NETWORK AT 12(,R11).
*        THE FOLLOWING CODE MODIFIES THIS MODULE TO EFFECT
*        THESE NEW REQUIREMENTS
*
RDQ1050  MVC   IERDD1+8(4),KMOD1   MODIFY ENTRY BRANCH ADDR
         MVC   RDQ1040(8),KMOD3    MODIFY EXIT ADDR
         B     RDQ1010             RETURN TO GET NEXT RECORD
*
RDQ1055  SR    R4,R4               RMAX COUNT HAS BEEN EXCEEDED
         ST    R4,WRMAX            ZERO OUT COUNT FOR RMAX IN PROGRAM
         PPISETON PPIRMAXR         SET RMAX BIT IN PPI
*
*        WHEN EOF HAS BEEN REACHED, THERE ARE NO MORE RECORDS TO
*        BE DEBLOCKED BUT THE SORT NETWORK MUST EMPTY ITS TREE.
*        FUTURE ENTRIES TO THIS MODULE DO NO PROCESSING, BUT
*        MERELY EXIT TO THE SORT NETWORK AT 16(,R11). THE
*        FOLLOWING CODING MODIFIES THE PRESENT ENTRY POINT TO
*        EFFECT THIS CHANGE AND THEN EXITS TO THE SORT NETWORK AT
*        8(,R11) THE EOF ENTRY
*
RDQ1060  MVC   IERDD1+8(4),KMOD4   BRANCH DIRECTLY TO SORT NETWORK
*
*        INTERFACE TO SORT NETWORK ON EOF
*
         L     R11,PPINET+4        ADDR OF SORT NETWORK
         B     8(,R11)
*
*        INTERFACE TO SORT NETWORK TO FLUSH TREE
*
RDQ1065  L     R11,PPINET+4        BRANCH IMMEDIATELY BACK TO NETWORK
         B     16(,R11)            AFTER INPUT EOF
*
*        CONSTANTS
*
KMOD1    B     RDQ1020             OVERLAY RDQ1010 AFTER G+1 RCDS
KMOD2    B     RDQ1010             TO RESTORE NETWORK ENTRY FOR FILLING
KMOD3    L     R11,PPINET+4        OVERLAY RDQ1040 AFTER G+1 RCDS
         B     12(,R11)            NORMAL BRANCH TO THE NETWORK
KMOD4    B     RDQ1065
KMOD5    LR    R5,R3               TO RESTORE INSTRUCTIONS OVERLAID
         A     R5,PPIBINSZ         BY BRANCH TO NETWORK AFTER TREE
         ST    R5,WADDRSA          IS FILLED
*
KADCB    DC    F'0'                INPUT DCB ADDR LOADED BY AP
*
*        WORK AREAS/TABLES
*
WADDRESS DC    A(0)                ADDR OF RECORD FROM LAST GET
WRMAX    DC    F'0'                COUNT TO COMPARE AGAINST PPIRMAX
WADDRSA  DC    A(0)             *  UPDATED ADDR OF RSA
WBYTECNT DC    F'0'             V  REMAINING BYTE COUNT IN RSA CHUNK
ADCONPTR DC    F'0'
*
*        DCB DSECT
*
         PRINT NOGEN
*
         DCBD  DSORG=PS,DEVD=(DA,TA)
*
         PRINT GEN
*
./ ADD NAME=IERRDR   0101-20211-20211-1200-00182-00182-00000-RELEASE 00
RDR      TITLE 'IERRDR - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRDR
*
*        MODULE FUNCTION -
*        OSCL/CRCX SORT PHASE ROUTINE FOR FIXED LENGTH
*        RECORDS WITH E15 AND/OR E16
*        THE FUNCTION OF THIS MODULE IS TO DEBLOCK FIXED LENGTH
*        RECORDS USING THE GET MACRO AND CONTAINS LINKAGE TO THE
*        USER MODIFICATION PROGRAMS.
*        THE INPUT RECORDS ARE LOCATED IN AN INPUT BUFFER.
*        BEFORE MOVING THE RECORD TO THE WORK AREA CALLED RSA,
*        RECORD STORAGE AREA, THE MODULE BRANCHES TO THE USER RTN
*        WHICH MAY -
*        1. DELETE
*        2. INSERT OR
*        3. ALTER, LENGTHEN, SHORTEN, OR DO NOTHING TO THE RECORD
*        THE ADDRESS OF THE RECORD IN THE INPUT AREA IS PASSED
*        TO THE USER. THE USER EXIT RETURNS VIA BRANCH REGISTER
*        AND PROPER DISPLACEMENTS
*
*        THIS MODULE KEEPS TRACK OF THE MAXIMUM AMOUNT OF
*        RECORDS THAT THE SORT CAN HANDLE AT ANY ONE TIME NMAX.
*        IT CHECKS TO SEE IF NMAX IS REACHED, AND WHEN IT IS
*        REACHED IT BRANCHES TO THE USER EXIT WHICH MAY -
*        1. SORT CURRENT NO
*        2. IGNORE NMAX OR
*        3. TERMINATE THE JOB
*        THE USER EXIT RETURNS VIA BRANCH REG AND PROPER
*        DISPLACEMENTS
*
*        THE MODULE ALSO KEEPS TRACK OF RMAX (= TO THE MAXIMUM
*        NUMBER OF RECORDS WHICH B&G HAS DECIDED WILL FIT ON ONE
*        REEL OF TAPE) AND CAUSES THE FLUSHING OF RSA AND A MERGE
*        TO FILL ONE REEL, WHICH IS THEN SET ASIDE
*
*        THE MODULE MOVES THE RECORD TO RSA AND PASSES THE
*        RECORD'S LOCATION IN RSA TO THE REPLACEMENT SORT. THIS
*        MODULE HANDLES UP TO 5 NON CONTIGUOUS RSA AREAS
*
*        THIS ROUTINE HAS A REINITIALIZATION ENTRY THRU WHICH IT
*        CAN REINITIALIZE ITSELF TO BEGIN REFILLING RSA AFTER A
*        MERGE HAS TAKEN PLACE
*
*        THE OPERATION OF THIS MODULE DOES NOT DEPEND UPON A
*        PARTICULAR REPRESENTATION OF THE EXTERNAL CHARACTER SET
*
*        IF THE CRCX TECHNIQUE IS USED, THE RMAX CHECK AT
*        RDRMXCNT IS BYPASSED THIS BECOMES AN UNCONDITIONAL
*        BRANCH TO RDOVLAY5
*
*        CHANGE LOG -
*        CORRECT IMPLEMENTATION OF STOPAFT PARAMETER          REL 1.1
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - IERADR
*
*        MACROS USED BY MODULE - SMPPI
*        GET
*
*        ENTRY POINTS - ENTRY FROM NETWORK
*                       CALLING SEQUENCE-
*                           L    R11,PPIDEB+4
*                           B    0(,R11)     AFTER G RCDS
*                           B    8(,R11)     FILL TREE
*
*                     - ENTRY FROM EOF
*                       CALLING SEQUENCE -
*                           L    R11,PPIDEB+4
*                           B    4(,R11)     EOF
*
*                     - ENTRY FROM BLOCK OR ALGORITHM
*                       CALLING SEQUENCE -
*                           L    R11,PPIDEB+4
*                           B    8(,R11)     BLK=NRML,ALG=EOS
*
*                     - ENTRY FROM INITIALIZATION ROUTINE
*                       CALLING SEQUENCE -
*                           L     R11,PPIDEB+4
*                           B     12(,R11)
*
*                     - ENTRY FROM GET, MOVE RTN, E15, E16, SSC
*                       CALLING SEQUENCE -
*                           BR    R14       RETURN REG
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPINET     PPIADSSC  PPISTOPF
*        PPIX16     PPIBDSVA  PPISTOPR
*        PPICNTL    PPIRMA
*        PPIBINSZ   PPIX15
*        PPIRMAXR
*        ADDR OF NETWORK, MOVE RTN, EXITS, SORT SYSTEM CONTROL,
*        MESSAGE MODULE, AND BINSIZE TO UPDATE RSA POINTER
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        UPDATE RECORD, DELETE, AND INSERT COUNTERS
*        PPICOUNT   PPIDELCT  PPISTOPR
*        PPIINSCT   PPICNTL
*
*        EXTERNAL ROUTINES -
*        MOVE ROUTINE TO MOVE RECORD FROM THE BUFFER TO RSA
*
*        EXTERNAL PARAMETERS - SEE REGISTERS
*
*        EXITS - NORMAL - EXIT TO NETWORK
*                         CALLING SEQUENCE -
*                             L    R11,PPINET+4
*                             B    4(,R11)     FILL TREE
*                             B    8(,R11)     ON INPUT EOF
*                             B    12(,R11)    NORMAL RUNNING
*                             B    16(,R11)    FLUSH TREE
*
*                       - EXIT TO GET
*                         CALLING SEQUENCE -
*                             GET  (R6)        R6 -> DCB
*
*                       - EXIT TO MOVE RTN
*                         CALLING SEQUENCE -
*                             L    R15,PPIBDSVA+4 MOVE RTN ADDR
*                             BALR R14,R15
*
*                       - EXIT TO E15 (OR ATTACHED EXIT)
*                         CALLING SEQUENCE -
*                             L    R15,PPIX15+4
*                             BALR R14,R15
*
*                       - EXIT TO SSC
*                         CALLING SEQUENCE -
*                             L    R15,PPIADSSC
*                             BALR R14,R15
*
*        EXITS - ERROR - EXIT TO E16
*                        CALLING SEQUENCE -
*                           L    R15,PPIX16+4
*                           BALR R14,R15
*
*        TABLES/WORK AREAS -
*        WSW1      - SWITCH IN THE INSERT RTN
*        WINNER    - SAVE AREA FOR ADDR IN RSA THAT THE WINNER JUST
*                    VACATED
*        WNMAX     - NMAX COUNTER
*        WDCB     -> INPUT FILE'S DCB
*        WRJ-2     - REGISTER SAVE AREA
*        WINPTRCD -> RECORD IN INPUT AREA
*        WADDRESS -> NEXT RECORD TO BE MOVED INTO RSA WHEN THE
*                    TREE IS REFILLED
*        WRMAX     - COUNT OF RECORDS USED TO COMPARE WITH PPIRMAX
*        WADDRSA   - UPDATED ADDR OF NEXT FREE AREA IN RSA
*        WBYTECNT  - COUNT OF REMAINING BYTES IN THIS RSA CHUNK
*
*        NOTES -
*        THIS MODULE WILL EXECUTE FOR ANY FIXED LENGTH SORT
*        HAVING USER EXITS E15 AND/OR E16 OR WHICH IS ATTACHED,
*        WHICH USES THE OSCILLATING OR CRCX METHOD
*
IERRDR   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRDR SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRDRI
*
*        MODULE NAME - IERRMA
*
*        THIS MODULE CONTAINS ALL OF THE MESSAGES THAT ARE
*        REQUIRED FOR PHASE 1 RUNNING PROGRAM
*
IERRMA   DSECT
*
         COPY  RMAMAIN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERRDRI  0101-20211-20211-1200-00341-00341-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERRDR SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERRDRI
*
         USING *,R11               MODULE BASE REG LOADED EXTERNALLY
         USING IERRCA,R13          PPI ADDR
         USING IERRMA,R14          MESSAGE MODULE ADDR
*
*        ENTER BRANCH TABLE
*        FROM REPLACEMENT SORT 0(,R11)
*        FROM READ MOD 4(,R11) OR
*        FROM REPLACEMENT SORT (INITIALLY TO FILL TREE),
*        ALGORITHM AT THE END OF A SEQUENCE BLOCK MODULE
*        AFTER FILLING TREE 8(R11)
*
IERDD1   B     RDOVLAYF            +00 REPL SORT, FINISHD FILLING TREE
         B     RDSETSW             +04 READ MOD (GET ON EOF)
         B     RDNORMAL            +08 NORMAL ENTRY FROM REPLACEMENT
*                                      SORT BLOCK MODULE OR ALGORITHM
*
*        ENTRY TO REINITIALIZE IN ORDER TO BEGIN REFILLING TREE
*
         OI    RDOVLAY6+1,X'F0'    +12 REACT BR INSTR TO FILLING EXIT
         NI    RDDOVLAY+1,X'00'    NOP BRANCH ON (G+1)TH RECORD
         MVC   RDNORMAL,K6         REINITIALIZE ENTRY BRANCH INSTR
         MVC   RDOVLAY5,K7         REOVERLAY BRANCH ON (G+1)TH RECORD
         L     R10,PPILAB08        LOAD ADDR OF RSA PARM TABLE
         ST    R10,ADCONPTR        STORE
         MVC   WADDRSA(8),0(R10)   MOVE NEW RSA PARMS INTO WORK AREA
*                                  FIRST WORD  = ADDR NEXT RSA BIN
*                                  SECOND WORD = BIN BYTE COUNT
         L     R1,WADDRESS         LOAD ADDR OF LAST RCD FOR MOVE RTN
         L     R3,WADDRSA          TO MOVE SAVED RCD INTO RSA
         B     RDRMXCNT
*
*        FROM REPLACEMT SORT BLOCK MOD, OR ALGORITHM
*
RDNORMAL ST    R3,WINNER           ADDR OF A FREE AREA IN RSA LAST WNR
RDLDCTRS STM   R9,R10,WRJ          SAVE TRANSPARENT REGS
         LM    R9,R10,WNMAX        RESTORE NMAX AND DCB ADDR
RDTSTISW PPITEST  PPIUIIP          USER INSERT IN PROGRESS ? OVERLY BY
*                                  AP IF ATTACHED, OR BY RP ON
*                                  SYSTEM EOF, WITH B RDUSREXT
         BO    RDUSREXT            ON, BRANCH TO USER EXIT
*
RDGET    NOP   0
         PPITEST PPISTOPF          STOP AFTER XXX RECORDS VALUE SET ?
         BZ    RDGETA              NO, BRANCH
         L     R15,DCBEODAD-IHADCB(R10)  R15 -> DCB EOD RTN
         ICM   R14,B'1111',PPISTOPR  R14 = STOP AFTER RECORD COUNT
         BZR   R15                 READ ENOUGH RECORDS ? TRIGGER
*                                  DCB EOD EXIT ROUTINE
         BCTR  R14,0               DECR COUNT
         STCM  R14,B'1111',PPISTOPR  STORE DECREMENTED COUNT
*
RDGETA   GET   (R10)               ON RETURN R1 -> NEXT RECORD
*
         L     R6,PPICOUNT         RECORD COUNTER
         LA    R6,1(,R6)           INCR RECORD CTR
         ST    R6,PPICOUNT         STORE RECORD COUNT
         ST    R1,WADDRESS         SET FOR R4 INIT ENTRY
         ST    R1,WINPTRCD         SAVE ADDR OF RCD THATS IN INPUT BLK
*
*        CALL USER MOD EXIT E15
*        PASS ADDR OF PARAMETER LIST (ADDR OF INPUT RECORD) IN R1
*
RDUSREXT LA    R1,WINPTRCD         ADDR OF PARAMETER LIST IF E15 NOT
*                                  ACTIVATED, OR IF ACTIVATED AND HIT
*                                  USER EOF, THIS INSTR WILL BE OVLAYED
*                                  BY B RDALSHNO
         MVC   UEXIT,PPIUEXIT      SETUP USER EXIT WORD
         L     R15,PPIX15+4        ADDR OF USER EXIT E15 IF ATTACHED
*                                  AP WILL LOAD PPIX15 WITH ADDR IN
*                                  PPIATP1E
         BASR  R14,R15             CALL USER EXIT E15
         MVC   PPIUEXIT,UEXIT      SAVE USER EXIT WORD FOR NEXT CALL
*
*        USER RETURNS TO MODULE VIA R14 AND RETURN CODE IN R15
*
*        USER EXIT PASSES ADDR OF RECORD TO BE INSERTED OR ADDR
*        OF WORK AREA IF THE EXIT ALTERS, LENGTHENS OR SHORTENS
*        THE RECORD POINTED TO BY R1
*
         B     *+4(R15)       *
RDOVLAY4 B     RDALSHNO       |    +00 ALTER,LENGTHN,SHORTN,DO NOTHING
*                             |        WILL BE OVERLAYED BY K4 IF,WHEN
*                             |        REACH NMAX IT IS IGNORED, OR BY
*                             |        AP WITH K4 IF EXIT NOT ACTIVE
         B     RDDELETE       |    +04 DELETE A RECORD
         B     RDUSREOF       |    +08 USER END OF FILE
*                             |
*        INSERT A RECORD      |
*                             |
RDTSTNMX BCT   R9,RDISWON     V    +12 DECR NMAX CTR BY ONE
*                                      TEST TO SEE IF REACHED
*                                      NMAX WILL BE OVERLAYED BY
*                                      K3 IF, WHEN REACH NMAX IT
*                                      IS IGNORED, OR BY AP WITH
*                                      K3 IF EXIT NOT ACTIVE
         B     RDWSW1ON            BRANCH TO NMAX USER EXIT E16
*
*        SYSTEM END OF FILE ROUTINE
*
RDSETSW  PPITEST  PPIUEOF          USER EOF ON ?
         BO    RDCNTSRT            YES, BRANCH TO FLUSH TREE
         PPITEST  PPIPEOF          ASSIGNMENT TIME EOF ?
         BZ    RDCNTSRT            YES, BRANCH TO FLUSH TREE
         CLI   REALEOF,X'01'       SIMULATED EOF AFTER REAL EOF ?
         BE    RDCNTSRT            YES, BRANCH
         MVI   REALEOF,X'01'       SET SWITCH TO INDICATE REST OF
*                                  EOF'S ARE SIMULATED
         SR    R1,R1               CLEAR INPUT RCD PARM REG
         MVC   RDTSTISW,K5         TO BYPASS GOING TO GET AFTER SYS EOF
         B     RDUSREXT-4          BRANCH TO USER
*
*        USER END OF FILE ROUTINE
*
RDUSREOF PPISETON PPIUEOF          SET USER EOF SWITCH
         MVC   RDUSREXT,RDOVLAY4   OVLAY USER EXIT BYPASS EXIT E15
         PPITEST  PPIPEOF          SYSTEM EOF SWITCH ON ?
         BO    RDCNTSRT            YES, BRANCH TO EOF FLUSH RTN
         L     R1,WINPTRCD         RESTORE ADDR OF RCD IN INPUT BLK
         B     RDALSHNO            BRANCH TO SORT THIS RECORD
*
RDISWON  PPISETON PPIUIIP          TURN ON USER INSERT IN PROCESS
         L     R8,PPIINSCT         INSERT COUNT
         LA    R8,1(,R8)           INCR INSERT CTR
         ST    R8,PPIINSCT         STORE INSERT COUNT
RDSTM    ST    R1,WADDRESS         SAVE FOR R4 INIT
         ST    R9,WNMAX            SAVE NMAX CTR
RDRMXCNT L     R6,WRMAX            INCREMENT COUNTER FOR RMAX RMAX =
         LA    R6,1(,R6)           MAX NO OF RECORDS ON 1 REEL TAPE
         C     R6,PPIRMAX          RMAX RECORDS BEEN EXCEEDED ?
         BH    RDRMAX              YES, BRANCH
         ST    R6,WRMAX            SAVE
*
*        INITALIZE AND BRANCH TO MOVE RTN TO MOVE NEXT INPUT RECORD
*        TO RSA
*
RDOVLAY5 B     RDDLDRSA            BR TO GET ADDR IN RSA TO MOVE RCD
*                                  WILL BE OVERLAYED BY L R5,WINNER
*                                  AFTER G+1 RCDS
RDDLDRE  LR    R4,R1               ADDR OF RCD IN INPUT BUFFER OR FROM
*                                  USER'S WORK AREA
         L     R15,PPIBDSVA+4      ADDR OF MOVE RTN IN GENERATED CORE
         BASR  R14,R15             BRANCH TO MOVE RTN MOVE RCD TO RSA
RDOVLAY6 B     RDFILLTR            BR TO SORT NETWORK FILLING TREE RTN
*                                  WILL BE OVLAYED BY NOP AFTER
*                                  TREE IS INITIALLY FILLED
*
*        NORMAL EXIT TO SORT NETWORK AFTER PREVIOUS INSTR IS
*        OVERLAYED BY NOP
*
         LR    R2,R1               ADDR OF RCD IN INPUT BUFFER
         L     R3,WINNER
         L     R11,PPINET+4        ADDR OF SORT NETWORK
         B     12(,R11)            BRANCH TO SORT NETWORK NORMAL RTN
*
*        EXIT TO SORT NETWORK WHILE FILLING TREE
*
RDFILLTR LR    R2,R1               ADDR OF RCD IN INPUT BUFFER
         A     R3,PPIBINSZ         UPDATE TO NEXT BIN IN THIS RSA
         ST    R3,WADDRSA          SAVE UPDATED RSA ADDRESS
         S     R3,PPIBINSZ         RESTORE FOR NETWORK ADDR OF THIS
*                                  RCD IN RSA
         L     R11,PPINET+4        ADDR OF NETWORK
         B     4(,R11)             BRANCH TO SORT NETWORK FILL TREE RTN
*
*        FINISHED FILLING TREE RTN - ONE TIME RTN
*
RDOVLAYF NI    RDOVLAY6+1,X'00'    NOP THE BR INSTR TO THE FILLING EXIT
         MVI   RDDOVLAY+1,X'F0'    OVERLAY INSTR IN RSA TABLE ROUTINE
         B     RDLDCTRS            BRANCH TO GET G+1 RECORD
*
*        RSA TABLE ROUTINE USED DURING FILLING OF TREE
*        ENTER HERE ONLY THROUGH G+1 RECORDS
*
RDDLDRSA L     R10,ADCONPTR        RSA TABLE PTR
RDDRTRN  LM    R3,R4,WADDRSA       R3 = ADDR IN THIS RSA
*                                  R4 = REMAINING BYTE CNT OF THIS RSA
         S     R4,PPIBINSZ         SUBTR SIZE OF THIS RCD
         BM    RDNEWRSA            BR IF MINUS RCD CANT FIT IN THIS RSA
RDDOVLAY NOP   RDDLAST             WILL BE A BR AFTER RSA HAS G RCDS
         ST    R4,WBYTECNT         SAVE REMAINING BYTE COUNT THIS RSA
         LR    R5,R3               ADDR IN RSA TO MOVE THE RCD
         B     RDDLDRE             BRANCH TO MOVE RCD TO RSA
*
RDNEWRSA LA    R10,8(,R10)         UPDATE RSA TABLE PTR TO NEXT RSA
*                                  ENTRY (NEXT NONCONTIGUOUS RSA)
         ST    R10,ADCONPTR        SAVE UPDATED PTR
         MVC   WADDRSA(8),0(R10)   MOVE NEW PARMS INTO WORK AREA
*                                  FIRST WORD  = ADDR NEXT RSA BIN
*                                  SECOND WORD = BIN BYTE COUNT
         B     RDDRTRN             BRANCH TO USE THIS RSA
*
*        PROCESS THE G+1 RECORD
*
RDDLAST  ST    R3,WINNER           ADDR IN RSA TO MOVE RCD
         MVC   RDOVLAY5(4),K1      OVLAY BRANCH INSTR TO RSA TABLE RTN
         B     RDOVLAY5            BRANCH TO MOVE G+1 RCD TO RSA
*
*        FROM USER ON NMAX RETURN
*        SORT CURRENT NO OF RCDS ONLY
*
RDSETPPI PPISETON PPIFSZE          TURN ESTIMATED FILE SWITCH ON
         PPISETON PPIUEOF          SET USER EOF FOR ALG
         PPITEST  PPIPEOF          SYS EOF REACHED ?
         BO    RDCNTSRT            YES, BRANCH AROUND NEXT INSTRUCTION
*                                  FLUSH TREE
         L     R6,PPICOUNT         RECORD COUNT
         BCTR  R6,0                DECR PPICOUNT
         ST    R6,PPICOUNT         STORE RECORD COUNT
         PPISETON PPIPEOF          SET EOF SW SO ALG WON'T RETURN
*
*        FROM GET ON END OF FILE
*
RDCNTSRT MVC   RDNORMAL,K2         OVERLAY DEBLOCK MODULE
         L     R11,PPINET+4        ADDR OF NETWORK
         B     8(,R11)             BRANCH TO NETWORK TO EMPTY TREE
*
RDEMPTYT L     R11,PPINET+4        ADDR OF NETWORK
         B     16(,R11)            BR TO SORT TO CONTINUE EMPTYING TREE
*
*        WRITE DIAGNOSTIC MESSAGE NMAX EXCEEDED
*
RDWSW1ON OI    WSW1,X'01'          TURN SWITCH 1 ON
RDMSGS   L     R14,PPIRMA+4        ADDR OF MESSAGE MODULE
         LR    R4,R1               SAVE ADDR OF NMAX+1 RCD
         LM    R0,R1,IER048        IER048I ESTIMATED MAXIMUM RECORD
         L     R15,PPIADSSC        LOAD PRINT RTN ADDR
         BAS   R14,12(,R15)        CALL PRINT RTN
*
*        CALL USER EXIT E16 - SORT CAPACITY NMAX HAS BEEN REACHED
*
         LR    R1,R4               RESTORE ADDR OF NMAX+1 RCD
         L     R15,PPIX16+4        ADDR OF NMAX EXIT
         BASR  R14,R15             CALL USER EXIT E16
*
*        USER RETURNS TO MODULE VIA R14 AND PROPER DISPLACEMENTS
*
         B     *+4(R15)
         B     RDSETPPI            +00 SORT CURRENT NO OF RCDS ONLY
         B     RDIGNORE            +04 IGNORE NMAX AND CONTINUE TO SORT
*
*        TERMINATE THE JOB
*        SET UP ABNORMAL END INDICATION FOR SORT SYSTEM CONTROL
*
         MVC   PPIABMNO,IERZ800    +08 SET ABEND CODE
         L     R15,PPIADSSC
         BAS   R14,16(,R15)        BRANCH TO SORT SYSTEM CONTROL
*                                  NO RETURN
*
IERZ800  DC    C'800'
*
*        IGNORE NMAX
*        OVERLAY NMAX TEST WITH A BYPASS BRANCH INSTRUCTION
*
RDIGNORE MVC   RDTSTNMX(4),K3      OVERLAY NMAX TEST INSERT RTN
         CLC   RDUSREXT,RDOVLAY4   USER EXIT CODE BEEN OVERLAID ?
         BNE   *+10                NO, BRANCH AROUND NEXT INSTRUCTION
         MVC   RDUSREXT,K4         CHANGE OVERLAID INSTRUCTION
         MVC   RDOVLAY4(4),K4      OVERLAY NMAX TEST,DO NOTHG,ALTER RTN
         TM    WSW1,X'01'          TEST SWITCH 1
         BO    RDISWON             ON, BRANCH TO TURN INSERT SWITCH ON
         B     RDISWOFF            BRANCH TO TURN INSERT SWITCH OFF
*
*        DO NOTHING, ALTER, LENGTHEN, SHORTEN A RCD
*        R1 -> INPUT RCD
*
RDALSHNO BCT   R9,RDISWOFF         DECR NMAX CTR BY ONE AND TEST TO SEE
*                                  NMAX REACHED
         B     RDMSGS              YES, BRANCH TO NMAX USER EXIT E16
*
RDISWOFF PPISETOF PPIUIIP          TURN OFF INSERT SWITCH
         B     RDSTM               BR TO LOAD ADDR OF FREE AREA IN RSA
*
*        DELETE A RECORD
*
RDDELETE PPISETOF PPIUIIP         TURN OFF INSERT SWITCH
         L     R7,PPIDELCT         DELETE COUNT
         LA    R7,1(0,R7)          INCR DELETE CTR BY ONE
         ST    R7,PPIDELCT         STORE DELETE COUNT
         B     RDGET               BRANCH TO GET ANOTHER RECORD
*
*        ENOUGH RECORDS HAVE BEEN READ IN TO FILL ONE REEL OF TAPE
*
RDRMAX   SR    R4,R4               RMAX COUNT HAS BEEN EXCEEDED
         ST    R1,WADDRESS         SAVE ADDR OF THIS RECORD
         ST    R4,WRMAX            ZERO OUT COUNT FOR RMAX IN PROGRAM
         PPISETON PPIRMAXR         SET RMAX BIT IN PPI
         MVC   RDNORMAL,K2         OVERLAY DEBLOCK MODULE
         L     R11,PPINET+4        ADDR OF NETWORK
         B     8(,R11)             BRANCH TO NETWORK TO EMPTY TREE
*
*        CONSTANTS
*
K1       L     R5,WINNER           OVERLAY WHEN FINISHED FILLING TREE
K2       B     RDEMPTYT            OVERLAY TO EMPTYTREE ON GET EOF
K3       B     RDISWON             BYPASS NMAX TEST IN INSERT RTN
K4       B     RDISWOFF            BYPASS NMAX TEST IN DO NOTHG,ETC RTN
K5       B     RDUSREXT            OVERLAY INSERT SW TEST BY AP IF
*                                  ATTACHED
K6       ST    R3,WINNER           AD OF FREE AREA IN RSA - LAST WINNER
K7       B     RDDLDRSA            BR TO GET AD IN RSA TO MOVE RECORD
*
*        WORK AREAS
*
WSW1     DC    X'00'               SWITCH 1 IN INSERT RTN
REALEOF  DC    X'00'
WINNER   DC    F'0'                SORT WINNER RCD ADDR
WNMAX    DC    F'0'                MAX NO OF RCDS TO SORT PLUS ONE (FOR
*                                  SPEED CAN NOW USE BCT TO DECR
*                                  NMAX CTR TO ZERO)
WDCB     DC    F'0'                ADDR OF DCB FOR INPUT FILE
*                                  LOADED BY ASSIGNMENT ROUTINE
WRJ      DC    2F'0'               SAVE TRANPARENT REGS
*
*        PARAMETER LIST PASSED TO E15 EXIT
*
WINPTRCD DC    F'0'                -> RECORD IN INPUT AREA
UEXIT    DC    F'0'                USER EXIT WORD
*
WADDRESS DC    F'0'                -> NEXT RECORD TO BE MOVED
WRMAX    DC    F'0'                COUNT TO COMPARE AGAINST PPIRMAX
WADDRSA  DC    F'0'                UPDATED ADDR OF RSA
WBYTECNT DC    F'0'                REMAINING BYTE COUNT IN RSA CHUNK
ADCONPTR DC    F'0'                UPDATED ADDR OF RSA PARAM TABLE
*
*        DCB DSECT
*
         PRINT NOGEN
*
         DCBD  DSORG=PS,DEVD=(DA,TA)
*
         PRINT GEN
*
./ ADD NAME=IERRDS   0101-20211-20211-1200-00150-00150-00000-RELEASE 00
RDS      TITLE 'IERRDS - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRDS
*
*        MODULE FUNCTION -
*        OSCL/CRCX SORT PHASE DEBLOCK MODULE WHICH
*        HANDLES VARIABLE LENGTH RECORDS BY WAY OF THE QSAM GET
*        MACRO AND CONTAINS LINKAGE TO THE USER MODIFICATION
*        EXITS E15 AND E16. THE INPUT RECORDS ARE LOCATED IN AN INPUT
*        BUFFER. BEFORE MOVING THE RECORD TO THE WORK AREA, RSA,
*        THE MODULE BRANCHES TO THE USER ROUTINE WHICH MAY -
*        1. DELETE
*        2. INSERT OR
*        3. ALTER, LENGTHEN, SHORTEN OR DO NOTHING TO THE RECORD
*        THE ADDRESS OF THE RECORD IN THE INPUT AREA IS PASSED
*        TO THE USER. THE USER RETURNS VIA BRANCH REGISTER AND
*        PROPER DISPLACEMENTS. THIS MODULE KEEPS TRACK OF THE
*        MAXIMUM AMOUNT OF RECORDS THAT THE SORT CAN HANDLE AT
*        ANY ONE TIME (NMAX). IT CHECKS TO SEE IF NMAX IS REACHED
*        AND IF IT IS REACHED, IT BRANCHES TO THE USER ROUTINE
*        WHICH MAY -
*        1. SORT CURRENT NUMBER
*        2. IGNORE NMAX OR
*        3. TERMINATE JOB
*        THE USER RETURNS VIA BRANCH REGISTER AND PROPER
*        DISPLACEMENTS. THE MODULE BRANCHES TO THE MOVE MODULE
*        IERRBF WHICH MOVES THE RECORD INTO RSA. IERRDS THEN
*        PASSES THE RECORD'S LOCATION IN RSA TO THE REPLACEMENT
*        SORT. USER EXITS E15 AND E16 ARE AVAILABLE IN THIS
*        MODULE. IT ALSO CHECKS TO DETERMINE WHEN RMAX HAS BEEN
*        REACHED, THE MAXIMUM NUMBER OF BYTES WHICH CAN FIT ONTO
*        ONE REEL OF TAPE, AND CAUSES RSA TO BE FLUSHED, FOLLOWED
*        BY A MERGE ONTO ONE REEL, WHICH IS THEN SET ASIDE. IT
*        CAN REINITIALIZE ITSELF TO BEGIN REFILLING RSA AFTER IT
*        HAS BEEN FLUSHED AND A MERGE TAKEN PLACE
*
*        IF THE CRCX TECHNIQUE IS USED, THE RMAX CHECK AT
*        RDSRMAX IS BYPASSED. THIS BECOMES AN UNCONDITIONAL
*        BRANCH TO RDSPTB
*
*        CHANGE LOG -
*        CORRECT IMPLEMENTATION OF STOPAFT PARAMETER          REL 1.1
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - IERADS
*
*        MACROS USED BY MODULE -
*        SMPPI
*        GET
*
*        ENTRY POINTS - ENTRY FROM NETWORK
*                       CALLING SEQUENCE -
*                           L     R11,PPIDEB+4
*                           B     8(,R11)    DURING TREE FILL
*
*                           L     R11,PPIDEB+4
*                           BR    R11        ONCE - WHEN TREE FULL
*
*                     - ENTRY FROM BLOCK
*                       CALLING SEQUENCE -
*                           L     R11,PPIDEB+4
*                           B     8(,R11)
*
*                     - ENTRY FROM EOF ROUTINE
*                       CALLING SEQUENCE -
*                           L     R11,PPIDEB+4
*                           B     4(,R11)
*
*                     - ENTRY FROM INITILIZATION ROUTINE
*                       CALLING SEQUENCE -
*                           L     R11,PPIDEB+4
*                           B     12(,R11)
*
*                     - ENTRY FROM E15
*                       CALLING SEQUENCE -
*                           BR    R14
*
*                     - ENTRY FROM E16
*                       CALLING SEQUENCE -
*                           BR    R14
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIBDSVA   PPINET      PPISTOPF
*        PPIX15     PPIX16      PPISTOPR
*        PPISTDCB   PPICOUNT
*        PPINSCT    PPIDELCT
*        PPIRMA     PPIADSSC
*        PPIRMAXR
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPIBDSVA   PPICOUNT    PPISTOPR
*        PPIINSCT   PPIDELCT
*        PPICNTL
*
*        EXTERNAL ROUTINES - EXTRN IERRMA - ERROR MESSAGE PRINT RTN
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL -
*        E15     - PHASE 1 RECORD MODIFICATION EXIT
*        E16     - PHASE 1 NMAX EXIT
*        NETWORK - PASS ADDR OF EACH INCOMING RECORD
*
*        EXITS - ERROR -
*        PPIADSSC - PRINT NMAX REACHED MESSAGE
*
*        TABLES/WORK AREAS -
*        WSAVE    - 3 WORD AREA TO SAVE REGISTER INFORMATION FOR
*                   MOVE ROUTINE WHEN ONLY A PORTION OF A RECORD
*                   FITS IN RSA
*        WNMAX    - RUNNING COUNT OF RECORDS IS KEPT SO IT CAN BE
*                   DETERMINED WHEN NMAX HAS BEEN REACHED
*        WINSALT  - INSERT - ALTER RECORD SWITCH
*        WSAVAIL  - SAVE AREA FOR THE RSA ADDR OF THE RECORD
*                   CURRENTLY BEING MOVED
*        WRMAX    - BYTE COUNT TO COMPARE AGAINST PPIRMAX
*        WADDRESS - ADDR OF NEXT RECORD TO BE MOVED INTO RSA
*                   WHEN THE TREE IS REFILLED
*
*        NOTES -
*        THIS MODULE IS USED FOR VARIABLE LENGTH RECORD SORTS
*        WHICH HAVE EXITS 15 OR 16 ACTIVE
*
IERRDS   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRDS SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRDSI
*
*        MODULE NAME - IERRMA
*
*        THIS MODULE CONTAINS ALL OF THE MESSAGES THAT ARE
*        REQUIRED FOR PHASE 1 RUNNING PROGRAM
*
IERRMA   DSECT
*
         COPY  RMAMAIN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERRDSI  0101-20211-20211-1200-00375-00375-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERRDS SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERRDSI
*
         USING *,R11
         USING IERRCA,R13
         USING IERRMA,R14          MESSAGE MODULE ADR
*
IERDD1   B     RDSOLAY             +00 GOTO OVERLAY EXITS
         B     RDSEOF              +04 GOTO EOF ROUTINE
         B     RDSNTER             +08 NORMAL ENTRY TO DEBLOCK ANOTHER
*
*        ENTRY TO REINITIALIZE TO BEGIN REFILLING THE TREE
*
         LA    R4,4                +12 CHANGE ENTRIES TO NETWORK
         STC   R4,RDSFIT+3
         LA    R4,24
         STC   R4,RDSSPEC-1
         MVC   RDSNTER(4),K6       MOVE IN CLI   NOFITSW,X'01'
*
*        CHAIN BINS TOGETHER BY PUTTING IN EACH BIN THE ADDR OF
*        THE NEXT AVAILABLE BIN. SAVE THE ADDR OF THE FIRST
*        AVAILABLE BIN IN PPIBDSVA+4 AND THE TOTAL NUMBER OF
*        AVAILABLE BINS IN PPIBDSVA+8
*
         SR    R3,R3
         ST    R3,PPIBDSVA+8       ZERO OUT AVAILABLE BINS COUNT
         IC    R3,PPILAB08         NUMBER OF RSA AREAS
         L     R7,PPILAB08         PTR TO RSA TABLE IN PPI
         L     R6,0(,R7)           ADDR OF THIS RSA AREA BIN
         ST    R6,PPIBDSVA+4       SAVE ADDR OF FIRST RSA BIN
RDAAAA   L     R5,4(,R7)           NO BYTES IN THIS RSA AREA
         LA    R8,RDBBBB           LOAD RETURN REG FOR THIS LOOP CALC
         SR    R4,R4
         D     R4,PPIBINSZ         R5 = NO BINS IN THIS RSA AREA
         L     R4,PPIBDSVA+8       TOTAL NO BINS IN RSA SO FAR
         AR    R4,R5               UPDATE BIN COUNT
         ST    R4,PPIBDSVA+8       SAVE UPDATED BIN COUNT
RDBBBB   BCT   R5,RDDDDD           DECR NO BINS CTR FOR THIS RSA
*                                  BRANCH IF MORE BINS IN THIS RSA
         BCT   R3,RDCCCC           DECR NO OF RSA'S CTR BR IF MORE
*                                  RSA'S THE LAST BIN IN THE LAST
*                                  RSA HAS NO CHAIN ADDR
         B     RDFFFF              BRANCH TO LOAD MOVE PARAMETERS
*
RDCCCC   LA    R8,RDSEEE           RESET RETURN REG FOR THIS LOOP
RDDDDD   A     R6,PPIBINSZ         ADDR OF THIS BIN + BIN SIZE
         LR    R4,R6               SAVE ADDR OF NEXT BIN
         S     R4,KFOUR            PTS TO AREA IN PREVIOUS BIN TO PUT
*                                  THE CHAIN ADDR OF NEXT BIN IN R6
         ST    R6,0(,R4)           PREVIOUS BIN NOW CHAINED TO NEXT BIN
         BR    R8                  BR TO RDBBBB ON ALL BINS EXCEPT THE
*                                  LAST BIN IN EACH RSA ELSE
*                                  BRANCH TO RDSEEE
*
RDSEEE   LA    R7,8(,R7)           UPDATE PPI RSA TABLE PTR TO NEXT
*                                  RSA ENTRY
         L     R6,0(,R7)           ADDR OF FIRST BIN IN NEXT RSA
         ST    R6,0(,R4)           STORE AS CHAIN ADDR IN LAST BIN
*                                  OF PREVIOUS RSA
         B     RDAAAA
*
*        LOAD PARMS TO MOVE SAVED RECORD INTO RSA
*
RDFFFF   L     R4,WADDRESS         GET ADDR OF SAVED RECORD
         B     RDSRMAX             BRANCH TO RESTART RMAX COUNT
*
*        NORMAL ENTRY TO DEBLOCK ANOTHER RECORD
*
RDSNTER  CLI   NOFITSW,X'01'       CHECK NO FIT SWITCH
         BL    RDSNORM             NO FIT SWITCH OFF
         BH    RDSSPEC             NO OF BINS WAS=0
         SR    R4,R4
         A     R4,PPIBDSVA+8
         BZ    RDSBINZ             BIN COUNT STILL=0
         L     R0,WSAVE
         L     R4,WSAVE+4          RELOAD REGS TO CONTINUE MOVE
         L     R2,WSAVE+8          LOC FOR CHAIN ADDR USED AFTER PARTL
         L     R3,PPIBDSVA+4       ADDR OF NEXT AVAIL BIN
         ST    R3,0(,R2)           INSERT CHAIN ADDR
         LA    R1,8                INDICATE DEBLOCK WITH NOFIT PREVIOUS
         L     R5,PPIBDSVA+4       LOAD ADDR OF NEXT BIN IN RSA
RDSMOVE  L     R15,PPIBDSVA+12     LOAD ADDR OF MOVE ROUTINE
         BASR  R14,R15             CALL MOVE ROUTINE
         B     RDSNOTF             +00 RECORD DIDN'T FIT
*
*        RECORD FIT ROUTINE
*
         CLI   NOFITSW,X'01'       +04 CHECK NO FIT SWITCH
         BNE   RDSUSUAL            LAST MOVE WAS NOT A NO FIT
         L     R3,WSAVAIL          GET RSA STARTING ADDR OF RECORD
         SR    R2,R2
         ST    R2,WSAVAIL          ZERO OUT WSAVAIL
         B     RDSUSUAL+4          R3 ALREADY LOADED
*
RDSUSUAL L     R3,PPIBDSVA+4       BEGIN ADDR OF RCD JUST MOVED
         AH    R3,EXPLFOUR         ADD EXT SIZE & 4
         L     R2,ADRHOLDB         LOAD BUFFER ADDR
         L     R4,PPIBDSVA+8
         SR    R4,R1
         ST    R4,PPIBDSVA+8       UPDATE BIN COUNT
         L     R4,0(,R5)
         ST    R4,PPIBDSVA+4       UPDATE AVAIL
         NI    NOFITSW,X'00'       TURN OFF NO FIT SWITCH
         L     R11,PPINET+4
RDSFIT   B     4(,R11)             EXIT TO SORT ON RECORD FIT CONDITION
*
*        RECORD NO FIT ROUTINE
*
RDSNOTF  ST    R0,WSAVE
         STM   R4,R5,WSAVE+4       SAVE INFO FOR NEXT MOVE
         SR    R3,R3
         ST    R3,PPIBDSVA+8       BINS AVAIL=0
         OI    NOFITSW,X'01'       SET NOFITSW=01
         A     R3,WSAVAIL
         BNZ   RDSBINZ             MORE THAN ONE NO FIT ON SAME RECORD
         L     R3,PPIBDSVA+4
         ST    R3,WSAVAIL          SAVE RSA ADR OF START OF RECORD
RDSBINZ  L     R11,PPINET+4
         B     24(,R11)            EXIT TO SORT ON RECORD NO FIT
*
RDSSPEC  SR    R4,R4
         A     R4,PPIBDSVA+8       CHECK BIN COUNT
         BZ    RDSBINZ             BIN COUNT STILL ZERO
         NI    NOFITSW,X'00'       ZERO NOFIT SW BIN COUNT NO LONGER 0
         L     R4,ADRHOLDA         RELOAD BUFFER ADDR
RDSPTB   L     R5,PPIBDSVA+4
         AH    R5,EXPLFOUR         ADD EXT SIZE & 4 TO AVAIL ADDR
         ST    R4,ADRHOLDB         SAVE BUFFER ADDR
         SR    R1,R1               INDICATE DEBLOCK TO MOVE ROUTINE
         B     RDSMOVE             CONTINUE PREP FOR MOVE
*
*        IF SORT IS ATTACHED THEN THE FOLLOWING INSTRUCTION
*        IS OVERLAID WITH -
*        B     RDSISWON            OVLY AFTER INPUT EOF
*
RDSNORM  PPITEST  PPIUIIP          USER INSERT IN PROCESS ?
         BO    RDSISWON            YES, BRANCH
*
*        THE FOLLOWING INSTRUCTION WITH BE OVERLAID WITH -
*        B     RDSISWON            OVLY AFTER INPUT EOF
*
RDSGET   NOP   0
*
         LM    R0,R1,KAWORK        DCB ADDR AND/OR VBS WORK
         PPITEST PPISTOPF          STOP AFTER XXX RECORDS VALUE SET ?
         BZ    RDSGETA             NO, BRANCH
         L     R15,DCBEODAD-IHADCB(R1)  R15 -> DCB EOD RTN
         ICM   R14,B'1111',PPISTOPR  R14 = STOP AFTER RECORD COUNT
         BZR   R15                 READ ENOUGH RECORDS, TRIGGER
*                                  DCB EOD EXIT ROUTINE
         BCTR  R14,0               DECR COUNT
         STCM  R14,B'1111',PPISTOPR  STORE DECREMENTED COUNT
*
RDSGETA  GET   (1),(0)
*
         L     R9,PPICOUNT
         LA    R9,1(,R9)
         ST    R9,PPICOUNT         ADD 1 TO RECORD COUNT
         ST    R1,WADDRESS         SET FOR R4 INIT ENTRY
         ST    R1,ADRHOLD
RDSISWON LA    R1,ADRHOLD          SET UP PARAMETER FOR USER MOD
*                                  WILL BE L R1,ADRHOLD ON USER EOF
         L     R9,WNMAX
*
*        CALL USER MOD EXIT E15
*        R1 -> INPUT RECORD
*
*        IF THE E15 EXIT IS NOT ENABLED THEN THE FOLLOWING
*        INSTRUCTION IS OVERLAID WITH -
*        B     RDSDONO
*
RDSUEXIT L     R15,PPIX15+4        OVERLAYED IF THIS EXIT NOT ACTIVATED
*                                  OR IF USER EOF REACHED
         MVC   UEXIT,PPIUEXIT      SETUP E15 PARAMTER LIST
         BASR  R14,R15             CALL USER MOD E15
         MVC   PPIUEXIT,UEXIT      SAVE USER EXIT WORD FOR NEXT CALL
*
*        USER EXIT RETURNS VIA R14 WITH RETURN CODE IN R15
*        R1 -> THE RECORD TO BE INSERTED OR -
*        THE ADDR OF THE WORK AREA IF THE USER HAS ALTERED THE
*        RECORD
*
         B     *+4(R15)        *
         B     RDSDONO         |   +00 ALTER OR DO NOTHING
         B     RDSLETE         |   +04 DELETE A RECORD
         B     RDSUEOF         |   +08 USER END OF FILE
*                              |
*        INSERT A RECORD       |
*                              |
*        IF E16 EXIT NOT ENABLED THEN THIS INSTRUCTION IS
*        OVERLAID WITH -       |
*        B     RDSINSRT        |
*                              |
RDSMAXCK BCT   R9,RDSINSRT     V   +12 CHECK FOR NMAX AND DECREMENT
         B     RDSMSG              NMAX RCHD GOTO OUTPUT MSG AND E16
*
RDSINSRT PPISETON PPIUIIP          SET USER INSERT SWITCH
         L     R5,PPIINSCT
         LA    R5,1(,R5)
         ST    R5,PPIINSCT         ADD 1 TO INSERT COUNT
RDSTSTBC LR    R4,R1               SET UP BUFF ADDR FOR MOVE
         ST    R9,WNMAX            SAVE NMAX REG
         ST    R1,WADDRESS         SET FOR REINITIALIZATION ENTRY
         SR    R5,R5
         A     R5,PPIBDSVA+8       TEST BIN COUNT
         BNZ   RDSRMAX             BRANCH UNLESS BIN COUNT EQUALS ZERO
         ST    R4,ADRHOLDA         SAVE RCD ADDR UNTIL BIN IS AVAILABLE
         OI    NOFITSW,X'03'       SET NO FIT SWITCH = 11
         B     RDSBINZ             GOTO NO FIT EXIT
*
*        IF E16 EXIT NOT ENABLED THEN THIS INSTRUCTION IS
*        OVERLAID TO: B RDSNOTM
*
RDSDONO  BCT   R9,RDSNOTM          CHECK FOR NMAX AND DECREMENT
         B     RDSMSG              NMAX RCHD GOTO OUTPUT MESS AND E16
*
RDSNOTM  PPISETOF PPIUIIP          TURN OFF USER INSERT SWITCH
         B     RDSTSTBC            GO CHECK BIN COUNT
*
RDSLETE  PPISETOF PPIUIIP          TURN OFF USER INSERT SWITCH
         L     R5,PPIDELCT
         LA    R5,1(,R5)
         ST    R5,PPIDELCT         ADD 1 TO DELETE COUNT
         B     RDSGET              GO GET ANOTHER RECORD
*
RDSMSG   STH   R15,WINSALT         SAVE INSERT ALTER CONDITION
         L     R14,PPIRMA+4        MESSAGE MODULE ADDR
         LR    R4,R1               SAVE BUFF ADDR
         LM    R0,R1,IER048        IER048I ESTIMATED MAXIMUM RECORD
         L     R15,PPIADSSC        LOAD PRINT RTN ADDR
         BAS   R14,12(,R15)        CALL PRINT RTN
*
*        CALL USER EXIT E16 SORT CAPACITY NMAX HAS BEEN REACHED
*
         LR    R1,R4               RESTORE BUFF ADDR
         L     R15,PPIX16+4        NMAX EXIT ADDR
         BASR  R14,R15             CALL USER EXIT E16
*
*        USER RETURNS TO MODULE VIA R14 WITH PROPER DISPLACEMENT
*        IN R15
*
         B     *+4(R15)
         B     RDSETPPI            +00 SORT CURRENT NO OF RCDS ONLY
         B     RDSIGNOR            +04 IGNORE NMAX CONTINUE SORT
*
*        TERMINATE THE JOB
*
         MVC   PPIABMNO,IERZ800    +08 SET ABEND CODE 800
         L     R15,PPIADSSC
         BAS   R14,16(,R15)        EXIT TO SORT SYSTEM CONTROL
*                                  NO RETURN
IERZ800  DC    C'800'
*
RDSSRTCR MVC   RDSNTER(4),K1       OVERLAY ENTRANCE TO: B RDSMPTYT
         L     R11,PPINET+4
         B     8(,R11)             BRANCH TO SORT TO EMPTY TREE
*
RDSMPTYT L     R11,PPINET+4
         B     16(,R11)            BRANCH TO SORT TO CONT EMPTY TREE
*
*        FROM USER ON NMAX E16 RETURN
*        TO SORT CURRENT NO OF RCDS ONLY
*
RDSETPPI PPISETON PPIFSZE          TURN ESTIMATED FILE SWITCH ON
         PPISETON PPIUEOF          SET USER EOF FOR ALG
         PPITEST  PPIPEOF          SYSTEM INPUT EOF REACHED ?
         BO    RDSSRTCR            YES, DO NOT DECR PPICOUNT FLUSH TREE
         L     R4,PPICOUNT         RCD IN INPUT BFR WILL NOT BE SORTED
         BCTR  R4,0                DECR PPICOUNT BY ONE
         ST    R4,PPICOUNT         RESTORE PPICOUNT
         PPISETON PPIPEOF          SET EOF SW SO ALG WON'T RETURN
         B     RDSSRTCR            BRANCH TO FLUSH TREE
*
*        IGNORE NMAX OVERLAY NMAX TEST WITH A BRANCH
*
RDSIGNOR MVC   RDSMAXCK(4),K2      OVERLAY NMAX CHECK IN INSERT LEG
*                                  SET TO: B RDSINSRT

         MVC   RDSDONO(4),K3       OVERLAY NMAX CHECK IN ALTER LEG
*                                  SET TO: B RDSNOTM
         SR    R5,R5
         AH    R5,WINSALT
         BZ    RDSNOTM             RESUME WITH INPUT RECORD
         B     RDSINSRT            RESUME WITH INSERT RECORD
*
RDSOLAY  LA    R4,12
         STC   R4,RDSFIT+3         OVERLAY FILLING FIT EXIT
         LA    R4,28
         STC   R4,RDSSPEC-1        OVERLAY FILLING NO FIT EXIT
         B     RDSNTER             BRANCH TO NORMAL ENTRANCE
*
RDSUEOF  PPISETON PPIUEOF          INDICATE USER EOF
         PPITEST  PPIPEOF          REACHED INPUT EOF ?
         BO    RDSSRTCR            YES, GO EMPTY TREE
         MVC   RDSUEXIT(4),K4      OVERLAY AFTER USER EOF
         MVC   RDSMSG,K7
         L     R1,ADRHOLD          RESTORE ADDR OF RCD IN INPUT BLK
         MVI   RDSISWON,X'58'      CHANGE LA INSTRUCTION TO L
         B     RDSNOTM             BRANCH TO MOVE INPUT RECORD
*
RDSEOF   PPITEST  PPIUEOF          USER REACHED EOF ?
         BO    RDSSRTCR            YES, BRANCH
         PPITEST  PPIPEOF          SIMULATED EOF ?
         BZ    RDSSRTCR            YES, BRANCH TO FLUSH TREE
         CLI   REALEOF,X'01'       SIMULATED EOF AFTER REAL EOF ?
         BE    RDSSRTCR
         MVI   REALEOF,X'01'       SET SWITCH TO INDICATE REST OF
*                                  EOF'S ARE SIMULATED
         MVC   RDSGET(4),K5        OVERLAY AFTER INPUT EOF
         SR    R1,R1
         ST    R1,ADRHOLD          INPUT EOF INDICATION TO USER
         B     RDSISWON            GOTO SET UP FOR BRANCH TO USER
*
*        TEST TO SEE WHETHER TO FLUSH TREE AND MERGE RECORDS ONTO
*        ONE REEL OF TAPE
*
RDSRMAX  L     R2,WRMAX            INCREMENT COUNTER FOR RMAX RMAX =
         MVC   WRCDLEN(2),0(R4)    MAX NO OF BYTES ON ONE REEL TAPE
         AH    R2,WRCDLEN
         ST    R2,WRMAX            SAVE
         C     R2,PPIRMAX          RMAX BYTES BEEN EXCEEDED ?
         BH    RDSRMXCT            YES, BRANCH
         B     RDSPTB
*
*        ENOUGH BYTES HAVE BEEN READ IN TO FILL ONE REEL OF TAPE
*
RDSRMXCT SR    R4,R4
         ST    R1,WADDRESS         SAVE ADDR OF THIS RECORD
         ST    R4,WRMAX            ZERO OUT COUNT FOR RMAX IN PROGRAM
         PPISETON PPIRMAXR         SET RMAX BIT IN PPI
         B     RDSSRTCR            BRANCH TO OVERLAY DEBLOCK
*
NOFITSW  DC    X'00'
REALEOF  DC    X'00'
EXPLFOUR DC    H'0'
WSAVE    DC    3F'0'               FOR MOVE RTN
*
*        PARAMETER LIST FOR E15 EXIT
*
ADRHOLD  DC    F'0'          *     -> RECORD
UEXIT    DC    F'0'          V     USER EXIT WORD
*
ADRHOLDA DC    F'0'                RECORD ADDR WHEN BIN COUNT=0
ADRHOLDB DC    F'0'                RECORD ADDR - MOVE RTN AND SORT RTN
WADDRESS DC    F'0'                ADDR OF NEXT RECORD TO BE MOVED
WRMAX    DC    F'0'                COUNT TO COMPARE AGAINST PPIRMAX
WNMAX    DC    F'0'                NUMBER OF RCDS TO GO & 1
WINSALT  DC    H'0'                INSERT ALTER SWITCH
WRCDLEN  DC    H'0'                HALFWORD BOUNDARY FOR RECORD LENGTH
WSAVAIL  DC    F'0'                SAVE AREA FOR RSA RECORD ADDR
KAWORK   DC    2F'0'               FOR DCB AND/OR VBS WORK ADDR
*
K1       B     RDSMPTYT            OVERLAY TO EMPTY TREE
K2       B     RDSINSRT            OVERLAY IN INSERT LEG
K3       B     RDSNOTM             OVERLAY IN ALTER LEG
K4       B     RDSDONO             OVERLAY AFTER USER EOF
K5       B     RDSISWON            OVLY AFTER INPUT EOF
K6       CLI   NOFITSW,X'01'
K7       NOP   0
KFOUR    DC    F'4'
*
*        DCB DSECT
*
         PRINT NOGEN
*
         DCBD  DSORG=PS,DEVD=(DA,TA)
*
         PRINT GEN
*
./ ADD NAME=IERRDT   0101-20211-20211-1200-00101-00101-00000-RELEASE 00
RDT      TITLE 'IERRDT - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRDT
*
*        MODULE FUNCTION -
*        OSCILLATING/CRCX SORT PHASE
*        IERRDT IS A DEBLOCK MODULE WHICH HANDLES VARIABLE
*        LENGTH RECORDS BY WAY OF THE QSAM GET MACRO. THERE ARE
*        NO USER MODIFICATIONS. THE MODULE LINKS TO THE VARIABLE
*        MOVE ROUTINE IERRBF WHICH MOVES THE VARIABLE LENGTH
*        RECORD FROM THE INPUT BUFFER INTO RSA BIN(S). UPON
*        RETURN FROM THE MOVE ROUTINE, THE MODULE PASSES ON TO
*        THE REPLACEMENT SORT THE RECORDS LOCATION IN RSA. IT
*        ALSO CHECKS TO DETERMINE WHEN RMAX HAS BEEN REACHED, THE
*        MAXIMUM NUMBER OF BYTES WHICH CAN FIT ONTO ONE REEL OF
*        TAPE, AND CAUSES RSA TO BE FLUSHED, FOLLOWED BY A MERGE
*        ONTO ONE REEL, WHICH IS THEN SET ASIDE. IT CAN
*        REINITIALIZE ITSELF TO BEGIN REFILLING RSA AFTER IT HAS
*        BEEN FLUSHED AND A MERGE TAKEN PLACE
*
*        IF THE CRCX TECH IS USED THE RMAX CHECK AT RDTRMAX IS
*        BYPASSED
*        THIS BECOMES AN UNCONDITIONAL BRANCH TO RDTMOVE
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT -
*        IERADT
*
*        LIST OF MACROS USED BY MODULE -
*        SMPPI
*        GET
*
*        ENTRY POINTS - ENTRY FROM NETWORK
*                       CALLING SEQUENCE -
*                           L     R11,PPIDEB+4
*                           B     8(,R11)    DURING TREE FILL
*
*                           L     R11,PPIDEB+4
*                           BR    R11        ONCE - WHEN TREE FULL
*
*                     - ENTRY FROM BLOCK
*                       CALLING SEQUENCE -
*                           L     R11,PPIDEB+4
*                           B     8(,R11)
*
*                     - ENTRY FROM EOF ROUTINE
*                       CALLING SEQUENCE -
*                           L     R11,PPIDEB+4
*                           B     4(,R11)
*
*                     - ENTRY FROM INITIALIZATION ROUTINE
*                       CALLING SEQUENCE -
*                           L     R11,PPIDEB+4
*                           B     12(,R11)
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIBDSVA   PPINET    PPISTDCB  PPISTOPF
*        PPICOUNT   PPIRMAXR  PPISTOPR
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPIBDSVA   PPICOUNT  PPICNTL   PPISTOPR
*
*        EXTERNAL ROUTINES -
*        IERRBF - USED TO MOVE RECORDS FROM INPUT BUFFER TO RSA
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL -
*        NETWORK - PASS ADDR OF EACH INCOMING RECORD
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS -
*        WSAVE   - SAVING 3 REGISTERS OF INFORMATION GIVEN BY THE
*                  MOVE MODULE (IERRBF)
*        WSAVAIL - HOLD THE ADDR OF THE RECORD CURRENTLY BEING
*                  MOVED INTO RSA
*        WRMAX   - COUNT OF RECORDS USED TO COMPARE WITH PPIRMAX
*
*        NOTES -
*        THIS MODULE IS USED IN THE OSCL/CRCX SORT PHASE FOR
*        VARIABLE LENGTH RECORDS WITHOUT USER EXITS
*
IERRDT   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRDT SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRDTI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERRDTI  0101-20211-20211-1200-00217-00217-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERRDT SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERRDTI
*
         USING *,R11
         USING IERRCA,R13
*
IERDD1   B     RDTOLAY             +00 GOTO OVERLAY EXITS
         B     RDTEOF              +04 GOTO EOF ROUTINE
         B     RDTBEGIN            +08 NORMAL ENTRY TO DEBLOCK
*                                      ANOTHER RECORD
*
*        ENTRY TO REINITIALIZE TO BEGIN REFILLING THE TREE
*
         LA    R4,4                +12 CHANGE ENTRIES TO NETWORK
         STC   R4,RDTFIT+3
         LA    R4,24
         STC   R4,RDTNORM-1
         MVC   RDTBEGIN(8),KREINITI
*
*        CHAIN BINS TOGETHER BY PUTTING IN EACH BIN THE ADDR OF
*        THE NEXT AVAILABLE BIN. SAVE THE ADDR OF THE FIRST
*        AVAILABLE BIN IN PPIBDSVA+4 AND THE TOTAL NUMBER OF
*        AVAILABLE BINS IN PPIBDSVA+8
*
         SR    R3,R3
         ST    R3,PPIBDSVA+8       REINITIALIZE TOTAL OF AVAILABE BINS
         IC    R3,PPILAB08         NUMBER OF RSA AREAS
         L     R7,PPILAB08         PTR TO RSA TABLE IN PPI
         L     R6,0(,R7)           ADDR OF THIS RSA AREA BIN
         ST    R6,PPIBDSVA+4       SAVE ADDR OF FIRST RSA BIN
RDAAAA   L     R5,4(,R7)           NO BYTES IN THIS RSA AREA
         LA    R8,RDBBBB           LOAD RETURN REG FOR THIS LOOP CALC
         SR    R4,R4
         D     R4,PPIBINSZ         R5 = NO BINS IN THIS RSA AREA
         L     R4,PPIBDSVA+8       TOTAL NO BINS IN RSA SO FAR
         AR    R4,R5               UPDATE BIN COUNT
         ST    R4,PPIBDSVA+8       SAVE UPDATED BIN COUNT
RDBBBB   BCT   R5,RDDDDD           DECR NO BINS CTR FOR THIS RSA
*                                  BR IF MORE BINS IN THIS RSA
         BCT   R3,RDCCCC           DECR NO OF RSA'S CTR BR IF MORE
*                                  RSA'S. THE LAST BIN IN THE LAST
*                                  RSA HAS NO CHAIN ADDR
         B     RDFFFF              BRANCH TO LOAD MOVE PARAMETERS
*
RDCCCC   LA    R8,RDEEEE           RESET RETURN REG FOR THIS LOOP
RDDDDD   A     R6,PPIBINSZ         ADDR OF THIS BIN + BIN SIZE
         LR    R4,R6               SAVE ADDR OF NEXT BIN
         S     R4,KFOUR            PTS TO AREA IN PREVIOS BIN TO PUT
*                                  THE CHAIN ADDR OF NEXT BIN (IN R6)
         ST    R6,0(,R4)           PREVIOUS BIN NOW CHAINED TO NEXT BIN
         BR    R8                  BRANCH TO RDBBBB ON ALL BINS EXCEPT
*                                  THE LAST BIN IN EACH RSA. OTHERWISE
*                                  BRANCH TO RDEEEE
RDEEEE   LA    R7,8(,R7)           UPDATE PPI RSA TABLE PTR TO NEXT
*                                  RSA ENTRY
         L     R6,0(,R7)           ADDR OF FIRST BIN IN NEXT RSA
         ST    R6,0(,R4)           STORE AS CHAIN ADDR IN LAST BIN
*                                  OF PREVIOUS RSA
         B     RDAAAA
*
*        LOAD PARAMETERS TO MOVE SAVED RECORD INTO RSA
*
RDFFFF   L     R4,ADRHOLD          GET ADDR OF SAVED RECORD
         B     RDTRMAX             BRANCH TO RESTART RMAX COUNT
*
*        NORMAL ENTRY TO DEBLOCK ANOTHER RECORD
*
RDTBEGIN CLI   NOFITSW,X'01'       CHECK NO FIT SWITCH
         BL    RDTNORM             NO FIT SWITCH OFF
         BH    RDTSPEC             NO OF BINS = 0 DURING FILL
         SR    R4,R4
         A     R4,PPIBDSVA+8
         BZ    RDTNOFIT
         L     R0,WSAVE
         L     R4,WSAVE+4
         L     R2,WSAVE+8          LOC FOR CHAIN ADDR USED AFTER PARTL
         L     R3,PPIBDSVA+4       ADDR OF NEXT AVAIL BIN
         ST    R3,0(,R2)           INSERT CHAIN ADDR
         L     R1,KEIGHT           INDICATE DEBLOCK WITH NOFIT PREV
RDTBINS  L     R5,PPIBDSVA+4       LOAD ADDR OF NEXT BIN IN RSA
         L     R15,PPIBDSVA+12     LOAD ADDR OF MOVE ROUTINE
         BASR  R14,R15             CALL MOVE ROUTINE
         B     RDTNOTF             +00 RECORD DIDN'T FIT
*
*        RECORD FIT ROUTINE
*
         CLI   NOFITSW,X'01'       +04 CHECK NO FIT SWITCH
         BNE   RDTUSUAL            LAST MOVE WAS NOT A NO FIT
         L     R3,WSAVAIL          GET RSA STARTING ADDR OF RECORD
         SR    R2,R2
         ST    R2,WSAVAIL          ZERO OUT WSAVAIL
         B     RDTUSUAL+4          R3 ALREADY LOADED
*
RDTUSUAL L     R3,PPIBDSVA+4       BEGIN ADDR OF RECORD JUST MOVED
         AH    R3,EXPLFOUR         ADD EXT SIZE + 4
         L     R2,ADRHOLD          LOAD BUFFER ADDR
         L     R4,PPIBDSVA+8
         SR    R4,R1
         ST    R4,PPIBDSVA+8       UPDATE BIN COUNT
         L     R4,0(,R5)
         ST    R4,PPIBDSVA+4       UPDATE AVAIL
         NI    NOFITSW,X'00'       TURN OFF NO FIT SWITCH
         L     R11,PPINET+4
RDTFIT   B     4(,R11)             EXIT TO SORT ON RECORD FIT CONDITION
*
*        RECORD NOFIT ROUTINE
*
RDTNOTF  ST    R0,WSAVE
         STM   R4,R5,WSAVE+4       SAVE INFO FOR NEXT MOVE
         SR    R3,R3
         ST    R3,PPIBDSVA+8       BINS AVAIL=0
         OI    NOFITSW,X'01'
         A     R3,WSAVAIL
         BNZ   RDTNOFIT            SECOND NOFIT ON SAME RECORD
         L     R3,PPIBDSVA+4
         ST    R3,WSAVAIL          SAVE RSA ADDR OF START OF RECORD
RDTNOFIT L     R11,PPINET+4
         B     24(,R11)            EXIT TO SORT ON RECORD NO FIT
*
RDTNORM  NOP   0
         PPITEST PPISTOPF          STOP AFTER XXX RECORDS VALUE SET ?
         BZ    RDTNORMA            NO, BRANCH
         L     R15,DCBEODAD-IHADCB(R6)  R15 -> DCB EOD RTN
         ICM   R14,B'1111',PPISTOPR  R14 = STOP AFTER RECORD COUNT
         BZR   R15                 READ ENOUGH RECORDS, TRIGGER
*                                  DCB EOD EXIT ROUTINE
         BCTR  R14,0               DECR COUNT
         STCM  R14,B'1111',PPISTOPR  STORE DECREMENTED COUNT
RDTNORMA LM    R0,R1,KAWORK        DCB ADDR AND/OR VBS WORK
*
         GET   (1),(0)
*
RDTGOT   ST    R1,ADRHOLD          SAVE ADDR OF RECORD
         L     R4,PPICOUNT
         LA    R4,1(,R4)           ADD ONE TO RECORD COUNT
         ST    R4,PPICOUNT
         LR    R4,R1               SET UP BUFFER ADDR FOR MOVE RTN
         SR    R3,R3
         A     R3,PPIBDSVA+8
         BNZ   RDTRMAX             BIN COUNT ¬= ZERO, BRANCH
         OI    NOFITSW,X'03'
         B     RDTNOFIT            SPECIAL NO FIT CONDITION
*
*        OVERLAY EXITS TO REPLACEMENT - CHANGE FROM FILLING TO
*        NORMAL
*
RDTOLAY  LA    R4,12
         STC   R4,RDTFIT+3         OVERLAY EXIT TO SORT - RECORD FIT
         LA    R4,28
         STC   R4,RDTNORM-1        OVERLAY EXIT TO SORT - RECORD NO FIT
         B     RDTBEGIN            BRANCH TO NORMAL ENTRY
*
*        EOF
*        SET UP UNCONDITIONAL RETURN TO REPLACEMENT FOR FUTURE USE
*
RDTEOF   MVC   RDTBEGIN(4),RDTFIT-4
         MVC   RDTBEGIN+4(4),KBRANCH  OVERLAY ENTRY WITH UNCOND EXIT
         L     R11,PPINET+4
         B     8(,R11)             ONE TIME EXIT AT EOF
*
RDTSPEC  SR    R4,R4
         A     R4,PPIBDSVA+8
         BZ    RDTNOFIT
         NI    NOFITSW,X'00'       ZERO NOFIT SW - SPEC CONDITION
         SR    R1,R1               INDICATE DEBLOCK TO MOVE
         L     R4,ADRHOLD          LOAD BUFFER ADDR
RDTMOVE  L     R5,PPIBDSVA+4
         AH    R5,EXPLFOUR         ADD EXT SIZE + 4 TO AVAIL ADDR
         SR    R1,R1               INICATE DEBLOCK TO MOVE ROUTINE
         B     RDTBINS+4           CONTINUE PREP FOR MOVE
*
*        FLUSH TREE AND MERGE RECORDS ONTO ONE REEL OF TAPE ?
*
RDTRMAX  L     R2,WRMAX            INCREMENT COUNTER FOR RMAX RMAX =
         MVC   WRCDLEN(2),0(R4)    MAX NO OF BYTES ON ONE REEL TAPE
         AH    R2,WRCDLEN
         ST    R2,WRMAX            SAVE
         C     R2,PPIRMAX          RMAX BYTES BEEN EXCEEDED ?
         BH    RDTRMXCT            YES, BRANCH
         B     RDTMOVE
*
*        ENOUGH BYTES HAVE BEEN READ IN TO FILL ONE REEL OF TAPE
*
RDTRMXCT SR    R4,R4
         ST    R4,WRMAX            ZERO OUT COUNT FOR RMAX IN PROGRAM
         PPISETON PPIRMAXR         SET RMAX BIT IN PPI
         B     RDTEOF              BRANCH TO OVERLAY DEBLOCK
*
KBRANCH  B     16(,R11)
KREINITI CLI   NOFITSW,X'01'
         BL    RDTNORM
*
NOFITSW  DC    X'00'
ADRHOLD  DC    F'0'
KEIGHT   DC    F'8'
KFOUR    DC    F'4'
WRMAX    DC    F'0'                COUNT TO COMPARE AGAINST PPIRMAX
WSAVE    DC    3F'0'
WSAVAIL  DC    F'0'                SAVE AREA FOR RSA RECORD ADDR
EXPLFOUR DC    H'0'                EXTRACT SIZE + 4
WRCDLEN  DC    H'0'                HALFWORD BOUNDARY FOR RECORD LENGTH
KAWORK   DC    2F'0'               FOR DCB AND/OR VBS WORK ADDR
*
*        DCB DSECT
*
         PRINT NOGEN
*
         DCBD  DSORG=PS,DEVD=(DA,TA)
*
         PRINT GEN
*
./ ADD NAME=IERRDX   0101-20211-20211-1200-00090-00090-00000-RELEASE 00
RDX      TITLE 'IERRDX - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRDX
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 3 RUNNING MODULE - FIXED LENGTH TAPE SORT
*        THE FUNCTION OF THIS MODULE IS TO DEBLOCK FIXED LENGTH
*        RECORDS STARTING FROM THE HI CORE END OF THE BUFFER TO
*        THE LOW CORE START OF THE BUFFER. THIS MODULE IS ONLY
*        EXECUTED WHEN A COPY PASS IN PHASE 2 IS TO BE
*        ELIMINATED. THE RECORDS IN PHASE 1 HAVE BEEN BLOCKED
*        FROM HI TO LOW CORE AS IF FOR A NORMAL PHASE 2 READ BACK
*        OPERATION. HOWEVER THE PHASE 1 ALGORITHM HAS DETERMINED
*        THAT PHASE 2 NEED NOT BE EXECUTED AND PHASE 3 IS
*        BROUGHT IN INSTEAD. WHEN IERRDX HAS DETERMINED THAT A
*        BUFFER IS EMPTY IT BRANCHES TO THE READ FORWARD MODULE
*        WHICH FILLS THE EMPTY BUFFER AND PASSES BACK THE
*        INFORMATION TO DEBLOCK TO START DEBLOCKING THIS OR THE
*        ALTERNATE BUFFER IF DOUBLE BUFFERED. THIS MODULE THEN
*        BRANCHES TO THE MERGE NETWORK WITH THE ADDRESS OF THE
*        FIRST RECORD IN THIS BUFFER
*
*        NORMAL FLOW IS FROM DEBLOCK TO MERGE NETWORK TO BLOCK
*        TO DEBLOCK ETC
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - IERADX
*
*        MACROS USED BY MODULE - SMPPI
*
*        ENTRY POINTS - ENTRY FROM BLOCK
*                       CALLING SEQUENCE -
*                           L    R11,PPIDEB+4
*                           B    4(,R11)
*
*                     - ENTRY FROM IERRGM
*                       CALLING SEQUENCE -
*                           L    R11,PPIDEB+4
*                           B    0(,R11)
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPINET   PPIRCDL2
*        PPIRD    PPISBLCT
*        ADDRESSES OF MODULES AND TABLES. RECORD LENGTH IS USED
*        IN A BUFFER ADDRESS CALCULATION
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED - NONE
*
*        EXTERNAL ROUTINES - NONE
*
*        EXTERNAL PARAMETERS - SEE REGISTERS
*
*        EXITS - NORMAL - EXIT TO MERGE NETWORK
*                         CALLING SEQUENCE -
*                             L    R11,PPINET+4
*                             B    8(,R11)
*
*                       - EXIT TO IERRGM
*                         CALLING SEQUENCE -
*                             L    R11,PPIRD+4
*                             B    4(,R11)
*
*        EXITS - ERROR - NONE
*
*        TABLES/WORK AREAS -
*        WDBLSV - ADDR OF TABLE OF INPUT BUFFER ADDRS
*
*        NOTES -
*        THIS MODULE WILL BE EXECUTED ONLY FOR FIXED LENGTH
*        RECORDS WHEN A PHASE 2 COPY PASS IS ELIMINATED FOR A
*        TAPE SORT
*
IERRDX   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRDX SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRDXI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERRDXI  0101-20211-20211-1200-00070-00070-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERRDX SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERRDXI
*
         USING *,R11               THIS MODULE BASE REGISTER
         USING IERRCA,R13          ADDR OF PPI
*
         B     RDHDB020            +00 FROM READ
         LR    R6,R3               +04 BLOCK -R3 HAS INCR & ADDR OF WNR
         SRL   R3,24               OBTAIN INCR
*
*        LOAD BLOCK COUNT OF WINNERS BUFFER
*        IF EMPTY BRANCH TO READ RTN
*
         L     R4,PPISBLCT         ADDR OF INPUT BFRS BLOCK CNT TABLE
         L     R5,0(R4,R3)         LOAD WINNER'S REMAINING BLOCK COUNT
         S     R5,KONE             DECR BY 1
         BNH   RDHDB010            BRANCH TO READ IF BUFFER IS EMPTY
         ST    R5,0(R4,R3)         SAVE ADJUSTED BLOCK COUNT
         LR    R3,R6               RESTORE R3
         SH    R3,PPIRCDL2         OBTAIN NEW INPUT RECORD ADDR
*
*        INTERFACE WITH NETWORK
*        R3 HAS INCR AND NEW INPUT RCD ADDR
*
         L     R11,PPINET+4        ADDR OF MERGE NETWORK
         B     8(,R11)             BRANCH TO NETWORK
*
*        INTERFACE WITH READ ROUTINE
*
RDHDB010 L     R6,WDBLSV           ADDR OF BUFFER ADDR TABLE
         L     R2,0(R6,R3)         THIS FILE'S EMPTY STRTG BFR ADDR
         L     R11,PPIRD+4         ADDR OF READ RTN
         B     4(,R11)             BRANCH TO READ RTN
*
*        RETURN POINT FROM READ RTN
*        DISPLACE ADDR IN R2 BY BLOCK CNT IN R1-1 RCD LENGTH TO
*        FIND FIRST RCD TO DEBLOCK IN THE BUFFER FOR MERGE
*
RDHDB020 L     R5,PPISBLCT         ADDR OF TABLE OF INPUT BFRS BLK CNT
         ST    R1,0(R5,R3)         STORE NEW BUFFER'S BLOCK COUNT IN
*                                  ITS APPROPRIATE PLACE
         BCTR  R1,0                BLOCK CNT -1
         MH    R1,PPIRCDL2         EQUALS CHAR CNT OF RCDS IN THIS BFR
*                                  MINUS ONE RCD
         AR    R1,R2               ADD STRTG ADDR+4 OF THE BUFFER
         ST    R4,0(R6,R3)         STORE STRTG ADDR OF BUFFER IN TABLE
*                                  OF INPUT BUFFER ADDR
         SLL   R3,24               REPOSITION INCR
         AR    R3,R1               INSERT STRTG ADDR OF 1ST RCD TO DBLK
*
*        INTERFACE TO MERGE NETWORK
*
         L     R11,PPINET+4        ADDR OF MERGE NETWORK
         B     8(,R11)             BRANCH TO MERGE NTWK
*
*        WORK AREAS
*
WDBLSV   DC    F'0'                AP WILL LOAD TO ADDR OF TABLE OF
*                                  INPUT BUFFER ADDRS
*
*        CONSTANTS
*
KONE     DC    F'1'                CONSTANT OF 1
*
./ ADD NAME=IERRGA   0101-20211-20211-1200-00108-00108-00000-RELEASE 00
RGA      TITLE 'IERRGA - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRGA
*
*        MODULE FUNCTION/OPERATION -
*        INPUT END OF FILE ROUTINE FOR THE SORT PHASE.
*        ENTERED FROM GET ON A USER EOF OR BY PPISTOPR VALUE.
*        CLOSE THE INPUT FILE AND CALL USER MODIFICATION
*        EXIT E17 IF ONE HAS BEEN PROVIDED.
*        SET SYTEM END OF FILE SWITCH.
*        THE MODULE RETURNS CONTROL TO THE SORT DEBLOCK ROUTINE
*        AT THE EOF ENTRY.
*
*        MACROS USED -
*        SMPPI   CLOSE
*
*        ENTRY POINTS - ENTRY FROM QSAM GET ON USER INPUT EOF
*                       CALLING SEQUENCE -
*                           L    R15,DCBEODAD
*                           BR   R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPISTDCB
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPIWKARE   PPICNTL
*        USER INPUT FILE IS CLOSED
*
*        EXTERNAL ROUTINES - NONE
*
*        EXTERNAL PARAMETERS - NONE
*
*        EXITS - NORMAL - BRANCH TO DEBLOCK AT EOF ENTRY
*                         L     R11,PPIDEB+4
*                         B     4(,R11)
*
*        EXITS - ERROR - NONE
*
*        TABLES/WORK AREAS - NONE
*
*        NOTES - N/A
*
IERRGA   CSECT
*
         BASR  R11,0           *   SET BASE REGISTER
         USING *,R11           |   PROG BASE REG
         USING IERRCA,R13      |
         B     RGAEOF          |   BRANCH TABLE
*                              |
RGAUSERX DC    F'0'            V   USER EOD MOD LINK ADDR
*                                  RGAUSERX IS SET BY THE IERAG*
*                                  MODULES WHEN PROCESSING A USER
*                                  EXIT REQUEST TO PROVIDE AN EOD EXIT
*
RGAEOF   PPISETON PPIPEOF          SET SYSTEM EOF SWITCH
         L     R9,PPISTDCB         GET POINTER TO DCB TABLE
         L     R2,0(,R9)           R2 -> INPUT SORTIN DCB ADDR
*
         CLOSE ((R2))              CLOSE SORTIN INPUT FILE
*
         LTR   R15,R15             CLOSE SUCCESSFULL ?
         BZ    RGAENT1             YES, BRANCH
*
         DC    H'0'                CLOSE FAILED, FORCE 0C1 ABEND
*                                  FOR DIAGNOSTIC PURPOSES
RGAENT1  MVI   0(R9),X'80'         MARK SORTIN DCB CLOSED IN DCB TABLE
         PPITEST  PPIDIAG+PPIDSIM  GENERATE DIAGNOSTIC MESSAGES ?
         BZ    RGAENT1A            NO, BYPASS MSG GENERATION
         LM    R0,R1,IER931
         L     R15,PPIADSSC
         BAS   R14,12(,R15)        CALL MSG WRITER
*
*        DETERMINE IF USER EXIT PROVIDED
*
RGAENT1A ICM   R2,B'1111',RGAUSERX  USER EOD EXIT ADDR AVAILABLE ?
         BNZ   RGAENT3             YES, BRANCH
*
*        RETURN CONTROL TO DEBLOCK
*
RGAENT2  L     R11,PPIDEB+4
         B     4(,R11)             BRANCH TO DEBLOCK
*
*        INVOKE USER EXIT
*
RGAENT3  STM   R14,R15,WRGAHLD     SAVE R14 R15
         LR    R15,R2              R15 -> USER EXIT
         BASR  R14,R15             CALL USER EXIT
         LM    R14,R15,WRGAHLD     RESTORE R14 R15
         B     RGAENT2             GOTO RESTORE R4
*
WRGAHLD  DC    2F'0'               SAVE FOR R14,R15 ACROSS USER EXIT
*
*        DEBUGGING MESSAGE
*
IER931   DC    A(IER931T)
         DC    A(IER931X-IER931T)
IER931T  DC    C'IER931I EOF ON SORTIN'
IER931X  EQU   *
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERRGB   0101-20211-20211-1200-00127-00127-00000-RELEASE 00
RGB      TITLE 'IERRGB - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRGB
*
*        MODULE FUNCTION/OPERATION -
*        THIS MODULE HANDLES TAPE INPUT IN THE INTERMEDIATE
*        MERGE PHASE BY WAY OF THE EXCP MACRO. THE MODULE READS
*        PHYSICAL RECORDS INTO BUFFER AREAS. THE ROUTINE
*        INTERFACES WITH IOS, THE ALGORITHM, THE BUFFER TABLE
*        ROUTINE, DEBLOCK, AND THE MERGE NETWORK. IF E28 IS
*        ACTIVATED BY A USER, THE READ ROUTINE (ON A READ ERROR)
*        ALLOWS THE USER TO TRY TO CORRECT THE ERROR AFTER IOS
*        HAS TRIED TO DO SO. IF THERE IS A PERMANENT READ ERROR,
*        CONTROL IS PASSED TO SORT SYSTEM CONTROL TO TERMINATE THE
*        JOB. THE NORMAL ENTRY TO THE MODULE USES REGISTERS R0-R7
*        AND THE PRIMING SUBROUTINE USES REGISTERS R0-R9. BOTH
*        SECTIONS USE R13-R15
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - IERAGB
*
*        MACROS USED -
*        SMPPI   EXCP
*        WAIT    CLOSE
*
*        ENTRY POINTS - ENTRY FROM TAPE ALGORITMS
*                       CALLING SEQUENCE -
*                            L    R11,PPIRD+4
*                            B    4(,R11)
*
*                     - ENTRY FROM MERGE BLOCK/DEBLOCK
*                       CALLING SEQUENCE -
*                            L    R11,PPIRD+4
*                            B    8(,R11)
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIADSSC   PPIDEPHO   PPIMRGMX
*        PPIRCDL2   PPISTDCB   PPIBDSVA
*        PPILAB03   PPIPSVA    PPISBLCT
*        PPITPTBL
*        PARAMETERS PASSED FROM MERGE BLOCK/DEBLOCK ROUTINES -
*        R2 - ADDRESS OF EMPTY BUFFER
*        R3 - INCREMENT
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPICNTL   PPITPTBL
*
*        PARAMETERS PASSED BACK TO MERGE BLOCK/DEBLOCK ROUTINES -
*        R1 - BLOCK COUNT
*        R2 - BUFFER ADDRESS FOR DEBLOCKING
*        R3 - INCREMENT
*        R4 - BUFFER ADDRESS FOR READING BACKWARDS
*
*        EXTERNAL ROUTINES - NONE
*
*        EXTERNAL PARAMETERS - NONE
*
*        EXITS - NORMAL - BRANCH TO MERGE NETWORK ON EOS
*                         L     R11,PPINETM+4
*                         B     4(,R11)
*
*                       - BRANCH TO MERGE BLOCK/DEBLOCK
*                         L     R11,PPIBLK2+4
*                         B     4(,R11)
*
*                       - BRANCH TO MERGE ALGORITHM WITH
*                                   INCREMENT IN R3
*                         L     R11,PPIALG+4
*                         BAL   R14,12(,R11)
*
*                       - BRANCH TO PRIMING ROUTINE TO SET UP
*                                   DEBLOCK BUFFER TABLE
*                         L     R11,PPIDEB2+4
*                         BR    R11
*
*        EXITS - ERROR -  TERMINATE OPTION OVERLAY FOR PERMANENT
*                         READ ERROR
*                         L     R11,PPIADSSC
*                         B     16(,R11)
*
*        TABLES/WORK AREAS -
*        KEOSCNT  - COUNT OF NUMBER OF EOS'S WHICH HAVE OCCURRED
*        KEOSPR   - UPDATED ADDR OF INCREMENT TABLE
*        KMRGMX   - EQUALS PPIMRGMX
*        KOUTINCR - INCREMENT OF PRESENT OUTPUT UNIT
*        KSAVE    - REGISTER SAVE AREA
*        KSAVEB   - REGISTER SAVE AREA
*        TINCR    - TABLE CONTAINS INCREMENTS OF FILES HAVING EOS
*                   CONDITIONS
*        TFCNT    - FILE COUNT
*
*        NOTES - N/A
*
IERRGB   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRGB SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRGBI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
*        IERCCWEQ
*
         IERCCWEQ
*
*        IERIOB
*
         IERIOB
*
         PRINT NOGEN
*
         DCBD  DSORG=PS,DEVD=(DA,TA)
*
         IEZDEB LIST=NO
*
         PRINT GEN
*
         SMPPI
*
         END
./ ADD NAME=IERRGBI  0101-20211-20211-1200-00441-00441-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERRGB SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERRGBI
*
         USING *,R11
         USING IERRCA,R13          PPIA DSECT
         USING IOBSTDRD,R5         IOB  DSECT
         USING IHADCB,R6           DCB  DSECT
*
IERDGB2  NOP   IERDGB2             +00 DUMMY ENTRY
         B     RGBPR200            +04 PRIMING SUBROUTINE
*
         STM   R2,R7,KSAVE         +08 BLOCK/DEBLOCK ENTRY
         ST    R2,IERDGB2
         CLI   KSAVE,C'$'          EMPTY BUFFER LAST BUFFER ?
         BNE   RGBPRCK             NO, BRANCH
RGBRTEOS L     R11,PPINETM+4       BRANCH TO MERGE NETWORK
         B     4(,R11)             ON EOS
*
RGBPRCK  CLI   KEOSCNT,X'00'       EOS OCCURRED AT PRIMING TIME ?
         BE    RGBST010            NO, BRANCH
         SR    R0,R0               EOS OCCURRED AT PRIMING TIME FOR
         IC    R0,KEOSCNT          AT LEAST ONE FILE SCAN TABLE TO
         LA    R15,TINCR           SEE IF IT OCCURRED FOR THIS
         STC   R3,RGBINST2+1       SPECIFIC FILE
RGBINST2 CLI   0(R15),X'00'        TABLE SCAN ?
         BE    RGBRTEOS            EOS ON THIS FILE
         LA    R15,1(,R15)
         BCT   R0,RGBINST2         CHECK NEXT TABLE ENTRY
RGBST010 L     R6,PPISTDCB         APPROPRIATE DCB VIA INCR IN R3
         L     R6,0(R3,R6)         AND PPI
         L     R5,DCBIOBAD         IOB ADDR
         TM    DCBBUFNO,2          NO OF BUFFERS FOR THIS FILE
         BO    RGBAL020            YES, CHECK FOR ALTERNATE
*
*        FILE ONLY HAS ONE BUFFER ATTACHED TO THE IOB
*
         IEREXCP  (R5)             READ BACKWARDS
*
         BAS   R4,RGBEOSCK         WAIT ON FILE CHECK FOR EOS
RGBRTRN  LM    R2,R7,KSAVE
         L     R11,PPIBLK2+4       BRANCH TO BLOCK/DEBLOCK
RGBRTRNV LA    R2,4(,R2)           FIX/VAR BYPASS EOS INDICATOR
*                                  VAR ALSO BYPASS BCC
         B     4(,R11)             RETURN TO DEBLOCK
*
RGBEOSCK L     R1,IOBECBPT
*
         IERWAIT  1,ECB=(1)        WAIT ON I/O COMPLETION
*
         BAS   R7,RGBEE100         EOF ERROR CHECK
RGBEOSV  TM    1(R2),X'07'         LAST BUFFER EOS ?
         BNOR  R4                  OF THE SEQUENCE
RGBEOS   MVI   KSAVE+8,C'$'        SET EOS BIT ON IN HIGH ORDER BYTE
         B     RGBRTRN             OF BUFFER ADDR FOR NEXT READ ON
*                                  THIS FILE
*
*        FILE HAS AN ALTERNATE BUFFER
*
RGBAL020 BAS   R4,RGBEOSCK         WAIT ON FILE CHECK FOR EOS
RGBRFBF  NOP   RGBFL040            IF ONLY HAVE PARTIAL OVERLAP THIS
*                                  NOP BECOMES AN UNCONDITIONAL
*                                  BRANCH HAVE FLOATING BUFFERS
*
*        *FULL OVERLAP
*
RGBAL030 LA    R2,IERDGB2          ATTACH BUFFER TO
         LA    R7,RGBRTRN          FILE VIA THE IOB START POINTER
         B     RGBIOBUP            AND DATA ADDR IN THE CCW
*
*        ERROR CHECK OF BUFFER READ HAS COMPLETED
*
RGBEE100 TM    IOBUSTAT,UC+UE      UNIT CHECK OR UNIT EXCEPTION
         BNZ   RGBEOF              YES, BRANCH
RGBPRMSK TM    IOBCSTAT,IL+PROTC+CDC  LENGTH AND CHAN DATA/PROTECT ?
         BNZ   RGBERROR            YES, BRANCH
*
*        NOTE -
*        ONLY AT PRIMING TIME, FOR FIXED LENGTH RECORDS IS
*        INCORRECT LENGTH INDICATION CONSIDERED NOT AN ERROR. THE
*        PRIMING ROUTINE WILL SET THE MASK APPROPRIATLY AND THEN
*        RESET IT AFTER RETURN IS MADE FROM THIS SUBROUTINE. THE
*        PRIMING RTN'S MASK IS X'08' (IE IT WILL SUPPRESS THE
*        INCORRECT LENGTH INDICATION IN THE CSW BEFORE ENTERING
*        THIS EOF - ERROR CHECK RTN)
*
RGBEE105 PPITEST  PPIOSC           OSCILLATING SORT ?
         BZ    RGBEE106            USE PPILAB/3 FOR BALANCED/POLYPHASE
         LH    R1,PPILAB07+2       USE PPILAB07 FOR OSCILLATING SORT
         B     RGBEE107            BUFFER ADDR LOADED ABOVE
*
RGBEE106 LH    R1,PPILAB03+2       STARTING BUFFER ADDR FOR -
RGBEE107 L     R2,IOBSTART
         SH    R1,IOBCSWCT         SUBTRACT RESIDUAL COUNT IN CSW
         L     R2,0(,R2)
         ST    R2,KSAVE+8          READ BACKWARDS
         MVI   KSAVE+8,X'00'
         LA    R2,1(,R2)
         SR    R2,R1               AND THE BLOCK CHARACTER COUNT
         SH    R1,KFOUR
RGBBRVR  NOP   RGBEE110            UNCOND BRANCH IF VAR RECORD FORMAT
         SR    R14,R14             NEED BLOCK COUNT IF FIX RCD FORMAT
RGBFIX   SH    R1,PPIRCDL2
         LA    R14,1(,R14)
         CH    R1,PPIRCDL2
         BNL   RGBFIX              BLOCKING FACTOR IN R14 WHEN NEG
         LR    R1,R14
RGBEE110 ST    R2,KSAVE            DEBLOCKING
         MVI   KSAVE,X'00'
         BR    R7                  GOTO DEBLOCK
*
*        END OF FILE
*
RGBEOF   TM    IOBUSTAT,UE         EOF CONDITION ?
         BO    RGBEOF1             YES, BRANCH
         TM    IOBSENS1,IOBS1B4    AT TAPE LOAD POINT ?
         BZ    RGBERROR            NO, BRANCH
         TM    PRIME,X'01'         PRIME TIME ?
         BZ    NOTPRIME            NO, ERROR TERMINATE
         STM   R3,R9,KSAVE
         SR    R0,R0
         IC    R0,0(,R3)           OBTAIN INCR FROM HIGH ORDER BYTE
         LR    R3,R0               OF PPIWKARE POINTER
         L     R6,PPISTDCB         OBTAIN DCB ADDR OF
         L     R6,0(R3,R6)         FILE WITH EOF
         NI    DCBIFLGS,255-DCBIFPEC  RESET I/O  ERROR FLAGS
         LH    R0,KNNINE           UPDATE FILE COUNT TO 32,768
         STC   R3,RGBINST+1
         BAS   R7,RGBFLUP          FIND FILE CNT
RGBBAL   B     RGBPORTN            BYPASS CLOSE IF NOT BALANCED
*
         OI    DCBOFLGS,DCBOFLRB   LAST I/O OP WAS READ BACKWARDS
*
         CLOSE ((R6),LEAVE)
*
         LTR   R15,R15             CLOSE SUCCESSFULL ?
         BZ    RGBPORTA            YES, BRANCH
*
         DC    H'0'                CLOSE FAILED, FORCE 0C1 ABEND
*                                  FOR DIAGNOSTIC PURPOSES
RGBPORTA L     R6,PPISTDCB
         AR    R6,R3
         MVI   0(R6),X'80'         TURN ON CLOSE BIT IN DCBTAB ENTRY
RGBPORTN L     R11,PPIALG+4        BRANCH TO MERGE ALGORITHM WITH
         BAS   R14,12(,R11)        INCR IN R3
         LM    R3,R9,KSAVE         RESTORE REGISTERS FOR PRIMING
         LR    R14,R4
         SLL   R14,2
         BCTR  R14,0               DECREMENT INCR
         EX    R14,KMOVE           BYPASS FILE ENTRY WITH EOF IN PPIA
         B     RGBPRLP             TURNOFF PRIMING IND
*
KMOVE    MVC   0(1,R3),4(R3)
RGBEOF1  MVI   RGBBAL+5,X'44'      TURN ON BIT INDICATING TAPE
         B     RGBEOF+16           MARK READ
*
*        READ ERROR HAS OCCURRED
*
RGBERROR PPISETON PPIREADE         TURN ON ERROR BIT IN PPI
RGBTERM  NOP   RGBSSCBR            AP SETS TO BRANCH IF NO EXIT 28
         L     R1,IOBDCBPT         DCB ADDR
         ST    R5,PPIWKARE         SET IOB ADDR WITH
         MVI   PPIWKARE,X'10'      INCREMENT TO CCW ADDR IN
         L     R0,PPIWKARE         THE HIGH ORDER BYTE
*
*        CALL EXIT E28
*
         L     R15,AE28
         BASR  R14,R15
RGBSSCBR L     R10,20(,R5)         LOAD IOB ADDR AND MODIFY
         L     R15,PPIADSSC
         BAS   R14,16(,R15)        NO RETURN
*                                  RESET I/O ERROR FLAGS
RGBSKIP  OI    IOBFLAG1,IOBCMDCH   SET COMMAND CHAINING ON
         NI    IOBCSTAT,255-IL-CDC
         NI    DCBIFLGS,255-DCBIFPEC  EXCEPTION BITS FOR PERM ERROR
RGBACCPT BAS   R7,RGBEE105         GET BUFFER ADDR
RGBEREOS TM    1(R2),X'07'         IF BLOCK WITH ERROR WAS EOS ALSO
         BO    RGBRTEOS            LINK TO MERGE
*
         IEREXCP  (R5)             ISSUE NEW READ INTO BUFFER AREA
*
         B     RGBEOSCK            WAIT IF NO ALTERNATE BUFFER
*
RGBIOBUP L     R4,IOBSTART         ATTACH THE ALTERNATE CCW TO
         L     R15,IOBECBPT
         MVC   IOBSTRTB,5(R15)     FILE TO HANDLE READS ON
         ST    R4,4(,R15)          THE ALTERNATE BUFFER
         L     R4,IOBSTART
         MVC   1(3,R4),1(R2)       STORE BUFFER ADDR IN CCW
         MVI   DCBBUFNO,2          UPDATE BUFNO
         LR    R4,R1               SAVE BLOCK COUNT
*
         IEREXCP  (R5)             READ BACKWARDS
*
         LR    R1,R4               RESTORE BLOCK COUNT FOR DEBLOCK
         BR    R7                  EXIT TO DEBLOCK
*
RGBFLUP  LA    R2,TFCNT            FIND FILE COUNT IN ORDER
RGBINST  CLI   0(R2),X'00'
         BE    RGBFL120            TO UPDATE COUNT
         LA    R2,4(,R2)
         B     RGBINST             CHECK NEXT FILE COUNT
*
RGBFL120 L     R4,0(,R2)           ADD SORT BLOCKING OR 32,768
         AR    R4,R0
         ST    R4,0(,R2)           TO FILE COUNT
         BR    R7                  RETURN TO MERGE ALGORITHM
*
*        PARTIAL OVERLAP
*
RGBFL040 LA    R2,TFCNT            ATTACH FLOATING BUFFER TO NEXT
         ST    R1,KSAVEB           SAVE BLOCK CNT FOR DEBLOCK
         L     R1,PPISBLCT         FILE TO BE READ
         LH    R7,KMRGMX
         LA    R4,PPIPSVA
         SR    R14,R14
         ST    R14,0(R3,R1)        SET RELEASED FILE'S BLCNT=0
RGBFL050 IC    R14,0(,R2)          OBTAIN DEBLOCK'S BLOCK COUNTERS
         L     R15,0(R14,R1)
         A     R15,0(,R2)          AND ADD THEM TO READ'S APPROPRIATE
         ST    R15,0(,R4)
         LA    R2,4(,R2)           FILE COUNTERS
         LA    R4,4(,R4)
         BCT   R7,RGBFL050         GET NEXT FILE COUNT
         LA    R2,PPIPSVA
         LH    R1,KMRGMX
         STC   R3,RGBINST1+1
         LR    R4,R2
         B     RGBINST1            GET LOWEST FILE COUNT
*
RGBFL060 LA    R4,4(,R4)           SCAN FOR LOWEST FILE COUNT
         CLC   1(3,R2),1(R4)
         BH    RGBEX070            AND FOR THE RELEASED
RGBINST1 CLI   0(R4),X'00'
         BE    RGBRL080            FILE COUNT
RGBLPEND BCT   R1,RGBFL060         CONTINUE SCAN
         LA    R0,PPIPSVA          OBTAIN FILE COUNT ADDRS VIA
         SR    R2,R0               DISPLACEMENTS OF LOWEST AND
         SR    R15,R0              RELEASED FROM PPIPSVA
         LA    R0,TFCNT
         AR    R15,R0
         AR    R2,R0
         MVI   DCBBUFNO,1          RELEASED FILE'S BUFNO(IN DCB)
         LR    R14,R6
         LR    R0,R5
         IC    R1,0(,R2)           INCR IN NEW FILE COUNT'S FIRST BYTE
         L     R6,PPISTDCB
         L     R6,0(R1,R6)         DCB AND IOB ADDR
         L     R5,DCBIOBAD         OF NEW FILE
         L     R4,PPIBDSVA         BUFFER TABLE ADDR
         AR    R4,R1
         L     R1,KSAVEB           RESTORE BLOCK CNT
RGBFBV   CLI   0(R4),C'$'          EOS ?
         BNE   RGBCONT             NOT EOS, BRANCH
         LR    R6,R14              REATTACH BUFFER TO PREVIOUS
         LR    R5,R0
         B     RGBAL030            (IE RELEASED FILE)
*
RGBCONT  CLI   KEOSCNT,X'00'       EOS AT PRIMING ?
         BNE   RGBFBV+8            NOT EOS, BRANCH
         L     R4,0(,R2)           UPDATE-
         AH    R4,PPISRTBL
         ST    R4,0(,R2)           NEW FILE COUNT
         L     R4,0(,R15)
         SH    R4,PPISRTBL
         ST    R4,0(,R15)          RELEASED FILE COUNT
         B     RGBAL030            ATTACH BUFFER
*
RGBEX070 LR    R2,R4               ADDR OF LOWEST FILE COUNT IN PPI
         B     RGBINST1            SAVE AREA
*
RGBRL080 LR    R15,R4              ADDR OF RELEASED FILE COUNT IN PPI
         B     RGBLPEND            SAVE AREA
*
NOTPRIME MVI   RGBTERM+1,X'F0'     SET UP TO TERMINATE JOB
         PPISETOF PPIACCPT         TURN OFF SO RCV WON'T RETURN
         B     RGBERROR            GO SET UP MSG AND TERMINATE
*
*        PRIMING SUBROUTINE
*
RGBPR200 MVI   KEOSCNT,X'00'
         XI    PRIME,X'01'         PRIME TIME SWITCH
         LA    R1,TINCR
         ST    R1,KEOSPR
RGBPRBAL NOP   RGBPR220            IF BALANCED OR FIRST TIME THROUGH
         SR    R1,R1               BYPASS SWITCHING OF
         IC    R1,PPIDEPHO+3
         CLI   KOUTINCR,X'00'      IOB ADDR IN NEW AND OLD OUTPUT
         BE    RGBPR210            DCBS
         L     R3,PPISTDCB
*                                  SWITCH THE IOB ADDR
         IC    R1,KOUTINCR         SO THAT THE DCBS ARE CORRECT
         L     R6,0(R1,R3)         FOR THIS SUBPASS THE OLD OUTPUT
         L     R5,DCBIOBAD         DCB NOW IS AN INPUT DCB AND MUST
         LR    R0,R6               POINT TO AN INPUT IOB (THE NEW
         IC    R1,PPIDEPHO+3       OUTPUT WAS AN INPUT DCB IN THE
         L     R6,0(R1,R3)         PREVIOUS SUBPASS)
         L     R2,DCBIOBAD
         IC    R15,DCBBUFNO
         ST    R5,DCBIOBAD
         ST    R6,IOBDCBPT
         LR    R6,R0
         LR    R5,R2
         ST    R6,IOBDCBPT
         ST    R2,DCBIOBAD
         STC   R15,DCBBUFNO
RGBPR210 STC   R1,KOUTINCR         SAVE THE NEW OUTPUT INCR FOR NEXT
RGBPR220 LA    R4,PPITPTBL         TIME THROUGH (SUBPASS)
*
*        ENSURE THAT THE DCBOFLGS ARE SET CORRECTLY FOR AN ABEND
*        AND RESTART
*
         L     R1,PPISTDCB         LOAD ADDR OF DCB ADDR TABLE
         SR    R3,R3
         IC    R3,PPIBDSVA         INSERT NUMBER OF WORK UNITS
RGBPR225 ICM   R2,B'1111',4(R1)    LOAD DCB ADDR
         BNP   RGBPR226            NO DCB ADDR, BRANCH
         DROP  R6
         USING IHADCB,R2
         NI    DCBOFLGS,255-DCBOFLWR  SHUT OUTPUT BIT OFF
         OI    DCBOFLGS,DCBOFLRB      TURN INPUT BIT ON
         DROP  R2
         USING IHADCB,R6
RGBPR226 LA    R1,4(,R1)           INCREMENT DCB TABLE ADDR
         BCT   R3,RGBPR225         N TIMES
         L     R1,PPISTDCB         LOAD ADDR OF DCB ADDR TABLE
         IC    R3,PPIDEPHO+3       DCB INCREMENT FOR OUTPUT UNIT
         L     R2,0(R1,R3)         LOAD DCB ADDR
         DROP  R6
         USING IHADCB,R2
         NI    DCBOFLGS,255-DCBOFLRB  TURN INPUT BIT OFF
         OI    DCBOFLGS,DCBOFLWR      TURN OUPUT BIT ON
         DROP  R2
         USING IHADCB,R6
         LH    R7,PPIMRGMX
         L     R9,PPISTDCB
         LA    R3,PPIWKARE
RGBPR230 TM    0(R4),X'80'         SEARCH THE TAPE TABLE FOR
         B     RGBPR240            INPUT FILES
         LA    R4,2(0,R4)
         B     RGBPR230            CONTINUE SCAN
*
RGBPR240 SR    R6,R6               PRIMING OF M BUFFERS
         IC    R6,1(,R4)
         STC   R6,0(,R3)
         L     R6,0(R6,R9)         OBTAIN THE IOB ADDR
         MVC   1(3,R3),DCBIOBAA    SAVE IN PPIA
         L     R5,DCBIOBAD
         L     R15,IOBSTART
         MVI   4(R15),SLI          SET SLI BIT FOR SHORT BLK
*
         IEREXCP  (R5)             READ BACKWARDS
*
         LA    R3,4(,R3)           UPDATE POINTERS AND
         LA    R4,2(,R4)           RETURN TO SEARCH FOR NEXT
         BCT   R7,RGBPR230         INPUT FILE
         LH    R4,PPIMRGMX
         L     R8,PPISBLCT
         LA    R9,TFCNT
         LA    R3,PPIWKARE
RGBPR245 L     R5,0(,R3)
         L     R1,IOBECBPT
*
         IERWAIT  1,ECB=(1)        ISSUE WAIT ON M BUFFERS
*
         NI    IOBCSTAT,255-IL     TURN OFF INCORRECT LENGTH BIT
         BAS   R7,RGBEE100         ERROR CHECK THE COMMANDS, AND
RGBBCCV  NOP   RGBPR280            THEN
*                                  ONLY FOR FIXED LENGTH RECORDS
         L     R15,IOBSTART
         MVI   4(R15),X'00'        TURN OFF SLI BIT USED ON SHORT BLK
RGBPR280 SR    R14,R14             LOAD INCR
         IC    R14,0(,R3)
RGBPREOS TM    1(R2),X'07'         EOS ON COMPLETED
         BO    RGBPR260            READS
         L     R6,IOBDCBPT
         CLI   DCBBUFNO,2          ALTERNATE BUFFER ?
         BE    RGBPR270            ALTERNATE BUFFER, BRANCH
RGBPR250 MVC   2(2,R9),PPISRTBL    SET READ'S FILE COUNT TO SORT BLK
RGBBRVAR LA    R2,4(,R2)           FIX BYPASS EOS INDICATOR
*                                  VAR BYPASS EOS INDICATOR AND BCC
RGBPR255 STC   R14,0(,R9)          STORE INCR IN HIGH ORDER BYTE OF
         LA    R9,4(,R9)           FILE COUNT AND UPDATE FILE POINTER
         ST    R1,0(R14,R8)        STORE BLOCK COUNT IN TABLE FOR THE
*                                  DEBLOCK RTN
         ST    R2,IERDGB2
         MVC   1(3,R3),IERDGB2+1   PASS RCD ADDR TO MERGE NETWORK
         LA    R3,4(,R3)           IN PPIA
RGBPRLP  BCT   R4,RGBPR245         ISSUE WAIT ON NEXT BUFFER
         MVC   KMRGMX(2),PPIMRGMX
         XI    PRIME,X'01'         TURN OFF PRIME SWITCH
         L     R11,PPIDEB2+4       B TO DEBLOCK BUFFER TABLE PRIME RTN
         BR    R11                 VIA R11
*
RGBPR260 L     R15,KEOSPR          EOS AT PRIMING TIME
         MVC   0(1,R15),0(R3)
         LA    R15,1(,R15)         STORE INCR IN TABLE TO INDICATE
         ST    R15,KEOSPR          TO RUNNING PGM WHICH FILE HAS
         SR    R15,R15             EOS CONDITION
         IC    R15,KEOSCNT
         LA    R15,1(,R15)         UPDATE COUNT
         STC   R15,KEOSCNT
         B     RGBPR250            LINK TO MERGE NETWORK
*
RGBPR270 LR    R0,R14
         STM   R0,R2,KSAVE         THE FILE HAS AN ALTERNATE BUFFER
         L     R1,IOBECBPT         SWITCH CCW ADDR
         L     R15,4(,R1)
         MVC   5(3,R1),IOBSTRTB
         ST    R15,IOBSTART
*
         IEREXCP  (R5)             START A READ ON THE FILE
*
         LM    R0,R2,KSAVE         2*SORT BLK
         LR    R14,R0
         LH    R15,PPISRTBL        AS THE READ'S FILE COUNT
         SLL   R15,1
         STH   R15,2(,R9)
         B     RGBBRVAR            LINK TO MERGE NETWORK
*
AE28     DC    A(0)                ADCON FOR EXIT 28
*
KSAVE    DC    7F'0'               SAVE AREA
KSAVEB   DC    F'0'                SAVE AREA
KFOUR    DC    H'4'                FOUR
KNNINE   DC    X'7FFF'             NEG NINE
KOUTINCR DC    X'00'               OUTPUT INCR
KEOSCNT  DC    X'00'               END OF SEQ CNT
KMRGMX   DC    H'0'                MAX MERGE ORD
KEOSPR   DC    A(TINCR)            ADDR OF INPUT INCR TABLE
*
TINCR    DC    4F'0'               INPUT INCR TABLE
TFCNT    DC    16F'0'              FILE COUNT TABLE
PRIME    DC    X'00'               TO DETERMINE IF A PRIME TIME
*
./ ADD NAME=IERRGC   0101-20211-20211-1200-00118-00118-00000-RELEASE 00
RGC      TITLE 'IERRGC - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRGC
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 2 READ ROUTINE - DISK BALN TECHNIQUE
*        MODULE HANDLES DISK INPUT IN THE INTERMEDIATE
*        MERGE PHASE BY WAY OF THE EXCP MACRO. THE MODULE READS
*        PHYSICAL RECORDS INTO BUFFER AREAS. THE ROUTINE
*        INTERFACES WITH IOS, THE ALGORITHM, THE BUFFER TABLE
*        ROUTINE, DEBLOCK, AND THE MERGE NETWORK. IF EXIT E28 IS
*        ACTIVATED BY A USER, THE READ ROUTINE (ON A READ ERROR)
*        ALLOWS THE USER TO TRY AND CORRECT THE ERROR AFTER IOS
*        HAS TRIED TO DO SO. IF THERE IS A PERMANENT READ ERROR
*        CONTROL IS PASSED TO SORT SYSTEM CONTROL TO TERMINATE
*        THE JOB
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - IERAGC
*
*        MACROS USED -
*        SMPPI   EXCP   WAIT
*
*        ENTRY POINTS - ENTRY FROM ALGORITHM
*                       CALLING SEQUENCE -
*                         L   R11,PPIRD+4
*                         BAL R14,0(,R11)
*                       PARAMETERS -
*                         DIRECTORY DISK READ ADDR PROVIDED IN PPIDIRAD
*
*                     - ENTRY FROM MERGE NETWORK/ALGORITHM
*                       CALLING SEQUENCE -
*                         L   R11,PPIRD+4
*                         B   4(,R11)
*
*                     - ENTRY FROM DEBLOCK
*                       CALLING SEQUENCE -
*                         L   R11,PPIRD+4
*                         B   8(,R11)
*                       PARAMETERS -
*                         R2 -> EMPTY BUFFER
*                         R3  = INCREMENT (M) TO LOCATE IOB
*
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIADSSC   PPIRCDL2   PPICNTL
*        PPIDIRAD   PPISBLCT   PPIWKARE
*        PPILAB03   PPISRTBL   PPIMRGMX
*        PPISTDCB   PPIPSVA    PPISTIOB
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED - NONE
*
*        EXTERNAL ROUTINES - NONE
*
*        EXTERNAL PARAMETERS -
*        R3 -> EMPTY INPUT BUFFER
*        R4  = INCREMENT TO IOB IN IOB TABLE (LOW ORDER BYTE)
*
*        EXITS - NORMAL - DEBLOCK - PHASE 2 PRIME RTN
*                         L   R11,PPIDEB2+4
*                         BR  R11
*
*                       - BLOCK/DEBLOCK
*                         L   R11,PPIBLK2+4
*                         B   4(,R11)
*
*                       - MERGE NETWORK
*                         L   R11,PPINETM+4
*                         B   4(,R11)
*
*                       - ALGORITHM
*                         L   R11,PPIALG+4
*                         BR  R14
*
*        EXITS - ERROR - USER EXIT 28
*
*        TABLES/WORK AREAS -
*        FILE COUNT TABLE
*        CCW LIST FOR READING DIRECTORY
*
*        NOTES - NONE
*
IERRGC   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRGC SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRGCI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
*        IERCCWEQ
*
         IERCCWEQ
*
*        IERIOB
*
         IERIOB
*
         PRINT NOGEN
*
         DCBD  DSORG=PS,DEVD=(DA,TA)
*
         IHAECB DSECT=NO,EXT=NO
*
         IEZDEB LIST=NO
*
         PRINT GEN
*
         SMPPI
*
         END
./ ADD NAME=IERRGCI  0101-20211-20211-1200-00452-00452-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERRGC SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERRGCI
*
         USING *,R11
         USING IOBSTDRD,R5         IOB DSECT
         USING IERRCA,R13          PPI DSECT
*
IERDGB2D B     RGCDR300            +00 READ DIRECTORY ENTRY
         B     RGCPR200            +04 PRIMING SUBROUTINE
         TM    1(R2),X'07'         +08 BLK/DEBLK ENTRY EOS ?
         BNO   RGCST010            NOT EOS, BRANCH
RGCRTEOS L     R11,PPINETM+4       EOS
         B     4(,R11)             ON EOS
*
*        NON EOS BLK/DEBLK ENTRY
*
RGCST010 STM   R2,R6,KSAVE         SAVE
         ST    R2,KSAVE1           REGISTERS
         L     R5,PPISTIOB         R5 -> IOB TABLE
         L     R5,0(R3,R5)         R5 -> IOB
         L     R2,IOBECBPT
         TM    4(R2),X'02'         TWO BUFFERS FOR FILE ?
         BO    RGCAL020            YES, BRANCH ALTERNATE
*
*        FILE ONLY HAS ONE BUFFER ATTACHED TO THE IOB
*
         IEREXCP  (R5)             READ
*
         LR    R1,R2
*
         IERWAIT  1,ECB=(1)        WAIT ON FILE NOW FOR IT HAS NO
*                                  ALT BUFFER
         BAS   R6,RGCER100         CALL ERROR CHECK RTN
RGCRTRN  LM    R2,R6,KSAVE         RESTORE REGISTERS
         LA    R2,4(,R2)           FIX/VAR - BYPASS EOS INDICATOR
*                                  VAR     - ALSO BYPASS BCC
         L     R11,PPIBLK2+4
         B     4(,R11)             DEBLOCK
*
*        FILE HAS ALTERNATE BUFFER ATTACHED TO THE IOB
*
RGCAL020 BAS   R4,RGCEOSCK         WAIT ON FILE ERR CK AND SEQ CK
RGCRFBF  NOP   RGCFL040            IF ONLY HAVE PARTIAL OVERLAP, THIS
*                                  NOP BECOMES AN UNCONDITIONAL
*                                  BRANCH HAVE FLOATING BUFFERS
RGCIOBUP L     R4,IOBSTART         ATTACH THE ALTERNATE BUFFER TO
         L     R15,IOBECBPT
         MVC   IOBSTRTB,5(R15)     THE IOB VIA THE CCW LIST
         ST    R4,4(,R15)
         L     R4,IOBSTART
         MVC   17(3,R4),KSAVE1+1   STORE BUFFER ADDR IN THE READ CCW
         MVI   4(R15),X'02'        UPDATE NO OF BUFFERS ATTACHED
         LR    R4,R1               SAVE BLOCK COUNT ON COMPLETED READ
*
         IEREXCP  (R5)             READ
*
         LR    R1,R4               RESTORE BLOCK COUNT FOR DEBLOCK
         B     RGCRTRN             GOTO DEBLOCK
*
RGCEOSCK L     R1,IOBECBPT         ISSUE WAIT ON PREVIOUS READ
*
         IERWAIT  1,ECB=(1)
*
         BAS   R6,RGCER100         CALL ERROR CHECK AND SEQUENCE CHECK
RGCEOSV  TM    1(R2),X'07'         EOS ?
         BNOR  R4                  EOS, DON'T ISSUE ANOTHER READ
         B     RGCRTRN             ON FILE
*
*        PARTIAL OVERLAP
*
RGCFL040 LA    R2,TFCNT            SCAN FILE COUNTERS TO DETERMINE
         ST    R1,KSAVEB           SAVE BLOCK CNT FOR DEBLOCK
         L     R1,PPISBLCT         WHICH FILE TO ATTACH ALT BUFFER
         LH    R6,KMRGMX           TO FOR NEXT READ
         LA    R4,PPIPSVA
         SR    R14,R14
         ST    R14,0(R3,R1)        SET RELEASED FILE'S BLCNT=0
RGCFL050 IC    R14,0(,R2)          OBTAIN DEBLOCK'S BLOCK COUNTERS
         L     R15,0(R14,R1)
         A     R15,0(,R2)          ADD THEM TO READ'S APPROPRIATE
         ST    R15,0(,R4)
         LA    R2,4(,R2)           FILE COUNTERS
         LA    R4,4(,R4)
         BCT   R6,RGCFL050         OBTAIN NEXT BLOCK COUNTER
         LA    R2,PPIPSVA
         LH    R1,KMRGMX
         STC   R3,RGCINST1+1
         LR    R4,R2
         B     RGCINST1            CHECK 0 FILE COUNT
*
RGCFL060 LA    R4,4(,R4)           SCAN FOR LOWEST FILE COUNT
         CLC   1(3,R2),1(R4)
         BH    RGCEX070            AND FOR RELEASED
RGCINST1 CLI   0(R4),X'00'
         BE    RGCRL080            FILE COUNT
RGCLPEND BCT   R1,RGCFL060         CONTINUE SCAN
         LA    R0,PPIPSVA          OBTAIN FILE COUNT ADDR VIA
         SR    R2,R0               DISPLACEMENTS OF LOWEST AND
         SR    R15,R0              RELEASED FROM PPIPSVA
         LA    R0,TFCNT
         AR    R15,R0
         AR    R2,R0
         L     R4,IOBECBPT
         MVI   4(R4),X'01'         RELEASED FILE'S NO OF BUFFERS
         LR    R14,R5
         IC    R1,0(,R2)
         L     R5,PPISTIOB         R5 -> IOB TABLE
         L     R5,0(R1,R5)         R5 -> IOB
         L     R4,IOBSTART         R4 -> CCW LIST
         L     R4,16(,R4)
         L     R1,KSAVEB           RESTORE BLOCK CNT
RGCFBV   TM    1(R4),X'07'         EOS CK ON BUFFER ALREADY ATTACHED ?
         BNO   RGCCONT             TO FILE
         LR    R5,R14              YES, GO BACK AND ATTACH ALT BUFFER
         B     RGCIOBUP            TO FILE IT WAS ON BEFORE
*
RGCCONT  L     R4,0(,R2)           UPDATE
         AH    R4,PPISRTBL
         ST    R4,0(,R2)           NEW FILE COUNT
         L     R4,0(,R15)          RELEASED FILE COUNT
         SH    R4,PPISRTBL
         ST    R4,0(,R15)
         B     RGCIOBUP            ATTACH BUFFER
*
RGCEX070 LR    R2,R4               ADDR OF LOWEST FILE COUNT IN PPI
         B     RGCINST1            SAVE AREA
*
RGCRL080 LR    R15,R4              ADDR OF RELEASED FILE COUNT IN PPI
         B     RGCLPEND            SAVE AREA
*
*        ERROR CHECK OF BUFFER READ HAS COMPLETED
*
RGCER100 L     R1,IOBECBPT
         CLI   0(R1),ECBNORM       SUCCESSFULLY COMPLETED W/O ERROR ?
         BNE   RGCRESET            NO, CHECK FOR PURGE
         L     R2,IOBSTART
         L     R2,16(,R2)          OBTAIN THE BUFFER ADDR
RGCER110 LH    R1,PPILAB03+2       OBTAIN THE BLOCK CHAR COUNT
         SH    R1,IOBCSW+5         SUBTRACT CSW RESIDUAL COUNT
         SH    R1,KFOUR
         ST    R2,KSAVE
         ST    R2,KSAVE+8
         MVI   KSAVE,X'00'
RGCBRVR  NOP   RGCTRKNO            UNCOND BRANCH IF VAR RECORD FORMAT
         SR    R14,R14
RGCFIX   SH    R1,PPIRCDL2         NEED BLOCK RECORD CNT IF FIX RECORD
         LA    R14,1(,R14)
         CH    R1,PPIRCDL2
         BNL   RGCFIX
         LR    R1,R14
*
*        UPDATE THE DISK ADDR FOR NEXT TIME THROUGH - MBBCCHHR
*
RGCTRKNO CLC   IOBR,PPIBPTRK+1     TRACK FULL ?
         BE    RGCUPH              YES, UPDATE HEAD
         IC    R14,IOBR            NO, UPDATE IOBR TO NEXT RECORD
         LA    R14,1(,R14)         INCR IOBR
         STC   R14,IOBR            STORE UPDATE IOBR
         BR    R6                  RETURN TO READ
*
RGCUPH   MVI   IOBR,X'01'          RESET RECORD NO TO 1 ON NEXT TRACK
         L     R15,IOBDCBPT        R15 -> DCB
         USING IHADCB,R15
*
*        SETUP FOR EXCP
*        CONVERT MBBCCHHR -> TTR
*
         STM   R14,12,12(R13)      SAVE REGS ACROSS RTN
         LR    R3,R13              SAVE R13
         L     R1,DCBDEBAD         R1 -> DEB
         LA    R2,IOBSEEK          R2 -> MBBCCHHR
         L     R15,PPIPRLTV        R15 -> CONVERSION RTN
         BASR  R14,R15             CONVERT MBBCCHHR -> TTR
         LR    R13,R3              RESTORE R13
         LTR   R15,R15          *  SET CC
         LM    R14,R15,12(R13)  |  RESTORE REGS, DO NOT RESTORE R0
         LM    R1,R12,24(R13)   |
         BNZ   RGCSSCBR         V  CONVERSION FAILED, TERMINATE SORT
*
*        INCR TT
*
         AL    R0,ADDTRK           INCR TT ONLY IN TTRN
*
*        SETUP FOR EXCP
*        CONVERT TTR -> MBBCCHHR
*
         STM   R14,12,12(R13)      SAVE REGS ACROSS RTN
         LR    R3,R13              SAVE R13
         L     R1,DCBDEBAD         R1 -> DEB
         LA    R2,DCBFDAD          R2 -> MBBCCHHR RESULT
         L     R15,PPIPCNVT        R15 -> CONVERSION RTN
         BASR  R14,R15             CONVERT TTR -> MBBCCHHR
         LR    R13,R3
         LTR   R15,R15          *  SET CC
         LM    R14,R12,12(R13)  |  RESTORE REGS
         BNZ   RGCSSCBR         V  CONVERSION FAILED, TERMINATE SORT
         MVC   IOBSEEK,DCBFDAD     MOVE UPDATED SEARCH ADDR TO IOB
         BR    R6                  RETURN TO READ
*
         DROP  R15
*
*        CHECK ECB ERROR CONDITION
*
RGCRESET CLI   0(R1),ECBREPRG      I/O REQUEST PURGED ?
         BNE   RGCERROR            NO, ERROR CONDITION
*
*        REQUEST PURGED DUE TO I/O ERROR ON OTHER READ
*        RESTORE REQUEST QUEUE
*
         L     R1,IOBDCBPT
         USING IHADCB,R1
         NI    DCBIFLGS,255-DCBIFPEC  RESET I/O
         OI    IOBFLAG1,IOBCMDCH   SET COMMAND CHAINING ON
         L     R1,DCBDEBAD         R1 -> DEB
         DROP  R1
         USING DEBBASIC,R1
         LA    R1,DEBUSRPG         POINT TO FIRST PURGED IOB ADDR
         DROP  R1
         IERESTOR (1)              RESTORE SVC
*
         B     RGWAIT              GOTO WAIT
*
*        READ ERROR HAS OCCURRED - CHECK TO SEE IF USER EXIT E28
*        WAS ACTIVATED AT ASSIGNMENT TIME
*
RGCERROR PPISETON PPIREADE         TURN ON ERROR BIT IN PPI
RGCTERM  NOP   RGCSSCBR  ÝMAYBE B¨ BRANCH TO TERMINATION
         L     R1,IOBDCBPT         DCB ADDR
         ST    R5,PPIWKARE         SET IOB ADDR WITH
         MVI   PPIWKARE,X'10'      INCREMENT TO CCW ADDR IN
         L     R0,PPIWKARE         THE HIGH ORDER BYTE
*                                  LINK TO USER IS OVERLAYED IF NOT
*        CALL  E28                 ACTIVATED
*
         L     R15,AE28
         BASR  R14,R15
*
*        TERMINATE SORT
*
RGCSSCBR L     R10,IOBDCBPT-IOBSTDRD(,R5)   R10 -> DCB
         L     R15,PPIADSSC        TERMINATE OPTION
         BAS   R14,16(,R15)        NO RETURN
*
RGCSKIP  NI    IOBUSTAT,255-UC-UE  ERROR ACCEPTED
         NI    IOBCSTAT,255-IL-CDC
         L     R1,IOBDCBPT         RESET ALL ERROR BITS SET BY IOS
         USING IHADCB,R1
         NI    DCBIFLGS,255-DCBIFPEC  IN THE IOB AND DCB
         L     R1,DCBDEBAD         R1 -> DEB
         DROP  R1
         USING DEBBASIC,R1
         LA    R1,DEBUSRPG         POINT TO FIRST PURGED IOB ADDR
         DROP  R1
         IERESTOR (1)              RESTORE SVC
         OI    IOBFLAG1,IOBCMDCH   SET COMMAND CHAINING ON
RGCACCPT L     R2,IOBSTART
         L     R2,16(,R2)
RGCACCV  TM    1(R2),X'07'         BLOCK WITH ERROR WAS EOS ?
         BO    RGCRTEOS            YES, BRANCH
         LR    R0,R6               SAVE ERROR CHECK  RETURN REG
         BAS   R6,RGCTRKNO         CALC NEXT TRACK ADDR
         LR    R6,R0               RESTORE REGISTER
*
         IEREXCP  (R5)             READ NEXT BLOCK INTO SAME BUFFER
*
RGWAIT   L     R1,IOBECBPT
*
         IERWAIT 1,ECB=(1)         AREA AND WAIT UNTIL COMMAND IS
*
         B     RGCER100            COMPLETED
*
RGCBR    B     RGCER110-8          OBTAIN BUFFER ADDR
*
*        PRIMING SUBROUTINE
*
RGCPR200 LA    R4,PPIWKARE         R4 -> WORK AREA - DISK ADDR
         L     R6,PPISTIOB         R6 -> IOB TABLE
         LA    R6,4(,R6)           R6 -> IOB ENTRY IN IOB TABLE
         LH    R2,PPIMRGMX
         STH   R2,KMRGMX
         SR    R3,R3
         SLL   R2,1
         IC    R3,PPILAB03         IF ONLY HAVE PARTIAL OVERLAP
         MVI   RGCRFBF+1,X'00'     RESET BRANCH TO NOP
         CR    R2,R3
         BNH   RGCPR205            PARTIAL
         MVI   RGCRFBF+1,X'F0'     SET UNCOND BRANCH IN PGM
RGCPR205 SRL   R2,1
         IC    R3,0(,R4)           M INCR FROM PPIWKARE
         L     R15,PPISTDCB
         L     R3,0(R3,R15)        R3 -> DCB FOR ALL IOBS
         USING IHADCB,R3
*
*        START LOOP TO PROCESS FOR EACH BUFFER
*
RGCPR210 L     R5,0(,R6)           R5 -> IOB
         ST    R3,IOBDCBPT         STORE DCB ADDR INTO IOB
*
*        SETUP FOR EXCP
*        CONVERT TTR -> MBBCCHHR
*
         STM   R14,12,12(R13)      SAVE REGS ACROSS RTN
         LR    R6,R13              SAVE R13
         SR    R0,R0
         ICM   R0,B'1110',5(R4)    R0 = TTR0 FROM PPIWKARE
         L     R1,DCBDEBAD         R1 -> DEB
         LA    R2,DCBFDAD          R2 -> MBBCCHHR RESULT
         L     R15,PPIPCNVT        R15 -> CONVERSION RTN
         BASR  R14,R15             CONVERT TTR -> MBBCCHHR
         LR    R13,R6
         LTR   R15,R15          *  SET CC
         LM    R14,R12,12(R13)  |  RESTORE REGS
         BNZ   RGCSSCBR         V  CONVERSION FAILED, TERMINATE SORT
         MVC   IOBSEEK,DCBFDAD     MOVE SEARCH ADDR TO IOB
         DROP  R3
*
         IEREXCP  (R5)             READ - PRIME M BUFFERS
*
         LA    R6,4(,R6)           UPDATE - IOB TABLE POINTER
         LA    R4,8(,R4)                    PPIWKARE POINTER
         BCT   R2,RGCPR210         LOOP TO PROCESS NEXT BUFFER
*
*        ALL BUFFERS PROCESSED
*        BEGIN WAIT LOOP
*
         L     R7,PPISTIOB
         LA    R3,4                INCR FOR IOB BUFFER AND BLCNT TABLES
         LH    R8,PPIMRGMX         SET WAIT LOOP COUNT
         LA    R9,TFCNT            R9 -> FILE COUNT TABLE
         LA    R4,PPIWKARE
RGCPR220 LA    R7,4(,R7)
*
*        WAIT ON M BUFFERS
*
         L     R5,0(,R7)           IOB ADDR
         L     R1,IOBECBPT
*
         IERWAIT  1,ECB=(1)
*
         BAS   R6,RGCER100         ERROR CHECK
RGCPR225 L     R14,PPISBLCT        STORE BLOCK COUNT IN TABLE
         ST    R1,0(R3,R14)        FOR DEBLOCK
         STC   R3,0(,R9)
         L     R14,IOBECBPT
         CLI   4(R14),X'02'        ALTERNATE BUFFERS ?
         BE    RGCPR250            YES, ALTERNATE BUFFERS
RGCPR230 MVC   2(2,R9),PPISRTBL    SET READ'S FILE COUNT TO SORT BLK
RGCBRVAR LA    R2,4(,R2)           FIX - BYPASS EOS INDICATOR
         ST    R2,0(,R4)           VAR - BYPASS EOS INDICATOR AND BCC
         STC   R3,0(,R4)           PASS RCD ADDR WITH INCR FOR MERGE
         LA    R9,4(,R9)           UPDATE
         LA    R4,4(,R4)           POINTERS
         LA    R3,4(,R3)
         BCT   R8,RGCPR220         NEXT FILE COUNT
         L     R11,PPIDEB2+4
         BR    R11                 TO BUFFER TABLE RTN
*
RGCPR250 TM    1(R2),X'07'         EOS ? DON'T ISSUE ANOTHER
         BO    RGCPR230            READ FOR THE FILE
         LH    R15,PPISRTBL        2*SRT BLK AS READ'S
         SLL   R15,1
         STH   R15,2(,R9)          FILE COUNT
         L     R15,IOBSTART        SWITCH THE CCW LIST
         MVC   IOBSTRTB,5(R14)     ADDR SO READ INTO
         ST    R15,4(,R14)         ALTERNATE BUFFER
         MVI   4(R14),X'02'
*
         IEREXCP  (R5)
*
         B     RGCBRVAR            SET READ
*
*        READ DIRECTORY ROUTINE
*
*        DIRECTORY BUFFER AREA ADDR HAS BEEN INITIALIZED BY IERAGC
*
*        DIRECTORY DISK READ ADDR PROVIDED IN PPIDIRAD
*
*        LOCATE DCB
RGCDR300 SR    R3,R3
         IC    R3,PPIDIRAD         OBTAIN M INCR FROM DISK ADDR TO
         L     R1,PPISTDCB         OBTAIN DCB ADDR
         AR    R1,R3               R1 -> DCB ENTRY
         L     R5,PPISTIOB         IOB TABLE
         L     R5,4(,R5)           R5 -> IOB
         MVC   IOBDCBPT,0(R1)      MOVE DCB ADDR INTO IOB
         MVC   KSAVE1,IOBSTART     SAVE CCW LIST ADDR FOR DATA READ
         LA    R1,KRDDIR           REPLACE WITH DIR CCW LIST IN IOB
         ST    R1,IOBSTART
         ST    R14,KSAVE           SAVE RETURN REGISTER
*
*        SETUP FOR EXCP
*        CONVERT TTR -> MBBCCHHR
*
         STM   R14,12,12(R13)      SAVE REGS ACROSS RTN
         L     R1,IOBDCBPT         R1 -> DCB
         USING IHADCB,R1
         LR    R3,R13              SAVE R13
         SR    R0,R0
         ICM   R0,B'1110',PPIDIRAD+5  R0 = TTR0
         LA    R2,DCBFDAD          R2 -> MBBCCHHR RESULT
         L     R1,DCBDEBAD         R1 -> DEB
         DROP  R1
         L     R15,PPIPCNVT        R15 -> CONVERSION RTN
         BASR  R14,R15             CONVERT TTR -> MBBCCHHR
         LR    R13,R3
         LTR   R15,R15          *  SET CC
         LM    R14,R12,12(R13)  |  RESTORE REGS
         BNZ   RGCSSCBR         V  CONVERSION FAILED, TERMINATE SORT
         L     R15,IOBDCBPT        R15 -> DCB
         USING IHADCB,R15
         MVC   IOBSEEK,DCBFDAD     MOVE SEARCH ADDR TO IOB
         DROP  R15
         LA    R15,IOBCC           PLACE POINTER TO DISK ADDR IN THE
         STCM  R15,B'0111',KRDDIR+1  DIRECTORY'S SEARCH ID CCW
*
         IEREXCP  (R5)             READ DIRECTORY
*
         L     R1,IOBECBPT
*
         IERWAIT 1,ECB=(1)
*
         L     R1,IOBECBPT
         CLI   0(R1),ECBNORM       SUCCESSFULLY COMPLETED I/O ?
         BNE   RGCSSCBR            NO, TERMINATE JOB
         MVC   IOBSTART,KSAVE1     RESTORE CCW LIST ADDR IN IOB
         L     R14,KSAVE           RETURN REGISTER
         L     R11,PPIALG+4        RESTORE CALLERS ADDRESSABILITY
         BR    R14                 RETURN TO CALLER
*
AE28     DC    A(0)                E28 ADCON
*
KSAVE    DC    5F'0'               SAVE AREA
KSAVE1   DC    F'0'                SAVE AREA
KSAVEB   DC    F'0'                SAVE AREA
ADDTRK   DC    X'00010000'         ADD 1 TO TTRN
KFOUR    DC    H'4'                CONSTANT FOUR
KMRGMX   DC    H'0'                MAX MERGE ORDER
*
TFCNT    DC    16F'0'              FILE COUNT TABLE
*
*        READ DIRECTORY CCCW LIST
*
KRDDIR   CCW   SEARIDEQ,0,SLI+CC,5 +0
         CCW   TIC,KRDDIR,SLI+CC,0 +8
         CCW   READDATA,0,SLI,64   +16      ADDR UPDATED BY IERAGC
*
./ ADD NAME=IERRGD   0101-20211-20211-1200-00091-00091-00000-RELEASE 00
RGD      TITLE 'IERRGD - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRGD
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 3 READ ROUTINE - TAPE
*        THIS MODULE HANDLES TAPE INPUT BY WAY OF THE EXCP
*        MACRO, AND READS THE PHYSICAL RECORDS INTO BUFFER AREAS.
*        THE ROUTINE INTERFACES WITH IOS AND THE FINAL MERGE
*        PHASE DEBLOCK MODULE. IF EXIT 38 ACTIVATED BY A USER,
*        THE READ ROUTINE (ON A READ ERROR) ALLOWS THE USER TO
*        TRY AND CORRECT THE ERROR AFTER IOS HAS TRIED TO DO SO.
*        IF THERE IS A PERMANENT READ ERROR, CONTROL IS PASSED TO
*        SORT SYSTEM CONTROL TO TERMINATE THE JOB
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - IERAGD
*
*        MACROS USED -
*        SMPPI   EXCP
*        WAIT    CLOSE
*
*        ENTRY POINTS - ENTRY FROM DEBLOCK
*                       CALLING SEQUENCE -
*                           L   R11,PPIRD+4
*                           B   4(,R11)
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIADSSC   PPISTDCB
*        PPILAB02   PPICNTL
*        PPILAB03   PPIPSVA
*        PPISRTBL
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPILAB02   PPILAB03
*        PPISBLCT   PPIWKARE
*
*        EXTERNAL ROUTINES -
*        IERAP3 - OPEN LIST
*
*        EXTERNAL PARAMETERS -
*        IERAP3 - USER READ OPTION
*
*        EXITS - NORMAL -
*        DEBLOCK
*        MERGE
*
*        EXITS - ERROR -
*        USER EXIT 38
*
*        TABLES/WORK AREAS - TABLE OF FILE COUNTS (TFCNT)
*
*        NOTES -
*        FOR TAPE ONLY
*
IERRGD   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRGD SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRGDI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
*        IERCCWEQ
*
         IERCCWEQ
*
*        IERIOB
*
         IERIOB
*
         PRINT NOGEN
*
         DCBD  DSORG=PS,DEVD=(DA,TA)
*
         IHAECB DSECT=NO,EXT=NO
*
         IEZDEB LIST=NO
*
         PRINT GEN
*
         SMPPI
*
         END
./ ADD NAME=IERRGDI  0101-20211-20211-1200-00261-00261-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERRGD SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERRGDI
*
         USING *,R11
         USING IERRCA,R13
         USING IOBSTDRD,R5
         USING IHADCB,R6
*
IERDGB3  NOP   IERDGB3             +00 DUMMY ENTRY
         STM   R2,R7,KSAVE         +04
         ST    R2,IERDGB3
         L     R6,PPISTDCB
         L     R6,0(R3,R6)         APPROPRIATE DCB VIA INCR IN R3
         L     R5,DCBIOBAD         IOB ADDR
         TM    DCBBUFNO,X'02'      ALTERNATE BUFFER FOR FILE ?
         BO    RGDAL020            YES, BRANCH
*
*        FILE ONLY HAS ONE BUFFER ATTACHED TO THE IOB
*
         IEREXCP  (R5)             READ BACKWARDS
*
         L     R1,IOBECBPT
*
         IERWAIT  1,ECB=(1)        WAIT ON IOB
*
RGDLINK  BAS   R7,RGDEE100         CALL EOF ERROR CHECK RTN
         LH    R2,KCOUNT           AVAILABLE BUFFER
         BCT   R2,RGDBF010         ON LIST TO ATTACH TO FILE
RGDRTRN  LM    R2,R7,KSAVE
         L     R11,PPIDEB+4
RGDRTRNV LA    R2,4(,R2)           FIXED - BYPASS EOS INDICATOR
*                                  VAR   - BYPASS EOS INDICATOR AND BCC
         BR    R11
*
*        ATTACH AVAILABLE BUFFER TO FILE WHICH PREVIOUSLY HAD NO
*        ALTERNATE BUFFER
*
RGDBF010 STH   R2,KCOUNT
         L     R2,PPILAB02
         BAS   R7,RGDIOBUP         UPDATE IOB - ATTACH BUFFER FROM
         LA    R2,4(,R2)           AVAILABLE LIST
         ST    R2,PPILAB02         UPDATE LIST
         IC    R2,KTOTAL           UPDATE
         LA    R2,1(,R2)           KTOTAL
         STC   R2,KTOTAL
         STC   R3,RGDINST+1
         LH    R0,PPISRTBL
         LA    R7,RGDRTRN
RGDFLUP  LA    R2,TFCNT            FIND FILE COUNT IN ORDER
RGDINST  CLI   0(R2),X'00'
         BE    RGDBF015            TO UPDATE COUNT
         LA    R2,4(,R2)
         B     RGDINST
*
RGDBF015 L     R4,0(,R2)           ADD SORT BLOCKING
         AR    R4,R0
         ST    R4,0(,R2)           TO FILE COUNT
         BR    R7
*
RGDIOBUP L     R4,IOBSTART         ATTACH NEW(OR ALTERNATE) CCW
         L     R15,IOBECBPT
         MVC   IOBSTRTB,5(R15)     TO FILE TO HANDLE READS ON
         ST    R4,4(,R15)          ALTERNATE BUFFER
         L     R4,IOBSTART
         MVC   1(3,R4),1(R2)       STORE BUFFER ADDR IN CCW
         MVI   DCBBUFNO,2          UPDATE BUFNO
         LR    R4,R1               SAVE BLOCK COUNT
*
         IEREXCP  (R5)             READ BACKWARDS
*
         LR    R1,R4               RESTORE BLOCK COUNT FOR DEBLOCK
         BR    R7
*
RGDAL020 L     R1,IOBECBPT
*
         IERWAIT  1,ECB=(1)        WAIT ON ALTERNATE
*
         BAS   R7,RGDEE100         CALL EOF ERROR CHECK RTN
RGDK2M   CLI   KTOTAL,X'00'        FULL OVERLAP TEST
         BL    RGDFL030
RGDAL025 LA    R2,IERDGB3          ATTACH EMPTY BUFFER
         LA    R7,RGDRTRN          TO SAME FILE AGAIN
         B     RGDIOBUP
*
*        PARTIAL OVERLAP
*
RGDFL030 LA    R2,TFCNT            ATTACH EMPTY BUFFER TO NEXT
         ST    R1,KSAVEB           SAVE BLOCK CNT FOR DEBLOCK
         L     R1,PPISBLCT
         LH    R7,KMRGMX           ADDING OF DEBLOCK
         LA    R4,PPIPSVA
         SR    R14,R14             COUNTS TO THE
         ST    R14,0(R3,R1)        SET RELEASED FILE'S BLCNT=0
RGDFL035 IC    R14,0(,R2)
         L     R15,0(R14,R1)       FILE COUNTS
         A     R15,0(,R2)
         ST    R15,0(,R4)
         LA    R2,4(,R2)
         LA    R4,4(,R4)
         BCT   R7,RGDFL035
         LA    R2,PPIPSVA          OBTAIN FILE COUNT ADDR VIA
         LH    R1,KMRGMX           FILE TO BE READ
         STC   R3,RGDINST1+1
         LR    R4,R2
         B     RGDINST1
*
RGDLP040 LA    R4,4(,R4)           SCAN FOR LOWEST FILE COUNT
         CLC   1(3,R2),1(R4)
         BH    RGDEX050            AND FOR THE RELEASED
RGDINST1 CLI   0(R4),X'00'
         BE    RGDRL060            FILE COUNT
RGDLPEND BCT   R1,RGDLP040
         LR    R1,R0
         LA    R0,PPIPSVA          DISPLACEMENTS OF LOWEST AND
         SR    R2,R0               RELEASED FROM PPIPSVA
         SR    R1,R0
         LA    R0,TFCNT
         AR    R1,R0
         AR    R2,R0
         L     R4,0(,R2)           UPDATE-
         AH    R4,PPISRTBL
         ST    R4,0(,R2)           NEW FILE COUNT
         MVI   DCBBUFNO,1          RELEASED FILE'S BUFNO
         L     R4,0(,R1)
         SH    R4,PPISRTBL
         ST    R4,0(,R1)           RELEASED FILE COUNT
         SR    R1,R1
         IC    R1,0(,R2)           INCR IN NEW FILE COUNT'S FIRST BYTE
         L     R6,PPISTDCB
         L     R6,0(R1,R6)         IOB ADDR
         L     R5,DCBIOBAD         OF NEW FILE
         L     R1,KSAVEB           RESTORE BLOCK CNT
         B     RGDAL025
*
RGDEX050 LR    R2,R4               ADDR OF LOWEST FILE COUNT
         B     RGDINST1
*
RGDRL060 LR    R0,R4
         B     RGDLPEND            ADDR OF RELEASED FILE COUNT
*
*        ERROR CHECK OF BUFFER READ HAS COMPLETED
*
RGDEE100 TM    IOBUSTAT,UE+UC      UNIT EXCEPTION OR UNIT CHECK ?
         BNZ   RGDEOF              YES, BRANCH
         TM    IOBCSTAT,IL+CDC     INCORRECT LEN OR CHANNEL DATA CHK ?
         BNZ   RGDERROR            YES, BRANCH
RGDEE110 LH    R1,PPISRTBL
         L     R4,IOBSTART
RGDBRVR  NOP   RGDVAR              VAR LENGTH RCDS - SET BRANCH,
*                                  FOR ALL BLOCKS MAY BE SHORT
         L     R0,KBLKCHR
RGDEE120 L     R4,0(,R4)           STARTING BUFFER ADDR FOR DEBLKING
         LA    R2,1(,R4)
         SR    R2,R0
         ST    R2,KSAVE
         MVI   KSAVE,X'00'
         ST    R4,KSAVE+8          STARTING BUFFER ADDR FOR READING
         BR    R7                  BACKWARDS
*
*        END OF FILE
*
RGDEOF   TM    IOBUSTAT,UE         END OF FILE ?
         BO    RGDEOF1             YES, BRANCH
         TM    IOBSENS1,IOBS1B4    AT LOAD POINT ?
         BZ    RGDERROR            NO, BRANCH
         L     R4,IOBSTART         YES
RGDTWO   L     R2,PPILAB02         UPDATE AVAILABLE LIST
         SH    R2,KFOUR
         MVC   1(3,R2),1(R4)       PLACE BUFFER (ON EOF) ADDR ON LIST
         ST    R2,PPILAB02
         LH    R2,KCOUNT
         LA    R2,1(,R2)           ADD ONE TO LIST'S COUNT
         STH   R2,KCOUNT
         CLI   DCBBUFNO,2          TWO BUFFERS ?
         BNE   RGDONE              NO, BRANCH
         MVI   DCBBUFNO,1
         L     R4,IOBECBPT
         L     R4,4(,R4)
         B     RGDTWO
*
RGDONE   LH    R0,KNNINE
         STC   R3,RGDINST+1
         BAS   R7,RGDFLUP          UPDATE FILE COUNT TO 32,768
         SR    R0,R0
         IC    R0,RGDK2M+1         GET  2*M
         SH    R0,KTWO             REDUCE MERGE ORDER
         STC   R0,RGDK2M+1
RGDONE1  OI    DCBOFLGS,DCBOFLRB   LAST I/O OP WAS READ BACKWARD
*
         CLOSE ((R6))              CLOSE THE INPUT FILE
*
         LTR   R15,R15             CLOSE SUCCESSFULL ?
         BZ    RGDONE2
*
         DC    H'0'                CLOSE FAILED, FORCE 0C1 ABEND
*                                  FOR DIAGNOSTIC PURPOSES
RGDONE2  L     R11,PPINET+4
         B     4(,R11)
*
RGDEOF1  MVI   RGDONE1+1,X'44'     TURN ON BIT INDIC TAPE
         B     RGDEOF+16           MARK READ
*
*        READ ERROR HAS OCCURRED
*
RGDERROR PPISETON PPIREADE         TURN ON PPI ERROR BIT
RGDTERM  NOP   RGDSSCBR
         L     R1,IOBDCBPT         DCB ADDR
         ST    R5,PPIWKARE         SET IOB ADDR WITH
         MVI   PPIWKARE,X'10'      INCREMENT TO CCW ADDR IN
         L     R0,PPIWKARE         THE HIGH ORDER BYTE
*
*        CALL E38
*
*        TERMINATION RTN WILL MAKE SYNAD ERROR MSG CODE THE ABEND CODE
*
         L     R15,AE38
         BASR  R14,R15
RGDSSCBR L     R15,PPIADSSC        R15 -> SORT SYSTEM CNTL VECTOR TABLE
         BAS   R14,16(,R15)        NO RETURN
*
RGDSKIP  OI    IOBFLAG1,IOBCMDCH   SET COMMAND CHAINING ON
         NI    IOBCSTAT,255-IL-CDC     RESET I/O ERROR FLAGS
         NI    DCBIFLGS,255-DCBIFPEC
*
RGDACCPT IEREXCP  (R5)             READ NEXT BLOCK INTO SAME BUFF AREA
*
         L     R1,IOBECBPT
*
         IERWAIT 1,ECB=(1)
*
RGDBR    B     RGDEE100
*
RGDVAR   LH    R1,PPILAB03+2
         SH    R1,IOBCSW+5         SUBTRACT RESIDUAL CSW LENGTH
         LR    R0,R1               SORT BLK MINUS REMAINING COUNT
         SH    R1,KFOUR
         B     RGDEE120            IN THE CCW = BLOCK CHAR COUNT
*
KMRGMX   DC    H'0'
KSAVE    DC    6F'0'               REGISTER SAVE AREA
KSAVEB   DC    F'0'
KTWO     DC    H'2'
KFOUR    DC    H'4'                CONSTANT
KNNINE   DC    X'7FFF'
KTOTAL   DC    X'00'               NO OF INPUT BUFFERS PRESENTLY ATTCH
         DC    X'00'
KCOUNT   DC    AL2(1)              AVAILABLE LIST COUNT
KBLKCHR  DC    A(0)                SORT BLOCK CHAR CNT (F AND V)
*
TFCNT    DC    16F'0'              FILE COUNT TABLE
*
*        EXTERNS
*
AE38     DC    A(0)                USER ERROR SYNAD RTN
*
./ ADD NAME=IERRGE   0101-20211-20211-1200-00097-00097-00000-RELEASE 00
RGE      TITLE 'IERRGE - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRGE
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 3 READ ROUTINE - DISK
*        THIS MODULE HANDLES DISK INPUT TO FINAL MERGE PHASE VIA
*        THE EXCP MACRO. IT INTERFACES WITH IOS, THE MERGE
*        NETWORK, AND THE DEBLOCK MODULE. IF EXIT 38 IS ACTIVATED
*        BY THE USER, THE READ ROUTINE (ON A READ ERROR) ALLOWS
*        THE USER TO TRY TO CORRECT THE READ ERROR AFTER IOS HAS
*        TRIED TO DO SO. IF THERE IS A PERMANENT READ ERROR
*        CONTROL IS PASSED TO SORT SYSTEM CONTROL TO TERMINATE
*        THE JOB.
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - IERAGE
*
*        MACROS USED -
*        SMPPI   EXCP   WAIT   CLOSE
*
*        ENTRY POINTS - ENTRY FROM DEBLOCK
*                       CALLING SEQUENCE -
*                         L  R11,PPIRD+4
*                         B  4(,R11)
*
*        INPUT PPI FIELDS REFERENCED -
*        PPIADSSC   PPISBLCT
*        PPILAB02   PPISRTBL
*        PPILAB03   PPISTIOB
*        PPIPSVA    PPICNTL
*        PPIRCDL2   PPIWKARE
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPILAB02   PPIPSVA
*        PPIRCDL2   PPISRTBL
*        PPIWKARE
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS NORMAL - DEBLOCK
*                       L   R11,PPIDEB+4
*                       BR  R11
*
*                     - MERGE NETWORK
*                       L   R11,PPINET+4
*                       B   15,4(,R11)
*
*        EXITS - ERROR - USER EXIT 38 IF PRESENT
*                        ON A READ ERROR
*                        L    R15,AE38
*                        BALR R14,R15
*
*        TABLES/WORK AREAS -
*        FILE COUNT TABLE
*
*        NOTES -
*        THIS IS FOR DISK ONLY
*
IERRGE   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRGE SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRGEI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
*        IERCCWEQ
*
         IERCCWEQ
*
*        IERIOB
*
         IERIOB
*
         PRINT NOGEN
*
         DCBD  DSORG=PS,DEVD=(DA,TA)
*
         IHAECB DSECT=NO,EXT=NO
*
         IEZDEB LIST=NO
*
         PRINT GEN
*
         SMPPI
*
         END
./ ADD NAME=IERRGEI  0101-20211-20211-1200-00350-00350-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERRGE SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERRGEI
*
         USING *,R11
         USING IERRCA,R13
         USING IOBSTDRD,R5
*
IERDGB3  NOP   IERDGB3             +00 DUMMY ENTRY (USED TO STORE
*                                      BUFFER ADDR PASSED TO RGE)
         STM   R2,R6,KSAVE         +04 DEBLOCK ENTRY
         ST    R2,IERDGB3
         L     R5,PPISTIOB         ADDR OF IOB TABLE
         L     R5,0(R3,R5)         IOB ADDR VIA INCR AND TABLE ADDR
RGEEOSCK CLI   1(R2),C'G'          END OF SEQUENCE BLOCK ? (HGHH)
         BE    RGEEOS              YES, BRANCH
         L     R1,IOBECBPT         NO OF BUFFERS ATTACHED
         TM    4(R1),X'02'         TO THIS FILE(IOB) = 2 ?
         BO    RGEAL020            YES, FILE HAS AN ALTERNATE BUFFER
*
*        FILE ONLY HAS ONE BUFFER ATTACHED TO THE IOB
*
         IEREXCP  (R5)             READ DISK
*
         L     R1,IOBECBPT
*
         IERWAIT  1,ECB=(1)        WAIT ON I/O COMPLETION
*
         BAS   R6,RGEER100         ERROR CHECK RTN
         LH    R2,KCOUNT           AVAILABLE BUFFER ON
         BCT   R2,RGEBF010         LIST TO ATTACH TO FILE
RGERTRN  LM    R2,R6,KSAVE
         L     R11,PPIDEB+4
RGERTRNV LA    R2,4(,R2)           FIX - BYPASS EOS INDICATOR
*                                  VAR - BYPASS EOS INDICATOR AND BCC
         BR    R11                 RETURN TO DEBLOCK
*
*        ATTACH AN ALTERNATE BUFFER TO THE FILE (BUFFER FREED BY
*        AN EOS-EOA ON ANOTHER FILE
*
RGEBF010 CLI   1(R4),C'G'          PREVIOUS BUFFER EOS ?
         BE    RGERTRN             YES, DON'T ATTACH TO THIS FILE
         STH   R2,KCOUNT
         L     R2,PPILAB02         OBTAIN BUFFER FROM LIST
         BAS   R6,RGEIOBUP         UPDATE IOB ATTACH THE BUFFER
         LA    R2,4(,R2)           UPDATE
         ST    R2,PPILAB02         THE LIST
         IC    R2,KTOTAL           AND KTOTAL
         LA    R2,1(,R2)
         STC   R2,KTOTAL
         STC   R3,RGEINST+1
         LH    R0,PPISRTBL
         LA    R6,RGERTRN
RGEFLUP  LA    R2,TFCNT            FIND FILE COUNT IN ORDER TO
RGEINST  CLI   0(R2),X'00'         UPDATE IT
         BE    RGEBF015            THIS IS FILE
         LA    R2,4(,R2)
         B     RGEINST             TRY AGAIN
*
RGEBF015 L     R4,0(,R2)           ADD SORT BLOCKING
         AR    R4,R0               OR 32,768 (FOR EOA/EOS)
         ST    R4,0(,R2)
         BR    R6                  TO FILE COUNT
*
*        FILE HAS AN ALTERNATE BUFFER ATTACHED TO THE IOB
*
RGEAL020 L     R1,IOBECBPT
*
         IERWAIT  1,ECB=(1)        WAIT ON ALTERNATE
*
         BAS   R6,RGEER100         ERROR CHECK RTN
*
*        FULL OVERLAP TEST
*        1. FOR 2M AREAS, ATTACH BUFFER TO SAME FILE (FULL OVERLAP)
*        2. FOR PARTIAL OVERLAP, ATTACH BUFFER TO FILE WITH
*           LEAST NO OF RECORDS LEFT IN ITS BUFFER(S)
*
RGEK2M   CLI   KTOTAL,X'00'
         BL    RGEFL030            PARTIAL OVERLAP - SCAN
RGEAL025 LA    R2,IERDGB3          ATTACH THE BUFFER TO THE
         LA    R6,RGERTRN          SAME FILE
         CLI   1(R4),C'G'          PREVIOUS BUFFER EOS ? (HGHH)
         BER   R6                  YES, NO START NEW READ ON THIS FILE
RGEIOBUP L     R4,IOBSTART         ATTACH THE ALTERNATE BUFFER TO
         L     R15,IOBECBPT
         MVC   IOBSTRTB,5(R15)     THE IOB VIA THE CCW LIST
         ST    R4,4(,R15)
         L     R4,IOBSTART
         MVC   17(3,R4),1(R2)      STORE BUFFER ADDR IN THE READ CCW
         MVI   4(R15),X'02'        UPDATE NO OF BUFFERS ATTACHED
         LR    R4,R1               SAVE BLOCK COUNT ON COMPLETED READ
*
         IEREXCP  (R5)             READ
*
         LR    R1,R4               RESTORE BLOCK COUNT FOR DEBLOCK
         BR    R6                  RETURN TO MAINLINE
*
*        PARTIAL OVERLAP
*        SCAN FILE COUNTERS TO DETERMINE WHICH FILE TO ATTACH
*        ALTERNATE BUFFER TO FOR THE NEXT READ
*
RGEFL030 LA    R2,TFCNT            FILE COUNT TABLE ADDR
         ST    R1,KSAVEB           SAVE BLOCK CNT FOR DEBLOCK
         L     R1,PPISBLCT
         LH    R6,KMRGMX
         LA    R4,PPIPSVA
         SR    R14,R14
         ST    R14,0(R3,R1)        SET RELEASED FILE'S BLCNT = 0
RGEFL040 IC    R14,0(,R2)          OBTAIN DEBLOCK'S BLOCK COUNTERS
         L     R15,0(R14,R1)
         A     R15,0(,R2)          AND ADD THEM TO READ'S APPROPRIATE
         ST    R15,0(,R4)
         LA    R2,4(,R2)           FILE COUNTERS
         LA    R4,4(,R4)
         BCT   R6,RGEFL040         REDUCE CNT & CONT
         LA    R2,PPIPSVA
         LH    R1,KMRGMX
         STC   R3,RGEINST1+1
         LR    R4,R2
         B     RGEINST1            START SCAN
*
RGEFL050 LA    R4,4(,R4)           SCAN FOR LOWEST FILE COUNT
         CLC   1(3,R2),1(R4)
         BH    RGEEX060            AND FOR THE RELEASED
RGEINST1 CLI   0(R4),X'00'
         BE    RGERL070            FILE COUNT
RGELPEND BCT   R1,RGEFL050         REDUCE CNT & CONT
         LA    R0,PPIPSVA          OBTAIN FILE COUNT ADDR VIA
         SR    R2,R0               DISPLACEMENTS OF LOWEST AND
         SR    R15,R0              RELEASED FROM PPIPSVA
         LA    R0,TFCNT
         AR    R15,R0
         AR    R2,R0
         L     R4,IOBECBPT         RELEASED FILE'S NO OF BUFFERS
         MVI   4(R4),X'01'         ATTACHED TO IOB
         LR    R14,R5
         IC    R1,0(,R2)           INCR IN NEW FILE COUNT'S FIRST BYTE
         L     R5,PPISTIOB
         L     R5,0(R1,R5)         IOB ADDR OF NEW FILE
         L     R4,IOBSTART
         L     R4,16(,R4)
         L     R1,KSAVEB           RESTORE BLOCK CNT
RGEFBV   CLI   1(R4),C'G'          EOS ?  (HGHH)
         BNE   RGECONT             NOT EOS, BRANCH
         LR    R5,R14
         L     R4,IOBECBPT         RESTORE NO
         MVI   4(R4),X'02'         BUFFERS ATTACHED
         L     R4,IOBSTART         TO FILE
         L     R4,16(,R4)
         B     RGEAL025            GO ISSUE READ
*
RGECONT  L     R6,0(,R2)           UPDATE
         AH    R6,PPISRTBL
         ST    R6,0(,R2)           NEW FILE COUNT
         L     R6,0(,R15)
         SH    R6,PPISRTBL
         ST    R6,0(,R15)          RELEASED FILE COUNT
         B     RGEAL025            GO ISSUE READ
*
RGEEX060 LR    R2,R4               ADDR OF LOWEST FILE COUNT IN PPI
         B     RGEINST1            SAVE AREA
*
RGERL070 LR    R15,R4              ADDR OF RELEASED FILE COUNT IN PPI
         B     RGELPEND            SAVE AREA
*
*        END OF SEQUENCE
*        MAKE BUFFER(S) ATTACHED TO THIS FILE'S IOB AVAILABLE
*
RGEEOS   L     R4,IOBSTART
         L     R2,PPILAB02         UPDATE THE AVAILABLE LIST BY 1 OR 2
         LH    R14,KCOUNT
RGEEOSA  SH    R2,KFOUR            BUFFERS
         MVC   1(3,R2),17(R4)      PLACE BUFFER ADDR ON LIST
         LA    R14,1(,R14)         ADD ONE TO LIST'S COUNT
         L     R15,IOBECBPT
         CLI   4(R15),X'02'        CK NO OF BUFFERS ATTACHED TO FILE'S
         BNE   RGEDONE             IOB
         MVI   4(R15),X'01'        SET NO TO 1 TO FALL THROUGH ABOVE
         L     R4,4(,R15)          TEST THE NEXT TIME
         B     RGEEOSA             IF 2 BUFFERS DO NEXT
*
RGEDONE  STH   R14,KCOUNT          SAVE LIST COUNT
         ST    R2,PPILAB02         AND POINTER
         LH    R0,KNNINE
         STC   R3,RGEINST+1        UPDATE FILE COUNT
         BAS   R6,RGEFLUP          TO 32,768
         SR    R0,R0
         IC    R0,RGEK2M+1         GET  2*M
         SH    R0,KTWO             REDUCE MERGE ORDER
         STC   R0,RGEK2M+1
         L     R11,PPINET+4
         B     4(,R11)             EXIT TO NETWORK
*
*        ERROR CHECK OF BUFFER READ HAS COMPLETED
*
RGEER100 L     R1,IOBECBPT
         CLI   0(R1),ECBNORM       SUCCESSFULLY COMPLETED W/O ERROR ?
         BNE   RGERESET            NO, CHECK FOR PURGE
RGEER110 L     R4,IOBSTART         R4 -> READ DATA CCW ADDR
         L     R4,16(,R4)          R4 -> I/O BUFFER ADDR
RGEVBCC  LH    R1,PPILAB03+2       FOR VAR - LH R1,0(,R4)
         SH    R1,KFOUR            IE LOAD BCC FROM BUFFER
         NOP   RGEVAR
         SH    R1,IOBCSW+5         SUBTRACT CSW RESIDUAL COUNT
         SR    R14,R14             IF FIXED RECORD FORMAT
RGEFIX   SH    R1,PPIRCDL2
         LA    R14,1(,R14)
         CH    R1,PPIRCDL2
         BNL   RGEFIX              NOT DONE
         LR    R1,R14
RGEVAR   ST    R4,KSAVE            STARTING
         ST    R4,KSAVE+8          BUFFER ADDR
         MVI   KSAVE,X'00'
*
*        UPDATE THE DISK ADDR FOR NEXT TIME THROUGH - MBBCCHHR
*
RGETRKNO CLC   IOBR,PPIBPTRK+1     TRACK FULL ?
         BE    RGEUPH              YES, BRANCH TO UPDATE HEAD
         IC    R15,IOBR            NO, UPDATE RECORD COUNT
         LA    R15,1(,R15)         UPDATE RECORD NO BY ONE
         STC   R15,IOBR            STORE UPDATED RECORD COUNT
         BR    R6                  RETURN TO MAINLINE
*
RGEUPH   MVI   IOBR,X'01'          SET RECORD NO TO 1 ON NEXT TRACK
*
*        LOCATE THE DCB
*
         L     R15,IOBDCBPT        R15 -> DCB
         USING IHADCB,R15
*
*        SETUP FOR EXCP
*        CONVERT MBBCCHHR -> TTR
*
         STM   R14,12,12(R13)      SAVE REGS ACROSS RTN
         LR    R3,R13              SAVE R13
         L     R1,DCBDEBAD         R1 -> DEB
         LA    R2,IOBSEEK          R2 -> MBBCCHHR
         L     R15,PPIPRLTV        R15 -> CONVERSION RTN
         BASR  R14,R15             CONVERT MBBCCHHR -> TTR
         LR    R13,R3              RESTORE R13
         LTR   R15,R15          *  SET CC
         LM    R14,R15,12(R13)  |  RESTORE REGS, DO NOT RESTORE R0
         LM    R1,R12,24(R13)   |
         BNZ   RGESSCBR         V  CONVERSION FAILED, TERMINATE SORT
*
*        INCR TT
*
         AL    R0,ADDTRK           INCR TT ONLY IN TTRN
*
*        SETUP FOR EXCP
*        CONVERT TTR -> MBBCCHHR
*
         STM   R14,12,12(R13)      SAVE REGS ACROSS RTN
         LR    R3,R13              SAVE R13
         L     R1,DCBDEBAD         R1 -> DEB
         LA    R2,DCBFDAD          R2 -> MBBCCHHR RESULT
         L     R15,PPIPCNVT        R15 -> CONVERSION RTN
         BASR  R14,R15             CONVERT TTR -> MBBCCHHR
         LR    R13,R3
         LTR   R15,R15          *  SET CC
         LM    R14,R12,12(R13)  |  RESTORE REGS
         BNZ   RGESSCBR         V  CONVERSION FAILED, TERMINATE SORT
         MVC   IOBSEEK,DCBFDAD     MOVE UPDATED SEARCH ADDR TO IOB
         BR    R6                  RETURN TO MAINLINE
*
         DROP  R15
*
RGERESET CLI   0(R1),ECBREPRG      I/O REQUEST PURGED ?
         BNE   RGEERROR            NO, ERROR CONDITION
*
*        REQUEST PURGED DUE TO I/O ERROR ON OTHER READ
*        RESTORE REQUEST QUEUE
*
         L     R1,IOBDCBPT
         USING IHADCB,R1
         NI    DCBIFLGS,255-DCBIFPEC  RESET I/O ERROR FLAGS
         OI    IOBFLAG1,IOBCMDCH   SET COMMAND CHAINING ON
         L     R1,DCBDEBAD         R1 -> DEB
         USING DEBBASIC,R1
         LA    R1,DEBUSRPG         POINT TO FIRST PURGED IOB ADDR
         DROP  R1
         IERESTOR (1)              RESTORE SVC
*
         B     RGWAIT              GOTO WAIT
*
*        READ ERROR HAS OCCURRED
*        CHECK TO SEE IF USER EXIT E38 WAS ACTIVATED
*
RGEERROR PPISETON PPIREADE         TURN ON ERROR BIT IN PPI
RGETERM  NOP   RGESSCBR
         L     R1,IOBDCBPT         DCB ADDR
         ST    R5,PPIWKARE         SET IOB ADDR WITH
         MVI   PPIWKARE,X'10'      INCREMENT TO CCW ADDR IN
         L     R0,PPIWKARE         THE HIGH ORDER BYTE
*                                  LINK TO USER IS OVERLAYED IF NOT
*        CALL  E38                 ACTIVATED
*
         L     R15,AE38
         BASR  R14,R15
RGESSCBR L     R10,IOBDCBPT        R10 -> DCB
         L     R15,PPIADSSC        TERMINATE OPTION
         BAS   R14,16(,R15)        NO RETURN
*
RGESKIP  NI    IOBUSTAT,255-UC-UE  ERROR ACCEPTED
         NI    IOBCSTAT,255-IL-CDC
         L     R1,IOBDCBPT         RESET ALL ERROR BITS SET BY IOS
         USING IHADCB,R1           IN THE IOB AND DCB
         NI    DCBIFLGS,255-DCBIFPEC
         L     R1,DCBDEBAD         R1 -> DEB
         USING DEBBASIC,R1
         LA    R1,DEBUSRPG         POINT TO FIRST PURGED IOB ADDR
         DROP  R1
*
         IERESTOR (1)              RESTORE SVC
*
         OI    IOBFLAG1,IOBCMDCH   SET COMMAND CHAINING ON
RGEACCPT L     R2,IOBSTART
         L     R2,16(,R2)
RGEACCV  CLI   1(R2),C'G'          EOS ? (HGHH)
         BE    RGEEOS              YES EOS, BRANCH
         BAS   R6,RGETRKNO         GO UPDATE DASD ADDR
*
         IEREXCP  (R5)             READ NEXT BLOCK INTO
*
RGWAIT   L     R1,IOBECBPT
*
         IERWAIT 1,ECB=(1)
*
         B     RGEER100            CHECK FOR ERROR
RGEBR    B     RGEER110            CONTINUE
*
KSAVE    DC    5F'0'               SAVE AREA
KSAVEB   DC    F'0'                BLOCK CNT
ADDTRK   DC    X'00010000'         ADD 1 TO TTRN
KCOUNT   DC    H'1'                NO AVAIL
KTOTAL   DC    X'0000'             TOTAL NO
KTWO     DC    H'2'
KFOUR    DC    H'4'                FOUR
KMRGMX   DC    H'0'                MAX MRG OR
KNNINE   DC    H'32767'            MAX VAL HW
*
TFCNT    DC    16F'0'              FILE COUNT TABLE
*
AE38     DC    A(0)                USER ERROR ROUTINE SET BY IERAGE
*
./ ADD NAME=IERRGF   0101-20211-20211-1200-00083-00083-00000-RELEASE 00
RGF      TITLE 'IERRGF - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRGF
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 3 (MERGE ONLY) MODULE
*        THE FUNCTION OF THIS MODULE IS TO CLOSE THE INPUT FILES
*        AS THEY REACH END OF FILE. THIS MODULE IS ENTERED FROM
*        QSAM GET ON EOF. AFTER CLOSING THE INPUT FILE THIS
*        ROUTINE WILL BRANCH TO THE MERGE CUTBACK ROUTINE IF EOF
*        OCCURS AT RUNNING TIME, OR WILL BRANCH TO DEBLOCK
*        ASSIGNMENT ROUTINE IF ASSIGNMENT TIME
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - NONE
*
*        MACROS USED BY MODULE -
*        SMPPI
*        CLOSE
*
*        ENTRY POINTS - ENTRY FROM QSAM GET
*                       CALLING SEQUENCE -
*                           L    R15,DCBEODAD
*                           BR   R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPICNTL   PPIPSVA   PPINET
*        ADDR OF DEBLOCK AP, ADDR OF MERGE NETWORK
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED - NONE
*
*        EXTERNAL ROUTINES - NONE
*
*        EXTERNAL PARAMETERS - SEE REGISTERS
*
*        EXITS - NORMAL - EXIT TO CLOSE
*                         CALLING SEQUENCE -
*                             CLOSE (R5)      R5=DCB ADDR
*
*                       - EXIT TO MERGE NETWORK
*                         CALLING SEQUENCE -
*                             L    R11,PPINET+4
*                             B    4(,R11)    CUTBACK RUN TIME
*
*                         EXIT TO IERADJ
*                         CALLING SEQUENCE -
*                             L    R15,PPIPSVA
*                             BR   R15        CUTBACK ASSGNMT TIME
*
*        EXITS - ERROR - NONE
*
*        TABLES/WORK AREAS - NONE
*
*        NOTES -
*        THIS MODULE WILL EXECUTE FOR ANY MERGE ONLY
*
IERRGF   CSECT
*
         BASR  11,0                SET BASE REGISTER
*
         USING *,R11
         USING IERRCA,R13
*
         LR    R2,R5               DCB PASS REG
*
         CLOSE ((R5))              CLOSE AN INPUT FILE
*
         PPITEST  PPIPEOF          TEST FOR ASSIGNMENT
         BZ    RGFPHAGN            GOTO ASSIGN RETURN
         L     R11,PPINET+4        ADDR OF MERGE NETWORK
         B     4(,R11)             BRANCH TO MERGE NETWORK
*
RGFPHAGN L     R15,PPIPSVA         ADDR OF DEBLOCK AP
         BR    R15                 GOTO ASSIGNMENT
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERRGL   0101-20211-20211-1200-00150-00150-00000-RELEASE 00
RGL      TITLE 'IERRGL - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRGL
*
*        MODULE FUNCTION/OPERATION - PHASE 2 RUNNING MODULE READ
*        FORWARD THE FUNCTION OF THIS MODULE IS TO READ FORWARD
*        ON THE INTERMEDIATE DATA SETS USING THE EXCP MACRO. IF
*        USER EXIT E28 SYNAD IS ACTIVATED THIS MODULE WILL BRANCH
*        TO IT ON ANY READ ERROR. THE PREVIOUSLY DEFINED ERROR
*        OPTION CODES TO HANDLE THE READ ERROR ARE -
*        20 - TERMINATE THE JOB
*        40 - SKIP THE PHYSICAL RECORD
*        80 - ACCEPT THE PHYSICAL RECORD
*        IF THE EXIT WAS NOT ACTIVATED THE SORT WILL TERMINATE
*        ON A READ ERROR
*
*        INITIALLY THIS MODULE PRIMES THE PRIMARY INPUT BUFFERS
*        AND STARTS THE READS ON ANY ALTERNATE BUFFERS. WHEN
*        DEBLOCK COMES TO IERRGL FOR A FULL BUFFER IERRGL
*        DETERMINES WHETHER THERE IS FULL OR PARTIAL OR NO
*        OVERLAP AND ISSUES THE NECESSARY READS & WAITS BEFORE
*        RETURNING TO DEBLOCK WITH A FULL BUFFER
*
*        THERE ARE BASICALLY 5 ROUTINES WITHIN THIS MODULE -
*        1 - RUNNING
*        2 - PRIMING
*        3 - OVERLAP
*        4 - ERROR CHECK
*        5 - END OF FILE
*        ON END OF FILE THIS MODULE BRANCHES TO THE MERGE
*        ALGORITHM TO DECREMENT THE MERGE ORDER BEFORE RETURNING
*        TO DEBLOCK
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - IERAGL
*
*        MACROS USED BY MODULE -
*        SMPPI   EXCP
*        WAIT    CLOSE
*
*        ENTRY POINTS - ENTRY FROM ALGORITHM
*                       CALLING SEQUENCE -
*                           L    R11,PPIRD+4
*                           B    4(,R11)    PRIME TIME
*                           BR   R14        EOF-PRIME TIME
*
*                     - ENTRY FROM DEBLOCK
*                       CALLING SEQUENCE -
*                           L    R11,PPIRD+4
*                           B    8(,R11)    RUN TIME
*
*                     - ENTRY FROM EXIT E28 SYNAD
*                       CALLING SEQUENCE -
*                           BR   R14        ERROR CHECK TIME
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIALG     PPIDEB2
*        PPILAB03   PPISRTBL
*        PPIADSSC   PPIBLK2
*        PPIRCDL2   PPIMRGMX
*        PPINETM    PPISTDCB
*        PPIBDSVA   PPISBLCT
*        VARIOUS LINKAGE ADDR, AND INFO FOR CALCULATIONS
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPIWKARE   PPIPSVA
*        PPICNTL
*        WORK AREAS AND TABLES, SET READ ERROR BIT IN PPCNTL
*        EXTERNAL ROUTINES - NONE
*
*        EXTERNAL PARAMETERS - SEE REGISTERS
*
*        EXITS - NORMAL - EXIT TO ALGORITHM
*                         CALLING SEQUENCE -
*                             L    R11,PPIALG+4
*                             BAL  R14,12(,R11)  EOF-PRIME TIME
*
*                       - EXIT TO SSC
*                         CALLING SEQUENCE -
*                             L    R15,PPIADSSC
*                             B    16(,R15)
*
*                       - EXIT TO NETWORK
*                         CALLING SEQUENCE -
*                             L    R11,PPINETM+4
*                             B    4(,R11)       END INPUT SEQUENCE
*
*                       - EXIT TO BUFFER TABLE RTN
*                         CALLING SEQUENCE -
*                             L    R11,PPIDEB2+4
*                             BR   R11           PRIME TIME
*
*                       - EXIT TO DEBLOCK
*                         CALLING SEQUENCE -
*                             L    R11,PPIBLK2+4
*                             B    4(,R11)       RUN TIME
*
*        EXITS - ERROR - EXIT TO E28 SYNAD
*                        CALLING SEQUENCE-
*                            L    R15,ADCONE28
*                            BALR R14,R15        ERROR CHECK TIME
*
*        TABLES/WORK AREAS -
*        WSAVE    - REGISTER SAVE AREA ON EVERY INPUT EOF
*        WSAVEB   - BLOCK COUNT OF BUFFER JUST FILLED
*        TINCR    - TABLE OF INPUT EOF INCREMENTS AT PRIME TIME
*        TFCNT    - TABLE OF INPUT FILE COUNTERS
*        WSENSE0  - SENSE BYTE 0 ON UNIT CHECK
*        PPIWKARE - TABLE OF INPUT RCD ADDR AT PRIME TIME
*
*        NOTES -
*        THIS MODULE WILL EXECUTE FOR ANY BALANCED TAPE SORT
*        INVOLVING A READ FORWARD EXECUTION TO SAVE A COPY PASS
*
IERRGL   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRGL SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRGLI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
*        IERCCWEQ
*
         IERCCWEQ
*
*        IERIOB
*
         IERIOB
*
         PRINT NOGEN
*
         DCBD  DSORG=PS,DEVD=(DA,TA)
*
         IHAECB DSECT=NO,EXT=NO
*
         IEZDEB LIST=NO
*
         PRINT GEN
*
         SMPPI
*
         END
./ ADD NAME=IERRGLI  0101-20211-20211-1200-00489-00489-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERRGL SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERRGLI
*
         USING *,R11               THIS MODULE BASE REGISTER
         USING IERRCA,R13          PPI BASE REG (DSECT)
         USING IOBSTDRD,R5         IOB BASE REG (DSECT)
         USING IHADCB,R6           DCB BASE REG (DSECT)
*
IERDGB2D NOP   IERDGB2D            +00 DUMMY ENTRY
         B     RGBPR200            +04 ENTRY FROM ALG - PRIME TIME
*
*        ENTRY FROM DEBLOCK DURING RUN TIME
*        R2 -> EMPTY INPUT BLOCK
*        R3  = INCREMENT OF THE INPUT UNIT
*
         STM   R2,R7,KSAVE         +08 SAVE REGS
         ST    R2,IERDGB2D         ALSO SAVE R2 SEPARATELY
RGBCKEOS CLI   2(R2),C'G'          AN EOS BFR ? AP WILL OVERLAY
*                                  THE 2 W/6 FOR VAR LEN BUFFER
         BNE   RGBST010            NOT EOS BUFFER, BRANCH
*
*        INTERFACE TO MERGE NETWORK ON END OF SEQUENCE FOR THIS
*        UNIT
*
RGBRTEOS L     R11,PPINETM+4
         B     4(,R11)             BRANCH TO MERGE ON AN INPUT EOS
*
*        THERE IS NO EOS ON THIS FILE
*        IF THERE IS NO ALTERNATE BUFFER ISSUE A READ ON THIS
*        FILE (TO FILL THE EMPTY BFR) AND A WAIT OTHERWISE ISSUE
*        A WAIT ON THE ALTERNATE BUFFER
*
RGBST010 L     R6,PPISTDCB         PTR TO INPUT DCB ADDR TABLE
         L     R6,0(R3,R6)         THIS FILE'S DCB ADDR
         L     R5,DCBIOBAD         THIS DCB'S IOB ADDR
         TM    DCBBUFNO,2          2 BUFFERS FOR THIS FILE ?
         BO    RGBAL020            YES, BRANCH TO WAIT ON THE ACT BFR
*
         IEREXCP  (R5)             READ FOREWARD
*
         BAS   R4,RGBEOSCK         CALL WAIT & CHECK IF EOS BUFFER
*
*        AT THIS POINT -
*        R1 = NO OF RECORDS IN THE BUFFER (FIXED LENGTH) OR
*        R1 = BCC MINUS 4 EOS BYTES (VARIABLE LENGTH)
*        IT INCLUDES THE 4 RDW BYTES FOR VARIABLE LENGTH WHICH
*        BLOCK WILL SUBTRACT
*
RGBRTRN  LM    R2,R7,KSAVE         R2 = STARTING ADDR OF THE
*                                       FILLED BUFFER
*
*        INTERFACE TO DEBLOCK
*        THE REGISTERS WILL CONTAIN -
*        R1  - BLOCK COUNT
*        R2 -> FIRST RECORD (LO CORE) IN THE BLOCK
*        R3  - FILE INCR
*        R4  - STARTING ADDR OF THE BLOCK
*
RGBRTRNV LA    R2,4(,R2)           R2 -> FIRST RECORD IN BUFFER AP
*                                  WILL OVERLAY 4 W/8 TO BYPASS THE 4
*                                   BYTES FOR THE BCC IN ADDTN TO EOS
         L     R11,PPIBLK2+4       ADDR OF BLOCK/DEBLOCK
         B     4(,R11)             GOTO BLOCK/DEBLOCK RTN
*
*        ISSUE A WAIT ON THE BUFFER
*
RGBEOSCK L     R1,IOBECBPT         ADDR OF IOB ECB
*
         IERWAIT 1,ECB=(1)         WAIT ON I/O COMPLETION
*
         BAS   R7,RGBEE100         CALL EOF/ERROR CHECK RTN
RGBEOSV  CLI   2(R2),C'G'          BUFFER EOS ? (HGHH)
         BNER  R4                  NO, TO DEBLOCK (NO ALT BFRS) OR
*                                  TO ALT BFR RTN
RGBEOS   MVI   KSAVE+8,C'$'        SET EOS BYTE ON IN HI ORDER BYTE OF
*                                  BUFFER ADDR FOR NXT RE ON THIS FILE
         B     RGBRTRN             RESTORE REGS THEN GOTO DEBLOCK
*
RGBAL020 BAS   R4,RGBEOSCK         WAIT ON FILE CHECK FOR EOS
RGBRFBF  NOP   RGBFL040            AP WILL SET THIS NOP TO A BR IF
*                                  HAVE PARTIAL OVLAP (FLOATING BFRS)
*
*        ATTACH EMPTY BUFFER FROM DEBLOCK TO THE FILE VIA THE IOB
*        START PTR AND DATA ADDR IN THE CCW
*
RGBAL030 LA    R2,IERDGB2D         ADDR OF THE BUFFER
         LA    R7,RGBRTRN          RETURN ADDR
         B     RGBIOBUP            BRANCH TO ISSUE READ ON BUFFER
*
*        ERROR CHECKING ROUTINE
*
RGBEE100 TM    IOBUSTAT,UE         UNIT EXCEPTION OR EOF TM ?
         BO    RGBEOF              YES, BRANCH TO EOF ROUTINE
         TM    IOBUSTAT,UC         UNIT CHECK ?
         BZ    RGBPRMSK            NO, BRANCH TO CHECK CHANNEL ERROR
         MVC   WSENSE0,IOBSENS0    SAVE SENSE BYTE, GOT DEVICE ERROR
         B     RGBERROR            BRANCH TO ERROR RTN
*
RGBPRMSK TM    IOBCSTAT,CDC        CHANNEL DATA CHECK ?
         BO    RGSTORRF            YES, BRANCH TO SAVE IOB ADDR BEFORE
*                                  GOING TO ERROR RTN
         L     R2,IOBSTART         SET R2 TO STARTING
         L     R2,0(,R2)           LOCATION IN THE BUFFER
         TM    IOBCSTAT,IL         INCORRECT LENGTH SET ?
         BZ    RGBEE105            NO, BRANCH
RGBLSTBK CLI   2(R2),C'G'          LAST BLOCK OF SEQUENCE ? (HGHH)
         BZ    RGSTORRF            NO, BLOCK IS IN ERROR
*
*        NO ERRORS ON THIS BUFFER
*
         NI    DCBIFLGS,255-DCBIFPEC  RESET I/O ERROR FLAGS
RGBEE105 LH    R1,PPILAB03+2       SIZE OF AN INPUT BUFFER
         SH    R1,IOBCSW+5         SUBTRACT CSW RESIDUAL COUNT
         LA    R2,0(,R2)           CLEAR COMMAND CODE IN R2
         ST    R2,KSAVE+8          SET R4 (IN SAVE AREA) FOR DEBLOCK
         SH    R1,KFOUR            SUBTR EOS BYTES FROM RESIDUAL COUNT
RGBBRVR  NOP   RGBEE110            AP WILL OVERLAY TO A BR IF V.L. RCDS
*
*        COUNT THE NUMBER OF RECORDS IN THE FIXED LENGTH BLOCK
*
         SR    R14,R14             RECORD CTR
RGBFIX   SH    R1,PPIRCDL2         SORT RECORD LENGTH
         LA    R14,1(,R14)         ADD 1 TO RECORD CTR
         CH    R1,PPIRCDL2         CHECK TO SEE IF MORE RCDS IN BUFFER
         BNL   RGBFIX              R1 >=, MORE RCDS REMAIN IN BUFFER
         LR    R1,R14              R1 = NO OF RCDS IN BUFFER
RGBEE110 ST    R2,KSAVE            SET R2 (IN SAVE AREA) FOR DEBLOCK
         BR    R7                  BR TO RGBEREOS IF E28 ACTIVE & USER
*                                  WANTS TO SKIP OR RGBBCCV AT
*                                  PRIME TIME OR RGBEOSV AT RUN TIME
*
*        END OF FILE ROUTINE
*        ONLY COME HERE AT PRIME TIME BECAUSE THE RUNNING
*        PORTION OF RGL ONLY CHECKS FOR EOS. THUS CAN ONLY GET
*        EOF AT PRIME
*
RGBEOF   STM   R3,R9,KSAVE         SAVE REGISTERS
         SR    R0,R0
         IC    R0,0(,R3)           OBTAIN FILE INCREMENT
         LR    R3,R0
         L     R6,PPISTDCB         DCB ADDR TABLE POINTER
         L     R6,0(R3,R6)         DCB ADDR
         NI    DCBIFLGS,255-DCBIFPEC  RESET I/O ERROR FLAGS
         LH    R0,KNNINE           UPDATE FILE CNT TO EOF
         STC   R3,RGBINST+1        SET I FIELD TO UNIT'S INCR
         BAS   R7,RGBFLUP          BR TO UPDATE UNIT'S FILE CTR TO EOF
         OI    DCBOFLGS,DCBOFTM    TAPE MARK HAS BEEN READ
*
         CLOSE ((R6))              CLOSE AND REWIND THIS FILE
*
         L     R6,PPISTDCB
         AR    R6,R3               ADD INCR TO GET TO THIS INPUT DCB
*                                  ADDR
         MVI   0(R6),X'80'         TURN ON CLOSE BIT IN DCB ADDR TABLE
*
*        INTERFACE TO ALGORITHM
*        EOF AT PRIME TIME
*
         L     R11,PPIALG+4
         BAS   R14,12(,R11)        GOTO ALGORITHM
         LM    R3,R9,KSAVE         RESTORE REGS FOR PRIMING
         LR    R14,R4              R4 HAS M MINUS NO OF ACTUAL FILLED
*                                  BUFFERS
         SLL   R14,2               X4
         BCTR  R14,0               -1
         EX    R14,KMOVE           BYPASS FILE ENTRY W/EOF IN PPIA
         B     RGBPRLP             BR TO DECR R4 & WAIT ON REMAING BFRS
*
*        R3 -> CORRECT ENTRY IN THE PPIWKARE TABLE
*
KMOVE    MVC   0(1,R3),4(R3)       SHIFT THE REMAINDER OF THE TABLE UP
*                                  TO OVLAY THIS EOF ENTRY. THERE
*                                  MUST BE NO HOLES IN THE TABLE
*
*        A REAL ERROR HAS OCCURED
*        EITHER UNIT OR CHANNEL DATA CHECK
*
RGBERROR PPISETON PPIREADE         TURN ON READ ERROR FLAG
RGLTERM  NOP   RGPRTABT            SKIP DIRECTLY TO END IF NO E28
         L     R1,IOBDCBPT         DCB ADDR AP WILL OVLAY TO BR TO
*                                  SSC IF E28 SYNAD NOT ACTIVATED
         ST    R5,PPIWKARE         IOB ADDR
         MVI   PPIWKARE,X'10'      INCR TO CCW ADDR
         L     R0,PPIWKARE         INCR TO CCW IN THE IOB & IOB ADDR
*
*        INTERFACE TO E28 SYNAD EXIT
*
         BASR  R14,R15             CALL USER EXIT
*
*        PRINT IOS READ ERROR MSG BEFORE TERMINATING
*
RGPRTABT LR    R4,R5               ADDR OF CURRENT IOB
         L     R15,PPIADSSC
         BAS   R14,16(,R15)        SORT SYSTEM CONTROL - NO RETURN
*
*        RESET ALL ERROR BITS SET BY IOS IN THE DCB & IOB
*        OTHERWISE THE FILE WILL REMAIN PURGED
*
RGBSKIP  OI    IOBFLAG1,IOBCMDCH   SET COMMAND CHAINING ON
         NI    IOBCSTAT,255-IL-CDC
         NI    DCBIFLGS,255-DCBIFPEC  RESET I/O
RGBACCPT BAS   R7,RGBEE105         AP WILL OVERLAY WITH B RGBEE105 ON
*                                  E28 ACCEPT OPTION = 80
RGBEREOS CLI   2(R2),C'G'          ERROR WAS ON EOS BLOCK ?
         BO    RGBRTEOS            EOS BUFFER, BRANCH
*
         IEREXCP  (R5)             ISSUE NEW READ INTO BUFFER AREA
*
         B     RGBEOSCK            GOTO WAIT
*
RGSTORRF ST    R5,PPIWKARE
         B     RGBERROR            ERROR RTN
*
*        ISSUE READ ON THE EMPTY BUFFER
*
RGBIOBUP L     R4,IOBSTART         ATTACH THE ALTERNATE CCW TO
         L     R15,IOBECBPT
         MVC   IOBSTRTB,5(R15)     FILE TO HANDLE READS ON
         ST    R4,4(,R15)          THE ALTERNATE BUFFER
         L     R4,IOBSTART
         MVC   1(3,R4),1(R2)       STORE BUFFER ADDR IN CCW
         MVI   DCBBUFNO,2          UPDATE BUFNO
         LR    R4,R1               SAVE BLOCK COUNT
*
         IEREXCP  (R5)             READ BACKWARDS
*
         LR    R1,R4               RESTORE BLOCK COUNT FOR DEBLOCK
         BR    R7                  RETURN TO EOF RTN
*
*        SEARCH FILE COUNTER TABLE
*        SET FILE COUNT ON EOF UNIT TO FFFF
*        RGBINST 'I' FIELD WILL CONTAIN INCR OF EOF UNIT (SET BY
*        EOF RTN)
*
RGBFLUP  LA    R2,TFCNT            ADDR OF TABLE OF FILE COUNTERS
RGBINST  CLI   0(R2),X'00'         COMPARE FOR EOF UNIT
         BE    RGBFL120            BRANCH WHEN FOUND
         LA    R2,4(,R2)           UPDATE POINTER
         B     RGBINST             CHECK FOR EOF
*
RGBFL120 L     R4,0(,R2)           OBTAIN THE COUNT OF THE UNIT
*                                  (COULD BE B, OR 2B)
         AR    R4,R0               ADD FFFF (EOF) TO FILE COUNT
         ST    R4,0(,R2)           RESTORE COUNT
         BR    R7                  RETURN TO EOF ROUTINE
*
*        PARTIAL OVERLAP FLOATING BUFFER RTN
*        EXECUTED DURING RUN TIME. AT THIS POINT HAVE AN EMPTY
*        BFR AND A FULL BUFFER ON THE FILE FOR DEBLK
*        FIND A FILE W/1 BFR HAVING THE LEAST AMOUNT OF RCDS IN
*        IT. THIS IS THE FILE TO ATTACH THE ALTERNATE BUFFER
*        (MOST LIKELY TO EMPTY FIRST)
*
RGBFL040 LA    R2,TFCNT            ATTACH FLOATING BUFFER TO NEXT
         ST    R1,KSAVEB           SAVE BLOCK CNT FOR DEBLOCK
         L     R1,PPISBLCT         FILE TO BE READ
         LH    R7,KMRGMX
         LA    R4,PPIPSVA
         SR    R14,R14
         ST    R14,0(R3,R1)        SET RELEASED FILE'S BLCNT=0
RGBFL050 IC    R14,0(,R2)          OBTAIN DEBLOCK'S BLOCK COUNTERS
         L     R15,0(R14,R1)
         A     R15,0(,R2)          AND ADD THEM TO READ'S APPROPRIATE
         ST    R15,0(,R4)
         LA    R2,4(,R2)           FILE COUNTERS
         LA    R4,4(,R4)
         BCT   R7,RGBFL050         GET NEXT COUNTER
         LA    R2,PPIPSVA
         LH    R1,KMRGMX
         STC   R3,RGBINST1+1
         LR    R4,R2
         B     RGBINST1            CHECK FILE COUNT
*
RGBFL060 LA    R4,4(,R4)           SCAN FOR LOWEST FILE COUNT
         CLC   1(3,R2),1(R4)
         BH    RGBEX070            AND FOR THE RELEASED
RGBINST1 CLI   0(R4),X'00'
         BE    RGBRL080            FILE COUNT
RGBLPEND BCT   R1,RGBFL060         CONTINUE SCAN
         LA    R0,PPIPSVA          OBTAIN FILE COUNT ADDR VIA
         SR    R2,R0               DISPLACEMENTS OF LOWEST AND
         SR    R15,R0              RELEASED FROM PPIPSVA
         LA    R0,TFCNT
         AR    R15,R0
         AR    R2,R0
         MVI   DCBBUFNO,1          RELEASED FILE'S BUFNO(IN DCB)
         LR    R14,R6
         LR    R0,R5
         IC    R1,0(,R2)           INCR IN NEW FILE COUNT'S FIRST BYTE
         L     R6,PPISTDCB
         L     R6,0(R1,R6)         DCB  AND IOB ADDR
         L     R5,DCBIOBAD         OF NEW FILE
         L     R4,PPIBDSVA         BUFFER TABLE ADDR
         AR    R4,R1
         L     R1,KSAVEB           RESTORE BLOCK CNT
RGBFBV   CLI   0(R4),C'$'          EOS ?
         BNE   RGBCONT             NO, BRANCH
         LR    R6,R14              REATTACH BUFFER TO PREVIOUS
         LR    R5,R0
         B     RGBAL030            (IE RELEASED FILE)
*
*        CHECK FOR EOS AT PRIMING ON THE FILE W/LEAST RCDS IN ITS
*        BUFFER
*
RGBCONT  CLI   WEOSCNT,X'00'       EOS ON THIS LOWEST FILE
         BNE   RGBFBV+8            YES, BRANCH FALL THRU IF NO
         L     R4,0(,R2)           FILE COUNT FOR LOWEST FILE=B
         AH    R4,PPISRTBL         ADD B NOW=2B
         ST    R4,0(,R2)           STORE AS NEW FILE COUNT
         L     R4,0(,R15)          FILE COUNT FOR RELEASED FILE=2B
         SH    R4,PPISRTBL         SUBTRACT B, NOW=B
         ST    R4,0(,R15)          STORE AS NEW FILE COUNT
         B     RGBAL030            BRANCH TO ACTUALLY ATTACH EMPTY BFR
*
*        FOUND A NEW LOWER FILE COUNT
*
RGBEX070 LR    R2,R4               ADDR OF LOWEST FILE COUNT
         B     RGBINST1            CHECK FILE COUNT
*
*        ADDR IN PPISVA OF UNIT WITH EMPTY BFR
*
RGBRL080 LR    R15,R4              ADDR OF RELEASED FILE COUNT
         B     RGBLPEND            CONTINUE SCAN FOR LOWEST FILE
*
*        PRIMING SUBROUTINE
*
RGBPR200 MVI   WEOSCNT,X'00'       RESET EOS CTR FROM PREVIOUS PRIME
*                                  PASS
         LA    R1,TINCR            ADDR OF TABLE OF INCREMENTS
         ST    R1,AEOSPR
RGBPR220 LA    R4,PPITPTBL         ADDR OF TAPE TABLE
         LH    R7,PPIMRGMX         M
         L     R9,PPISTDCB         DCB TABLE OF ADDR PTR
         LA    R3,PPIWKARE
*
*        SEARCH TAPE TABLE FOR INPUT FILES
*        AS A UNIT IS FOUND ISSUE A READ ON IT AND RETURN
*
RGBPR230 TM    0(R4),X'80'         TEST FOR INPUT BIT
         BO    RGBPR240            YES, INPUT UNIT BRANCH
         LA    R4,2(,R4)           UPDATE TAPE TABLE POINTER
         B     RGBPR230            CHECK NEXT ENTRY IN TABLE
*
*        PRIME M BUFFERS
*
RGBPR240 SR    R6,R6
         IC    R6,1(,R4)           INPUT UNIT INCREMENT FROM TAPE TABLE
         STC   R6,0(,R3)           STORE IN PPIWKARE 1ST BYTE
         L     R6,0(R6,R9)         INPUT UNIT'S DCB ADDR
         MVC   1(3,R3),DCBIOBAA    STORE IT'S IOB ADDR IN NEXT 3 BYTES
*                                  IN PPIWKARE TABLE
         L     R5,DCBIOBAD         IOB ADDR
*
         IEREXCP  (R5)             READ FORWARD, PRIME 1 INPUT BLOCK
*
         LA    R3,4(,R3)           UPDATE PPIWKARE PTR
         LA    R4,2(,R4)           UPDATE TAPE TABLE PTR
         BCT   R7,RGBPR230         DECR MERGE ORDER BY 1 GO BACK TO
*                                  PRIME ANOTHER INPUT BUFFER
*
*        M INPUT BUFFERS HAVE BEEN PRIMED
*        ISSUE WAITS ON EACH BUFFER
*
         LH    R4,PPIMRGMX         M
         L     R8,PPISBLCT         TABLE OF BLOCK CTRS PTR
         LA    R9,TFCNT            PTR  TO TABLE OF FILE CTRS
         LA    R3,PPIWKARE         PTR TO PPIWKARE TABLE
RGBPR245 L     R5,0(,R3)           ADDR OF IOB
         L     R6,IOBDCBPT         LOAD DCB ADDR
         L     R1,IOBECBPT         ADDR OF IOB'S ECB
*
         IERWAIT 1,ECB=(1)         ISSUE A WAIT ON THE BUFFER
*                                  (IN ORDER OF PRIMING)
         BAS   R7,RGBEE100         BRANCH TO ERROR CHECK RTN
RGBBCCV  NOP   RGBPR280            AP WILL CHANGE TO A BR FOR V L RCD
         L     R15,IOBSTART
         MVI   4(R15),X'00'        TURN OFF SLI FOR FIXED LEN RECORDS
RGBPR280 SR    R14,R14
         IC    R14,0(,R3)          INCR OF UNIT (FROM PPIWKARE TABLE)
RGBPREOS TM    2(R2),X'07'         EOS ON COMPLETED READ ?
         BO    RGBPR260            YES, EOS BUFFER
*
*        CHECK UNIT FOR AN ALTERNATE BUFFER
*
         L     R6,IOBDCBPT         ADDR OF THE IOB'S DCB
         CLI   DCBBUFNO,2          DCB HAVE 2 BUFFERS ?
         BE    RGBPR270            YES, THERE IS AN ALTERNATE BUFFER
RGBPR250 MVC   2(2,R9),PPISRTBL    SET UNIT'S TABLE OF FILE COUNTERS TO
*                                  SORT BLKG=B
RGBBRVAR LA    R2,4(,R2)           FIXED LEN - BYPASS EOS INDICATOR
*                                  VAR LEN - BYPASS EOS & BCC AP WILL
*                                  OVERLAY THE 4 TO AN 8 DISPLACEMENT
         STC   R14,0(,R9)          STORE INCR IN HI BYTE OF FILE CTR
         LA    R9,4(,R9)           UPDATE FILE PTR
         ST    R1,0(R14,R8)        STORE BLOCK COUNT IN TABLE OF BLOCK
*                                  CTR FOR THE DEBLOCK RTN
         ST    R2,IERDGB2D         SAVE STRTG ADDR OF INPUT BUFFER JUST
*                                  READ IN
         MVC   1(3,R3),IERDGB2D+1  STORE IN PPIWKARE TABLE NEXT TO INCR
*                                  FOR MERGE NETWORK
         LA    R3,4(,R3)           UPDATE PPIWKARE PTR
RGBPRLP  BCT   R4,RGBPR245         DECR MERGE ORDER, LOOP TO PROCESS
*                                  NEXT UNIT'S PRIMARY BUFFER
*
*        M INPUT BUFFERS ARE PRIMED
*        THEY HAVE BEEN CHECKED FOR ERRORS. READS ON ALL THE
*        ALTERNATE BUFFERS HAVE BEEN STARTED & THE IOBS HAVE BEEN
*        UPDATED TO POINT TO THE ALT CCW. THE WAITS WILL BE
*        ISSUED AT RUN TIME
*
         MVC   KMRGMX(2),PPIMRGMX
*
*        INTERFACE WITH BUFFER TABLE ROUTINE TO BUILD TABLE OF
*        INPUT BUFFER ADDRS (FIRST RCD ADDR IN EACH BUFFER FOR
*        NETWORK)
*
         L     R11,PPIDEB2+4
         BR    R11                 BUILD INPUT BUFFER ADDR TABLE
*
*        END OF SEQUENCE ROUTINE AT PRIMING TIME
*        MOVE INCR OF EOS UNIT INTO INCREMENT TABLE AND UPDATE
*        EOS COUNTER
*
RGBPR260 L     R15,AEOSPR          PTR TO TABLE OF INCREMENTS
         MVC   0(1,R15),0(R3)      MOVE INCR OF EOS UNIT INTO TABLE
*                                  THIS TABLE IS FOR RUN TIME TO TELL
*                                  WHICH UNITS HIT EOS AT PRIME TIME
         LA    R15,1(,R15)         UPDATE TABLE PTR
         ST    R15,AEOSPR          STORE UPDATED PTR
         SR    R15,R15
         IC    R15,WEOSCNT
         LA    R15,1(,R15)         UPDATE COUNT OF NO OF EOS UNITS
         STC   R15,WEOSCNT         RESTORE UPDATED COUNTER
         B     RGBPR250            CHECK SORT BLOCKING
*
*        PRIME ALTERNATE BUFFER ROUTINE
*        SWITCH THE ALTERNATE CCW WITH THE PRIME CCW AND ISSUE A
*        READ ON THE IOB (ALT CCW ADDR NOW IN IOB)
*
RGBPR270 LR    R0,R14              INCR OF UNIT
         STM   R0,R2,KSAVE
         L     R1,IOBECBPT
         L     R15,4(,R1)          ALT CCW ADDR
         MVC   5(3,R1),IOBSTRTB    MOVE PRIMARY CCW ADDR INTO ALT CCW
*                                  LOCATION (4 BYTES AFTER ECB)
         ST    R15,IOBSTART        STORE ALT CCW ADDR AS NEW PRIMARY
*                                  CCW ADDR IN THE IOB
*
         IEREXCP  (R5)             START A READ ON THE ALT BUFFER
*
         LM    R0,R2,KSAVE         R0=INCR, R1=BLOCK CNT FOR FL RCDS OR
*                                  BCC-4 EOS BYTES FOR VL RCDS,
*                                  R2=STRTG ADDR OF PREVIOUS PRMRY BFR
         LR    R14,R0              INCR OF THIS INPUT UNIT
         LH    R15,PPISRTBL        B
         SLL   R15,1               2XB
         STH   R15,2(,R9)          STORE IN TABLE OF FILE CTRS FOR
         B     RGBBRVAR            THIS UNIT
*
*        ADCONS
*
AEOSPR   DC    A(TINCR)            TABLE OF INCREMENTS PTR
ADCONE28 DC    F'0'                SYNAD E28 ADDR LOADED BY IERAGL
*
*        WORK AREAS/TABLES
*
TINCR    DC    4F'0'               TABLE OF INCREMENTS (EOS UNITS AT
*                                  PRIME TIME)
TFCNT    DC    16F'0'              TABLE OF FILE CTRS
WSENSE0  DC    X'00'               SENSE BYTE 0 ON UNIT CHECK
WEOSCNT  DC    X'00'               CTR FOR NO OF UNITS HITTING EOS
*
*        CONSTANT
*
KSAVE    DC    7F'0'               WILL HAVE R3-R9 ON EVERY INPUT EOF
*                                  AND R2-R7 DURING RUN TIME
KSAVEB   DC    F'0'                BLOCK CNT OF BFR JUST READ IN-FILLED
*                                  DURING FLOATG BFR RTN
KNNINE   DC    X'FFFF'             FFFF
KMRGMX   DC    X'0000'             NO OF INPUT UNITS ENTERG FIRST PASS
KFOUR    DC    X'0004'             CONSTANT OF FOUR
KOUTINCR DC    X'00'               TEMP STORAGE
*
./ ADD NAME=IERRGM   0101-20211-20211-1200-00112-00112-00000-RELEASE 00
RGM      TITLE 'IERRGM - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRGM
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 3 RUNNING MODULE. READ FORWARD
*        THE FUNCTION OF THIS READ FORWARD MODULE IS TO FILL
*        INPUT BUFFERS AS NEEDED BY DEBLOCK VIA THE EXCP MACRO.
*        IF THERE IS PARTIAL OVERLAP IT WILL ASSIGN AN AVAILABLE
*        BUFFER FROM THE AVAILABLE BUFFER TABLE TO A UNIT HAVING
*        ONLY 1 BUFFER (THE UNIT WHOSE BUFFER HAS THE LEAST
*        AMOUNT OF RECORDS IN IT). AS EACH INPUT UNIT GOES TO EOF
*        ITS BUFFER ADDRESS(ES) ARE PUT IN THE AVAILABLE BUFFER
*        TABLE
*
*        THIS MODULE CHECKS FOR READ ERRORS AND IF USER EXIT E38
*        SYNAD IS NOT ACTIVATED IT WILL GOTO SSC TO TERMINATE THE
*        JOB. IF E38 SYNAD IS ACTIVATED THE USER MAY TRY TO FIX
*        THE ERROR AFTER IOS HAS TRIED TO DO SO
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - IERAGM
*
*        MACROS USED BY MODULE -
*        DCBD SMPPI
*        EXCP CLOSE
*        WAIT
*
*        ENTRY POINTS - ENTRY FROM DEBLOCK
*                       CALLING SEQUENCE -
*                           L    R11,PPIRD+4
*                           B    4(,R11)
*
*                     - ENTRY FROM USER EXIT E38 SYNAD
*                       CALLING SEQUENCE -
*                           BR   R14        RETURN
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIADSSC   PPISRTBL
*        PPILAB03   PPISTDCB
*        PPISBLCT   PPIDEB
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPILAB02   PPIWKARE
*        PPIPSVA    PPICNTL
*
*        EXTERNAL ROUTINES - NONE
*
*        EXTERNAL PARAMETERS - SEE REGISTERS
*
*        EXITS - NORMAL - TO DEBLOCK EXIT
*                         CALLING SEQUENCE -
*                             L    R11,PPIBLK2+4
*                             B    4(,R11)
*
*        EXITS - ERROR - EXIT TO USER SYNAD EXIT E38
*                        CALLING SEQUENCE -
*                            L    R15,AE38
*                            BALR R14,R15
*
*                      - EXIT TO SSC VIA
*                            L    R15,PPIADSSC
*                            B    16(,R15)
*
*        TABLES/WORK AREAS -
*        TFCNT   - FILE COUNT TABLE, 4 BYTES PER ENTRY, M ENTRIES
*                  TELLS STATUS OF EACH ORIGINAL INPUT FILE
*                  IN REGARD TO THE NUMBER OF BUFFERS ATTACHED TO
*                  EACH FILE (IE EITHER 2,1, OR THE FILE WENT TO
*                  EOF)
*        WSENSE0 - HOLDS SENSE BYTE ON UNIT CHECK
*
*        NOTES -
*        THIS MODULE WILL EXECUTE FOR ANY TAPE SORT REQUIRING A
*        READ FORWARD PASS IN PHASE 3
*
IERRGM   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRGM SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRGMI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
*        IERCCWEQ
*
         IERCCWEQ
*
*        IERIOB
*
         IERIOB
*
         PRINT NOGEN
*
         DCBD  DSORG=PS,DEVD=(DA,TA)
*
         IHAECB DSECT=NO,EXT=NO
*
         IEZDEB LIST=NO
*
         PRINT GEN
*
         SMPPI
*
         END
./ ADD NAME=IERRGMI  0101-20211-20211-1200-00342-00342-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERRGM SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERRGMI
*
         USING *,R11
         USING IERRCA,R13
         USING IOBSTDRD,R5
         USING IHADCB,R6
*
IERDGB3  NOP   IERDGB3             +00 DUMMY ENTRY
         STM   R2,R7,KSAVE         +04 ENTRY
         ST    R2,IERDGB3
         L     R6,PPISTDCB
         L     R6,0(R3,R6)         APPROPRIATE DCB VIA INCR IN R3
         L     R5,DCBIOBAD         IOB ADDR
         TM    DCBBUFNO,2          BUFNO, CHECK FOR ALTERNATE BUFFER
         BO    RGDAL020            FOR FILE
*
*        FILE ONLY HAS ONE BUFFER ATTACHED TO THE IOB
*
         IEREXCP  (R5)             READ FORWARD
*
         L     R1,IOBECBPT
*
         IERWAIT  1,ECB=(1)        WAIT ON I/O COMPLETION
*
RGDLINK  BAS   R7,RGDEE100         EOF ERROR CHECK RTN
*
*        RETURN FROM EOF ERROR CHECK RTN
*        R1 = ACTUAL COUNT OF RECORDS IN THE BUFFER FOR FIXED
*        LENGTH OR ACTUAL NO OF BYTES IN BUFFER -4 (FOR BCC) FOR
*        VARIABLE LENGTH RECORDS
*        R2 AND R4 CONTAIN STARTING ADDR OF THE BUFFER
*
         LH    R2,KCOUNT           AVAILABLE BUFFER
         BCT   R2,RGDBF010         ON LIST TO ATTACH TO FILE
RGDRTRN  LM    R2,R7,KSAVE
         L     R11,PPIDEB+4
RGDRTRNV LA    R2,4(,R2)           FIXED - BYPASS EOS INDICATOR
*                                  VAR   - BYPASS EOS INDICATOR AND BCC
         BR    R11
*
*        ATTACH AVAILABLE BUFFER TO FILE WHICH PREVIOUSLY HAD NO
*        ALTERNATE BUFFER
*
RGDBF010 STH   R2,KCOUNT
         L     R2,PPILAB02
         BAS   R7,RGDIOBUP         UPDATE IOB, ATTACH BUFFER FROM
         LA    R2,4(,R2)           AVAILABLE LIST
         ST    R2,PPILAB02         UPDATE LIST
         STC   R3,RGDINST+1        FILE INCR (FROM DEBLOCK)
         LH    R0,PPISRTBL
         LA    R7,RGDRTRN
RGDFLUP  LA    R2,TFCNT            FIND FILE COUNT IN ORDER
RGDINST  CLI   0(R2),X'00'
         BE    RGDBF015            TO UPDATE COUNT
         LA    R2,4(,R2)
         B     RGDINST
*
RGDBF015 L     R4,0(,R2)           ADD SORT BLOCKING
         AR    R4,R0
         ST    R4,0(,R2)           TO FILE COUNT
         BR    R7
*
RGDIOBUP L     R4,IOBSTART         ATTACH NEW (OR ALTERNATE) CCW
         L     R15,IOBECBPT
         MVC   IOBSTRTB,5(R15)     TO FILE TO HANDLE READS ON
         ST    R4,4(,R15)          ALTERNATE BUFFER
         L     R4,IOBSTART
         MVC   1(3,R4),1(R2)       STORE BUFFER ADDR IN CCW
         MVI   DCBBUFNO,X'02'      UPDATE BUFNO
         LR    R4,R1               SAVE BLOCK COUNT
*
         IEREXCP  (R5)             READ FORWARD
*
         LR    R1,R4               RESTORE BLOCK COUNT FOR DEBLOCK
         BR    R7
*
RGDAL020 L     R1,IOBECBPT
*
         IERWAIT  1,ECB=(1)        WAIT ON ALTERNATE
*
         BAS   R7,RGDEE100         CALL EOF ERROR CHECK RTN
*
*        RETURN FROM EOF ERROR CHECK RTN
*        R1 = ACTUAL COUNT OF RCDS IN THE BUFFER FOR FIXED
*        LENGTH OR ACTUAL NO OF BYTES IN BUFFER -4 (FOR BCC) FOR
*        VARIABLE LENGTH RECORDS
*        R2 AND R4 CONTAIN STARTING ADDR OF THE BUFFER
*
RGDK2M   CLI   KTOTAL,X'00'        FULL OVLAP TEST 'I' FIELD SET TO 2M
*                                  BY AP AND RECALC ON EACH INPUT
*                                  EOF BY RP
         BL    RGDFL030            BRANCH ON KTOTAL LESS THAN 2M
*
*        FULL OVERLAP IN PHASE 3
*
RGDAL025 LA    R2,IERDGB3          ATTACH EMPTY BUFFER
         LA    R7,RGDRTRN          TO SAME FILE AGAIN
         B     RGDIOBUP            BRANCH TO UPDATE IOB
*
*        PARTIAL OVERLAP ROUTINE
*        ASSIGN AN AVAILABLE BUFFER TO A UNIT HAVING ONLY 1
*        BUFFER. SINCE THERE MAY BE MORE THAN 1 UNIT HAVING 1
*        BUFFER TAKE THE BUFFER WITH THE LEAST AMOUNT OF RECORDS
*        IN IT
*
RGDFL030 LA    R2,TFCNT            ADDR OF TABLE OF FILE COUNTERS
         ST    R1,KSAVEB           SAVE BLOCK CNT FOR DEBLOCK
         L     R1,PPISBLCT
         LH    R7,KMRGMX           ADDING OF DEBLOCK
         LA    R4,PPIPSVA
         SR    R14,R14             COUNTS TO THE
         ST    R14,0(R3,R1)        SET RELEASED FILE'S BLCNT=0
*
*        THE TABLE OF FILE COUNTERS CONTAIN ENTRIES OF ALL THE
*        INPUT UNITS INTO PHASE 3. EACH ENTRY IS 4 BYTES. FIRST
*        BYTE IS THE FILE INCR. THE NEXT 3 BYTES IS EITHER 2B OR
*        B DEPENDING WHETHER 2 OR 1 BUFFER IS ATTACHED TO THE
*        FILE. TAKE THESE ENTRIES AND ADD THE BLOCK COUNT OF EACH
*        FILE'S BLOCK COUNTERS AND ESTABLISH A PPIPSVA TABLE
*        WHICH WILL HAVE A 4 BYTE ENTRY FOR EACH FILE. FIRST BYTE
*        IS FILE INCR. NEXT 3 BYTES IS(2B OR B) + REMAINING
*        BLOCK COUNT FROM THE TABLE OF BLOCK COUNTERS. THE
*        RELEASED FILE'S BLOCK COUNT WAS SET TO 0 SO ITS ENTRY IN
*        PPIPSVA TABLE CANNOT EXCEED 2B
*
RGDFL035 IC    R14,0(,R2)
         L     R15,0(R14,R1)       FILE COUNTS
         A     R15,0(,R2)
         ST    R15,0(,R4)
         LA    R2,4(,R2)
         LA    R4,4(,R4)
         BCT   R7,RGDFL035
         LA    R2,PPIPSVA          OBTAIN FILE COUNT ADDR VIA
         LH    R1,KMRGMX           FILE TO BE READ
         STC   R3,RGDINST1+1
         LR    R4,R2
         B     RGDINST1            BRANCH TO SCAN PPISVA TABLE
*
*        FIND THE FILE ENTRY IN PPIPSVA OF THE FILE RELEASING THE
*        BUFFER AND THE FILE TO WHICH THE BUFFER WILL BE GIVEN.
*        THE DISPLACEMENTS WILL CORRESPOND TO THE DISPLACEMENTS
*        OF THESE FILES IN THE TABLE OF FILE CTRS. THE RELEASED
*        FILES BUFFER WILL BE UPDATED TO B AND THE NEW 2 BUFFER
*        FILE WILL BE UPDATED TO 2B IN THE TABLE OF FILE CTRS
*
RGDLP040 LA    R4,4(,R4)           SCAN FOR LOWEST FILE COUNT
         CLC   1(3,R2),1(R4)
         BH    RGDEX050            AND FOR THE RELEASED
RGDINST1 CLI   0(R4),X'00'
         BE    RGDRL060            FILE COUNT
RGDLPEND BCT   R1,RGDLP040
         LR    R1,R0
         LA    R0,PPIPSVA          DISPLACEMENTS OF LOWEST AND
         SR    R2,R0               RELEASED FROM PPIPSVA
         SR    R1,R0
         LA    R0,TFCNT
         AR    R1,R0
         AR    R2,R0
         L     R4,0(,R2)           UPDATE
         AH    R4,PPISRTBL
         ST    R4,0(,R2)           NEW FILE COUNT
         MVI   DCBBUFNO,1          RELEASED FILE'S BUFNO (IN DCB)
         L     R4,0(,R1)
         SH    R4,PPISRTBL
         ST    R4,0(,R1)           RELEASED FILE COUNT
         SR    R1,R1
         IC    R1,0(,R2)           INCR IN NEW FILE COUNT'S FIRST BYTE
         L     R6,PPISTDCB
         L     R6,0(R1,R6)         IOB ADDR
         L     R5,DCBIOBAD         OF NEW FILE
         L     R1,KSAVEB           RESTORE BLOCK CNT
         B     RGDAL025
*
RGDEX050 LR    R2,R4               ADDR OF LOWEST FILE COUNT
         B     RGDINST1
*
RGDRL060 LR    R0,R4
         B     RGDLPEND           ADDR OF RELEASED FILE COUNT
*
*        END OF FILE/ERROR CHECK ROUTINE
*
RGDEE100 TM    IOBUSTAT,UE         UNIT EXCEPTION ? HIT TAPE MARK
         BO    RGDEOFR             YES, BRANCH TO EOF ROUTINE
         TM    IOBUSTAT,UC         UNIT CHECK FOR DEVICE ERROR ?
         BZ    RGDPRMSK            NO, BRANCH TO CHECK CHANNEL ERROR
         MVC   WSENSE0,IOBSENS0    SENSE BYTE IN IOB TO SAVE AREA
RGSTORRF ST    R5,PPIWKARE         SAVE IOB ADDR IN CASE NO SYNAD RTN
RGDERROR PPISETON PPIREADE         TURN ON ERROR BIT IN PPI
RGMTERM  NOP   RGPRTABT
         L     R1,IOBDCBPT         DCB ADDR IN IOB FOR E38 SYNAD
         ST    R5,PPIWKARE         IOB ADDR
         MVI   PPIWKARE,X'10'      INCR TO CCW ADDR IN IOB FOR E38
         L     R0,PPIWKARE
*
*        INTERFACE WITH USER EXIT E38 SYNAD
*
         L     R15,AE38
         BASR  R14,R15             CALL USER EXIT E38
*
*        PRINT IOS READ ERROR MSG BEFORE TERMINATING
*
RGPRTABT L     R4,PPIWKARE         ADDR OF IOB WITH ERROR ON IT
         L     R15,PPIADSSC
         BAS   R14,16(,R15)        CALL TERMINATE RTN, NO RETURN
*
RGDSKIP  OI    IOBFLAG1,IOBCMDCH      ERROR ACCEPTED, RESET ERROR BITS
         NI    IOBCSTAT,255-IL-CDC    IN THE IOB AND DCB
         NI    DCBIFLGS,255-DCBIFPEC  DCB EXCEPTION BITS FOR PERM ERROR
*
RGDACCPT IEREXCP  (R5)             READ FORWARD INTO SAME BUFFER
*
         L     R1,IOBECBPT
*
         IERWAIT 1,ECB=(1)         WAIT ON I/O COMPLETION
*
RGDACCBR B     RGDEE110
*
*        NO UNIT EXCEPTION OR UNIT CHECK BITS ON
*        CHECK IF OTHER ERRORS
*
RGDPRMSK TM    IOBCSTAT,CDC        CHANNEL ERROR ?
         BO    RGSTORRF            YES, BRANCH TO SAVE IOB ADDR
         TM    IOBCSTAT,IL         INCORRECT LENGTH  ?
         BO    RGDEOSBF            YES, BRANCH TO CHECK IF EOS BUFFER
RGDEE110 L     R4,IOBSTART         ADDR OF CCW FROM IOB
         L     R4,0(,R4)           STARTING BFR ADDR FROM CCW FOR DEBLK
*
*        TEST FOR VARIABLE LENGTH RECORDS
*
RGDBRVR  NOP   RGDVAR              AP WILL MAKE A BR IF VAR LEN RCDS
         TM    2(R4),X'07'         BUFFER EOS ?
         BO    RGDFIX              YES, BRAN TO COUNT RCDS IN SHORT BLK
         LH    R1,PPISRTBL         NO, LOAD SORT BLOCKING INTO R1
RGDEE120 LR    R2,R4
         ST    R2,KSAVE            STORE IN R2 POSITION IN SAVE AREA
         MVI   KSAVE,X'00'         ZERO OUT CC
         ST    R4,KSAVE+8          STORE IN R4 POS'N IN SAVE AREA
         BR    R7                  RETURN TO MAIN LINE TO EITHER THE
*                                  OVERLAP OR NO OVERLAP RTN
*
*        CHECK IF BUFFER IS AN EOS BUFFER
*        (INCORRECT LENGTH BIT IS ON IN CSW)
*
RGDEOSBF L     R4,IOBSTART
         L     R4,0(,R4)
RGDEOSB1 CLI   2(R4),C'G'          EOS ? (HGHH)
         BZ    RGSTORRF            NO, BRANCH TO PRT MSG BEFORE TERM
         NI    DCBIFLGS,255-DCBIFPEC  RESET IFLGS
         B     RGDBRVR             BRANCH TO CHK IF VAR LEN RCDS
*
*        DETERMINE ACTUAL NO OF BYTES IN THE VAR LEN BUFFER
*        MINUS 4 FOR THE BCC
*
RGDVAR   LH    R1,PPILAB03+2       SIZE OF ROUNDED INPUT BUFFER
         SH    R1,IOBCSW+5         SUBTRACT CSW RESIDUAL COUNT
         LR    R0,R1
         SH    R1,KFOUR            MINUS 4 BYTES FOR BCC
         B     RGDEE120            BR TO LOAD R2 & R4 W/STRTG BFR ADDR
*
*        COUNT THE NUMBER OF RECORDS IN THE FIXED LENGTH EOS
*        BUFFER
*
RGDFIX   L     R1,KBLKCHR          COUNT OF A FULL BUFFER FROM PPILAB03
         SH    R1,IOBCSW+5         SUBTRACT CSW RESIDUAL COUNT
         SH    R1,KFOUR            MINUS 4 FOR EOS BYTES
         SR    R14,R14
RGDLOOP  SH    R1,PPIRCDL2         SUBTR LEN OF 1 FL RCD FROM COUNT
         LA    R14,1(,R14)         INCR RECORD COUNTER BY 1
         CH    R1,PPIRCDL2         COMPARE REMAINING COUNT
         BNL   RGDLOOP             BR ON EQ OR GTR (MORE RCDS IN BFR)
         LR    R1,R14              LOAD NO OF RCDS IN BUFFER IN R1
         B     RGDEE120            BRANCH TO LOAD R2 AND R4 FOR DEBLOCK
*
*        END OF FILE ROUTINE
*        PUT THIS FILE'S BUFFER(S) ON THE AVAILABLE BUFFER
*
RGDEOFR  L     R4,IOBSTART         ADDR OF PRIMARY CCW FROM THE IOB
RGDTWO   L     R2,PPILAB02         AVAIL BUFFER TABLE PTR
         SH    R2,KFOUR            DECR PTR
         MVC   1(3,R2),1(R4)       BUFFER ADDR IN CCW TO TABLE
         ST    R2,PPILAB02         UPDATED BUFFER TABLE PTR
         LH    R2,KCOUNT
         LA    R2,1(,R2)           ADD 1 TO AVAILABLE BUFFER CTR
         STH   R2,KCOUNT           STORE UPDATED CTR
         CLI   DCBBUFNO,2          THIS FILE HAVE 2 BUFFERS ?
         BNE   RGDONE              NO, BRANCH
         MVI   DCBBUFNO,1          YES, CHANGE THE 2 TO 1
         L     R4,IOBECBPT         ADDR OF THE ECB
         L     R4,4(,R4)           ADDR OF THE ALTERNATE CCW
         B     RGDTWO
*
RGDONE   LH    R0,KNNINE           EOF INDICATION TO UPDATE TABLE OF
*                                  FILE COUNTERS
         STC   R3,RGDINST+1        INCR OF EOF FILE
         BAS   R7,RGDFLUP          UPDATE TABLE OF FILE CTR ENTRY (EOF)
         LH    R7,KMRGMX1          ACTUAL INPUT MERGE ORDER UPDATED
         BCTR  R7,0                DECR BY 1 FOR THE INPUT EOF
         STH   R7,KMRGMX1          RESTORE NEW MERGE ORDER
         AR    R7,R7               2M
         STC   R7,RGDK2M+1         SET THE 'I' FIELD OF THE CLI INSTR
         OI    DCBOFLGS,DCBOFTM    TAPE MARK HAS BEEN READ
*
         CLOSE ((R6))              CLOSE THE INPUT FILE
*
*        INTERFACE TO MERGE NETWORK TO CUTBACK MERGE ORDER THEN
*        MERGE GOES TO BLOCK WITH ANOTHER WINNER
*
         L     R11,PPINET+4
         B     4(,R11)
*
*        WORK AREAS/TABLES
*
TFCNT    DC    16F'0'              FILE COUNT TABLE, 4 BYTE ENTRIES
*                                  FIRST BYTE - FILE INCR
*                                  NEXT 3 BYTES - 2B=2 BFRS OR B=1 BFR
*                                  OR FFFF FOR EOF ON THE FILE
WSENSE0  DC    X'00'               SENSE BYTE SAVED ON UNIT CHECK
*
KTOTAL   DC    X'0000'             NO OF INPUT BUFFERS PRESENTLY
*                                  ATTACHED
KMRGMX   DC    H'0'                AP INSERTS INPUT MERGE ORDER INTO
*                                  PHASE 3
KMRGMX1  DC    H'0'                AP INSERTS INPUT MERGE ORDER INTO
*                                  PH 3  RP DECR BY 1 EACH INPUT EOF
KCOUNT   DC    H'1'                AVAILABLE BUFFER COUNTER
KNNINE   DC    X'7FFF'             EOF CONSTANT FOR TFCNT ENTRY ON EOF
KFOUR    DC    H'4'                CONSTANT OF 4
KBLKCHR  DC    F'0'                SORT BLOCK CHAR CNT (F AND V RCDS)
KSAVE    DC    6F'0'               REGISTER SAVE AREA
KSAVEB   DC    F'0'
*
*        ADCONS
*
AE38     DC    F'0'                ADDR OF USER EXIT E38 SYNAD
*
./ ADD NAME=IERRGO   0101-20211-20211-1200-00100-00100-00000-RELEASE 00
RGO      TITLE 'IERRGO - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRGO - NOT SUPPORTED
*
*        MODULE FUNCTION/OPERATION -
*        THIS MODULE HANDLES DRUM INPUT IN THE INTERMEDIATE
*        MERGE PHASE BY WAY OF THE EXCP MACRO. THE MODULE READS
*        PHYSICAL RECORDS INTO BUFFER AREAS. THE ROUTINE
*        INTERFACES WITH IOS, THE ALGORITHM, THE BUFFER TABLE
*        ROUTINE, DEBLOCK, AND THE MERGE NETWORK. IF EXIT E28 IS
*        ACTIVATED BY A USER, THE READ ROUTINE ON A READ ERROR IS
*        PASSED TO SORT SYSTEM CONTROL TO TERMINATE THE JOB
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - IERAGO
*
*
*        MACROS USED BY MODULE -
*        EXCP WAIT
*        CLOSE SMPPI
*
*        ENTRY POINTS - ENTRY FROM ALGORITHM
*                       CALLING SEQUENCE -
*                           L R11,PPIRD+4
*                           BAL R14,0(,R11)
*
*                     - ENTRY FROM MERGE NETWORK
*                       CALLING SEQUENCE -
*                           L  R11,PPIRD+4
*                           B  4(,R11)
*
*                     - ENTRY FROM DEBLOCK
*                       CALLING SEQUENCE -
*                           L  R11,PPIRD+4
*                           B  8(,R11)
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPISTIOB   PPISBLCT   PPIPSVA
*        PPILAB03   PPIADSSC   PPIMRGMX
*        PPISTDCB   PPIDIRAD
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPISRTBL   PPIRCDL2
*        PPIWKARE   PPICNTL
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL -
*        IERDB2 - NORMAL INTERFACE
*        IERD01 - EOS EXIT
*        IERDDT - TAPE - EOF EXIT
*                 DRUM - READ DIRECTORY EXIT
*        IERRDL - PRIMING EXIT
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS -
*        FILE COUNT TABLE
*        CCW LIST FOR READING DIRECTORY
*
*        NOTES - N/A
*
IERRGO   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRGO SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRGOI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
*        IERCCWEQ
*
         IERCCWEQ
*
*        IERIOB
*
         IERIOB
*
         PRINT NOGEN
*
         DCBD  DSORG=PS,DEVD=(DA,TA)
*
         IHAECB DSECT=NO,EXT=NO
*
         IEZDEB LIST=NO
*
         PRINT GEN
*
         SMPPI
*
         END
./ ADD NAME=IERRGOI  0101-20211-20211-1200-00360-00360-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERRGO SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERRGOI - NOT SUPPORTED
*
         USING *,R11
         USING IOBSTDRD,R5         IOB DSECT
         USING IERRCA,R13          PPIA DSECT
*
IERDGB2D B     RGODR300            +00 DIRECTORY ENTRY
         B     RGOPR200            +04 PRIMING SUBROUTINE
         TM    1(R2),X'07'         +08 BLOCK/DEBLOCK ENTRY, TEST EOS
         BNO   RGOST010            NOT EOS, BRANCH
RGORTEOS L     R11,PPINETM+4       GOTO MERGE NETWORK
         B     4(,R11)             ON EOS
*
RGOST010 STM   R2,R6,KSAVE         SAVE
         ST    R2,KSAVE1           REGISTERS
         L     R5,PPISTIOB         ADDR OF IOB TABLE
         L     R5,0(R3,R5)         IOB ADDR
         L     R2,IOBECBPT         NO OF BUFFERS ATTACHED
         TM    4(R2),X'02'         CHECK FOR ALTERNATE
         BO    RGOAL020
*
*        FILE ONLY HAS ONE BUFFER ATTACHED TO THE IOB
*
         IEREXCP  (R5)             READ
*
         LR    R1,R2
*
         IERWAIT  1,ECB=(1)        WAIT ON IOB NOW FOR IT HAS NO
*
         BAS   R6,RGOER100         ALT BUFFER TO GIVE DEBLOCK ERR CK
RGORTRN  LM    R2,R6,KSAVE         RESTORE REGISTERS
         LA    R2,4(,R2)           FIX/VAR BYPASS EOS INDICATOR
*                                  VAR ALSO BYPASS BCC
         L     R11,PPIBLK2+4       GOTO DEBLOCK ROUTINE
         B     4(,R11)
*
*        FILE HAS ALTERNATE BUFFER ATTACHED TO THE IOB
*
RGOAL020 BAS   R4,RGOEOSCK         WAIT ON FILE ERR CK AND SEQ CK
RGORFBF  NOP   RGOFL040            IF ONLY HAVE PARTIAL OVERLAP, THIS
*                                  NOP BECOMES AN UNCONDITIONAL
*                                  BRANCH. HAVE FLOATING BUFFERS
RGOIOBUP L     R4,IOBSTART         ATTACH THE ALTERNATE BUFFER TO
         L     R15,IOBECBPT
         MVC   IOBSTRTB,5(R15)     THE IOB VIA THE CCW LIST
         ST    R4,4(,R15)
         L     R4,IOBSTART
         MVC   17(3,R4),KSAVE1+1   STORE BUFFER ADDR IN THE READ CCW
         MVI   4(R15),X'02'        UPDATE NO OF BUFFERS ATTACHED
         LR    R4,R1               SAVE BLOCK COUNT ON COMPLETED READ
*
         IEREXCP  (R5)             READ
*
         LR    R1,R4               RESTORE BLOCK COUNT FOR DEBLOCK
         B     RGORTRN
*
RGOEOSCK L     R1,IOBECBPT         ISSUE WAIT ON PREVIOUS READ
*
         IERWAIT 1,ECB=(1)         WAIT ON I/O COMPLETION
*
         BAS   R6,RGOER100         ERROR CHECK, AND
RGOEOSV  TM    1(R2),X'07'         SEQUENCE CHECK
         BNOR  R4                  IF EOS, DON'T ISSUE ANOTHER READ
         B     RGORTRN             ON FILE
*
*        PARTIAL OVERLAP
*
RGOFL040 LA    R2,TFCNT            SCAN FILE COUNTERS TO DETERMINE
         ST    R1,KSAVEB           SAVE BLOCK CNT FOR DEBLOCK
         L     R1,PPISBLCT         WHICH FILE TO ATTACH ALT BUFFER
         LH    R6,KMRGMX           TO FOR NEXT READ
         LA    R4,PPIPSVA
         SR    R14,R14
         ST    R14,0(R3,R1)        SET RELEASED FILE'S BLCNT=0
RGOFL050 IC    R14,0(,R2)          OBTAIN DEBLOCK'S BLOCK COUNTERS
         L     R15,0(R14,R1)
         A     R15,0(,R2)          ADD THEM TO READ'S APPROPRIATE
         ST    R15,0(,R4)
         LA    R2,4(,R2)           FILE COUNTERS
         LA    R4,4(,R4)
         BCT   R6,RGOFL050
         LA    R2,PPIPSVA
         LH    R1,KMRGMX
         STC   R3,RGOINST1+1
         LR    R4,R2
         B     RGOINST1
*
RGOFL060 LA    R4,4(0,R4)          SCAN FOR LOWEST FILE COUNT
         CLC   1(3,R2),1(R4)
         BH    RGOEX070            AND FOR RELEASED
RGOINST1 CLI   0(R4),X'00'
         BE    RGORL080            FILE COUNT
RGOLPEND BCT   R1,RGOFL060
         LA    R0,PPIPSVA          OBTAIN FILE COUNT ADDR VIA
         SR    R2,R0               DISPLACEMENTS OF LOWEST AND
         SR    R15,R0              RELEASED FROM PPIPSVA
         LA    R0,TFCNT
         AR    R15,R0
         AR    R2,R0
         L     R4,IOBECBPT
         MVI   4(R4),1             RELEASED FILE'S NO OF BUFFERS
         LR    R14,R5
         IC    R1,0(,R2)
         L     R5,PPISTIOB         IOB OF NEW FILE
         L     R5,0(R1,R5)
         L     R4,IOBSTART
         L     R4,16(,R4)
         L     R1,KSAVEB           RESTORE BLOCK CNT
RGOFBV   TM    1(R4),X'07'         EOS CK ON BUFFER ALREADY ATTACHED
         BNO   RGOCONT             TO FILE
         LR    R5,R14              YES, GO BACK AND ATTACH ALT BUFFER
         B     RGOIOBUP            TO FILE IT WAS ON BEFORE
*
RGOCONT  L     R4,0(,R2)           UPDATE
         AH    R4,PPISRTBL
         ST    R4,0(,R2)           NEW FILE COUNT
         L     R4,0(,R15)          RELEASED FILE COUNT
         SH    R4,PPISRTBL
         ST    R4,0(,R15)
         B     RGOIOBUP
*
RGOEX070 LR    R2,R4               ADDR OF LOWEST FILE COUNT IN PPI
         B     RGOINST1            SAVE AREA
*
RGORL080 LR    R15,R4              ADDR OF RELEASED FILE COUNT IN PPI
         B     RGOLPEND            SAVE AREA
*
*        ERROR CHECK OF BUFFER READ HAS COMPLETED
*
RGOER100 L     R1,IOBECBPT
         CLI   0(R1),ECBNORM       CHANNEL PROGRAM SUCCESSFUL ?
         BNE   RGORESET            NO, BRANCH
         L     R2,IOBSTART
         L     R2,16(,R2)          OBTAIN THE BUFFER ADDR
RGOER110 LH    R1,PPILAB03+2       OBTAIN THE BLOCK CHAR COUNT
         SH    R1,IOBCSW+5         SUBTRACT RESIDUAL COUNT IN CSW
         SH    R1,KFOUR
         ST    R2,KSAVE
         ST    R2,KSAVE+8
         MVI   KSAVE,X'00'
RGOBRVR  NOP   RGOTRKNO            UNCOND BRANCH IF VAR RCD FORMAT
         SR    R14,R14
RGOFIX   SH    R1,PPIRCDL2         NEED BLOCK RCD CNT IF FIX RCD
         LA    R14,1(,R14)
         CH    R1,PPIRCDL2
         BNL   RGOFIX
         LR    R1,R14
*
*        UPDATE THE DRUM ADDR FOR NEXT TIME THROUGH - MBBCCHHR
*
RGOTRKNO CLI   IOBR,0              RECORD NUMBER = 0 ?
         BE    RGOUPH              YES, UPDATE HEAD
RGOUPR   LA    R14,IOBR            R14 -> IOBR
RGOUPNO  IC    R15,0(,R14)
         LA    R15,1(,R15)         INCR RECORD COUNT BY 1
         STC   R15,0(,R14)
         BR    R6
*
RGOUPH   MVI   IOBR,1              RESET RECORD NUMBER TO 1
         IC    R15,IOBHH+1         INCREMENT HEAD NUMBER
         LA    R15,1(,R15)
         STC   R15,IOBHH+1         STORE NEW HEAD NUMBER
         BR    R6
*
RGORESET CLI   0(R1),ECBREPRG      REQUEST ELEMENT AVAIL AFTER PURGE ?
         BNE   RGOERROR
*
*        REQUEST PURGED DUE TO I/O ERROR ON OTHER READ
*        RESTORE REQUEST QUEUE
*
         L     R1,IOBDCBPT
         USING IHADCB,R1
         NI    DCBIFLGS,255-DCBIFPEC  RESET I/O
         OI    IOBFLAG1,IOBCMDCH   SET COMMAND CHAINING ON
         L     R1,DCBDEBAD         R1 -> DEB
         USING DEBBASIC,R1
         LA    R1,DEBUSRPG         POINT TO FIRST PURGED IOB ADDR
         DROP  R1
         IERESTOR (1)              RESTORE SVC
*
         B     RGWAIT
*
*        READ ERROR HAS OCCURRED - CHECK TO SEE IF USER EXIT E28
*        WAS ACTIVATED AT ASSIGNMENT TIME
*
RGOERROR PPISETON PPIREADE         TURN ON ERROR BIT IN PPI
RGOTERM  NOP   RGOSSCBR
         L     R1,IOBDCBPT         DCB ADDR
         ST    R5,PPIWKARE         SET IOB ADDR WITH
         MVI   PPIWKARE,X'10'      INCREMENT TO CCW ADDR IN
         L     R0,PPIWKARE         THE HIGH ORDER BYTE
*
*        CALL USER EXIT E28
*        LINK TO USER IS OVERLAYED IF NOT ACTIVATED
*
         L     R15,AE28
         BASR  R14,R15
RGOSSCBR ST    R4,RGOSVEME         STORE ORIGINAL CONTENTS OF R4
         L     R15,PPIADSSC
         BAS   R14,16(,R15)        NO RETURN
*
RGOSKIP  NI    IOBUSTAT,255-UC-UE  ERROR ACCEPTED
         NI    IOBCSTAT,255-IL-CDC
         L     R1,IOBDCBPT            RESET ALL ERROR BITS SET BY IOS
         USING IHADCB,R1              IN THE IOB AND DCB
         NI    DCBIFLGS,255-DCBIFPEC  RESET I/O
         L     R1,DCBDEBAD         R1 -> DEB
         USING DEBBASIC,R1
         LA    R1,DEBUSRPG         POINT TO FIRST PURGED IOB ADDR
         DROP  R1
         IERESTOR (1)              RESTORE SVC
         OI    IOBFLAG1,IOBCMDCH   SET COMMAND CHAINING ON
RGOACCPT L     R2,IOBSTART
         L     R2,16(,R2)
RGOACCV  TM    1(R2),X'07'         IF BLOCK WITH ERROR WAS ALSO
         BO    RGORTEOS            EOS, LINK TO MERGE
         LR    R0,R6               SAVE ERROR CK RETURN REG
         BAS   R6,RGOTRKNO
         LR    R6,R0               RESTORE REGISTER
*
         IEREXCP  (R5)             READ NEXT BLOCK INTO SAME BUFFER
*
RGWAIT   L     R1,IOBECBPT
*
         IERWAIT  1,ECB=(1)        AREA AND WAIT UNTIL COMMAND IS
*                                  FINISHED
         B     RGOER100
RGOBR    B     RGOER110-8
*
*        PRIMING SUBROUTINE
*
RGOPR200 LA    R4,PPIWKARE         WORK AREA ADDR CONTAINS DRUM ADDR
         L     R6,PPISTIOB         FOR PRIMING
         LA    R6,4(,R6)
         LH    R2,PPIMRGMX
         STH   R2,KMRGMX
         SR    R3,R3
         SLL   R2,1
         IC    R3,PPILAB03         IF ONLY HAVE PARTIAL OVERLAP
         CR    R2,R3
         BNH   RGOPR205
         MVI   RGORFBF+1,X'F0'     SET UNCOND BRANCH IN PGM
         B     *+8
*
RGOPR205 MVI   RGORFBF+1,X'00'     RESET BRANCH TO NOP
         SRL   R2,1
         IC    R3,0(,R4)           INCR FOR
         L     R15,PPISTDCB
         L     R3,0(R3,R15)        DCB ADDR
RGOPR210 L     R5,0(,R6)           IOB ADDR
         ST    R3,IOBDCBPT         PLACE DCB ADDR AND
         MVC   IOBCC(5),3(R4)      DRUM ADDR IN THE IOB
*
         IEREXCP  (R5)             READ PRIME M BUFFERS
*
         LA    R6,4(,R6)           UPDATE IOB TABLE POINTER
         LA    R4,8(,R4)                  WORK AREA POINTER
         BCT   R2,RGOPR210
         L     R7,PPISTIOB
         LA    R3,4                INCR FOR IOB BUFFER AND BLCNT TABLES
         LH    R8,PPIMRGMX
         LA    R9,TFCNT
         LA    R4,PPIWKARE
RGOPR220 LA    R7,4(,R7)
*
*        WAIT ON M BUFFERS
*
         L     R5,0(,R7)           IOB ADDR
         L     R1,IOBECBPT
*
         IERWAIT 1,ECB=(1)         WAIT ON I/O COMPLETION
*
         BAS   R6,RGOER100         ERROR CHECK
RGOPR225 L     R14,PPISBLCT        STORE BLOCK COUNT IN TABLE
         ST    R1,0(R3,R14)        FOR DEBLOCK
         STC   R3,0(,R9)
         L     R14,IOBECBPT
         CLI   4(R14),X'02'        CHECK FOR ALTERNATE BUFFERS
         BE    RGOPR250
RGOPR230 MVC   2(2,R9),PPISRTBL    SET READ'S FILE COUNT TO SORT BLK
RGOBRVAR LA    R2,4(,R2)           FIX, BYPASS EOS INDICATOR
         ST    R2,0(,R4)           VAR, BYPASS EOS INDICATOR AND BCC
         STC   R3,0(,R4)           PASS RCD ADDR WITH INCR FOR MERGE
         LA    R9,4(,R9)           UPDATE
         LA    R4,4(,R4)           POINTERS
         LA    R3,4(,R3)
         BCT   R8,RGOPR220
         L     R11,PPIDEB2+4       GET ADDR OF BUFFER TABLE ROUTINE
         BR    R11                 BRANCH TO ROUTINE
*
RGOPR250 TM    1(R2),X'07'         IF EOS, DON'T ISSUE ANOTHER
         BO    RGOPR230            READ FOR THE FILE
         LH    R15,PPISRTBL        2*SRT BLK AS READ'S
         SLL   R15,1
         STH   R15,2(,R9)          FILE COUNT
         L     R15,IOBSTART        SWITCH THE CCW LIST
         MVC   IOBSTRTB,5(R14)     ADDR SO READ INTO
         ST    R15,4(,R14)         ALTERNATE BUFFER
         MVI   4(R14),X'02'
*
         IEREXCP  (R5)
*
         B     RGOBRVAR
*
*        READ DIRECTORY ROUTINE
*
RGODR300 SR    R3,R3
         IC    R3,PPIDIRAD         OBTAIN INCR FROM DRUM ADDR TO
         L     R1,PPISTDCB         OBTAIN CORRECT DCB ADDR
         L     R5,PPISTIOB         IOB TABLE
         L     R5,4(,R5)           FIRST INPUT IOB ADDR
         AR    R1,R3
         MVC   IOBDCBPT,0(R1)      PLACE DCB ADDR IN IOB
         MVC   KSAVE1(4),IOBSTART  SAVE CCW LIST ADDR FOR READ
         LA    R1,KRDDIR           PLACE DIR CCW LIST ADDR IN IOB
         ST    R1,IOBSTART
         ST    R14,KSAVE           SAVE RETURN REGISTER
         MVC   IOBCC(5),PPIDIRAD+3
         LA    R15,IOBCC           PLACE POINTER TO DRUM ADDR IN THE
         ST    R15,KRDDIR          DIRECTORY'S SEARCH ID CCW
         MVI   KRDDIR,SEARIDEQ
*
         IEREXCP  (R5)             READ DIRECTORY
*
         L     R1,IOBECBPT
*
         IERWAIT  1,ECB=(1)        WAIT ON I/O COMPLETION
*
         L     R1,IOBECBPT
         CLI   0(R1),ECBNORM       CHANNEL PROGRAM SUCCESSFUL ?
         BNE   RGOSSCBR            NO, TERMINATE THE JOB
RGODRRTN MVC   IOBSTART,KSAVE1     RESTORE CCW LIST ADDR IN IOB
         L     R14,KSAVE           AND RETURN REGISTER
         L     R11,PPIALG+4        SET ALGORITHM'S BASE REGISTER
         BR    R14                 RETURN TO IT
*
AE28     DC    A(0)                ADDR OF USER EXIT RTN
*
RGOSVEME DC    F'0'
KSAVE    DC    5F'0'
KSAVE1   DC    F'0'
KSAVEB   DC    F'0'
KFOUR    DC    AL2(4)
KMRGMX   DC    AL2(0)
*
TFCNT    DC    16F'0'              FILE COUNT TABLE
*
*        CCW LIST FOR READING THE DIRECTORY
*
KRDDIR   CCW   SEARIDEQ,0,CC+SLI,5  SEARCH ID
         CCW   TIC,KRDDIR,CC+SLI,0  TIC
         CCW   READDATA,0,SLI,64
*
./ ADD NAME=IERRGP   0101-20211-20211-1200-00087-00087-00000-RELEASE 00
RGP      TITLE 'IERRGP - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRGP - NOT SUPPORTED
*
*        MODULE FUNCTION/OPERATION -
*        THIS MODULE HANDLES DRUM INPUT TO THE FINAL MERGE PHASE
*        BY WAY OF THE EXCP MACRO. THE ROUTINE INTERFACES WITH
*        IOS, THE MERGE NETWORK AND THE DEBLOCK MODULE. IF E38 IS
*        ACTIVATED BY THE USER THE READ ROUTINE (ON A READ ERROR)
*        ALLOWS THE USER TO TRY AMD CORRECT THE ERROR AFTER IOS
*        HAS TRIED TO DO SO. IF THERE IS A PERMANENT READ ERROR
*        CONTROL IS PASSED TO SORT SYSTEM CONTROL TO TERMINATE THE JOB
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - IERAGP
*
*        MACROS USED BY MODULE -
*        SMPPI   EXCP
*        WAIT    CLOSE
*
*        ENTRY POINTS - ENTRY FROM DEBLOCK
*                         CALLING SEQUENCE
*                         L  R11,PPIRD+4
*                         B  4(,R11)
*                            DISP 0= DUMMY
*                            DISP 4= DEBLOCK
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPISTIOB   PPILAB02
*        PPISBLCT   PPIPSVA
*        PPILAB03   PPIADSSC
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPISRTBL   PPIRCDL2
*        PPICNTL    PPIWKARE
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL -
*        IERDD34 - NORMAL INTERFACE
*        IERDO1  - EOS EXIT
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS -
*        FILE COUNT TABLE
*
*        NOTES - N/A
*
IERRGP   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRGP SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRGPI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
*        IERCCWEQ
*
         IERCCWEQ
*
*        IERIOB
*
         IERIOB
*
         PRINT NOGEN
*
         DCBD  DSORG=PS,DEVD=(DA)
*
         IHAECB DSECT=NO,EXT=NO
*
         IEZDEB LIST=NO
*
         PRINT GEN
*
         SMPPI
*
         END
./ ADD NAME=IERRGPI  0101-20211-20211-1200-00345-00345-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERRGP SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERRGPI - NOT SUPPORTED
*
         USING *,R11
         USING IERRCA,R13
         USING IOBSTDRD,R5         SET IOB ADDRESSABILITY
*
IERDGB3  NOP   IERDGB3             +00 DUMMY ENTRY
         STM   R2,R6,KSAVE         +04 DEBLOCK ENTRY
         ST    R2,IERDGB3
         L     R5,PPISTIOB         ADDR OF IOB TABLE
         L     R5,0(R3,R5)         IOB ADDR VIA INCR AND TABLE ADDR
RGPEOSCK CLI   1(R2),C'G'          CHECK FOR EOS BYTE 1 OF
         BE    RGPEOS              EOS INDICATION WORD
         L     R1,IOBECBPT         NO OF BUFFERS ATTACHED
         TM    4(R1),X'02'         TO THIS FILE(IOB) 2 ?
         BO    RGPAL020            YES, FILE HAS AN ALTERNATE BUFFER
*
*        FILE ONLY HAS ONE BUFFER ATTACHED TO THE IOB
*
         IEREXCP  (R5)                READ DRUM
*
         L     R1,IOBECBPT
*
         IERWAIT  1,ECB=(1)        WAIT ON I/O COMPLETION
*
         BAS   R6,RGPER100         CALL ERROR CHECK RTN
         LH    R2,KCOUNT           AVAILABLE BUFFER ON
         BCT   R2,RGPBF010         LIST TO ATTACH TO FILE
RGPRTRN  LM    R2,R6,KSAVE
         L     R11,PPIDEB+4        GET DEBLOCK ROUTINE
RGPRTRNV LA    R2,4(,R2)           FIX - BYPASS EOS INDICATOR
*                                  VAR - BYPASS EOS INDICATOR AND BCC
         BR    R11
*
*        ATTACH AN ALTERNATE BUFFER TO THE FILE
*        BUFFER FREED BY AN EOS-EOA ON ANOTHER FILE
*
RGPBF010 TM    1(R4),X'07'         IF PREVIOUS BUFFER EOS, DON'T
         BO    RGPRTRN             ATTACH TO THIS FILE
         STH   R2,KCOUNT
         L     R2,PPILAB02         OBTAIN BUFFER FROM LIST
         BAS   R6,RGPIOBUP         UPDATE IOB, ATTACH THE BUFFER
         LA    R2,4(,R2)           UPDATE
         ST    R2,PPILAB02         THE LIST
         IC    R2,KTOTAL           AND KTOTAL
         LA    R2,1(,R2)
         STC   R2,KTOTAL
         STC   R3,RGPINST+1
         LH    R0,PPISRTBL
         LA    R6,RGPRTRN
RGPFLUP  LA    R2,TFCNT            FIND FILE COUNT IN ORDER TO
RGPINST  CLI   0(R2),X'00'         UPDATE IT
         BZ    RGPBF015
         LA    R2,4(,R2)
         B     RGPINST
*
RGPBF015 L     R4,0(,R2)           ADD SORT BLOCKING
         AR    R4,R0               OR 32,768 (FOR EOA/EOS)
         ST    R4,0(,R2)
         BR    R6                  BRANCH TO FILE COUNT
*
*        FILE HAS AN ALTERNATE BUFFER ATTACHED TO THE IOB
*
RGPAL020 L     R1,IOBECBPT
*
         IERWAIT  1,ECB=(1)        WAIT ON ALTERNATE
*
         BAS   R6,RGPER100         CALL ERROR CHECK RTN
*
*        FULL OVERLAP TEST
*        1 FOR 2M AREAS, ATTACH BUFFER TO SAME FILE (FULL OVERLAP)
*        2 FOR PARTIAL OVERLAP, ATTACH BUFFER TO FILE WITH LEAST
*                               NO OF RECORDS LEFT IN ITS BUFFER(S)
*
RGPK2M   CLI   KTOTAL,X'00'
         BL    RGPFL030
RGPAL025 LA    R2,IERDGB3          ATTACH THE BUFFER TO THE
         LA    R6,RGPRTRN          SAME FILE
         TM    1(R4),X'07'         IF PREVIOUS BUFFER EOS, DON'T
         BOR   R6                  START NEW READ ON FILE
RGPIOBUP L     R4,IOBSTART         ATTACH THE ALTERNATE BUFFER TO
         L     R15,IOBECBPT
         MVC   IOBSTRTB,5(R15)     THE IOB VIA THE CCW LIST
         ST    R4,4(,R15)
         L     R4,IOBSTART
         MVC   17(3,R4),1(R2)      STORE BUFFER ADDR IN THE READ CCW
         MVI   4(R15),X'02'        UPDATE NO OF BUFFERS ATTACHED
         LR    R4,R1               SAVE BLOCK COUNT ON COMPLETED READ
*
         IEREXCP  (R5)             READ
*
         LR    R1,R4               RESTORE BLOCK COUNT FOR DEBLOCK
         BR    R6
*
*        PARTIAL OVERLAP - SCAN FILE COUNTERS TO DETERMINE WHICH
*        FILE TO ATTACH ALTERNATE BUFFER FOR THE NEXT READ
*
RGPFL030 LA    R2,TFCNT            FILE COUNT TABLE ADDR
         ST    R1,KSAVEB           SAVE BLOCK CNT FOR DEBLOCK
         L     R1,PPISBLCT
         LH    R6,KMRGMX
         LA    R4,PPIPSVA
         SR    R14,R14
         ST    R14,0(R3,R1)        SET RELEASED FILE'S BLCNT=0
RGPFL040 IC    R14,0(,R2)          OBTAIN DEBLOCK'S BLOCK COUNTERS
         L     R15,0(R14,R1)
         A     R15,0(,R2)          ADD THEM TO READ'S APPROPRIATE
         ST    R15,0(,R4)
         LA    R2,4(,R2)           FILE COUNTERS
         LA    R4,4(,R4)
         BCT   R6,RGPFL040
         LA    R2,PPIPSVA
         LH    R1,KMRGMX
         STC   R3,RGPINST1+1
         LR    R4,R2
         B     RGPINST1
*
RGPFL050 LA    R4,4(0,R4)          SCAN FOR LOWEST FILE COUNT
         CLC   1(3,R2),1(R4)
         BH    RGPEX060            AND FOR THE RELEASED
RGPINST1 CLI   0(R4),X'00'
         BE    RGPRL070            FILE COUNT
RGPLPEND BCT   R1,RGPFL050
         LA    R0,PPIPSVA          OBTAIN FILE COUNT ADDR VIA
         SR    R2,R0               DISPLACEMENTS OF LOWEST AND
         SR    R15,R0              RELEASED FROM PPIPSVA
         LA    R0,TFCNT
         AR    R15,R0
         AR    R2,R0
         L     R4,IOBECBPT         RELEASED FILE'S NO OF BUFFERS
         MVI   4(R4),X'01'         ATTACHED TO IOB
         LR    R14,R5
         IC    R1,0(,R2)           INCR IN NEW FILE COUNT'S FIRST BYTE
         L     R5,PPISTIOB
         L     R5,0(R1,R5)         IOB ADDR OF NEW FILE
         L     R4,IOBSTART
         L     R4,16(,R4)
         L     R1,KSAVEB           RESTORE BLOCK CNT
RGPFBV   TM    1(R4),X'07'         EOS ?
         BZ    RGPCONT
         LR    R5,R14
         B     RGPAL025
*
RGPCONT  L     R4,0(,R2)           UPDATE
         AH    R4,PPISRTBL
         ST    R4,0(,R2)           NEW FILE COUNT
         L     R4,0(,R15)
         SH    R4,PPISRTBL
         ST    R4,0(,R15)          RELEASED FILE COUNT
         B     RGPAL025
*
RGPEX060 LR    R2,R4               ADDR OF LOWEST FILE COUNT IN PPI
         B     RGPINST1            SAVE AREA
*
RGPRL070 LR    R15,R4              ADDR OF RELEASED FILE COUNT IN PPI
         B     RGPLPEND            SAVE AREA
*
*        END OF SEQUENCE - MAKE BUFFER(S) ATTACHED TO THIS FILE'S
*        IOB AVAILABLE
*
RGPEOS   L     R4,IOBSTART
         L     R2,PPILAB02         UPDATE THE AVAILABLE LIST BY 1 OR 2
         LH    R14,KCOUNT
         SH    R2,KFOUR            BUFFERS
         MVC   1(3,R2),17(R4)      PLACE BUFFER ADDR ON LIST
         LA    R14,1(0,R14)        ADD ONE TO LIST'S COUNT
         L     R15,IOBECBPT
         CLI   4(R15),X'02'        CK NO OF BUFFERS ATTACHED TO FILE'S
         BNE   RGPDONE             IOB
         MVI   4(R15),X'01'        SET NO TO 1 TO FALL THROUGH ABOVE
         L     R4,4(,R15)          TEST THE NEXT TIME
         B     RGPEOS+12
*
RGPDONE  STH   R14,KCOUNT          SAVE LIST COUNT
         ST    R2,PPILAB02         AND POINTER
         LH    R0,KNNINE
         STC   R3,RGPINST+1        UPDATE FILE COUNT
         BAS   R6,RGPFLUP          TO 32,768
         SR    R0,R0
         IC    R0,RGPK2M+1         GET 2*M
         SH    R0,KTWO             REDUCE MERGE ORDER
         STC   R0,RGPK2M+1
         L     R11,PPINET+4        GOTO NETWORK
         B     4(,R11)
*
*        ERROR CHECK OF BUFFER READ HAS COMPLETED
*
RGPER100 L     R1,IOBECBPT
         CLI   0(R1),ECBNORM       CHANNEL PROGRAM COMPLETE NO ERROR ?
         BNE   RGPRESET
RGPER110 L     R4,IOBSTART         CCW ADDR
         L     R4,16(,R4)          BUFFER ADDR
RGPVBCC  LH    R1,PPILAB03+2       FOR VAR LH R1,0(,R4)   IE LOAD
         SH    R1,KFOUR
         NOP   RGPVAR              BCC FROM BUFFER
         SH    R1,IOBCSW+5         SUBTRACT CSW RESIDUAL COUNT
         SR    R14,R14             IF FIXED RCD FORMAT
RGPFIX   SH    R1,PPIRCDL2
         LA    R14,1(,R14)
         CH    R1,PPIRCDL2
         BNL   RGPFIX
         LR    R1,R14
RGPVAR   ST    R4,KSAVE            STARTING
         ST    R4,KSAVE+8          BUFFER ADDR
         MVI   KSAVE,X'00'
*
*        UPDATE THE DRUM ADDR FOR NEXT TIME THROUGH - MBBCCHHR
*
RGPTRKNO CLC   IOBR,PPIBPTRK+1     TRACK FULL ?
         BE    RGPUPH              YES, UPDATE HEAD
         IC    R15,IOBR
         LA    R15,1(,R15)         INCR RECORD COUNT BY 1
         STC   R15,IOBR
         BR    R6
*
RGPUPH   MVI   IOBR,X'01'          RESET RECORD NUMBER TO 1
*
*        LOCATE THE DCB
*
         L     R15,IOBDCBPT        R15 -> DCB
         USING IHADCB,R15
*
*        SETUP FOR EXCP
*        CONVERT MBBCCHHR -> TTR
*
         STM   R14,12,12(R13)      SAVE REGS ACROSS RTN
         LR    R3,R13              SAVE R13
         L     R1,DCBDEBAD         R1 -> DEB
         LA    R2,IOBSEEK          R2 -> MBBCCHHR
         L     R15,PPIPRLTV        R15 -> CONVERSION RTN
         BASR  R14,R15             CONVERT MBBCCHHR -> TTR
         LR    R13,R3              RESTORE R13
         LTR   R15,R15          *  SET CC
         LM    R14,R15,12(R13)  |  RESTORE REGS, DO NOT RESTORE R0
         LM    R1,R12,24(R13)   |
         BNZ   RGPSSCBR         V  CONVERSION FAILED, TERMINATE SORT
*
*        INCR TT
*
         AL    R0,ADDTRK           INCR TT ONLY IN TTRN
*
*        SETUP FOR EXCP
*        CONVERT TTR -> MBBCCHHR
*
         STM   R14,12,12(R13)      SAVE REGS ACROSS RTN
         LR    R3,R13              SAVE R13
         L     R1,DCBDEBAD         R1 -> DEB
         LA    R2,DCBFDAD          R2 -> MBBCCHHR RESULT
         L     R15,PPIPCNVT        R15 -> CONVERSION RTN
         BASR  R14,R15             CONVERT TTR -> MBBCCHHR
         LR    R13,R3
         LTR   R15,R15          *  SET CC
         LM    R14,R12,12(R13)  |  RESTORE REGS
         BNZ   RGPSSCBR         V  CONVERSION FAILED, TERMINATE SORT
         MVC   IOBSEEK,DCBFDAD     MOVE UPDATED SEARCH ADDR TO IOB
         BR    R6                  RETURN TO MAINLINE
*
         DROP  R15
*
RGPRESET CLI   0(R1),ECBREPRG      REQUEST ELEMENT AVAIL AFTER PURGE ?
         BNE   RGPERROR            NO, ERROR CONDITION
*
*        REQUEST PURGED DUE TO I/O ERROR ON PREVIOUS READ
*        RESTORE REQUEST QUEUE
*
         L     R1,IOBDCBPT         R1 -> DCB
         USING IHADCB,R1
         NI    DCBIFLGS,255-DCBIFPEC  RESET I/O
         OI    IOBFLAG1,IOBCMDCH   SET COMMAND CHAINING ON
         L     R1,DCBDEBAD         R1 -> DEB
         USING DEBBASIC,R1
         LA    R1,DEBUSRPG         POINT TO FIRST PURGED IOB ADDR
         DROP  R1
         IERESTOR (1)              RESTORE SVC
*
         B     RGWAIT
*
*        READ ERROR HAS OCCURRED - CHECK TO SEE IF USER EXIT E38
*        WAS ACTIVATED AT ASSIGNMENT TIME
*
RGPERROR PPISETON PPIREADE         TURN ON ERROR BIT IN PPI
RGPTERM  NOP   RGPSSCBR
         L     R1,IOBDCBPT         DCB ADDR
         ST    R5,PPIWKARE         SET IOB ADDR WITH
         MVI   PPIWKARE,X'10'      INCREMENT TO CCW ADDR IN
         L     R0,PPIWKARE         THE HIGH ORDER BYTE
*
*        CALL USER EXIT E38
*        LINK TO E38 IS OVERLAYED IF NOT ACTIVATED
*
         L     R15,AE38            R15 -> E38
         BASR  R14,R15             CALL E38
RGPSSCBR ST    R4,RGPSVEME
         L     R15,PPIADSSC        TERMINATE OPTION ON OVERLAY FOR
         BAS   R14,16(,R15)        NO RETURN
*
RGPSKIP  NI    IOBUSTAT,255-UC-UE  IF ERROR ACCEPTED
         NI    IOBCSTAT,255-IL-CDC
         L     R1,IOBDCBPT            RESET ALL ERROR BITS SET BY IOS
         USING IHADCB,R1              IN THE IOB AND DCB
         NI    DCBIFLGS,255-DCBIFPEC  RESET I/O
         L     R1,DCBDEBAD         R1 -> DEB
         USING DEBBASIC,R1
         LA    R1,DEBUSRPG         POINT TO FIRST PURGED IOB ADDR
         DROP  R1
         IERESTOR (1)              RESTORE SVC
         OI    IOBFLAG1,IOBCMDCH   SET COMMAND CHAINING ON
RGPACCPT L     R2,IOBSTART
         L     R2,16(,R2)          IF BLOCK WITH ERROR WAS ALSO
RGPACCV  TM    1(R2),X'07'         EOS ?
         BO    RGPEOS              YES, BRANCH
         BAS   R6,RGPTRKNO
*
         IEREXCP  (R5)             READ NEXT BLOCK INTO
*
RGWAIT   L     R1,IOBECBPT
*
         IERWAIT 1,ECB=(1)         WAIT ON I/O COMPLETION
*
         B     RGPER100
*
RGPBR    B     RGPER110
*
RGPSVEME DC    F'0'
KSAVE    DC    5F'0'
KSAVEB   DC    F'0'
ADDTRK   DC    X'00010000'         ADD 1 TO TTRN
KCOUNT   DC    H'1'
KTOTAL   DC    X'0000'
KTWO     DC    H'2'
KFOUR    DC    H'4'
KMRGMX   DC    H'0'
KNNINE   DC    X'7FFF'
*
TFCNT    DC    16F'0'              FILE COUNT TABLE
*
AE38     DC    A(0)                USER ERROR ROUTINE
*
./ ADD NAME=IERRMA   0101-20211-20211-1200-00038-00038-00000-RELEASE 00
RMA      TITLE 'IERRMA - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRMA
*
*        MODULE FUNCTION/OPERATION - THIS MODULE CONTAINS ALL OF
*        THE MESSAGES THAT ARE REQUIRED FOR PHASE 1 RUNNING
*        PROGRAM
*
*        USED AS A DSECT IN -
*        IERADD,-ADE,-ADR,-ADS
*        -RDD,-RDE,-RDR,-RDS
*        -AOI,-AIJ,-AOK,-AOO
*        -9ON,-ROI,-ROJ,-ROK
*        -ROO,-8ON,-RPC
*
*        MACROS USED - N/A
*
*        ENTRY POINTS - N/A
*
*        INPUT - PPI FIELDS REFERENCED - N/A
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED - N/A
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL - N/A
*
*        EXITS - ERROR N/A
*
*        TABLES/WORK AREAS - N/A
*
IERRMA   CSECT
*
         COPY  RMAMAIN
*
         END
./ ADD NAME=IERRMB   0101-20211-20211-1200-00036-00036-00000-RELEASE 00
RMB      TITLE 'IERRMB - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRMB
*
*        MODULE FUNCTION/OPERATION -
*        THIS MODULE CONTAINS ALL OF THE MESSAGES THAT ARE
*        REQUIRED FOR PHASE 2 RUNNING PROGRAM
*
*        USED AS A DSECT IN -
*        IERAON,-AOR,-AOS
*        -RON,-ROR,-ROS
*        -RPF,-RPM,-8PM
*
*        MACROS USED - N/A
*
*        ENTRY POINTS - N/A
*
*        INPUT - PPI FIELDS REFERENCED - N/A
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED - N/A
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL - N/A
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS - N/A
*
IERRMB   CSECT
*
         COPY  RMBMAIN
*
         END
./ ADD NAME=IERRMC   0101-20211-20211-1200-00036-00036-00000-RELEASE 00
RMC      TITLE 'IERRMC - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRMC
*
*        MODULE FUNCTION/OPERATION -
*        THIS MODULE CONTAINS ALL OF THE MESSAGES THAT ARE
*        REQUIRED FOR PHASE 3 RUNNING PROGRAM
*
*        USED AS A DSECT IN -
*        IERRPG
*        -AOP,-AOQ,-AOU,-AOV
*        -ROP,-ROQ,-ROU,-ROV
*
*        MACROS USED - N/A
*
*        ENTRY POINTS - N/A
*
*        INPUT - PPI FIELDS REFERENCED - N/A
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED - N/A
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL - N/A
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS - N/A
*
IERRMC   CSECT
*
         COPY RMCMAIN
*
         END
./ ADD NAME=IERROA   0101-20211-20211-1200-00086-00086-00000-RELEASE 00
ROA      TITLE 'IERROA - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERROA
*
*        MODULE FUNCTION/OPERATION -
*        REPLACEMENT NETWORK FOR FIXED LENGTH RECORDS CONTAINING
*        MULTIPLE CONTROL FIELDS. THIS MODULE GENERATES
*        ASCENDING OR DESCENDING SEQUENCES USING A REPLACEMENT
*        SELECTION TECHNIQUE
*
*        MODULES IN WHICH THIS MODULE APPEARS AS A DSECT -
*        IERAOA, IERROW, IERAOW
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM INITIAL WRITE ROUTINE
*                       CALLING SEQUENCE -
*                         L   R11,PPINET
*                         BR  R11 ENTER NETWORK TO FILL TREE
*
*                     - ENTRY FROM DEBLOCK ROUTINE
*                       CALLING SEQUENCE -
*                         L  R11,PPINET
*                         B  X(,R11)
*                         WHERE X = 4  FOR ENTRY WHILE FILLING
*                                 = 8  FOR ENTRY AT EOF
*                                 = 12 FOR ENTRY WHILE RUNNING
*                                 = 16 FOR ENTRY AFTER EOF
*
*        INPUT - PPI FIELDS REFERENCED - PPISRTG
*        COMPARES FILE SIZE TO G (PPISRTG)
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED - N/A
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL - ADDR IN PPIDEB+4 (DEBLOCK)
*                         PLUS DISP = 8 WHEN FILLING TREE
*
*                         PLUS DISP = 0 FIRST TIME AFTER TREE IS
*                         FILLED
*
*                       - ADDR IN PPIADSSC
*                         PLUS DISP = 20 TO CLOSE WHEN INPUT
*                         FILE WAS ZERO
*
*                       - ADDR IN PPIBLK+4 (BLOCK)
*                         PLUS DISP = 0 TO BLOCK AT END OF FILE
*
*                         PLUS DISP = 4 TO BLOCK AT END OF
*                         SEQUENCE
*
*                         PLUS DISP = 12 FOR NORMAL BLOCK
*
*                       - ADDR IN R12 TO EQUALS ROUTINE
*
*        EXITS ERROR - N/A
*
*        TABLES/WORK AREAS -
*        WASAVE   - FILLING REGISTER SAVE AREA
*        WATREE   - LOCATION OF THE TREE
*        WALTNODE - ADDR OF LAST TEST NODE
*
*        NOTES - N/A
*
IERROA   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERROA SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERROAI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERROAI  0101-20211-20211-1200-00593-00593-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERROA SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERROAI
*
         USING *,R11
         USING IERRCA,R13
*
*        ENTRY TABLE
*
IERDOA   B     OAPICK              +00 FILL TREE
         B     OAFIRET             +04 DEBLOCK WHILE FILLING
         B     OAEOF               +08 DEBLOCK AT EOF
         B     OARETRUN            +12 DEBLOCK WHILE RUNNING
         B     OARETEOF            +16 DEBLOCK AFTER EOF
*
*        INITIAL ENTRY TO START FILLING OR ENTRY TO CONTINUE
*        FILLING TREE
*
OAPICK   L     R11,PPIDEB+4        DEBLOCK BASE REGISTER
*
*        EXIT TO DEBLOCK ROUTINE
*
         B     8(,R11)             GET TO FILL
*
*        ENTRY FROM DEBLOCK WHILE FILLING
*
*        SETS UP TO FILL THE TREE AND DETERMINES WHEN THE TREE
*        IS FILLED
*
OAFIRET  S     R3,KAFOUR           DECREMENT NEW ADDR BY FOUR BYTES
         LM    R7,R9,WASAVE        FILLING REGISTERS
         ST    R9,0(,R3)           ADDR OF TREE WITH RECORD
OAFILDUM LR    R5,R9               ADDR OF TREE (NLA)
         BCT   R7,OAGCT            DECREMENT WAY COUNTER
         LA    R7,4                RESET WAY COUNTER
         LA    R9,20(,R9)          INCREMENT TO NEXT NODE
OAGCT    BCT   R8,OAMORE           DECREMENT G COUNTER
         L     R4,OASAME           SET MODE
         STM   R7,R9,WASAVE
         CLC   OAGCT+4(4),OANOSAME   RUNNING OR FLUSHING ?
         BNE   OANEXT2               RUNNING SITUATION
         MVC   OACASE44(4),OA44FLSH  OVERLAY TO BRANCH TO FLUSH ROUTINE
         MVC   OACAS27(2),KNOP     NOP THE BR INSTR TO THE FILL ROUTINE
         MVC   OACAS15(2),KNOP     NOP THE BR INSTR TO THE FILL ROUTINE
         MVC   OACASE41(4),OA41FLSH  OVERLAY TO BR TO FLUSH RTN CASE
         L     R7,12(,R5)
         CL    R7,WATREE           FILE SIZE = G - 2 ?
         BL    OANEXT2             SET LAST NODE
         LA    R7,48               TO FORMAT 30
         ST    R7,4(,R5)
         B     OANEXT2             FLUSHING SITUATION
*
OAMORE   L     R4,OAFILL           SET MODE
         STM   R7,R9,WASAVE        SAVE FILLING REGISTERS
         B     OANEXT2
*
*        ENTRY FROM DEBLOCK AT EOF
*
*        DETERMINES IF EOF SITUATION IS A NORMAL ONE, FILE SIZE
*        LESS THEN G, OR FILE SIZE IS ZERO AND BRANCHES
*        ACCORDINGLY
*
OAEOF    CLC   PPISRTG,WASAVE+4    COMPARE G COUNT IN PPI TO FILL NO
         BNE   OANOZERO
*
*        EXIT TO CLOSE ROUTINE
*
         LA    R1,4                SET UP PARAMETER TO END OF PHASE
         L     R15,PPIADSSC        R15 -> SSC
         BAS   R14,20(,R15)        INPUT FILE WAS ZERO
*
OANOZERO LA    R10,0               CONSTANT OF 0
         CL    R10,WASAVE+4        COMPARE TO FILL COUNT
         BE    OARETEOF
*
*        FILE SIZE IS LESS THAN G
*        THE CODING IS MODIFIED TO FILL THE REMAINDER OF THE
*        TREE WITH FAKE RECORDS. THESE RECORDS ARE THE TREE
*        ADDRESSES
*
         MVC   OACASE44(4),OA44FILL  MOD TO CHECK FOR DUMMY RCD
         MVC   OACAS27(4),OAMODC27   MOD TO CHECK FOR DUMMY RCD
         MVC   OACAS15(4),OAMODC15   MOD TO CHECK FOR DUMMY RCD
         MVC   OAC8A(6),OACHMVC     MODIFICATION TO CHECK FOR DUMMY REC
         OI    OACSUB8+1,X'F0'      INITIALIZE BRANCH INST IN CASE 8
         MVC   OAGCT+4(4),OANOSAME  MODIFICATION TO START TREE FLUSHING
         MVC   OAPICK(12),OAMODIFY  MODIFY FILLING RETURN LOCATION
OAMODIFY LM    R7,R9,WASAVE    *    FILLING REGISTERS
         L     R3,WATREE       |    DUMMY ADDR
         B     OAFILDUM        V
*
*        MODE POSITIONS AND BRANCH TABLE
*        THROUGH THE COMBINATION OF MODE AND FORMAT AN INDEXED
*        BRANCH IS PERFORMED WHICH BRANCHES TO THE CASE WHICH
*        HANDLES THE INDICATED SITUATION
*
OAFLUSH  DC    A(OABTABLE)
OANEW    DC    A(OABTABLE+4)
OAFILL   DC    A(OABTABLE+8)
OASAME   DC    A(OABTABLE+12)
OABTABLE B     OANEXT
         B     OANEXT
         B     OACASE3
         B     OANEXT
         B     OACASE5
         B     OACASE6
         DC    A(0)                SPACE TO MAINTAIN POSITIONS IN TABLE
OAMODLOC B     OACASE8
         B     OACASE9
         B     OACASE10
         DC    A(0)                SPACE TO MAINTAIN POSITIONS IN TABLE
         B     OANEXT
         B     OACASE13
         B     OACASE14
         B     OACASE15
         B     OACASE16
         B     OACASE17
         B     OACASE18
         DC    A(0)                SPACE TO MAINTAIN POSITIONS IN TABLE
         B     OANEXT
         B     OACASE21
         B     OACASE22
         DC    A(0)                SPACE TO MAINTAIN POSITIONS IN TABLE
         B     OACASE16
         B     OACASE25
         B     OACASE26
         B     OACASE27
         B     OACASE28
         B     OACASE29
         B     OACASE30
         DC    A(0)                SPACE TO MAINTAIN POSITIONS IN TABLE
         B     OANEXT
         B     OACASE33
         B     OACASE34
         DC    A(0)                SPACE TO MAINTAIN POSITIONS IN TABLE
         B     OACASE16
         B     OACASE37
         B     OACASE38
         DC    A(0)                SPACE TO MAINTAIN POSITIONS IN TABLE
         B     OACASE28
         B     OACASE41
         B     OACASE42
         B     OACASE44
         B     OACASE44
*
*        CASE - S/SSS SITUATION WHILE RUNNING
*
OACASE44 NOP   *+4                 WILL BE BAL R14,OASUB1 ON FILE < G
*                                  FILL,ORBAL R14 OASUBF44 FLUSH
         CLC   0(1,R3),0(R8)       COMPARE WINNER TO LOSER 2
         BNE   OAC44A
         LR    R2,R8               LOAD ADDR FOR EQUALS
*
*        EXIT TO EQUALS ROUTINE
*
         BASR  R14,R12             LINK TO EQUALS ROUTINE
*
*
OAC44A   BNH   OACASE16
         CLC   0(1,R3),0(R9)       COMPARE WINNER TO LOSER 3
         BNE   OAC44B
         LR    R2,R9               LOAD ADDR FOR EQUALS
*
*        EXIT TO EQUALS ROUTINE
*
         BASR  R14,R12             LINK TO EQUALS ROUTINE
*
OAC44B   BNH   OASHIFT3
OASHIFT4 STM   R8,R9,8(R5)         LOSER 2 + 3 TO LOSER 1 + 2
         ST    R3,16(,R5)          WINNER TO LOSER 3
         LR    R3,R7               LOSER 1 TO WINNER
OANEXT   L     R5,0(,R5)           ADDR OF NEXT NODE
OANEXT2  LM    R6,R9,4(R5)         LOAD NODE
         B     0(R4,R6)            GOTO PROPER CASE
*
*        CASE - N/SSS SITUATION WHILE RUNNING
*
OACASE42 L     R4,OASAME           UPDATE MODE
         LA    R10,144             FORMAT SSN
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OASHIFT4
*
*        CASE - -/SSS SITUATION WHILE FLUSHING
*
OACASE41 NOP   OASUBF41            WILL BE BAL R14,OASUBF41 WHEN FLUSHG
OASUB41  L     R4,OASAME           UPDATE MODE
         LA    R10,96              FORMAT SS-
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OASHIFT4
*
*        CASE - N/SSN SITUATION WHILE RUNNING
*
OACASE38 L     R4,OASAME           UPDATE MODE
         LA    R10,128             FORMAT SNN
         ST    R10,4(,R5)          UPDATE FORMAT
OAC38A   CLC   0(1,R3),0(R9)       COMPARE WINNER TO LOSER 3
         BNE   OAC38B
         LR    R2,R9               LOAD ADDR FOR EQUALS
*
*        EXIT TO EQUALS ROUTINE
*
         BASR  R14,R12             LINK TO EQUALS ROUTINE
*
OAC38B   BNH   OASHIFT3
         B     OASHIFT4
*
*        CASE - -/SSN SITUATION WHILE FLUSHING
*
OACASE37 L     R4,OASAME           UPDATE MODE
         LA    R10,80              FORMAT SN-
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OASHIFT4
*
*        CASE - N/SNN SITUATION WHILE RUNNING
*
OACASE34 L     R4,OASAME           UPDATE MODE
         LA    R10,112             FORMAT NNN
         ST    R10,4(,R5)          UPDATE FORMAT
         CLC   0(1,R3),0(R8)       COMPARE WINNER TO LOSER 2
         BNE   OAC34A
         LR    R2,R8               LOAD ADDR FOR EQUALS
*
*        EXIT TO EQUALS ROUTINE
*
         BASR  R14,R12             LINK TO EQUALS ROUTINE
*
OAC34A   BNH   OASHIFT2
         B     OAC38A
*
*        CASE - -/SNN SITUATION WHILE FLUSHING
*
OACASE33 L     R4,OASAME           UPDATE MODE
         LA    R10,64              FORMAT NN-
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OASHIFT4
*
*        CASE - N/NNN SITUATION WHILE RUNNING
*
OACASE30 LA    R10,160             FORMAT SSS
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OACASE44
*
*        CASE - -/NNN SITUATION WHILE FLUSHING
*
OACASE29 L     R4,OANEW            UPDATE MODE
         LA    R10,96              FORMAT SS-
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OASHIFT4
*
*        CASE - S/SS- SITUATION WHILE RUNNING
*
OACASE28 CLC   0(1,R3),0(R8)       COMPARE WINNER TO LOSER 2
         BNE   OAC28A
         LR    R2,R8               LOAD ADDR FOR EQUALS
*
*        EXIT TO EQUALS ROUTINE
*
         BASR  R14,R12             LINK TO EQUALS ROUTINE
*
OAC28A   BNH   OACASE16
OASHIFT3 ST    R8,8(,R5)           LOSER 2 TO LOSER 1
         ST    R3,12(,R5)          WINNER TO LOSER 2
         LR    R3,R7               LOSER 1 TO WINNER
         L     R5,0(,R5)           ADDR OF NEXT NODE
         LM    R6,R9,4(R5)         LOAD NODE
         B     0(R4,R6)            GOTO PROPER CASE
*
*        CASE - S/SS- SITUATION WHILE FILLING
*
OACASE27 LA    R10,160             FORMAT SSS
         ST    R10,4(,R5)          UPDATE FORMAT
OACAS27  NOP   *+4                 WILL BE BAL R14,OASUB2 ON FILE < G
         CLC   0(1,R3),0(R8)       COMPARE WINNER TO HIGH 2
         BNE   OAC27A
         LR    R2,R8               LOAD ADDR FOR EQUALS
*
*        EXIT TO EQUALS ROUTINE
*
         BASR  R14,R12             LINK TO EQUALS ROUTINE
*
OAC27A   BNH   OAC27B
OASUB2R  ST    R3,16(,R5)          WINNER TO LOSER 3
         B     OAPICK
*
OAC27B   CLC   0(1,R3),0(R7)       COMPARE WINNER TO LOSER 1
         BNE   OAC27C
         LR    R2,R7               LOAD ADDR FOR EQUALS
*
*        EXIT TO EQUALS ROUTINE
*
         BASR  R14,R12             LINK TO EQUALS ROUTINE
*
OAC27C   BNH   OAC27D
         ST    R8,16(,R5)          LOSER 2 TO LOSER 3
         ST    R3,12(,R5)          WINNER TO LOSER 2
         B     OAPICK
*
OAC27D   STM   R7,R8,12(R5)        LOSER 1 + 2 TO LOSER 2 + 3
         ST    R3,8(,R5)           WINNER TO LOSER 1
         B     OAPICK
*
*        CASE - N/SS- SITUATION WHILE RUNNING
*
OACASE26 L     R4,OASAME           UPDATE MODE
         LA    R10,80              FORMAT SN-
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OASHIFT3
*
*        CASE - -/SS- SITUATION WHILE FLUSHING
*
OACASE25 L     R4,OASAME           UPDATE MODE
         LA    R10,48              FORMAT S--
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OASHIFT3
*
*        CASE - N/SN- SITUATION WHILE RUNNING
*
OACASE22 L     R4,OASAME           UPDATE MODE
         LA    R10,64              FORMAT NN-
         ST    R10,4(,R5)          UPDATE FORMAT
         CLC   0(1,R3),0(R8)       COMPARE WINNER TO LOSER 2
         BNE   OAC22A
         LR    R2,R8               LOAD ADDR FOR EQUALS
*
*        EXIT TO EQUALS ROUTINE
*
         BASR  R14,R12             LINK TO EQUALS ROUTINE
*
OAC22A   BNH   OASHIFT2
         B     OASHIFT3
*
*        CASE - -/SN- SITUATION WHILE FLUSHING
*
OACASE21 L     R4,OASAME           UPDATE MODE
         LA    R10,32              FORMAT N--
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OASHIFT3
*
*        CASE - N/NN- SITUATION WHILE RUNNING
*
OACASE18 LA    R10,96              FORMAT SS-
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OACASE28
*
*        CASE - -/NN- SITUATION WHILE FLUSHING
*
OACASE17 L     R4,OANEW            UPDATE MODE
         LA    R10,48              FORMAT S--
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OASHIFT3
*
*        CASE - S/S-- SITUATION WHILE RUNNING
*
OACASE16 CLC   0(1,R3),0(R7)       COMPARE WINNER TO LOSER 1
         BNE   OAC16A
         LR    R2,R7               LOAD ADDR FOR EQUALS
*
*        EXIT TO EQUALS ROUTINE
*
         BASR  R14,R12             LINK TO EQUALS ROUTINE
*
OAC16A   BNH   OANEXT
OASHIFT2 ST    R3,8(,R5)           WINNER TO LOSER 1
         LR    R3,R7               LOSER 1 TO WINNER
         L     R5,0(,R5)           ADDR OF NEXT NODE
         LM    R6,R9,4(R5)         LOAD NODE
         B     0(R4,R6)            GOTO PROPER CASE
*
*        CASE - S/S-- SITUATION WHILE FILLING
*
OACASE15 LA    R10,96              FORMAT SS-
         ST    R10,4(,R5)          UPDATE FORMAT
OACAS15  NOP   *+4                 WILL BE BAL R14,OASUB3 ON FILE LT G
         CLC   0(1,R3),0(R7)       COMPARE WINNER TO LOSER 1
         BNE   OAC15A
         LR    R2,R7               LOAD ADDR FOR EQUALS
*
*        EXIT TO EQUALS ROUTINE
*
         BASR  R14,R12             LINK TO EQUALS ROUTINE
*
OAC15A   BH    OAC15B
         ST    R7,12(,R5)          LOSER 1 TO LOSER 2
         ST    R3,8(,R5)           WINNER TO LOSER 1
         B     OAPICK
*
OAC15B   ST    R3,12(,R5)          WINNER TO LOSER 2
         B     OAPICK
*
*        CASE - N/S-- SITUATION WHILE RUNNING
*
OACASE14 LA    R10,32              FORMAT N--
         ST    R10,4(,R5)          UPDATE FORMAT
         L     R4,OASAME           UPDATE MODE
         B     OASHIFT2
*
*        CASE - -/S-- SITUATION WHILE FLUSHING
*
OACASE13 L     R4,OASAME           UPDATE MODE
OAC13A   LA    R10,0               FORMAT ---
         ST    R10,4(,R5)          UPDATE FORMAT
         LR    R3,R7               LOSER 1 TO WINNER
         B     OANEXT
*
*        CASE - N/N-- SITUATION WHILE RUNNING
*
OACASE10 LA    R10,48              FORMAT S--
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OACASE16
*
*        CASE - -/N-- SITUATION WHILE FLUSHING
*
OACASE9  L     R4,OANEW            UPDATE MODE
         B     OAC13A
*
*        INDICATES THE TREE IS FILLED AND FORCES THE NETWORK
*        INTO A RUNNING SITUATION
*
OACASE8  LR    R5,R3               TREE ADDR EQUALS DUMMY RECORD
         CL    R3,WATREE           REAL RECORD OR TREE ADDR ?
         BNL   OARETEOF+8          TREE ADDR, BRANCH
         ST    R3,WALTNODE         SAVE ADDR OF RECD IN LAST TEST NODE
OAC8A    MVC   OAMODLOC(4),OAMODC8B  MODIFY BRANCH TABLE
OACSUB8  NOP   OARETEOF            INITIALIZED TO BRANCH AT FILE < G
         L     R11,PPIDEB+4        DEBLOCK BASE REGISTER
*
*        EXIT TO DEBLOCK ROUTINE
*
         B     0(,R11)             MODIFY AND GET
*
*        INDICATES THERE IS A RECORD TO BE BLOCKED
*
OACASE8A LR    R5,R7               TREE ADDR = DUMMY RECORD
         CL    R3,WATREE           REAL RECORD, NOT TREE ADDR ?
         BNL   OARETEOF+8          TREE ADDR, BRANCH
OACASE8B L     R10,WALTNODE        ADDR OF RECORD IN LAST TEST NODE
         ST    R3,WALTNODE         ADDR OF NEXT RECD TO LAST TEST NODE
         LR    R3,R10              ADDR TO WINNER POSITION
         LA    R3,4(,R3)           INCREMENT ADDR BY 4 BYTES
         L     R11,PPIBLK+4        BLOCK BASE REGISTER
*
*        EXIT TO BLOCK ROUTINE
*
         B     12(,R11)            PUT INFERS GET
*
*        INDICATES THAT IT IS THE END OF A SEQUENCE
*
OACASE6  L     R10,WALTNODE        ADDR OF RECORD IN LAST TEST NODE
         ST    R3,WALTNODE         ADDR OF NEXT RECD TO LAST TEST NODE
         LR    R3,R10              ADDR TO WINNER POSITION
         LA    R3,4(,R3)           INCREMENT ADDR BY 4 BYTES
         L     R11,PPIBLK+4        BLOCK BASE REGISTER
*
*        EXIT TO BLOCK ROUTINE
*
         B     4(,R11)             PUT EOS
*
*        INDICATES THAT IT IS END OF FILE
*
OACASE5  L     R3,WALTNODE         ADDR OF RECORD IN LAST TEST NODE
         LA    R3,4(,R3)           INCREMENT ADDR BY 4 BYTES
         L     R11,PPIBLK+4        BLOCK BASE REGISTER
*
*        EXIT TO BLOCK ROUTINE
*
         B     0(,R11)             PUT EOF
*
*        CASE - S/--- SITUATION WHILE FILLING
*
OACASE3  LA    R10,48              FORMAT S--
         ST    R10,4(,R5)          UPDATE FORMAT
         ST    R3,8(,R5)           WINNER TO LOSER 1
         B     OAPICK
*
*        ENTRY FROM DEBLOCK WHILE RUNNING
*
*        SEQUENCE CHECKS THE NEW RECORD AND STARTS IT THROUGH
*        THE REPLACEMENT NETWORK
*
OARETRUN S     R3,KAFOUR           DECREMENT NEW ADDR BY FOUR BYTES
         L     R2,WALTNODE         ADDR OF RECORD IN LAST TEST NODE
         L     R5,0(,R2)           NODE ADDR WITH RECORD HELD BACK
         ST    R5,0(,R3)           NODE ADDR WITH NEW RECORD
         CLC   0(1,R3),0(R2)       COMPARE NEW RECORD TO ONE HELD BACK
         BNE   OASCHECK
*
*        EXIT TO EQUALS ROUTINE
*
         BASR  R14,R12             LINK TO EQUALS ROUTINE
*
OASCHECK BL    OAMODNEW
         L     R4,OASAME           UPDATE MODE
         B     OANEXT2
*
OAMODNEW L     R4,OANEW            UPDATE MODE
         B     OANEXT2
*
*        ENTRY FROM DEBLOCK AFTER EOF
*
*        SET UP TO FLUSH ANOTHER RECORD FROM THE TREE
*
OARETEOF L     R10,WALTNODE        ADDR OF RECORD IN LAST TEST NODE
         L     R5,0(,R10)          NODE ADDR WITH RECORD HELD BACK
         L     R4,OAFLUSH          UPDATE MODE
         L     R3,WATREE           SET DUMMY RCD AS NEXT INPUT RCD
         B     OANEXT2
*
*        IF R3 HAS DUMMY RCD TREAT AS THE AUTO LOSER (FILE < G)
*
OASUB1   CL    R3,WATREE           REAL OR DUMMY RCD ?
         BNL   OASHIFT4            DUMMY RCD, BRANCH
         BR    R14                 R3 HAS A REAL RCD CONTINUE NORMALLY
*
OASUB2   CL    R3,WATREE           REAL OR DUMMY RCD ?
         BNL   OASUB2R             DUMMY RCD, BRANCH
         BR    R14                 R3 HAS A REAL RCD CONTINUE NORMALLY
*
OASUB3   CL    R3,WATREE           REAL OR DUMMY RCD ?
         BNL   OAC15B              DUMMY RCD, BRANCH (EQ OR GT)
         BR    R14                 R3 HAS A REAL RCD CONTINUE NORMALLY
*
OASUBF41 CLC   16(4,R5),WATREE     -/SSS CONDITION ?
         BLR   R14                 YES, -/SSS
         CLC   12(4,R5),WATREE     NO, -/SS- CONDITION ?
         BL    OACASE25            YES, -/SS- ?
         CLC   8(4,R5),WATREE      NO, -/S-- CONDITION ?
         BL    OACASE13            YES, -/S-- ?
         B     OAC13A              NO, IT IS A -/--- CONDITION
*
OASUBF44 CLC   16(4,R5),WATREE     /SSS CONDITION ?
         BL    OARSSS              YES, CHECK IF IN RCD IS REAL
         CLC   12(4,R5),WATREE     NO, IT IS A /SS- CONDITION
         BL    OARSS               YES, CHECK IF IN RCD IS REAL
         CLC   8(4,R5),WATREE      NO, IT IS A /S-- CONDITION
         BL    OARS                YES, CHECK IF IN RCD IS REAL
         B     OAR                 NO, IT IS A /--- CHK IF IN IS REAL
*
OARSSS   CL    R3,WATREE           REAL OR DUMMY RCD ?
         BNL   OASUB41             RCD IS DUMMY, GOTO CASE -/SSS
         BR    R14                 IN RCD IS REAL, GOTO CASE S/SSS
*
OARSS    CL    R3,WATREE           REAL OR DUMMY RCD ?
         BNL   OACASE25            IN RCD IS DUMMY, GOTO CASE -/SS-
         LA    R10,96              UPDATE FORMAT
         ST    R10,4(,R5)          SET FORMAT OF S/SS-
         B     OACASE28            GOTO CASE S/SS-
*
OARS     CL    R3,WATREE           REAL OR DUMMY RCD ?
         BNL   OACASE13            IN RCD IS A DUMMY, GOTO CASE -/S--
         LA    R10,48              INPT RCD IS REAL. UPDATE FORMAT TO
         ST    R10,4(,R5)          S/S--
         B     OACASE16            BR TO CASE S/S--
*
OAR      CL    R3,WATREE           REAL OR DUMMY IN RCD X/--- ?
         BNL   OAC13A              INPUT RCD IS DUMMY, BR TO CASE -/---
         L     R4,OASAME           UPDATE MODE
         LA    R10,0               INPUT RCD IS REAL.UPDATE FORMAT
         ST    R10,4(,R5)          TO  /---
         B     OANEXT
*
*        CONSTANTS
*
KAFOUR   DC    F'4'                ADDR DECREMENT
KNOP     DC    X'4700'             NOP
*
*        WORK AREAS
*        THE ORDERING OF THESE WORK AREAS MUST BE MAINTAINED
*
WASAVE   DC    3F'0'               FILLING REGISTER SAVE AREA
*                                  INITIALIZED BY IERAOA
WATREE   DC    X'7FFFFFFF'         USED FOR DUMMY RECORDS
WALTNODE DC    F'0'                LAST TEST NODE
         DC    A(16)               FORMAT OF LAST TEST NODE
WATREEAD DC    F'0'                LOCATION OF TREE
*
*        MODIFICATION INSTRUCTIONS
*
OAMODC8  B     OACASE8A            MOD TO CK FOR DUMMY AND HOLD BACK
OAMODC8B B     OACASE8B            MODIFICATION TO SKIP DUMMY CHECK
OACHMVC  MVC   OAMODLOC(4),OAMODC8 MODIFY BRANCH TABLE
OANOSAME L     R4,OAFLUSH          MODIFICATION TO START FLUSHING TREE
*
OA44FILL BAS   R14,OASUB1          FILE < G CHECK IF R3 A DUMMY
OAMODC27 BAS   R14,OASUB2          FILE < G CHECK IF R3 A DUMMY
OAMODC15 BAS   R14,OASUB3          FILE < G CHECK IF R3 A DUMMY
OA44FLSH BAS   R14,OASUBF44        BR TO FLUSH RTN CASE44
OA41FLSH BAS   R14,OASUBF41        BR TO FLUSH RTN CASE 41
*
./ ADD NAME=IERROB   0101-20211-20211-1200-00083-00083-00000-RELEASE 00
ROB      TITLE 'IERROB - OS/360 SORT/MERGE - 360S-SM-23'
*
*        MODULE NAME - IERROB
*
*        MODULE FUNCTION/OPERATION -
*        REPLACEMENT NETWORK FOR FIXED LENGTH RECORDS WHICH
*        CONTAIN SINGLE CONTROL FIELDS AND/OR REQUIRE EXTRACT.
*        THIS MODULE GENERATES ASCENDING OR DESCENDING SEQUENCES
*        USING A REPLACEMENT SELECTION TECHNIQUE
*
*        MODULES IN WHICH THIS MODULE APPEARS A DSECT -
*        IERAOB, IERROX, IERAOX
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM INITIAL WRITE ROUTINE
*                       CALLING SEQUENCE -
*                         L   R11,PPINET
*                         BR  R11     ENTER NETWORK TO FILL TREE
*
*                     - ENTRY FROM DEBLOCK ROUTINE
*                       CALLING SEQUENCE -
*                         L  R11,PPINET
*                         B  X(,R11)
*
*                         WHERE X = 4 ENTRY WHILE FILLING
*                                 = 8 ENTRY AT EOF
*                                 =12 ENTRY WHILE RUNNING
*                                 =16 ENTRY AFTER EOF
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPISRTG
*        COMPARES FILE SIZE TO G (PPISRTG)
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED - N/A
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL - ADDR IN PPIDEB+4 (DEBLOCK)
*                                 PLUS DISP=8 WHEN FILLING
*                                             TREE
*                                 PLUS DISP=0 FIRST TIME AFTER
*                                 TREE IS FILLED
*
*                       - ADDR IN PPIADSSC
*                                 PLUS DISP=20 TO CLOSE WHEN
*                                              INPUT FILE ZERO
*
*                       - ADDR IN PPIBLK+4(BLOCK)
*                                 PLUS DISP=0  TO BLOCK AT EOF
*                                 PLUS DISP=4  TO BLOCK AT EOS
*                                 PLUS DISP=12 FOR NORMAL BLOCK
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS -
*        WASAVE    - FILLING REGISTER SAVE AREA
*        WATREE   -> TREE LOCATION
*        WALTNODE -> LAST TEST NODE
*
*        NOTES - N/A
*
IERROB   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERROB SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERROBI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERROBI  0101-20211-20211-1200-00524-00524-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERROB SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERROBI
*
         USING *,R11
         USING IERRCA,R13
*
*        ENTRY TABLE
*
IERDOA   B     OAPICK              +00 FILL TREE
         B     OAFIRET             +04 DEBLOCK WHILE FILLING
         B     OAEOF               +08 DEBLOCK AT EOF
         B     OARETRUN            +12 DEBLOCK WHILE RUNNING
         B     OARETEOF            +16 DEBLOCK AFTER EOF
*
*        INITIAL ENTRY TO START FILLING OR ENTRY TO CONTINUE
*        FILLING TREE
*
OAPICK   L     R11,PPIDEB+4        DEBLOCK BASE REGISTER
*
*        EXIT TO DEBLOCK ROUTINE
*
         B     8(,R11)             GET TO FILL
*
*        ENTRY FROM DEBLOCK WHILE FILLING
*
*        SETS UP TO FILL THE TREE AND DETERMINES WHEN THE TREE
*        IS FILLED
*
OAFIRET  S     R3,KAINCDEC         DECREMENT NEW ADDR BY EXTRACT INC+4
         CLI   KASWITCH+3,X'FF'    CHECK EXTRACT SWITCH
         BNE   OANOTON1            OFF, BRANCH
         BAS   R14,4(,R12)         CALL EXTRACT ROUTINE
OANOTON1 LM    R7,R9,WASAVE        FILLING REGISTERS
         ST    R9,0(0,R3)          ADDR OF TREE WITH RECORD
OAFILDUM LR    R5,R9               ADDR OF TREE (NLA)
         BCT   R7,OAGCT            DECREMENT WAY COUNTER
         LA    R7,4                RESET WAY COUNTER
         LA    R9,20(,R9)          INCREMENT TO NEXT NODE
OAGCT    BCT   R8,OAMORE           DECREMENT G COUNTER
         L     R4,OASAME           SET MODE
         STM   R7,R9,WASAVE
         CLC   OAGCT+4(4),OANOSAME  RUNNING OR FLUSHING ?
         BNE   OANEXT2             RUNNING SITUATION
         MVC   OACASE44(4),OA44FLSH  OVERLAY TO BRANCH TO FLUSH ROUTINE
         MVC   OACAS27(2),KNOP     NOP THE BR INSTR TO THE FILL ROUTINE
         MVC   OACAS15(2),KNOP     NOP THE BR INSTR TO THE FILL ROUTINE
         MVC   OACASE41(4),OA41FLSH  OVERLAY TO BR TO FLUSH RTN CASE
         L     R7,12(,R5)
         CL    R7,WATREE           FILE SIZE = G - 2 ?
         BL    OANEXT2             LOW, SET LAST NODE
         LA    R7,48               TO FORMAT 30
         ST    R7,4(,R5)
         B     OANEXT2             FLUSHING SITUATION
*
OAMORE   L     R4,OAFILL           SET MODE
         STM   R7,R9,WASAVE        SAVE FILLING REGISTERS
         B     OANEXT2
*
*        ENTRY FROM DEBLOCK AT EOF
*
*        DETERMINES IF EOF SITUATION IS A NORMAL ONE
*        FILE SIZE < G THEN G, OR FILE SIZE IS ZERO AND BRANCHES
*        ACCORDINGLY
*
OAEOF    CLC   PPISRTG(4),WASAVE+4  G COUNT IN PPI = FILL NO ?
         BNE   OANOZERO            NO, BRANCH
*
*        EXIT TO CLOSE ROUTINE
*
         LA    R1,4                SET UP PARAMETER TO END OF PHASE
         L     R15,PPIADSSC        R15 -> SSC
         BAS   R14,20(,R15)        INPUT FILE WAS ZERO
*
OANOZERO LA    R10,0               CONSTANT OF 0
         CL    R10,WASAVE+4        FILL COUNT= 0 ?
         BE    OARETEOF            YES, BRANCH
*
*        FILE SIZE IS LESS THAN G
*        THE CODING IS MODIFIED TO FILL THE REMAINDER OF THE
*        TREE WITH FAKE RECORDS. THESE RECORDS ARE THE TREE ADDRS
*
         MVC   OACASE44(4),OA44FILL  MOD TO CHECK FOR DUMMY RCD
         MVC   OACAS27(4),OAMODC27   MOD TO CHECK FOR DUMMY RCD
         MVC   OACAS15(4),OAMODC15   MOD TO CHECK FOR DUMMY RCD
         MVC   OAC8A(6),OACHMVC     MODIFICATION TO CHECK FOR DUMMY REC
         OI    OACSUB8+1,X'F0'      INITIALIZE BRANCH INST IN CASE 8
         MVC   OAGCT+4(4),OANOSAME  MODIFICATION TO START TREE FLUSHING
         MVC   OAPICK(12),OAMODIFY  MODIFY FILLING RETURN LOCATION
OAMODIFY LM    R7,R9,WASAVE         FILLING REGISTERS
         L     R3,WATREE            DUMMY ADDRESS
         B     OAFILDUM
*
*        MODE POSITIONS AND BRANCH TABLE
*
*        THROUGH THE COMBINATION OF MODE AND FORMAT AN INDEXED
*        BRANCH IS PERFORMED WHICH BRANCHES TO THE CASE WHICH
*        HANDLES THE INDICATED SITUATION
*
OAFLUSH  DC    A(OABTABLE)
OANEW    DC    A(OABTABLE+4)
OAFILL   DC    A(OABTABLE+8)
OASAME   DC    A(OABTABLE+12)
OABTABLE B     OANEXT
         B     OANEXT
         B     OACASE3
         B     OANEXT
         B     OACASE5
         B     OACASE6
         DC    A(0)                SPACE TO MAINTAIN POSITIONS IN TABLE
OAMODLOC B     OACASE8
         B     OACASE9
         B     OACASE10
         DC    A(0)                SPACE TO MAINTAIN POSITIONS IN TABLE
         B     OANEXT
         B     OACASE13
         B     OACASE14
         B     OACASE15
         B     OACASE16
         B     OACASE17
         B     OACASE18
         DC    A(0)                SPACE TO MAINTAIN POSITIONS IN TABLE
         B     OANEXT
         B     OACASE21
         B     OACASE22
         DC    A(0)                SPACE TO MAINTAIN POSITIONS IN TABLE
         B     OACASE16
         B     OACASE25
         B     OACASE26
         B     OACASE27
         B     OACASE28
         B     OACASE29
         B     OACASE30
         DC    A(0)                SPACE TO MAINTAIN POSITIONS IN TABLE
         B     OANEXT
         B     OACASE33
         B     OACASE34
         DC    A(0)                SPACE TO MAINTAIN POSITIONS IN TABLE
         B     OACASE16
         B     OACASE37
         B     OACASE38
         DC    A(0)                SPACE TO MAINTAIN POSITIONS IN TABLE
         B     OACASE28
         B     OACASE41
         B     OACASE42
         B     OACASE44
         B     OACASE44
*
*        CASE - AN S/SSS SITUATION WHILE RUNNING
*
OACASE44 NOP   *+4                 WILL BE BAL R14,OASUB1 ON FILE < G
*                                  FILL, ORBAL R14 OASUBF44 FLUSH
         CLC   0(1,R3),0(R8)       COMPARE WINNER TO LOSER 2
         BNH   OACASE16
         CLC   0(1,R3),0(R9)       COMPARE WINNER TO LOSER 3
         BNH   OASHIFT3
OASHIFT4 STM   R8,R9,8(R5)         LOSER 2 + 3 TO LOSER 1 + 2
         ST    R3,16(,R5)          WINNER TO LOSER 3
         LR    R3,R7               LOSER 1 TO WINNER
OANEXT   L     R5,0(,R5)           ADDR OF NEXT NODE
OANEXT2  LM    R6,R9,4(R5)         LOAD NODE
         B     0(R4,R6)            GOTO PROPER CASE
*
*        CASE - AN N/SSS SITUATION WHILE RUNNING
*
OACASE42 L     R4,OASAME           UPDATE MODE
         LA    R10,144             FORMAT SSN
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OASHIFT4
*
*        CASE - AN -/SSS SITUATION WHILE FLUSHING
*
OACASE41 NOP   OASUBF41            WILL BE BAL R14,OASUBF41 WHEN FLUSHG
OASUB41  L     R4,OASAME           UPDATE MODE
         LA    R10,96              FORMAT SS-
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OASHIFT4
*
*        CASE - N/SSN SITUATION WHILE RUNNING
*
OACASE38 L     R4,OASAME           UPDATE MODE
         LA    R10,128             FORMAT SNN
         ST    R10,4(,R5)          UPDATE FORMAT
OAC38A   CLC   0(1,R3),0(R9)       COMPARE WINNER TO LOSER 3
         BNH   OASHIFT3
         B     OASHIFT4
*
*        CASE - AN -/SSN SITUATION WHILE FLUSHING
*
OACASE37 L     R4,OASAME           UPDATE MODE
         LA    R10,80              FORMAT SN-
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OASHIFT4
*
*        CASE - AN N/SNN SITUATION WHILE RUNNING
*
OACASE34 L     R4,OASAME           UPDATE MODE
         LA    R10,112             FORMAT NNN
         ST    R10,4(,R5)          UPDATE FORMAT
         CLC   0(1,R3),0(R8)       COMPARE WINNER TO LOSER 2
         BNH   OASHIFT2
         B     OAC38A
*
*        CASE - AN -/SNN SITUATION WHILE FLUSHING
*
OACASE33 L     R4,OASAME           UPDATE MODE
         LA    R10,64              FORMAT NN-
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OASHIFT4
*
*        CASE - AN N/NNN SITUATION WHILE RUNNING
*
OACASE30 LA    R10,160             FORMAT SSS
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OACASE44
*
*        CASE - AN -/NNN SITUATION WHILE FLUSHING
*
OACASE29 L     R4,OANEW            UPDATE MODE
         LA    R10,96              FORMAT SS-
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OASHIFT4
*
*        CASE - AN S/SS- SITUATION WHILE RUNNING
*
OACASE28 CLC   0(1,R3),0(R8)       COMPARE WINNER TO LOSER 2
         BNH   OACASE16
OASHIFT3 ST    R8,8(,R5)           LOSER 2 TO LOSER 1
         ST    R3,12(,R5)          WINNER TO LOSER 2
         LR    R3,R7               LOSER 1 TO WINNER
         L     R5,0(,R5)           ADDR OF NEXT NODE
         LM    R6,R9,4(R5)         LOAD NODE
         B     0(R4,R6)            GOTO PROPER CASE
*
*        CASE - AN S/SS- SITUATION WHILE FILLING
*
OACASE27 LA    R10,160             FORMAT SSS
         ST    R10,4(,R5)          UPDATE FORMAT
OACAS27  NOP   *+4                 WILL BE BAL R14,OASUB2 ON FILE < G
         CLC   0(1,R3),0(R8)       COMPARE WINNER TO HIGH 2
         BNH   OAC27A
OASUB2R  ST    R3,16(0,R5)         WINNER TO LOSER 3
         B     OAPICK
*
OAC27A   CLC   0(1,R3),0(R7)       COMPARE WINNER TO LOSER 1
         BNH   OAC27B
         ST    R8,16(0,R5)         LOSER 2 TO LOSER 3
         ST    R3,12(0,R5)         WINNER TO LOSER 2
         B     OAPICK
*
*
OAC27B   STM   R7,R8,12(R5)        LOSER 1 + 2 TO LOSER 2 + 3
         ST    R3,8(0,R5)          WINNER TO LOSER 1
         B     OAPICK
*
*        CASE - AN N/SS- SITUATION WHILE RUNNING
*
OACASE26 L     R4,OASAME           UPDATE MODE
         LA    R10,80              FORMAT SN-
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OASHIFT3
*
*        CASE - AN -/SS- SITUATION WHILE FLUSHING
*
OACASE25 L     R4,OASAME           UPDATE MODE
         LA    R10,48              FORMAT S--
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OASHIFT3
*
*        CASE - AN N/SN- SITUATION WHILE RUNNING
*
OACASE22 L     R4,OASAME           UPDATE MODE
         LA    R10,64              FORMAT NN-
         ST    R10,4(,R5)          UPDATE FORMAT
         CLC   0(1,R3),0(R8)       COMPARE WINNER TO LOSER 2
         BNH   OASHIFT2
         B     OASHIFT3
*
*        CASE - AN -/SN- SITUATION WHILE FLUSHING
*
OACASE21 L     R4,OASAME           UPDATE MODE
         LA    R10,32              FORMAT N--
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OASHIFT3
*
*        CASE - AN N/NN- SITUATION WHILE RUNNING
*
OACASE18 LA    R10,96              FORMAT SS-
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OACASE28
*
*        CASE - AN -/NN- SITUATION WHILE FLUSHING
*
OACASE17 L     R4,OANEW            UPDATE MODE
         LA    R10,48              FORMAT S--
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OASHIFT3
*
*        CASE - AN S/S-- SITUATION WHILE RUNNING
*
OACASE16 CLC   0(1,R3),0(R7)       COMPARE WINNER TO LOSER 1
         BNH   OANEXT
OASHIFT2 ST    R3,8(,R5)           WINNER TO LOSER 1
         LR    R3,R7               LOSER 1 TO WINNER
         L     R5,0(,R5)           ADDR OF NEXT NODE
         LM    R6,R9,4(R5)         LOAD NODE
         B     0(R4,R6)            GOTO PROPER CASE
*
*        CASE - AN S/S-- SITUATION WHILE FILLING
*
OACASE15 LA    R10,96              FORMAT SS-
         ST    R10,4(,R5)          UPDATE FORMAT
OACAS15  NOP   *+4                 WILL BE BAL R14,OASUB3 ON FILE LTG
         CLC   0(1,R3),0(R7)       COMPARE WINNER TO LOSER 1
         BH    OAC15A
         ST    R7,12(,R5)          LOSER 1 TO LOSER 2
         ST    R3,8(,R5)           WINNER TO LOSER 1
         B     OAPICK
*
OAC15A   ST    R3,12(,R5)          WINNER TO LOSER 2
         B     OAPICK
*
*        CASE - AN N/S-- SITUATION WHILE RUNNING
*
OACASE14 LA    R10,32              FORMAT N--
         ST    R10,4(,R5)          UPDATE FORMAT
         L     R4,OASAME           UPDATE MODE
         B     OASHIFT2
*
*        CASE - AN -/S-- SITUATION WHILE FLUSHING
*
OACASE13 L     R4,OASAME           UPDATE MODE
OAC13A   LA    R10,0               FORMAT ---
         ST    R10,4(,R5)          UPDATE FORMAT
         LR    R3,R7               LOSER 1 TO WINNER
         B     OANEXT
*
*        CASE - AN N/N-- SITUATION WHILE RUNNING
*
OACASE10 LA    R10,48              FORMAT S--
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OACASE16
*
*        CASE - AN -/N-- SITUATION WHILE FLUSHING
*
OACASE9  L     R4,OANEW            UPDATE MODE
         B     OAC13A
*
*        INDICATES THE TREE IS FILLED AND FORCES THE NETWORK
*        INTO A RUNNING SITUATION
*
OACASE8  LR    R5,R3               TREE ADDR EQUALS DUMMY RECORD
         CL    R3,WATREE           A REAL RECORD OR TREE ADDR ?
         BNL   OARETEOF+8          A TREE ADDR, BRANCH
         ST    R3,WALTNODE         SAVE ADDR OF RECD IN LAST TEST NODE
OAC8A    MVC   OAMODLOC(4),OAMODC8B  MODIFY BRANCH TABLE
OACSUB8  NOP   OARETEOF            INITIALIZED TO BRANCH AT FILE < G
         L     R11,PPIDEB+4        DEBLOCK BASE REGISTER
*
*        EXIT TO DEBLOCK ROUTINE
*
         B     0(,R11)             MODIFY AND GET
*
*        INDICATES THERE IS A RECORD TO BE BLOCKED
*
OACASE8A LR    R5,R8               TREE ADDRESS = DUMMY RECORD
         CL    R3,WATREE           A REAL RECORD OR TREE ADDR ?
         BNL   OARETEOF+8          TREE ADDR, BRANCH
OACASE8B L     R10,WALTNODE        ADDR OF RECORD IN LAST TEST NODE
         ST    R3,WALTNODE         ADDR OF NEXT RECD TO LAST TEST NODE
         LR    R3,R10              ADDR TO WINNER POSITION
         A     R3,KAINCDEC         INC ADDR BY EXTRACT INCREMENT+4
         L     R11,PPIBLK+4        BLOCK BASE REGISTER
*
*        EXIT TO BLOCK ROUTINE
*
         B     12(,R11)            PUT INFERS GET
*
*        INDICATES THAT IT IS THE END OF A SEQUENCE
*
OACASE6  L     R10,WALTNODE        ADDR OF RECORD IN LAST TEST NODE
         ST    R3,WALTNODE         ADDR OF NEXT RECD TO LAST TEST NODE
         LR    R3,R10              ADDR TO WINNER POSITION
         A     R3,KAINCDEC         INC ADDR BY EXTRACT INCREMENT +4
         L     R11,PPIBLK+4        BLOCK BASE REGISTER
*
*        EXIT TO BLOCK ROUTINE
*
         B     4(,R11)             PUT EOS
*
*        INDICATES THAT IT IS END OF FILE
*
OACASE5  L     R3,WALTNODE         ADDR OF RECORD IN LAST TEST NODE
         A     R3,KAINCDEC         INC ADDR BY EXTRACT INCREMENT +4
         L     R11,PPIBLK+4        BLOCK BASE REGISTER
*
*        EXIT TO BLOCK ROUTINE
*
         B     0(,R11)             PUT EOF
*
*        CASE - AN S/--- SITUATION WHILE FILLING
*
OACASE3  LA    R10,48              FORMAT S--
         ST    R10,4(,R5)          UPDATE FORMAT
         ST    R3,8(,R5)           WINNER TO LOSER 1
         B     OAPICK
*
*        ENTRY FROM DEBLOCK WHILE RUNNING
*
*        SEQUENCE CHECKS THE NEW RECORD AND STARTS IT THROUGH
*        THE REPLACEMENT NETWORK
*
OARETRUN S     R3,KAINCDEC         DECREMENT NEW ADDR BY EXTRACT INC+4
         CLI   KASWITCH+3,X'FF'    EXTRACT ON ?
         BNE   OANOTON2            NO, BRANCH
         BAS   R14,4(,R12)         CALL EXTRACT ROUTINE
OANOTON2 L     R2,WALTNODE         ADDR OF RECORD IN LAST TEST NODE
         L     R5,0(,R2)           NODE ADDR WITH RECORD HELD BACK
         ST    R5,0(,R3)           NODE ADDR WITH NEW RECORD
         CLC   0(1,R3),0(R2)       COMPARE NEW RECORD TO ONE HELD BACK
         BL    OAMODNEW
         L     R4,OASAME           UPDATE MODE
         B     OANEXT2
*
OAMODNEW L     R4,OANEW            UPDATE MODE
         B     OANEXT2
*
*        ENTRY FROM DEBLOCK AFTER EOF
*
*        SET UP TO FLUSH ANOTHER RECORD FROM THE TREE
*
OARETEOF L     R10,WALTNODE        ADDR OF RECORD IN LAST TEST NODE
         L     R5,0(,R10)          NODE ADDR WITH RECORD HELD BACK
         L     R4,OAFLUSH          UPDATE MODE
         L     R3,WATREE           SET DUMMY RCD AS NEXT INPUT RCD
         B     OANEXT2
*
*        IF R3 HAS DUMMY RCD TREAT AS THE AUTO LOSER FILE < G
*
OASUB1   CL    R3,WATREE           REAL OR DUMMY RCD ?
         BNL   OASHIFT4            DUMMY RCD, BRANCH
         BR    R14                 R3 HAS A REAL RCD CONTINUE NORMALLY
*
OASUB2   CL    R3,WATREE           REAL OR DUMMY RCD ?
         BNL   OASUB2R             DUMMY RCD, BRANCH
         BR    R14                 R3 HAS A REAL RCD CONTINUE NORMALLY
*
OASUB3   CL    R3,WATREE           REAL OR DUMMY RECORD ?
         BNL   OAC15A              DUMMY RCD, BRANCH
         BR    R14                 R3 HAS A REAL RCD CONTINUE NORMALLY
*
OASUBF41 CLC   16(4,R5),WATREE     A -/SSS CONDITION ?
         BLR   R14                 YES, A -/SSS
         CLC   12(4,R5),WATREE     NO, A -/SS- CONDITION ?
         BL    OACASE25            YES. A -/SS-
         CLC   8(4,R5),WATREE      NO, A -/S-- CONDITION ?
         BL    OACASE13            YES, A -/S--
         B     OAC13A              NO, A -/--- CONDITION
*
OASUBF44 CLC   16(4,R5),WATREE     A /SSS CONDITION ?
         BL    OARSSS              YES, CHECK IF IN RCD IS REAL
         CLC   12(4,R5),WATREE     NO, A /SS- CONDITION ?
         BL    OARSS               YES, CHECK IF IN RCD IS REAL
         CLC   8(4,R5),WATREE      NO, A /S-- CONDITION ?
         BL    OARS                YES, CHECK IF IN RCD IS REAL
         B     OAR                 NO, A /--- CHK IF IN IS REAL
*
OARSSS   CL    R3,WATREE           REAL OR DUMMY RCD ?
         BNL   OASUB41             DUMMY RCD, GOTO CASE -/SSS
         BR    R14                 IN RCD IS REAL GOTO CASE S/SSS
*
OARSS    CL    R3,WATREE           REAL OR DUMMY RCD ?
         BNL   OACASE25            RCD IS DUMMY, GOTO CASE -/SS-
         LA    R10,96              UPDATE FORMAT
         ST    R10,4(,R5)          SET FORMAT OF S/SS-
         B     OACASE28            GOTO CASE S/SS-
*
OARS     CL    R3,WATREE           REAL OR DUMMY RCD ?
         BNL   OACASE13            RCD IS  DUMMY, GOTO CASE -/S--
         LA    R10,48              INPT RCD IS REAL UPDATE FORMAT TO
         ST    R10,4(,R5)          S/S--
         B     OACASE16            BRANCH TO CASE S/S--
*
OAR      CL    R3,WATREE           REAL OR DUMMY IN RCD X/--- ?
         BNL   OAC13A              INPUT RCD IS DUMMY, BR TO CASE -/---
         L     R4,OASAME           UPDATE MODE
         LA    R10,0               INPUT RCD IS REAL UPDATE FORMAT
         ST    R10,4(,R5)          TO  /---
         B     OANEXT
*
*        CONSTANTS
*
KASWITCH DC    X'00000000'         EXTRACT SWITCH
KNOP     DC    X'4700'             NOP
*
*        WORK AREAS
*
*        THE ORDERING OF THESE WORK AREAS MUST BRANCH MAINTAINED
*
WASAVE   DC    3F'0'               FILLING REGISTER SAVE AREA
WATREE   DC    X'7FFFFFFF'         USED FOR DUMMY RECORDS
WALTNODE DC    F'0'                LAST TEST NODE
         DC    A(16)               FORMAT OF LAST TEST NODE
KAINCDEC DC    F'0'                ADDR INC OR DEC OF EXTRACT INC+4
WATREEAD DC    F'0'                LOCATION OF TREE
*
*        MODIFICATION INSTRUCTIONS
*
OAMODC8  B     OACASE8A            MOD TO CK FOR DUMMY AND HOLD BACK
OAMODC8B B     OACASE8B            MODIFICATION TO SKIP DUMMY CHECK
OACHMVC  MVC   OAMODLOC(4),OAMODC8 MODIFY BRANCH TABLE
OANOSAME L     R4,OAFLUSH          MODIFICATION TO START FLUSHING TREE
*
OA44FILL BAS   R14,OASUB1          FILE < G CHECK IF R3 A DUMMY
OAMODC27 BAS   R14,OASUB2          FILE < G CHECK IF R3 A DUMMY
OAMODC15 BAS   R14,OASUB3          FILE < G CHECK IF R3 A DUMMY
OA44FLSH BAS   R14,OASUBF44        BR TO FLUSH RTN CASE44
OA41FLSH BAS   R14,OASUBF41        BR TO FLUSH RTN CASE 41
*
./ ADD NAME=IERROC   0101-20211-20211-1200-00088-00088-00000-RELEASE 00
ROC      TITLE 'IERROC - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME IERROC
*
*        MODULE FINCTION/OPERATION -
*        REPLACEMENT NETWORK FOR VARIABLE LENGTH RECORDS
*        CONTAINING MULTIPLE CONTROL FIELDS. THIS MODULE
*        GENERATES ASCENDING OR DESCENDING SEQUENCES USING A
*        REPLACEMENT SELECTION TECHNIQUE
*
*        MODULES IN WHICH THIS MODULE APPEARS A DSECT -
*        IERAOC, IERROY, IERAOY
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM INITIAL WRITE ROUTINE
*                       CALLING SEQUENCE -
*                         L   R11,PPINET
*                         BR  R11 ENTER NETWORK TO FILL TREE
*
*                     - ENTRY FROM DEBLOCK ROUTINE
*                       CALLING SEQUENCE -
*                         L  R11,PPINET
*                         B  X(,R11)
*
*                         WHERE X = 4 FOR ENTRY WHILE FILLING (FIT)
*                                 = 8 FOR ENTRY AT EOF
*                                 =12 FOR ENTRY WHILE RUNNING (FIT)
*                                 =16 FOR ENTRY AFTER EOF
*                                 =24 FOR ENTRY FROM DEBLOCK
*                                     WHILE FILLING (NO FIT)
*                                 =28 FOR ENTRY FROM DEBLOCK
*                                     WHILE RUNNING (NO FIT)
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPISRTG
*        COMPARES FILE SIZE TO G (PPISRTG)
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED - N/A
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL - ADDR IN PPIDEB+4 (DEBLOCK)
*                         PLUS DISP=8 WHEN FILLING
*                                     TREE
*
*                         PLUS DISP=0 FIRST TIME AFTER
*                         TREE IS FILLED
*
*                         PLUS DISP=20 TO CLOSE WHEN
*                                   INPUT FILE ZERO
*
*                         PLUS DISP=0 TO BLOCK AT EOF
*
*                         PLUS DISP=4 TO BLOCK AT EOS
*
*                         PLUS DISP=12 FOR NORMAL BLOCK
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS -
*        WCSAVE   - FILLING REGISTER SAVE AREA
*        WCTREE   - TREE LOCATION
*        WCLTNODE - FORMAT OF LAST TEST NODE
*
*        NOTES - N/A
*
IERROC   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERROC SOURCE
*
*----------------------------------------------------------------------
*
         COPY IERROCI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERROCI  0101-20211-20211-1200-00332-00332-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERROC SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERROCI
*
         USING *,R11
         USING IERRCA,R13
*
*        ** ENTRY TABLE
*
IERDOA   B     OCPICK              +00 FILL TREE
         B     OCGOTFIL            +04 DEBLK WHILE FILLING (FIT)
         B     OCEOF               +08 DEBLK AT EOF
         B     OCGOTRUN            +12 DEBLK WHILE RUNNING (FIT)
         B     OCRETEOF            +16 DEBLK AFTER EOF
         DC    A(0)                +20 KEEP INC IN ENTRY TABLE
         B     OCNOGOFI            +24 DEBLK WHILE FILLING - NOFIT
         B     OCNOGORN            +28 DEBLK WHILE RUNNING - NOFIT
*
*        INITIAL ENTRY TO START FILLING OR ENTRY TO CONTINUE
*        FILLING TREE
*
OCPICK   L     R11,PPIDEB+4        DEBLOCK BASE REGISTER
*
*        EXIT TO DEBLOCK ROUTINE
*
         B     8(,R11)             GET TO FILL
*
*        SETS UP TO FILL THE TREE WITH REAL OR IMAGINARY RECORDS
*        AND DETERMINES WHEN THE TREE IS FILLED
*
*        ENTRY FROM DEBLOCK WHILE FILLING (RECORD FITS)
*
OCGOTFIL LM    R7,R9,WCSAVE        FILLING REGISTERS
         L     R4,OCSAME           UPDATE MODE
         S     R3,KCFOUR           DECREMENT NEW ADDR BY FOUR BYTES
         ST    R9,0(,R3)           ADDR OF TREE WITH RECORD
OCSUBFIT LR    R5,R9               ADDR OF TREE (NEXT LEVEL ADDR)
         BCT   R7,OCGCT            DECREMENT WAY COUNTER
         LA    R7,2                RESET WAY COUNTER
         LA    R9,12(,R9)          INCREMENT TO NEXT NODE
OCGCT    BCT   R8,OCFILREG         DECREMENT G COUNTER
         STM   R7,R9,WCSAVE
         B     OCNEXT2
*
OCFILREG STM   R7,R9,WCSAVE        SAVE FILLING REGISTERS
         B     OCNEXT2
*
*        ENTRY FROM DEBLOCK WHILE FILLING (RECORD DOES NOT FIT)
*
OCNOGOFI LM    R7,R9,WCSAVE        FILLING REGISTERS
         L     R4,OCSTEMP          UPDATE MODE
         LR    R3,R9               USE TREE ADDR AS WINNER
         B     OCSUBFIT
*
*        DETERMINES IF EOF SITUATION IS A NORMAL ONE, FILE SIZE < G
*        OR FILE SIZE IS ZERO AND BRANCHES ACCORDINGLY
*
*        ENTRY FROM DEBLOCK AT EOF
*
OCEOF    CLC   PPISRTG(4),WCSAVE+4  COMPARE G COUNT IN PPIA TO FILL NO
         BNE   OCNOZERO
*
*        EXIT TO CLOSE ROUTINE
*
         LA    R1,4                SET UP PARAMETER TO END OF PHASE
         L     R15,PPIADSSC        R15 -> SSC
         BAS   R14,20(,R15)        INPUT FILE WAS ZERO
*
OCNOZERO MVC   OCC7A(8),OCC7EOF    MODIFY CASE7 TO FORCE TREE FLUSHING
         LA    R10,0               CONSTANT OF 0
         CL    R10,WCSAVE+4        COMPARE TO FILL COUNT
         BE    OCRETEOF
*
*        FILE SIZE IS LESS THAN G
*        THE CODING IS MODIFIED TO FILL THE REMAINDER OF THE
*        TREE WITH IMAGINARY RECORDS (T1)
*
         OI    OCC8A+1,X'F0'       INITIALIZE BRANCH INST IN CASE8
         MVC   OCPICK(4),OCMODIFY  MODIFY FILLING RETURN LOCATION
OCMODIFY B     OCNOGOFI
*
*        MODE POSITIONS AND BRANCH TABLE
*
*        THROUGH THE COMBINATION OF MODE AND FORMAT AN INDEXED
*        BRANCH IS PERFORMED WHICH BRANCHES TO THE CASE WHICH
*        HANDLES THE INDICATED SITUATION
*
OCNTEMP  DC    A(OCBTABLE)
OCNEW    DC    A(OCBTABLE+4)
OCSTEMP  DC    A(OCBTABLE+8)
OCSAME   DC    A(OCBTABLE+12)
OCBTABLE DC    A(0)                SPACE TO MAINTAIN POSITIONS IN TABLE
         DC    A(0)                SPACE TO MAINTAIN POSITIONS IN TABLE
         B     OCCASE3
         B     OCCASE4
         B     OCCASE5
         B     OCCASE6
         B     OCCASE7
OCMODLOC B     OCCASE8
         B     OCCASE9
         B     OCCASE10
         B     OCNEXT
         B     OCNEXT
         B     OCCASE13
         B     OCCASE14
         B     OCNEXT
         B     OCNEXT
         B     OCCASE17
         B     OCCASE18
         B     OCNEXT
         B     OCNEXT
         B     OCCASE21
         B     OCCASE22
         B     OCCASE23
         B     OCCASE24
*
*        CASE - AN S1/S1 SITUATION
*
OCCASE24 CLC   0(1,R3),0(R7)       COMPARE WINNER TO LOSER
         BNE   OCC24A
         LR    R2,R7               LOAD ADDR FOR EQUALS
*
*        EXIT TO EQUALS ROUTINE
*
         BASR  R14,R12             CALL EQUALS ROUTINE
OCC24A   BNH   OCNEXT
OCEXCH   ST    R3,8(,R5)           WINNER TO LOSER
         LR    R3,R7               LOSER TO WINNER
OCNEXT   L     R5,0(,R5)           ADDR OF NEXT NODE
OCNEXT2  LM    R6,R7,4(R5)         LOAD NODE
         B     0(R4,R6)            GOTO PROPER CASE
*
*        CASE - A T1/S1 SITUATION
*
OCCASE23 L     R4,OCSAME           UPDATE MODE
         LA    R10,64              FORMAT T1
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OCEXCH
*
*        CASE - AN S2/S1 SITUATION
*
OCCASE22 L     R4,OCSAME           UPDATE MODE
         LA    R10,48              FORMAT S2
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OCEXCH
*
*        CASE - A T2/S1 SITUATION
*
OCCASE21 L     R4,OCSAME           UPDATE MODE
         LA    R10,32              FORMAT T2
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OCEXCH
*
*        CASE - AN S2/T1 SITUATION
*
OCCASE18 L     R4,OCSTEMP          UPDATE MODE
         LA    R10,48              FORMAT S2
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OCEXCH
*
*        CASE - A T2/T1 SITUATION
*
OCCASE17 L     R4,OCSTEMP          UPDATE MODE
         LA    R10,32              FORMAT T2
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OCEXCH
*
*        CASE - AN S2/S2 SITUATION
*
OCCASE14 LA    R10,80              FORMAT S1
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OCCASE24
*
*        CASE - A T2/S2 SITUATION
*
OCCASE13 L     R4,OCNEW            UPDATE MODE
*
*        CASE - A T2/T2 SITUATION
*
OCCASE9  LA    R10,64              FORMAT T1
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OCEXCH
*
*        CASE - AN S2/T2 SITUATION
*
OCCASE10 LA    R10,64              FORMAT T1
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OCNEXT
*
*        INDICATES THE TREE IS FILLED AND FORCES THE NETWORK INTO
*        A RUNNING SITUATION
*
OCCASE8  ST    R3,WCLTNODE         SAVE ADDR OF RECD IN LAST TEST NODE
         MVC   OCMODLOC(4),OCMODC8 MODIFY BRANCH TABLE
OCC8A    NOP   OCRETEOF            INITIALIZED TO BRANCH AT FILE < G
         L     R11,PPIDEB+4        DEBLOCK BASE REGISTER
*
*        EXIT TO DEBLOCK ROUTINE
*
         B     0(,R11)             MODIFY AND GET
*
*        INDICATES THERE IS A RECORD TO BE BLOCKED
*
OCCASE8A L     R10,WCLTNODE        ADDR OF RECORD IN LAST TEST NODE
         ST    R3,WCLTNODE         ADDR OF NEXT RECD TO LAST TEST NODE
         LR    R3,R10              ADDR TO WINNER POSITION
         LA    R3,4(,R3)           INCREMENT ADDR BY 4 BYTES
         L     R11,PPIBLK+4        BLOCK BASE REGISTER
*
*        EXIT TO BLOCK ROUTINE
*
         B     12(,R11)            PUT INFERS GET
*
*        INDICATES THAT A T1 (IMAGINARY) HAS BEEN FORCED OUT OF
*        THE TREE
*
OCCASE7  L     R10,WCLTNODE        ADDR OF RECORD IN LAST TEST NODE
         ST    R3,0(,R10)          NODE ADDR (T1) WITH RECORD HELD BACK
         LR    R5,R3               NODE ADDR AS NEXT LEVEL ADDR
OCC7A    L     R10,OCNTEMP         MODE NTEMP
         ST    R10,WCSPECL         SET SPECIAL INDICATOR TO NTEMP
         L     R11,PPIDEB+4        DEBLOCK BASE REGISTER
*
*        EXIT TO DEBLOCK ROUTINE
*
         B     8(,R11)             GET TO FILL (DEBLOCK EXIT MODIFIED)
*
*        INDICATES THAT IT IS THE END OF A SEQUENCE
*
OCCASE6  L     R10,OCSTEMP         MODE STEMP
         ST    R10,WCSPECL         SET SPECIAL INDICATOR TO STEMP
         L     R10,WCLTNODE        ADDR OF RECORD IN LAST TEST NODE
         ST    R3,WCLTNODE         ADDR OF NEXT RECD TO LAST TEST NODE
         LR    R3,R10              ADDR TO WINNER POSITION
         LA    R3,4(,R3)           INCREMENT ADDR BY 4 BYTES
         L     R11,PPIBLK+4        BLOCK BASE REGISTER
*
*        EXIT TO BLOCK ROUTINE
*
         B     4(,R11)             PUT EOS
*
*        INDICATES THAT IT IS END OF FILE
*
OCCASE5  L     R3,WCLTNODE         ADDR OF RECORD IN LAST TEST NODE
         LA    R3,4(0,R3)          INCREMENT ADDR BY 4 BYTES
         L     R11,PPIBLK+4        BLOCK BASE REGISTER
*
*        EXIT TO BLOCK ROUTINE
*
         B     0(,R11)             PUT EOF
*
*        CASE - AN S1/- SITUATION
*
OCCASE4  ST    R3,8(,R5)           WINNER TO LOSER
         LA    R10,80              FORMATS1
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OCPICK
*
*        CASE - A T1/- SITUATION
*
OCCASE3  ST    R3,8(,R5)           WINNER TO LOSER
         LA    R10,64              FORMAT T1
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OCPICK
*
*        ENTRY FROM DEBLOCK WHILE RUNNING (RECORD FITS)
*
*        SEQUENCE CHECKS THE NEW RECORD AND STARTS IT THROUGH
*        THE REPLACEMENT NETWORK
*
OCGOTRUN S     R3,KCFOUR           DECREMENT NEW ADDR BY FOUR BYTES
         L     R10,OCSTEMP         MODE STEMP
         ST    R10,WCSPECL         SET SPECIAL INDICATOR TO STEMP
         L     R2,WCLTNODE         ADDR OF RECORD IN LAST TEST NODE
         L     R5,0(,R2)           NODE ADDR WITH RECORD HELD BACK
         ST    R5,0(,R3)           NODE ADDR WITH NEW RECORD
         CLC   0(1,R3),0(R2)       COMPARE NEW RECORD TO ONE HELD BACK
         BNE   OCSCHECK
*
*        EXIT TO EQUALS ROUTINE
*
         BASR  R14,R12             CALL EQUALS ROUTINE
OCSCHECK BL    OCMODNEW
         L     R4,OCSAME           UPDATE MODE
         B     OCNEXT2
*
OCMODNEW L     R4,OCNEW            UPDATE MODE
         B     OCNEXT2
*
*        SET UP TO FLUSH ANOTHER RECORD FROM THE TREE AFTER END
*        OF FILE OR BECAUSE THE INCOMONG RECORD WILL NOT FIT
*
*        ENTRY FROM DEBLOCK AFTER EOF
*
OCRETEOF L     R4,OCNTEMP          UPDATE MODE
         B     OCSUBNO
*
*        ENTRY FROM DEBLOCK WHILE RUNNING (RECORD DOES NOT FIT)
*
OCNOGORN L     R4,WCSPECL          UPDATE MODE
OCSUBNO  L     R10,WCLTNODE        ADDR OF RECORD IN LAST TEST NODE
         L     R5,0(,R10)          NODE ADDR WITH RECORD HELD BACK
         LR    R3,R5               TREE ADDR AS WINNER
         B     OCNEXT2
*
*        CONSTANTS
*
         DC    0F'0'               FORCE FULL WORD BOUNDARY
KCFOUR   DC    X'00000004'         ADDR DECREMENT
*
*        WORK AREAS
*        THE ORDERING OF THESE WORK AREAS MUST BE MAINTAINED
*
WCSAVE   DC    3F'0'               FILLING REGISTER SAVE AREA
WCTREE   DC    F'0'                LOCATION OF TREE
WCLTNODE DC    F'0'                LAST TEST NODE
         DC    A(16)               FORMAT OF LAST TEST NODE
WCSPECL  DC    A(OCBTABLE+8)       SPECIAL (MODE) INDICATOR
*
*        MODIFICATION INSTRUCTIONS
*
*        THE ORDERING OF THESE INSTRUCTIONS MUST BE MAINTAINED
*
OCMODC8  B     OCCASE8A            MODIFICATION TO HOLD BACK A RECORD
OCC7EOF  L     R4,OCNTEMP          UPDATE MODE * MODIFICATION TO CASE7
         B     OCNEXT2                         * TO FORCE TREE FLUSHING
*
./ ADD NAME=IERROD   0101-20211-20211-1200-00089-00089-00000-RELEASE 00
ROD      TITLE 'IERROD - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERROD
*
*        MODULE FUNCTION/OPERATION -
*        REPLACEMENT NETWORK FOR VARIABLE LENGTH RECORDS WHICH
*        CONTAIN SINGLE CONTROL FIELDS AND/OR REQUIRE EXTRACT.
*        THIS MODULE GENERATES ASCENDING OR DESCENDING SEQUENCES
*        USING A REPLACEMENT SELECTION TECHNIQUE
*
*        MODULES IN WHICH THIS MODULE APPEARS A DSECT -
*        IERAOD, IERROZ, IERAOZ
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM INITIAL WRITE ROUTINE
*                       CALLING SEQUENCE -
*                         L   R11,PPINET
*                         BR  R11 ENTER NETWORK TO FILL TREE
*
*                     - ENTRY FROM DEBLOCK ROUTINE
*                       CALLING SEQUENCE -
*                         L  R11,PPINET
*                         B  X(,R11)
*
*                         WHERE X =  4 FOR ENTRY WHILE FILLING
*                                 =  8 FOR ENTRY AT EOF
*                                 = 12 FOR ENTRY WHILE RUNNING
*                                 = 16 FOR ENTRY AFTER EOF
*                                 = 24 FOR ENTRY FROM DEBLOCK
*                                      WHILE FILLING (NO FIT)
*                                 = 28 FOR ENTRY FROM DEBLOCK
*                                      WHILE RUNNING (NO FIT)
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPISRTG
*        COMPARES FILE SIZE TO G (PPISRTG)
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED - N/A
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL - ADDR IN PPIDEB+4 (DEBLOCK)
*                                 PLUS DISP=8 WHEN FILLING TREE
*
*                                 PLUS DISP=0 FIRST TIME AFTER
*                                             TREE IS FILLED
*
*                       - ADDR IN PPIADSSC
*                                 PLUS DISP=20 TO CLOSE WHEN
*                                              INPUT FILE ZERO
*
*                       - ADDR IN PPIBLK+4 (BLOCK)
*                                 PLUS DISP=0 TO BLOCK AT EOF
*
*                                 PLUS DISP=4 TO BLOCK AT EOS
*
*                                 PLUS DISP=12 FOR NORMAL BLOCK
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS -
*        WCSAVE   - FILLING REGISTER SAVE AREA
*        WCTREE   - TREE LOCATION
*        WCLTNODE - FORMAT OF LAST NODE
*
*        NOTES - N/A
*
IERROD   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERROD SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRODI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERRODI  0101-20211-20211-1200-00335-00335-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERROD SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERRODI
*
         USING *,R11
         USING IERRCA,R13
*
*        ** ENTRY TABLE
*
IERDOA   B     OCPICK              +00 FILL TREE
         B     OCGOTFIL            +04 FROM DEBLK WHILE FILLING (FIT)
         B     OCEOF               +08 FROM DEBLK AT EOF
         B     OCGOTRUN            +12 FROM DEBLK WHILE RUNNING (FIT)
         B     OCRETEOF            +16 FROM DEBLK AFTER EOF
         DC    A(0)                +20 TO KEEP INC IN ENTRY TABLE
         B     OCNOGOFI            +24 FROM DEBLK WHILE FILLING NOFIT
         B     OCNOGORN            +28 FROM DEBLK WHILE RUNNING NOFIT
*
*        INITIAL ENTRY TO START FILLING OR ENTRY TO CONTINUE
*        FILLING TREE
*
OCPICK   L     R11,PPIDEB+4        DEBLOCK BASE REGISTER
*
*        EXIT TO DEBLOCK ROUTINE
*
         B     8(,R11)             GET TO FILL
*
*        SETS UP TO FILL THE TREE WITH REAL OR IMAGINARY RECORDS
*        AND DETERMINES WHEN THE TREE IS FILLED
*
*        ENTRY FROM DEBLOCK WHILE FILLING (RECORD FITS)
*
OCGOTFIL S     R3,KCINCDEC         DECREMENT NEW ADDR BY EXTRACT INC+4
         CLI   KCSWITCH+3,X'FF'    EXTRACT SWITCH ON ?
         BNE   OCNOTON1            NO, BRANCH
*
*        EXIT TO EXTRACT ROUTINE
*
         BAS   R14,4(,R12)         CALL EXTRACT ROUTINE
OCNOTON1 LM    R7,R9,WCSAVE        FILLING REGISTERS
         L     R4,OCSAME           UPDATE MODE
         ST    R9,0(,R3)           ADDR OF TREE WITH RECORD
OCSUBFIT LR    R5,R9               ADDR OF TREE (NEXT LEVEL ADDR)
         BCT   R7,OCGCT            DECREMENT WAY COUNTER
         LA    R7,2                RESET WAY COUNTER
         LA    R9,12(,R9)          INCREMENT TO NEXT NODE
OCGCT    BCT   R8,OCFILREG         DECREMENT G COUNTER
         STM   R7,R9,WCSAVE
         B     OCNEXT2
*
OCFILREG STM   R7,R9,WCSAVE        SAVE FILLING REGISTERS
         B     OCNEXT2
*
*
*        ENTRY FROM DEBLOCK WHILE FILLING (RECORD DOES NOT FIT)
*
OCNOGOFI LM    R7,R9,WCSAVE        FILLING REGISTERS
         L     R4,OCSTEMP          UPDATE MODE
         LR    R3,R9               USE TREE ADDR AS WINNER
         B     OCSUBFIT
*
*        DETERMINES IF EOF SITUATION IS A NORMAL ONE
*        FILE SIZE LESS THEN G, OR FILE SIZE IS ZERO AND
*        BRANCHES ACCORDINGLY
*
*        ENTRY FROM DEBLOCK AT EOF
*
OCEOF    CLC   PPISRTG(4),WCSAVE+4  COMPARE G COUNT IN PPIA TO FILL NO
         BNE   OCNOZERO
*
*        EXIT TO CLOSE ROUTINE
*
         LA    R1,4                SET UP PARAMETER TO END OF PHASE
         L     R15,PPIADSSC        R15 -> SSC
         BAS   R14,20(,R15)        INPUT FILE WAS ZERO
*
OCNOZERO MVC   OCC7A(8),OCC7EOF    MODIFY CASE7 TO FORCE TREE FLUSHING
         LA    R10,0               CONSTANT OF 0
         CL    R10,WCSAVE+4        COMPARE TO FILL COUNT ?
         BE    OCRETEOF            EQUAL
*
*        FILE SIZE IS LESS THAN G
*        THE CODING IS MODIFIED TO FILL THE REMAINDER OF THE
*        TREE WITH IMAGINARY RECORDS (T1)
*
         OI    OCC8A+1,X'F0'       INITIALIZE BRANCH INST IN CASE8
         MVC   OCPICK(4),OCMODIFY  MODIFY FILLING RETURN LOCATION
OCMODIFY B     OCNOGOFI
*
*        MODE POSITIONS AND BRANCH TABLE
*
*        THROUGH THE COMBINATION OF MODE AND FORMAT AN INDEXED
*        BRANCH IS PERFORMED WHICH BRANCHES TO THE CASE WHICH
*        HANDLES THE INDICATED SITUATION
*
OCNTEMP  DC    A(OCBTABLE)
OCNEW    DC    A(OCBTABLE+4)
OCSTEMP  DC    A(OCBTABLE+8)
OCSAME   DC    A(OCBTABLE+12)
OCBTABLE DC    A(0)                SPACE TO MAINTAIN POSITIONS IN TABLE
         DC    A(0)                SPACE TO MAINTAIN POSITIONS IN TABLE
         B     OCCASE3
         B     OCCASE4
         B     OCCASE5
         B     OCCASE6
         B     OCCASE7
OCMODLOC B     OCCASE8
         B     OCCASE9
         B     OCCASE10
         B     OCNEXT
         B     OCNEXT
         B     OCCASE13
         B     OCCASE14
         B     OCNEXT
         B     OCNEXT
         B     OCCASE17
         B     OCCASE18
         B     OCNEXT
         B     OCNEXT
         B     OCCASE21
         B     OCCASE22
         B     OCCASE23
         B     OCCASE24
*
*        CASE - AN S1/S1 SITUATION
*
OCCASE24 CLC   0(1,R3),0(R7)       COMPARE WINNER TO LOSER
         BNH   OCNEXT
OCEXCH   ST    R3,8(,R5)           WINNER TO LOSER
         LR    R3,R7               LOSER TO WINNER
OCNEXT   L     R5,0(,R5)           ADDR OF NEXT NODE
OCNEXT2  LM    R6,R7,4(R5)         LOAD NODE
         B     0(R4,R6)            GOTO PROPER CASE
*
*        CASE - A T1/S1 SITUATION
*
OCCASE23 L     R4,OCSAME           UPDATE MODE
         LA    R10,64              FORMAT T1
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OCEXCH
*
*        CASE - AN S2/S1 SITUATION
*
OCCASE22 L     R4,OCSAME           UPDATE MODE
         LA    R10,48              FORMAT S2
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OCEXCH
*
*        CASE - A T2/S1 SITUATION
*
OCCASE21 L     R4,OCSAME           UPDATE MODE
         LA    R10,32              FORMAT T2
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OCEXCH
*
*        CASE - AN S2/T1 SITUATION
*
OCCASE18 L     R4,OCSTEMP          UPDATE MODE
         LA    R10,48              FORMAT S2
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OCEXCH
*
*        CASE - A T2/T1 SITUATION
*
OCCASE17 L     R4,OCSTEMP          UPDATE MODE
         LA    R10,32              FORMAT T2
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OCEXCH
*
*        CASE - AN S2/S2 SITUATION
*
OCCASE14 LA    R10,80              FORMAT S1
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OCCASE24
*
*        CASE - A T2/S2 SITUATION
*
OCCASE13 L     R4,OCNEW            UPDATE MODE
*
*        CASE - A T2/T2 SITUATION
*
OCCASE9  LA    R10,64              FORMAT T1
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OCEXCH
*
*        CASE - AN S2/T2 SITUATION
*
OCCASE10 LA    R10,64              FORMAT T1
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OCNEXT
*
*        INDICATES THE TREE IS FILLED AND FORCES THE NETWORK INTO
*        A RUNNING SITUATION
*
OCCASE8  ST    R3,WCLTNODE         SAVE ADDR OF RECD IN LAST TEST NODE
         MVC   OCMODLOC(4),OCMODC8 MODIFY BRANCH TABLE
OCC8A    NOP   OCRETEOF            INITIALIZED TO BRANCH AT FILE < G
         L     R11,PPIDEB+4        DEBLOCK BASE REGISTER
*
*        EXIT TO DEBLOCK ROUTINE
*
         B     0(,R11)             MODIFY AND GET
*
*        INDICATES THERE IS A RECORD TO BE BLOCKED
*
OCCASE8A L     R10,WCLTNODE        ADDR OF RECORD IN LAST TEST NODE
         ST    R3,WCLTNODE         ADDR OF NEXT RECD TO LAST TEST NODE
         LR    R3,R10              ADDR TO WINNER POSITION
         A     R3,KCINCDEC         INC ADDR BY EXTRACT INCREMENT+4
         L     R11,PPIBLK+4        BLOCK BASE REGISTER
*
*        EXIT TO BLOCK ROUTINE
*
         B     12(,R11)            PUT INFERS GET
*
*        INDICATES THAT A T1 (IMAGINARY) HAS BEEN FORCED OUT OF
*        THE TREE
*
OCCASE7  L     R10,WCLTNODE        ADDR OF RECORD IN LAST TEST NODE
         ST    R3,0(,R10)          NODE ADDR (T1) WITH RECORD HELD BACK
         LR    R5,R3               NODE ADDR AS NEXT LEVEL ADDR
OCC7A    L     R10,OCNTEMP         MODE NTEMP
         ST    R10,WCSPECL         SET SPECIAL INDICATOR TO NTEMP
         L     R11,PPIDEB+4        DEBLOCK BASE REGISTER
*
*        EXIT TO DEBLOCK ROUTINE
*
         B     8(,R11)             GET TO FILL (DEBLOCK EXIT MODIFIED)
*
*        INDICATES THAT IT IS THE END OF A SEQUENCE
*
OCCASE6  L     R10,OCSTEMP         MODE STEMP
         ST    R10,WCSPECL         SET SPECIAL INDICATOR TO STEMP
         L     R10,WCLTNODE        ADDR OF RECORD IN LAST TEST NODE
         ST    R3,WCLTNODE         ADDR OF NEXT RECD TO LAST TEST NODE
         LR    R3,R10              ADDR TO WINNER POSITION
         A     R3,KCINCDEC         INC ADDR BY EXTRACT INCREMENT+4
         L     R11,PPIBLK+4        BLOCK BASE REGISTER
*
*        EXIT TO BLOCK ROUTINE
*
         B     4(,R11)             PUT EOS
*
*        INDICATES THAT IT IS END OF FILE
*
OCCASE5  L     R3,WCLTNODE         ADDR OF RECORD IN LAST TEST NODE
         A     R3,KCINCDEC         INC ADDR BY EXTRACT INCREMENT+4
         L     R11,PPIBLK+4        BLOCK BASE REGISTER
*
*        EXIT TO BLOCK ROUTINE
*
         B     0(,R11)             PUT EOF
*
*        CASE - AN S1/- SITUATION
*
OCCASE4  ST    R3,8(,R5)           WINNER TO LOSER
         LA    R10,80              FORMATS1
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OCPICK
*
*        CASE - A T1/- SITUATION
*
OCCASE3  ST    R3,8(,R5)           WINNER TO LOSER
         LA    R10,64              FORMAT T1
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OCPICK
*
*        ENTRY FROM DEBLOCK WHILE RUNNING (RECORD FITS)
*
*        SEQUENCE CHECKS THE NEW RECORD AND STARTS IT THROUGH
*        THE REPLACEMENT NETWORK
*
OCGOTRUN S     R3,KCINCDEC         DECREMENT NEW ADDR BY EXTRACT INC+4
         CLI   KCSWITCH+3,X'FF'    EXTRACT SWITCH ON ?
         BNE   OCNOTON2            NO, BRANCH
*
*        EXIT TO EXTRACT ROUTINE
*
         BAS   R14,4(,R12)         CALL EXTRACT ROUTINE
OCNOTON2 L     R10,OCSTEMP         MODE STEMP
         ST    R10,WCSPECL         SET SPECIAL INDICATOR TO STEMP
         L     R2,WCLTNODE         ADDRESS OF RECORD IN LAST TEST NODE
         L     R5,0(,R2)           NODE ADDR WITH RECORD HELD BACK
         ST    R5,0(,R3)           NODE ADDR WITH NEW RECORD
         CLC   0(1,R3),0(R2)       COMPARE NEW RECORD TO ONE HELD BACK
         BL    OCMODNEW
         L     R4,OCSAME           UPDATE MODE
         B     OCNEXT2
*
OCMODNEW L     R4,OCNEW            UPDATE MODE
         B     OCNEXT2
*
*        SET UP TO FLUSH ANOTHER RECORD FROM THE TREE AFTER END
*        OF FILE OR BECAUSE THE INCOMONG RECORD WILL NOT FIT
*
*        ENTRY FROM DEBLOCK AFTER EOF
*
OCRETEOF L     R4,OCNTEMP          UPDATE MODE
         B     OCSUBNO
*
*        ENTRY FROM DEBLOCK WHILE RUNNING (RECORD DOES NOT FIT)
*
OCNOGORN L     R4,WCSPECL          UPDATE MODE
OCSUBNO  L     R10,WCLTNODE        ADDR OF RECORD IN LAST TEST NODE
         L     R5,0(,R10)          NODE ADDR WITH RECORD HELD BACK
         LR    R3,R5               TREE ADDR AS WINNER
         B     OCNEXT2
*
*        CONSTANTS
*
KCSWITCH DC    X'00000000'         EXTRACT SWITCH
KCINCDEC DC    F'0'                ADDR INC OR DEC OF EXTRACT INC+4
*
*        WORK AREAS
*        THE ORDERING OF THESE WORK AREAS MUST BE MAINTAINED
*
WCSAVE   DC    3F'0'               FILLING REGISTER SAVE AREA
WCTREE   DC    F'0'                LOCATION OF TREE
WCLTNODE DC    F'0'                LAST TEST NODE
         DC    A(16)               FORMAT OF LAST TEST NODE
WCSPECL  DC    A(OCBTABLE+8)       SPECIAL (MODE) INDICATOR
*
*        MODIFICATION INSTRUCTIONS
*
*        THE ORDERING OF THESE INSTRUCTIONS MUST BE MAINTAINED
*
OCMODC8  B     OCCASE8A            MODIFICATION TO HOLD BACK A RECORD
OCC7EOF  L     R4,OCNTEMP          UPDATE MODE * MODIFICATION TO CASE7
         B     OCNEXT2                         * TO FORCE TREE FLUSHING
*
./ ADD NAME=IERROE   0101-20211-20211-1200-00080-00080-00000-RELEASE 00
ROE      TITLE 'IERROE - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERROE
*
*        MODULE FUNCTION/OPERATION -
*        POLYPHASE REPLACEMENT NETWORK FOR FIXED LENGTH RECORDS
*        CONTAINING MULTIPLE CONTROL FIELDS
*        THIS MODULE GENERATES ASCENDING OR DESCENDING SEQUENCES
*        USING A REPLACEMENT SELECTION TECHNIQUE
*
*        MODULES IN WHICH THIS MODULE APPEARS A DSECT - IERAOE
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM INITIAL WRITE ROUTINE
*                       CALLING SEQUENCE -
*                         L   R11,PPINET
*                         BR  R11       ENTER NETWORK TO FILL TREE
*
*                     - ENTRY FROM DEBLOCK ROUTINE
*                       CALLING SEQUENCE -
*                         L  R11,PPINET
*                         B  X(,R11)
*                            X= 4 ENTRY WHILE FILLING
*                             = 8 ENTRY AT EOF
*                             =12 ENTRY WHILE RUNNING
*                             =16 ENTRY AFTER EOF
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPISRTG
*        COMPARES FILE SIZE TO G (PPISRTG)
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED - N/A
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL - ADDR IN PPIDEB+4 (DEBLOCK)
*                                 PLUS DISP= 0 FIRST TIME AFTER
*                                              TREE IS FILLED
*                                 PLUS DISP= 8 WHEN FILLING TREE
*
*                       - ADDR IN PPIADSSC
*                                 PLUS DISP=20 TO CLOSE WHEN
*                                              INPUT FILE ZERO
*
*                       - ADDR IN PPIBLK+4 (BLOCK)
*                                 PLUS DISP= 0 TO BLOCK AT EOF
*                                 PLUS DISP= 4 TO BLOCK AT EOS
*                                 PLUS DISP=12 FOR NORMAL BLOCK
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS -
*        WASAVE   - FILLING REGISTER SAVE AREA
*        WATREE   - LOCATION OF TREE
*        WALTNODE - LAST TEST NODE
*
*        NOTES - N/A
*
IERROE   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERROE SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERROEI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERROEI  0101-20211-20211-1200-00651-00651-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERROE SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERROEI
*
         USING *,R11
         USING IERRCA,R13
*
*        ENTRY TABLE
*
IERDOA   B     OAPICK              +00 FILL TREE
         B     OAFIRET             +04 FROM DEBLOCK WHILE FILLING
         B     OAEOF               +08 FROM DEBLOCK AT EOF
         B     OARETRUN            +12 FROM DEBLOCK WHILE RUNNING
         B     OARETEOF            +16 FROM DEBLOCK AFTER EOF
*                                  +20
*
*        ENTRY FROM ALGORITHM TO INDICATE THE SEQUENCE AFTER THIS
*        IS TO BE REVERSED
*
*        REVERSE CONDITIONAL BRANCHES WHICH DETERMINE THE
*        RESULTS OF COMPARES BETWEEN RECORDS OF THE NEW OR NEXT
*        SEQUENCE
*
         XI    OAC10A+1,X'60'      IN CASE 10
         XI    OAC18A+1,X'60'      IN CASE 18
         XI    OAC22A+1,X'60'      IN CASE 22
         XI    OAC30A+1,X'60'      IN CASE 30
         XI    OAC30B+1,X'60'      IN CASE 30
         XI    OAC34A+1,X'60'      IN CASE 34
         XI    OAC38B+1,X'60'      IN CASE 38
*
*        SET A SWITCH ON IN THE END OF SEQUENCE CODE CASE 6
*
         LA    R10,255             CONSTANT 'FF'
         ST    R10,KAREVSW         SET REVERSAL SWITCH ON IN CASE 6
*
*        INITIAL ENTRY TO START FILLING OR ENTRY TO CONTINUE
*        FILLING TREE
*
OAPICK   L     R11,PPIDEB+4        DEBLOCK BASE REGISTER
*
*        EXIT TO DEBLOCK ROUTINE
*
         B     8(,R11)             GET TO FILL OR GET FOR REVERSAL
*
*        ENTRY FROM DEBLOCK WHILE FILLING
*
*        SETS UP TO FILL THE TREE AND DETERMINES WHEN THE TREE
*        IS FILLED
*
OAFIRET  S     R3,KAFOUR           DECREMENT NEW ADDR BY FOUR BYTES
         LM    R7,R9,WASAVE        FILLING REGISTERS
         ST    R9,0(,R3)           ADDR OF TREE WITH RECORD
OAFILDUM LR    R5,R9               ADDR OF TREE (NLA)
         BCT   R7,OAGCT            DECREMENT WAY COUNTER
         LA    R7,4                RESET WAY COUNTER
         LA    R9,20(,R9)          INCREMENT TO NEXT NODE
OAGCT    BCT   R8,OAMORE           DECREMENT G COUNTER
         L     R4,OASAME           SET MODE
         STM   R7,R9,WASAVE
         CLC   OAGCT+4(4),OANOSAME   RUNNING OR FLUSHING ?
         BNE   OANEXT2             RUNNING SITUATION
         MVC   OACASE44(4),OA44FLSH  OVERLAY TO BRANCH TO FLUSH ROUTINE
         MVC   OACAS27(2),KNOP     NOP THE BR INSTR TO THE FILL ROUTINE
         MVC   OACAS15(2),KNOP     NOP THE BR INSTR TO THE FILL ROUTINE
         MVC   OACASE41(4),OA41FLSH  OVERLAY TO BR TO FLUSH RTN CASE 41
         B     OANEXT2             FLUSHING SITUATION
*
OAMORE   L     R4,OAFILL           SET MODE
         STM   R7,R9,WASAVE        SAVE FILLING REGISTERS
         B     OANEXT2
*
*        ENTRY FROM DEBLOCK AT EOF
*
*        DETERMINES IF EOF SITUATION IS A NORMAL ONE
*        FILE SIZE LESS THEN G, OR FILE SIZE IS ZERO AND
*        BRANCHES ACCORDINGLY
*
OAEOF    CLC   PPISRTG(4),WASAVE+4  COMPARE G COUNT IN PPI TO FILL NO
         BNE   OANOZERO
*
*        EXIT TO CLOSE ROUTINE
*
         LA    R1,4                SET UP PARAMETER TO END OF PHASE
         L     R15,PPIADSSC        R15 -> SSC
         BAS   R14,20(,R15)        INPUT FILE WAS ZERO
*
OANOZERO LA    R10,0               CONSTANT OF 0
         CL    R10,WASAVE+4        COMPARE TO FILL COUNT
         BE    OARETEOF
*
*        FILE SIZE IS LESS THAN G
*        THE CODING IS MODIFIED TO FILL THE REMAINDER OF THE
*        TREE WITH FAKE RECORDS. THESE RECORDS ARE THE TREE ADDRS
*
         MVC   OACASE44(4),OA44FILL  MOD TO CHECK FOR DUMMY RCD
         MVC   OACAS27(4),OAMODC27   MOD TO CHECK FOR DUMMY RCD
         MVC   OACAS15(4),OAMODC15   MOD TO CHECK FOR DUMMY RCD
         MVC   OAC8A(6),OACHMVC     MODIFICATION TO CHECK FOR DUMMY REC
         OI    OACSUB8+1,X'F0'      INITIALIZE BRANCH INST IN CASE 8
         MVC   OAGCT+4(4),OANOSAME  MODIFICATION TO START TREE FLUSHING
         MVC   OAPICK(12),OAMODIFY  MODIFY FILLING RETURN LOCATION
OAMODIFY LM    R7,R9,WASAVE         FILLING REGISTERS
         L     R3,WATREE            DUMMY ADDRESS
         B     OAFILDUM
*
*        MODE POSITIONS AND BRANCH TABLE
*
*        THROUGH THE COMBINATION OF MODE AND FORMAT AN INDEXED
*        BRANCH IS PERFORMED WHICH BRANCHES TO THE CASE WHICH
*        HANDLES THE INDICATED SITUATION
*
OAFLUSH  DC    A(OABTABLE)
OANEW    DC    A(OABTABLE+4)
OAFILL   DC    A(OABTABLE+8)
OASAME   DC    A(OABTABLE+12)
OABTABLE B     OANEXT
         B     OANEXT
         B     OACASE3
         B     OANEXT
         B     OACASE5
         B     OACASE6
         DC    A(0)                SPACE TO MAINTAIN POSITIONS IN TABLE
OAMODLOC B     OACASE8
         B     OACASE9
         B     OACASE10
         DC    A(0)                SPACE TO MAINTAIN POSITIONS IN TABLE
         B     OANEXT
         B     OACASE13
         B     OACASE14
         B     OACASE15
         B     OACASE16
         B     OACASE17
         B     OACASE18
         DC    A(0)                SPACE TO MAINTAIN POSITIONS IN TABLE
         B     OANEXT
         B     OACASE21
         B     OACASE22
         DC    A(0)                SPACE TO MAINTAIN POSITIONS IN TABLE
         B     OACASE16
         B     OACASE25
         B     OACASE26
         B     OACASE27
         B     OACASE28
         B     OACASE29
         B     OACASE30
         DC    A(0)                SPACE TO MAINTAIN POSITIONS IN TABLE
         B     OANEXT
         B     OACASE33
         B     OACASE34
         DC    A(0)                SPACE TO MAINTAIN POSITIONS IN TABLE
         B     OACASE16
         B     OACASE37
         B     OACASE38
         DC    A(0)                SPACE TO MAINTAIN POSITIONS IN TABLE
         B     OACASE28
         B     OACASE41
         B     OACASE42
         B     OACASE44
         B     OACASE44
*
*        CASE - AN S/SSS SITUATION WHILE RUNNING
*
OACASE44 NOP   *+4                 WILL BE BAL R14,OASUB1 ON FILE < G
*                                  FILL, ORBAL R14 OASUBF44 FLUSH
         CLC   0(1,R3),0(R8)       COMPARE WINNER TO LOSER 2
         BNE   OAC44A
         LR    R2,R8               LOAD ADDR FOR EQUALS
*
*        EXIT TO EQUALS ROUTINE
*
         BASR  R14,R12             CALL EQUALS ROUTINE
OAC44A   BNH   OACASE16
         CLC   0(1,R3),0(R9)       COMPARE WINNER TO LOSER 3
         BNE   OAC44B
         LR    R2,R9               LOAD ADDR FOR EQUALS
*
*        EXIT TO EQUALS ROUTINE
*
         BASR  R14,R12             LINK TO EQUALS ROUTINE
OAC44B   BNH   OASHIFT3
OASHIFT4 STM   R8,R9,8(R5)         LOSER 2 + 3 TO LOSER 1 + 2
         ST    R3,16(,R5)          WINNER TO LOSER 3
         LR    R3,R7               LOSER 1 TO WINNER
OANEXT   L     R5,0(,R5)           ADDR OF NEXT NODE
OANEXT2  LM    R6,R9,4(R5)         LOAD NODE
         B     0(R4,R6)            GOTO PROPER CASE
*
*        CASE - AN N/SSS SITUATION WHILE RUNNING
*
OACASE42 L     R4,OASAME           UPDATE MODE
         LA    R10,144             FORMAT SSN
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OASHIFT4
*
*        CASE - AN -/SSS SITUATION WHILE FLUSHING
*
OACASE41 NOP   OASUBF41            WILL BE BAL R14,OASUBF41 WHEN FLUSHG
OASUB41  L     R4,OASAME           UPDATE MODE
         LA    R10,96              FORMAT SS-
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OASHIFT4
*
*        CASE - AN N/SSN SITUATION WHILE RUNNING
*
OACASE38 L     R4,OASAME           UPDATE MODE
         LA    R10,128             FORMAT SNN
         ST    R10,4(,R5)          UPDATE FORMAT
OAC38A   CLC   0(1,R3),0(R9)       COMPARE WINNER TO LOSER 3
         BNE   OAC38B
         LR    R2,R9               LOAD ADDR FOR EQUALS
*
*        EXIT TO EQUALS ROUTINE
*
         BASR  R14,R12             LINK TO EQUALS ROUTINE
OAC38B   BNL   OASHIFT3
         B     OASHIFT4
*
*        CASE - AN -/SSN SITUATION WHILE FLUSHING
*
OACASE37 L     R4,OASAME           UPDATE MODE
         LA    R10,80              FORMAT SN-
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OASHIFT4
*
*        CASE - AN N/SNN SITUATION WHILE RUNNING
*
OACASE34 L     R4,OASAME           UPDATE MODE
         LA    R10,112             FORMAT NNN
         ST    R10,4(,R5)          UPDATE FORMAT
         CLC   0(1,R3),0(R8)       COMPARE WINNER TO LOSER 2
         BNE   OAC34A
         LR    R2,R8               LOAD ADDR FOR EQUALS
*
*        EXIT TO EQUALS ROUTINE
*
         BASR  R14,R12             CALL EQUALS ROUTINE
OAC34A   BNL   OASHIFT2
         B     OAC38A
*
*        CASE - AN -/SNN SITUATION WHILE FLUSHING
*
OACASE33 L     R4,OASAME           UPDATE MODE
         LA    R10,64              FORMAT NN-
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OASHIFT4
*
*        CASE - AN N/NNN SITUATION WHILE RUNNING
*
OACASE30 LA    R10,160             FORMAT SSS
         ST    R10,4(,R5)          UPDATE FORMAT
         CLC   0(1,R3),0(R8)       COMPARE WINNER TO LOSER 2
         BNE   OAC30A
         LR    R2,R8               LOAD ADDR FOR EQUALS
*
*        EXIT TO EQUALS ROUTINE
*
         BASR  R14,R12             CALL EQUALS ROUTINE
OAC30A   BNL   OAC10SS
         CLC   0(1,R3),0(R9)       COMPARE WINNER TO LOSER 3
         BNE   OAC30B
         LR    R2,R9               LOAD ADDR FOR EQUALS
*
*        EXIT TO EQUALS ROUTINE
*
         BASR  R14,R12             CALL EQUALS ROUTINE
OAC30B   BNL   OASHIFT3
         B     OASHIFT4
*
*        CASE - AN -/NNN SITUATION WHILE FLUSHING
*
OACASE29 L     R4,OANEW            UPDATE MODE
         LA    R10,96              FORMAT SS-
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OASHIFT4
*
*        CASE - AN S/SS- SITUATION WHILE RUNNING
*
OACASE28 CLC   0(1,R3),0(R8)       COMPARE WINNER TO LOSER 2
         BNE   OAC28A
         LR    R2,R8               LOAD ADDR FOR EQUALS
*
*        EXIT TO EQUALS ROUTINE
*
         BASR  R14,R12             CALL EQUALS ROUTINE
OAC28A   BNH   OACASE16
OASHIFT3 ST    R8,8(,R5)           LOSER 2 TO LOSER 1
         ST    R3,12(,R5)          WINNER TO LOSER 2
         LR    R3,R7               LOSER 1 TO WINNER
         L     R5,0(0,R5)          ADDR OF NEXT NODE
         LM    R6,R9,4(R5)         LOAD NODE
         B     0(R4,R6)            GOTO PROPER CASE
*
*        CASE - AN S/SS- SITUATION WHILE FILLING
*
OACASE27 LA    R10,160             FORMAT SSS
         ST    R10,4(,R5)          UPDATE FORMAT
OACAS27  NOP   *+4                 WILL BE BAL R14,OASUB2 ON FILE < G
         CLC   0(1,R3),0(R8)       COMPARE WINNER TO HIGH 2
         BNE   OAC27A
         LR    R2,R8               LOAD ADDRESS FOR EQUALS
*
*        EXIT TO EQUALS ROUTINE
*
         BASR  R14,R12             LINK TO EQUALS ROUTINE
OAC27A   BNH   OAC27B
OASUB2R  ST    R3,16(,R5)          WINNER TO LOSER 3
         B     OAPICK
*
OAC27B   CLC   0(1,R3),0(R7)       COMPARE WINNER TO LOSER 1
         BNE   OAC27C
         LR    R2,R7               LOAD ADDR FOR EQUALS
*
*        EXIT TO EQUALS ROUTINE
*
         BASR  R14,R12             LINK TO EQUALS ROUTINE
OAC27C   BNH   OAC27D
         ST    R8,16(,R5)          LOSER 2 TO LOSER 3
         ST    R3,12(,R5)          WINNER TO LOSER 2
         B     OAPICK
*
OAC27D   STM   R7,R8,12(R5)        LOSER 1 + 2 TO LOSER 2 + 3
         ST    R3,8(,R5)           WINNER TO LOSER 1
         B     OAPICK
*
*        CASE - AN N/SS- SITUATION WHILE RUNNING
*
OACASE26 L     R4,OASAME           UPDATE MODE
         LA    R10,80              FORMAT SN-
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OASHIFT3
*
*        CASE - AN -/SS- SITUATION WHILE FLUSHING
*
OACASE25 L     R4,OASAME           UPDATE MODE
         LA    R10,48              FORMAT S--
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OASHIFT3
*
*        CASE - AN N/SN- SITUATION WHILE RUNNING
*
OACASE22 L     R4,OASAME           UPDATE MODE
         LA    R10,64              FORMAT NN-
         ST    R10,4(,R5)          UPDATE FORMAT
         CLC   0(1,R3),0(R8)       COMPARE WINNER TO LOSER 2
         BNE   OAC22A
         LR    R2,R8               LOAD ADDR FOR EQUALS
*
*        EXIT TO EQUALS ROUTINE
*
         BASR  R14,R12             CALL EQUALS ROUTINE
OAC22A   BNL   OASHIFT2
         B     OASHIFT3
*
*        CASE - AN -/SN- SITUATION WHILE FLUSHING
*
OACASE21 L     R4,OASAME           UPDATE MODE
         LA    R10,32              FORMAT N--
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OASHIFT3
*
*        CASE - AN N/NN- SITUATION WHILE RUNNING
*
OACASE18 LA    R10,96              FORMAT SS-
         ST    R10,4(,R5)          UPDATE FORMAT
         CLC   0(1,R3),0(R8)       COMPARE WINNER TO LOSER 2
         BNE   OAC18A
         LR    R2,R8               LOAD ADDR FOR EQUALS
*
*        EXIT TO EQUALS ROUTINE
*
         BASR  R14,R12             CALL EQUALS ROUTINE
OAC18A   BNL   OAC10SS
         B     OASHIFT3
*
*        CASE - AN -/NN- SITUATION WHILE FLUSHING
*
OACASE17 L     R4,OANEW            UPDATE MODE
         LA    R10,48              FORMAT S--
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OASHIFT3
*
*        CASE - AN S/S-- SITUATION WHILE RUNNING
*
OACASE16 CLC   0(1,R3),0(R7)       COMPARE WINNER TO LOSER 1
         BNE   OAC16A
         LR    R2,R7               LOAD ADDR FOR EQUALS
*
*        EXIT TO EQUALS ROUTINE
*
         BASR  R14,R12             LINK TO EQUALS ROUTINE
OAC16A   BNH   OANEXT
OASHIFT2 ST    R3,8(,R5)           WINNER TO LOSER 1
         LR    R3,R7               LOSER 1 TO WINNER
         L     R5,0(,R5)           ADDR OF NEXT NODE
         LM    R6,R9,4(R5)         LOAD NODE
         B     0(R4,R6)            GOTO PROPER CASE
*
*        CASE - AN S/S-- SITUATION WHILE FILLING
*
OACASE15 LA    R10,96              FORMAT SS-
         ST    R10,4(,R5)          UPDATE FORMAT
OACAS15  BC    0,*+4               WILL BE BAL R14,OASUB3 ON FILE LTG
         CLC   0(1,R3),0(R7)       COMPARE WINNER TO LOSER 1
         BNE   OAC15A
         LR    R2,R7               LOAD ADDR FOR EQUALS
*
*        EXIT TO EQUALS ROUTINE
*
         BASR  R14,R12             CALL EQUALS ROUTINE
OAC15A   BH    OAC15B
         ST    R7,12(,R5)          LOSER 1 TO LOSER 2
         ST    R3,8(,R5)           WINNER TO LOSER 1
         B     OAPICK
*
OAC15B   ST    R3,12(,R5)          WINNER TO LOSER 2
         B     OAPICK
*
*        CASE - AN N/S-- SITUATION WHILE RUNNING
*
OACASE14 LA    R10,32              FORMAT N--
         ST    R10,4(,R5)          UPDATE FORMAT
         L     R4,OASAME           UPDATE MODE
         B     OASHIFT2
*
*        CASE - AN -/S-- SITUATION WHILE FLUSHING
*
OACASE13 L     R4,OASAME           UPDATE MODE
OAC13A   LA    R10,0               FORMAT ---
         ST    R10,4(,R5)          UPDATE FORMAT
         LR    R3,R7               LOSER 1 TO WINNER
         B     OANEXT
*
*        CASE - AN N/N-- SITUATION WHILE RUNNING
*
OACASE10 LA    R10,48              FORMAT S--
         ST    R10,4(,R5)          UPDATE FORMAT
OAC10SS  CLC   0(1,R3),0(R7)       COMPARE WINNER TO LOSER 1
         BNE   OAC10A
         LR    R2,R7               LOAD ADDR FOR EQUALS
*
*        EXIT TO EQUALS ROUTINE
*
         BASR  R14,R12             CALL EQUALS ROUTINE
OAC10A   BNL   OANEXT
         B     OASHIFT2
*
*        CASE - AN -/N-- SITUATION WHILE FLUSHING
*
OACASE9  L     R4,OANEW            UPDATE MODE
         B     OAC13A
*
*        INDICATES THE TREE IS FILLED AND FORCES THE NETWORK INTO
*        A RUNNING SITUATION
*
OACASE8  LR    R5,R3               TREE ADDR EQUALS DUMMY RECORD
         CL    R3,WATREE           REAL RECORD OR TREE ADDR ?
         BNL   OARETEOF+8          TREE ADDR, BRANCH
         ST    R3,WALTNODE         SAVE ADDR OF RECD IN LAST TEST NODE
OAC8A    MVC   OAMODLOC(4),OAMODC8B MODIFY BRANCH TABLE
OACSUB8  NOP   OARETEOF            INITIALIZED TO BRANCH AT FILE < G
         L     R11,PPIDEB+4        DEBLOCK BASE REGISTER
*
*        EXIT TO DEBLOCK ROUTINE
*
         B     0(,R11)             MODIFY AND GET
*
*        INDICATES THERE IS A RECORD TO BE BLOCKED
*
OACASE8A LR    R5,R7               TREE ADDR EQUALS DUMMY RECORD
         CL    R3,WATREE           REAL RECORD NOT TREE ADDR ?
         BNL   OARETEOF+8          TREE ADDR, BRANCH
OACASE8B L     R10,WALTNODE        ADDR OF RECORD IN LAST TEST NODE
         ST    R3,WALTNODE         ADDR OF NEXT RECD TO LAST TEST NODE
         LR    R3,R10              ADDR TO WINNER POSITION
         LA    R3,4(,R3)           INCREMENT ADDR BY 4 BYTES
         L     R11,PPIBLK+4        BLOCK BASE REGISTER
*
*        EXIT TO BLOCK ROUTINE
*
         B     12(,R11)            PUT INFERS GET
*
*        INDICATES THAT IT IS THE END OF A SEQUENCE
*
OACASE6  L     R10,WALTNODE        ADDR OF RECORD IN LAST TEST NODE
         ST    R3,WALTNODE         ADDR OF NEXT RECD TO LAST TEST NODE
         LR    R3,R10              ADDR TO WINNER POSITION
         LA    R3,4(,R3)           INCREMENT ADDR BY 4 BYTES
*
*        CHECK SEQUENCE REVERSING SWITCH
*        IF IT IS ON COMPLETE THE SEQUENCE REVERSING CYCLE
*
         CLI   KAREVSW+3,X'00'     CHECK REVERSAL SWITCH
         BE    OASWOFF             OFF, REVERSAL NOT IN PROCESS
*
*        TURN OFF RERVERSAL SWITCH
*        REVERSE THE CONDITIONAL BRANCHES WHICH DETERMINE THE
*        RESULTS OF COMPARES BETWEEN RECORDS OF THE PRESENT
*        SEQUENCE. REVERSE THE CONDITIONAL BRANCH WHICH
*        DETERMINES THE RESULT OF THE SEQUENCE CHECK OF THE
*        INCOMING RECORD
*
         SR    R10,R10             ZERO REG
         ST    R10,KAREVSW         TURN REVERSAL SWITCH OFF
         XI    OAC16A+1,X'60'      IN CASE 16
         XI    OAC28A+1,X'60'      IN CASE 28
         XI    OAC44A+1,X'60'      IN CASE 44
         XI    OAC44B+1,X'60'      IN CASE 44
         XI    OASCHECK+1,X'60'    IN SEQUENCE CHECK
OASWOFF  L     R11,PPIBLK+4        BLOCK BASE REGISTER
*
*        EXIT TO BLOCK ROUTINE
*
         B     4(0,R11)            PUT EOS
*
*        INDICATES THAT IT IS END OF FILE
*
OACASE5  L     R3,WALTNODE         ADDR OF RECORD IN LAST TEST NODE
         LA    R3,4(,R3)           INCREMENT ADDR BY 4 BYTES
         L     R11,PPIBLK+4        BLOCK BASE REGISTER
*
*        EXIT TO BLOCK ROUTINE
*
         B     0(,R11)             PUT EOF
*
*        CASE - AN S/--- SITUATION WHILE FILLING
*
OACASE3  LA    R10,48              FORMAT S--
         ST    R10,4(,R5)          UPDATE FORMAT
         ST    R3,8(,R5)           WINNER TO LOSER 1
         B     OAPICK
*
*        ENTRY FROM DEBLOCK WHILE RUNNING
*
*        SEQUENCE CHECKS THE NEW RECORD AND STARTS IT THROUGH
*        THE REPLACEMENT NETWORK
*
OARETRUN S     R3,KAFOUR           DECREMENT NEW ADDR BY FOUR BYTES
         L     R2,WALTNODE         ADDR OF RECORD IN LAST TEST NODE
         L     R5,0(,R2)           NODE ADDR WITH RECORD HELD BACK
         ST    R5,0(,R3)           NODE ADDR WITH NEW RECORD
         CLC   0(1,R3),0(R2)       COMPARE NEW RECORD TO ONE HELD BACK
         BNE   OASCHECK
*
*        EXIT TO EQUALS ROUTINE
*
         BASR  R14,R12             LINK TO EQUALS ROUTINE
OASCHECK BL    OAMODNEW
         L     R4,OASAME           UPDATE MODE
         B     OANEXT2
*
OAMODNEW L     R4,OANEW            UPDATE MODE
         B     OANEXT2
*
*        ENTRY FROM DEBLOCK AFTER EOF
*
*        SET UP TO FLUSH ANOTHER RECORD FROM THE TREE
*
OARETEOF L     R10,WALTNODE        ADDR OF RECORD IN LAST TEST NODE
         L     R5,0(,R10)          NODE ADDR WITH RECORD HELD BACK
         L     R4,OAFLUSH          UPDATE MODE
         L     R3,WATREE           SET DUMMY RCD AS NEXT INPUT RCD
         B     OANEXT2
*
*        IF R3 HAS DUMMY RCD TREAT AS THE AUTO LOSER (FILE < G)
*
OASUB1   CL    R3,WATREE           REAL OR DUMMY RECORD ?
         BNL   OASHIFT4            DUMMY RCD, BRANCH
         BR    R14                 R3 HAS A REAL RCD, CONTINUE NORMALLY
*
OASUB2   CL    R3,WATREE           REAL OR DUMMY RECORD ?
         BNL   OASUB2R             DUMMY RCD, BRANCH
         BR    R14                 R3 HAS A REAL RCD, CONTINUE NORMALLY
*
OASUB3   CL    R3,WATREE           REAL OR DUMMY RECORD ?
         BNL   OAC15B              R3 HAS A DUMMY RCD, BRANCH
         BR    R14                 R3 HAS A REAL RCD, CONTINUE NORMALLY
*
OASUBF41 CLC   16(4,R5),WATREE     A -/SSS CONDITION ?
         BL    R14                 YES, A -/SSS ?
         CLC   12(4,R5),WATREE     NO, A -/SS- CONDITION ?
         BL    OACASE25            YES, A -/SS- ?
         CLC   8(4,R5),WATREE      NO, A -/S-- CONDITION ?
         BL    OACASE13            YES, A -/S-- ?
         B     OAC13A              NO, A -/--- CONDITION
*
OASUBF44 CLC   16(4,R5),WATREE     A /SSS CONDITION ?
         BL    OARSSS              YES, NOW CHECK IN RCD IS REAL ?
         CLC   12(4,R5),WATREE     NO, A /SS- CONDITION ?
         BL    OARSS               YES, CHECK IF IN RCD IS REAL ?
         CLC   8(4,R5),WATREE      NO, A /S-- CONDITION ?
         BL    OARS                YES,  CHECK IF IN RCD IS REAL
         B     OAR                 NO, A /---, CHK IF IN IS REAL
*
OARSSS   CL    R3,WATREE           REAL OR DUMMY RECORD ?
         BNL   OASUB41             IN RCD IS DUMMY, GOTO CASE -/SSS
         BR    R14                 IN RCD IS REAL, GOTO CASE S/SSS
*
OARSS    CL    R3,WATREE           REAL OR DUMMY RECORD ?
         BNL   OACASE25            IN RCD IS DUMMY, GOTO CASE -/SS-
         LA    R10,96              UPDATE FORMAT
         ST    R10,4(,R5)          SET FORMAT OF S/SS-
         B     OACASE28            GOTO CASE S/SS-
*
OARS     CL    R3,WATREE           IN A REAL OR DUMMY RECORD ?
         BNL   OACASE13            IN RCD IS A DUMMY, GOTO CASE -/S--
         LA    R10,48              INPT RCD IS REAL, UPDATE FORMAT TO
         ST    R10,4(,R5)          S/S--
         B     OACASE16            BRANCH TO CASE S/S--
*
OAR      CL    R3,WATREE           A REAL OR DUMMY IN RCD X/--- ?
         BNL   OAC13A              INPUT RCD IS DUMMY, BR TO CASE -/---
         L     R4,OASAME           UPDATE MODE
         LA    R10,0               INPUT RCD IS REAL, UPDATE FORMAT
         ST    R10,4(,R5)          TO  /---
         B     OANEXT
*
*        CONSTANTS
*
         DC    0F'0'               WORD BOUNDARY
KAFOUR   DC    X'00000004'         ADDR DECREMENT
KAREVSW  DC    X'000000FF'         SWITCH USED WHILE REVERSING SEQUENCE
*                                  THIS SWITCH IS INITIALLY ON
KNOP     DC    X'4700'             NOP
*
*        WORK AREAS
*        THE ORDERING OF THESE WORK AREAS MUST BR MAINTAINED
*
WASAVE   DC    3F'0'               FILLING REGISTER SAVE AREA
WATREE   DC    X'7FFFFFFF'         USED FOR DUMMY RECORDS
WALTNODE DC    F'0'                LAST TEST NODE
         DC    A(16)               FORMAT OF LAST TEST NODE
WATREEAD DC    F'0'                LOCATION OF TREE
*
*        MODIFICATION INSTRUCTIONS
*
OAMODC8  B     OACASE8A            MOD TO CK FOR DUMMY AND HOLD BACK
OAMODC8B B     OACASE8B            MODIFICATION TO SKIP DUMMY CHECK
OACHMVC  MVC   OAMODLOC(4),OAMODC8 MODIFY BRANCH TABLE
OANOSAME L     R4,OAFLUSH          MODIFICATION TO START FLUSHING TREE
OA44FILL BAS   R14,OASUB1          FILE < G CHECK IF R3 A DUMMY
OAMODC27 BAS   R14,OASUB2          FILE < G CHECK IF R3 A DUMMY
OAMODC15 BAS   R14,OASUB3          FILE < G CHECK IF R3 A DUMMY
OA44FLSH BAS   R14,OASUBF44        BR TO FLUSH RTN CASE44
OA41FLSH BAS   R14,OASUBF41        BR TO FLUSH RTN CASE 41
*
./ ADD NAME=IERROF   0101-20211-20211-1200-00082-00082-00000-RELEASE 00
ROF      TITLE 'IERROF - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERROF
*
*        MODULE FUNCTION/OPERATION -
*        POLYPHASE REPLACEMENT NETWORK FOR FIXED LENGTH RECORDS
*        WHICH CONTAIN SINGLE CONTROL FIELDS AND/OR REQUIRE
*        EXTRACTING. THIS MODULE GENERATES ASCENDING OR
*        DESCENDING SEQUENCES USING A REPLACEMENT SELECTION
*        TECHNIQUE
*
*        MODULE IN WHICH THIS MODULE APPEARS A DSECT - IERAOF
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM INITIAL WRITE ROUTINE
*                       CALLING SEQUENCE -
*                           L   R11,PPINET
*                           BR  R11       ENTER NETWORK TO FILL TREE
*
*                     - ENTRY FROM DEBLOCK ROUTINE
*                       CALLING SEQUENCE -
*                           L  R11,PPINET
*                           B  X(,R11)
*                              X= 4 ENTRY WHILE FILLING
*                               = 8 ENTRY AT EOF
*                               =12 ENTRY WHILE RUNNING
*                               =16 ENTRY AFTER EOF
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPISRTG
*        COMPARES FILE SIZE TO G (PPISRTG)
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED - N/A
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL - ADDR IN PPIDEB+4 (DEBLOCK)
*                                 PLUS DISP= 0 FIRST TIME AFTER
*                                              TREE IS FILLED
*                                 PLUS DISP= 8 WHEN FILLING
*                                              TREE
*
*                       - ADDR IN PPIADSSC
*                                 PLUS DISP=20 TO CLOSE WHEN
*                                              INPUT FILE ZERO
*
*                       - ADDR IN PPIBLK+4 (BLOCK)
*                                 PLUS DISP= 0 TO BLOCK AT EOF
*                                 PLUS DISP= 4 TO BLOCK AT EOS
*                                 PLUS DISP=12 FOR NORMAL BLOCK
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS -
*        WASAVE   - FILLING REGISTER SAVE AREA
*        WATREE   - LOCATION OF TREE
*        WALTNODE - LAST TEST NODE
*
*        NOTES - N/A
*
IERROF   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERROF SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERROFI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERROFI  0101-20211-20211-1200-00575-00575-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERROF SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERROFI
*
         USING *,R11
         USING IERRCA,R13
*
*        ENTRY TABLE
*
IERDOA   B     OAPICK              +00 FILL TREE
         B     OAFIRET             +04 DEBLOCK WHILE FILLING
         B     OAEOF               +08 DEBLOCK AT EOF
         B     OARETRUN            +12 DEBLOCK WHILE RUNNING
         B     OARETEOF            +16 DEBLOCK AFTER EOF
*                                  +20 ALGORITHM TO REVERSE SEQ
*
*        ENTRY FROM ALGORITHM TO INDICATE THE SEQUENCE AFTER THIS
*        IS TO BE REVERSED
*
*        REVERSE CONDITIONAL BRANCHES WHICH DETERMINE THE
*        RESULTS OF COMPARES BETWEEN RECORDS OF THE NEW OR NEXT
*        SEQUENCE
*
         XI    OAC10A+1,X'60'      IN CASE 10
         XI    OAC18A+1,X'60'      IN CASE18
         XI    OACASE22+19,X'60'   IN CASE22
         XI    OAC30A+1,X'60'      IN CASE30
         XI    OAC30B+1,X'60'      IN CASE30
         XI    OACASE34+19,X'60'   IN CASE34
         XI    OAC38A+7,X'60'      IN CASE38
*
*        SET A SWITCH ON IN THE END OF SEQUENCE CODE, CASE 6
*
         LA    R10,255             CONSTANT 'FF'
         ST    R10,KAREVSW         SET REVERSAL SWITCH ON IN CASE 6
*
*        INITIAL ENTRY TO START FILLING OR ENTRY TO CONTINUE
*        FILLING TREE
*
OAPICK   L     R11,PPIDEB+4        DEBLOCK BASE REGISTER
*
*        EXIT TO DEBLOCK ROUTINE
*
         B     8(,R11)             GET TO FILL OR GET FOR REVERSAL
*
*        ENTRY FROM DEBLOCK WHILE FILLING
*
*        SETS UP TO FILL THE TREE AND DETERMINES WHEN THE TREE
*        IS FILLED
*
OAFIRET  S     R3,KAINCDEC         DECREMENT NEW ADDR BY EXTRACT INC+4
         CLI   KASWITCH+3,X'FF'    CHECK EXTRACT SWITCH
         BNE   OANOTON1            OFF, BRANCH
*
*        EXIT TO EXTRACT ROUTINE
*
         BAS   R14,4(,R12)         CALL EXTRACT ROUTINE
         SPACE 2
OANOTON1 LM    R7,R9,WASAVE        FILLING REGS
         ST    R9,0(,R3)           ADDR OF TREE WITH RECORD
OAFILDUM LR    R5,R9               ADDR OF TREE (NLA)
         BCT   R7,OAGCT            DECREMENT WAY COUNTER
         LA    R7,4                RESET WAY COUNTER
         LA    R9,20(,R9)          INCREMENT TO NEXT NODE
OAGCT    BCT   R8,OAMORE           DECREMENT G COUNTER
         L     R4,OASAME           SET MODE
         STM   R7,R9,WASAVE
         CLC   OAGCT+4(4),OANOSAME  RUNNING OR FLUSHING ?
         BNE   OANEXT2             RUNNING SITUATION
         MVC   OACASE44(4),OA44FLSH  OVERLAY TO BRANCH TO FLUSH ROUTINE
         MVC   OACAS27(2),KNOP     NOP THE BR INSTR TO THE FILL ROUTINE
         MVC   OACAS15(2),KNOP     NOP THE BR INSTR TO THE FILL ROUTINE
         MVC   OACASE41(4),OA41FLSH  OVERLAY TO BR TO FLUSH RTN CASE 41
         B     OANEXT2             FLUSHING SITUATION
*
OAMORE   L     R4,OAFILL           SET MODE
         STM   R7,R9,WASAVE        SAVE FILLING REGISTERS
         B     OANEXT2
*
*        ENTRY FROM DEBLOCK AT EOF
*
*        DETERMINES IF EOF SITUATION IS A NORMAL ONE
*        FILE SIZE LESS THEN G, OR FILE SIZE IS ZERO AND
*        BRANCHES ACCORDINGLY
*
OAEOF    CLC   PPISRTG(4),WASAVE+4  COMPARE G COUNT IN PPI TO FILL NO
         BNE   OANOZERO
*
*        EXIT TO CLOSE ROUTINE
*
         LA    R1,4                SET UP PARAMETER TO END OF PHASE
         L     R15,PPIADSSC        R15 -> SSC
         BAS   R14,20(,R15)        INPUT FILE WAS ZERO
*
OANOZERO LA    R10,0               CONSTANT OF 0
         CL    R10,WASAVE+4        COMPARE TO FILL COUNT
         BE    OARETEOF
*
*        FILE SIZE IS LESS THAN G
*        THE CODING IS MODIFIED TO FILL THE REMAINDER OF THE
*        TREE WITH FAKE RECORDS. THESE RECORDS ARE THE TREE ADDRS
*
         MVC   OACASE44(4),OA44FILL  MOD TO CHECK FOR DUMMY RCD
         MVC   OACAS27(4),OAMODC27   MOD TO CHECK FOR DUMMY RCD
         MVC   OACAS15(4),OAMODC15   MOD TO CHECK FOR DUMMY RCD
         MVC   OAC8A(6),OACHMVC    MODIFICATION TO CHECK FOR DUMMY REC
         OI    OACSUB8+1,X'F0'     INITIALIZE BRANCH INST IN CASE 8
         MVC   OAGCT+4(4),OANOSAME  MODIFICATION TO START TREE FLUSHING
         MVC   OAPICK(12),OAMODIFY  MODIFY FILLING RETURN LOCATION
OAMODIFY LM    R7,R9,WASAVE         FILLING REGISTERS
         L     R3,WATREE            DUMMY ADDR
         B     OAFILDUM
*
*        MODE POSITIONS AND BRANCH TABLE
*
*        THROUGH THE COMBINATION OF MODE AND FORMAT AN INDEXED
*        BRANCH IS PERFORMED WHICH BRANCHES TO THE CASE WHICH
*        HANDLES THE INDICATED SITUATION
*
OAFLUSH  DC    A(OABTABLE)
OANEW    DC    A(OABTABLE+4)
OAFILL   DC    A(OABTABLE+8)
OASAME   DC    A(OABTABLE+12)
OABTABLE B     OANEXT
         B     OANEXT
         B     OACASE3
         B     OANEXT
         B     OACASE5
         B     OACASE6
         DC    A(0)                SPACE TO MAINTAIN POSITIONS IN TABLE
OAMODLOC B     OACASE8
         B     OACASE9
         B     OACASE10
         DC    A(0)                SPACE TO MAINTAIN POSITIONS IN TABLE
         B     OANEXT
         B     OACASE13
         B     OACASE14
         B     OACASE15
         B     OACASE16
         B     OACASE17
         B     OACASE18
         DC    A(0)                SPACE TO MAINTAIN POSITIONS IN TABLE
         B     OANEXT
         B     OACASE21
         B     OACASE22
         DC    A(0)                SPACE TO MAINTAIN POSITIONS IN TABLE
         B     OACASE16
         B     OACASE25
         B     OACASE26
         B     OACASE27
         B     OACASE28
         B     OACASE29
         B     OACASE30
         DC    A(0)                SPACE TO MAINTAIN POSITIONS IN TABLE
         B     OANEXT
         B     OACASE33
         B     OACASE34
         DC    A(0)                SPACE TO MAINTAIN POSITIONS IN TABLE
         B     OACASE16
         B     OACASE37
         B     OACASE38
         DC    A(0)                SPACE TO MAINTAIN POSITIONS IN TABLE
         B     OACASE28
         B     OACASE41
         B     OACASE42
         B     OACASE44
         B     OACASE44
*
*        CASE - AN S/SSS SITUATION WHILE RUNNING
*
OACASE44 NOP   *+4                 WILL BE BAL R14,OASUB1 ON FILE < G
*                                  FILL, ORBAL R14 OASUBF44 FLUSH
         CLC   0(1,R3),0(R8)       COMPARE WINNER TO LOSER 2
         BNH   OACASE16
         CLC   0(1,R3),0(R9)       COMPARE WINNER TO LOSER 3
         BNH   OASHIFT3
OASHIFT4 STM   R8,R9,8(R5)         LOSER 2 + 3 TO LOSER 1 + 2
         ST    R3,16(,R5)          WINNER TO LOSER 3
         LR    R3,R7               LOSER 1 TO WINNER
OANEXT   L     R5,0(,R5)           ADDR OF NEXT NODE
OANEXT2  LM    R6,R9,4(R5)         LOAD NODE
         B     0(R4,R6)            GOTO PROPER CASE
*
*        CASE - AN N/SSS SITUATION WHILE RUNNING
*
OACASE42 L     R4,OASAME           UPDATE MODE
         LA    R10,144             FORMAT SSN
         ST    R10,4(0,R5)         UPDATE FORMAT
         B     OASHIFT4
*
*        CASE - AN -/SSS SITUATION WHILE FLUSHING
*
OACASE41 NOP   OASUBF41            WILL BE BAL R14,OASUBF41 WHEN FLUSHG
OASUB41  L     R4,OASAME           UPDATE MODE
         LA    R10,96              FORMAT SS-
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OASHIFT4
*
*        CASE - AN N/SSN SITUATION WHILE RUNNING
*
OACASE38 L     R4,OASAME           UPDATE MODE
         LA    R10,128             FORMAT SNN
         ST    R10,4(,R5)          UPDATE FORMAT
OAC38A   CLC   0(1,R3),0(R9)       COMPARE WINNER TO LOSER 3
         BNL   OASHIFT3
         B     OASHIFT4
*
*        CASE - AN -/SSN SITUATION WHILE FLUSHING
*
OACASE37 L     R4,OASAME           UPDATE MODE
         LA    R10,80              FORMAT SN-
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OASHIFT4
*
*        CASE - AN N/SNN SITUATION WHILE RUNNING
*
OACASE34 L     R4,OASAME           UPDATE MODE
         LA    R10,112             FORMAT NNN
         ST    R10,4(,R5)          UPDATE FORMAT
         CLC   0(1,R3),0(R8)       COMPARE WINNER TO LOSER 2
         BNL   OASHIFT2
         B     OAC38A
*
*        CASE - AN -/SNN SITUATION WHILE FLUSHING
*
OACASE33 L     R4,OASAME           UPDATE MODE
         LA    R10,64              FORMAT NN-
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OASHIFT4
*
*        CASE - AN N/NNN SITUATION WHILE RUNNING
*
OACASE30 LA    R10,160             FORMAT SSS
         ST    R10,4(,R5)          UPDATE FORMAT
         CLC   0(1,R3),0(R8)       COMPARE WINNER TO LOSER 2
OAC30A   BNL   OAC10SS
         CLC   0(1,R3),0(R9)       COMPARE WINNER TO LOSER 3
OAC30B   BNL   OASHIFT3
         B     OASHIFT4
*
*        CASE - AN -/NNN SITUATION WHILE FLUSHING
*
OACASE29 L     R4,OANEW            UPDATE MODE
         LA    R10,96              FORMAT SS-
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OASHIFT4
*
*        CASE - AN S/SS- SITUATION WHILE RUNNING
*
OACASE28 CLC   0(1,R3),0(R8)       COMPARE WINNER TO LOSER 2
         BNH   OACASE16
OASHIFT3 ST    R8,8(,R5)           LOSER 2 TO LOSER 1
         ST    R3,12(,R5)          WINNER TO LOSER 2
         LR    R3,R7               LOSER 1 TO WINNER
         L     R5,0(,R5)           ADDR OF NEXT NODE
         LM    R6,R9,4(R5)         LOAD NODE
         B     0(R4,R6)            GOTO PROPER CASE
*
*        CASE - AN S/SS- SITUATION WHILE FILLING
*
OACASE27 LA    R10,160             FORMAT SSS
         ST    R10,4(,R5)          UPDATE FORMAT
OACAS27  NOP   *+4                 WILL BE BAL R14,OASUB2 ON FILE < G
         CLC   0(1,R3),0(R8)       COMPARE WINNER TO HIGH 2
         BNH   OAC27A
OASUB2R  ST    R3,16(,R5)          WINNER TO LOSER 3
         B     OAPICK
*
OAC27A   CLC   0(1,R3),0(R7)       COMPARE WINNER TO LOSER 1
         BNH   OAC27B
         ST    R8,16(,R5)          LOSER 2 TO LOSER 3
         ST    R3,12(,R5)          WINNER TO LOSER 2
         B     OAPICK
*
OAC27B   STM   R7,R8,12(R5)        LOSER 1 + 2 TO LOSER 2 + 3
         ST    R3,8(,R5)           WINNER TO LOSER 1
         B     OAPICK
*
*        CASE - AN N/SS- SITUATION WHILE RUNNING
*
OACASE26 L     R4,OASAME           UPDATE MODE
         LA    R10,80              FORMAT SN-
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OASHIFT3
*
*        CASE - AN -/SS- SITUATION WHILE FLUSHING
*
OACASE25 L     R4,OASAME           UPDATE MODE
         LA    R10,48              FORMAT S--
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OASHIFT3
*
*        CASE - AN N/SN- SITUATION WHILE RUNNING
*
OACASE22 L     R4,OASAME           UPDATE MODE
         LA    R10,64              FORMAT NN-
         ST    R10,4(0,R5)         UPDATE FORMAT
         CLC   0(1,R3),0(R8)       COMPARE WINNER TO LOSER 2
         BNL   OASHIFT2
         B     OASHIFT3
*
*        CASE - AN -/SN- SITUATION WHILE FLUSHING
*
OACASE21 L     R4,OASAME           UPDATE MODE
         LA    R10,32              FORMAT N--
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OASHIFT3
*
*        CASE - AN N/NN- SITUATION WHILE RUNNING
*
OACASE18 LA    R10,96              FORMAT SS-
         ST    R10,4(,R5)          UPDATE FORMAT
         CLC   0(1,R3),0(R8)       COMPARE WINNER TO LOSER 2
OAC18A   BNL   OAC10SS
         B     OASHIFT3
*
*        CASE - AN -/NN- SITUATION WHILE FLUSHING
*
OACASE17 L     R4,OANEW            UPDATE MODE
         LA    R10,48              FORMAT S--
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OASHIFT3
*
*        CASE - AN S/S-- SITUATION WHILE RUNNING
*
OACASE16 CLC   0(1,R3),0(R7)       COMPARE WINNER TO LOSER 1
         BNH   OANEXT
OASHIFT2 ST    R3,8(,R5)           WINNER TO LOSER 1
         LR    R3,R7               LOSER 1 TO WINNER
         L     R5,0(,R5)           ADDR OF NEXT NODE
         LM    R6,R9,4(R5)         LOAD NODE
         B     0(R4,R6)            GOTO PROPER CASE
*
*        THIS CASE HANDLES AN S/S-- SITUATION WHILE FILLING
*
OACASE15 LA    R10,96              FORMAT SS-
         ST    R10,4(,R5)          UPDATE FORMAT
OACAS15  NOP   *+4                 WILL BE BAL R14,OASUB3 ON FILE < G
         CLC   0(1,R3),0(R7)       COMPARE WINNER TO LOSER 1
         BH    OAC15A
         ST    R7,12(,R5)          LOSER 1 TO LOSER 2
         ST    R3,8(,R5)           WINNER TO LOSER 1
         B     OAPICK
*
OAC15A   ST    R3,12(,R5)          WINNER TO LOSER 2
         B     OAPICK
*
*        CASE - AN N/S-- SITUATION WHILE RUNNING
*
OACASE14 LA    R10,32              FORMAT N--
         ST    R10,4(,R5)          UPDATE FORMAT
         L     R4,OASAME           UPDATE MODE
         B     OASHIFT2
*
*        CASE - AN -/S-- SITUATION WHILE FLUSHING
*
OACASE13 L     R4,OASAME           UPDATE MODE
OAC13A   LA    R10,0               FORMAT ---
         ST    R10,4(,R5)          UPDATE FORMAT
         LR    R3,R7               LOSER 1 TO WINNER
         B     OANEXT
*
*        CASE - AN N/N-- SITUATION WHILE RUNNING
*
OACASE10 LA    R10,48              FORMAT S--
         ST    R10,4(,R5)          UPDATE FORMAT
OAC10SS  CLC   0(1,R3),0(R7)       COMPARE WINNER TO LOSER 1
OAC10A   BNL   OANEXT
         B     OASHIFT2
*
*        CASE - AN -/N-- SITUATION WHILE FLUSHING
*
OACASE9  L     R4,OANEW            UPDATE MODE
         B     OAC13A
*
*        INDICATES THE TREE IS FILLED AND FORCES THE NETWORK INTO
*        A RUNNING SITUATION
*
OACASE8  LR    R5,R3               TREE ADDR EQUALS DUMMY RECORD
         CL    R3,WATREE           REAL RECORD OR TREE ADDR ?
         BNL   OARETEOF+8          TREE ADDR, BRANCH
         ST    R3,WALTNODE         SAVE ADDR OF RECD IN LAST TEST NODE
OAC8A    MVC   OAMODLOC(4),OAMODC8B  MODIFY BRANCH TABLE
OACSUB8  NOP   OARETEOF            INITIALIZED TO BRANCH AT FILE < G
         L     R11,PPIDEB+4        DEBLOCK BASE REGISTER
*
*        EXIT TO DEBLOCK ROUTINE
*
         B     0(,R11)             MODIFY AND GET
*
*        INDICATES THERE IS A RECORD TO BE BLOCKED
*
OACASE8A LR    R5,R7               ADDR OF THE TREE
         CL    R3,WATREE           A REAL RECORD NOT TREE ADDR ?
         BNL   OARETEOF+8          TREE ADDR, BRANCH
OACASE8B L     R10,WALTNODE        ADDR OF RECORD IN LAST TEST NODE
         ST    R3,WALTNODE         ADDR OF NEXT RECD TO LAST TEST NODE
         LR    R3,R10              ADDR TO WINNER POSITION
         A     R3,KAINCDEC         INC ADDR BY EXTRACT INCREMENT+4
         L     R11,PPIBLK+4        BLOCK BASE REGISTER
*
*        EXIT TO BLOCK ROUTINE
*
         B     12(,R11)            PUT INFERS GET
*
*        INDICATES THAT IT IS THE END OF A SEQUENCE
*
OACASE6  L     R10,WALTNODE        ADDR OF RECORD IN LAST TEST NODE
         ST    R3,WALTNODE         ADDR OF NEXT RECD TO LAST TEST NODE
         LR    R3,R10              ADDR TO WINNER POSITION
         A     R3,KAINCDEC         INC ADDR BY EXTRACT INCREMENT+4
*
*        CHECK SEQUENCE REVERSING SWITCH
*        IF ON COMPLETE THE SEQUENCE REVERSING CYCLE
*
         CLI   KAREVSW+3,X'00'     CHECK REVERSAL SWITCH
         BE    OASWOFF             OFF, REVERSAL IS NOT IN PROCESS
*
*        TURN OFF RERVERSAL SWITCH
*        REVERSE THE CONDITIONAL BRANCHES WHICH DETERMINE THE
*        RESULTS OF COMPARES BETWEEN RECORDS OF THE PRESENT
*        SEQUENCE. REVERSE THE CONDITIONAL BRANCH WHICH
*        DETERMINES THE RESULT OF THE SEQUENCE CHECK OF THE
*        INCOMING RECORD
*
         SR    R10,R10             ZERO REG
         ST    R10,KAREVSW         TURN REVERSAL SWITCH OFF
         XI    OACASE16+7,X'60'    IN CASE16
         XI    OACASE28+7,X'60'    IN CASE28
         XI    OACASE44+11,X'60'   IN CASE 44
         XI    OACASE44+21,X'60'   IN CASE 44
         XI    OANOTON2+19,X'60'   IN SEQUENCE CHECK
OASWOFF  L     R11,PPIBLK+4        BLOCK BASE REGISTER
*
*        EXIT TO BLOCK ROUTINE
*
         B     4(,R11)             PUT EOS
*
*        INDICATES THAT IT IS END OF FILE
*
OACASE5  L     R3,WALTNODE         ADDR OF RECORD IN LAST TEST NODE
         A     R3,KAINCDEC         INC ADDR BY EXTRACT INCREMENT+4
         L     R11,PPIBLK+4        BLOCK BASE REGISTER
*
*        EXIT TO BLOCK ROUTINE
*
         B     0(,R11)             PUT EOF
*
*        CASE - AN S/--- SITUATION WHILE FILLING
*
OACASE3  LA    R10,48              FORMAT S--
         ST    R10,4(,R5)          UPDATE FORMAT
         ST    R3,8(0,R5)          WINNER TO LOSER 1
         B     OAPICK
*
*        ENTRY FROM DEBLOCK WHILE RUNNING
*
*        SEQUENCE CHECKS THE NEW RECORD AND STARTS IT THROUGH
*        THE REPLACEMENT NETWORK
*
OARETRUN S     R3,KAINCDEC         DECREMENT NEW ADDR BY EXTRACT INC+4
         CLI   KASWITCH+3,X'FF'    CHECK EXTRACT SWITCH
         BNE   OANOTON2            OFF, BRANCH
*
*        EXIT TO EXTRACT ROUTINE
*
         BAS   R14,4(,R12)         CALL EXTRACT ROUTINE
OANOTON2 L     R2,WALTNODE         ADDR OF RECORD IN LAST TEST NODE
         L     R5,0(,R2)           NODE ADDR WITH RECORD HELD BACK
         ST    R5,0(,R3)           NODE ADDR WITH NEW RECORD
         CLC   0(1,R3),0(R2)       COMPARE NEW RECORD TO ONE HELD BACK
         BL    OAMODNEW
         L     R4,OASAME           UPDATE MODE
         B     OANEXT2
*
OAMODNEW L     R4,OANEW            UPDATE MODE
         B     OANEXT2
*
*        ENTRY FROM DEBLOCK AFTER EOF
*
*        SET UP TO FLUSH ANOTHER RECORD FROM THE TREE
*
OARETEOF L     R10,WALTNODE        ADDR OF RECORD IN LAST TEST NODE
         L     R5,0(,R10)          NODE ADDR WITH RECORD HELD BACK
         L     R4,OAFLUSH          UPDATE MODE
         L     R3,WATREE           SET DUMMY RCD AS NEXT INPUT RCD
         B     OANEXT2
*
*        IF R3 HAS DUMMY RCD TREAT AS THE AUTO LOSER (FILE < G)
*
OASUB1   CL    R3,WATREE           REAL OR DUMMY RECORD ?
         BNL   OASHIFT4            DUMMY RCD, BRANCH
         BR    R14                 R3 HAS A REAL RCD CONTINUE NORMALLY
*
OASUB2   CL    R3,WATREE           REAL OR DUMMY RECORD ?
         BNL   OASUB2R             DUMMY RCD, BRANCH
         BR    R14                 R3 HAS A REAL RCD CONTINUE NORMALLY
*
OASUB3   CL    R3,WATREE           REAL OR DUMMY RECORD ?
         BNL   OAC15A              DUMMY RCD, BRANCH
         BR    R14                 R3 HAS A REAL RCD CONTINUE NORMALLY
*
OASUBF41 CLC   16(4,R5),WATREE     A -/SSS CONDITION ?
         BLR   R14                 YES, A -/SSS
         CLC   12(4,R5),WATREE     NO, A -/SS- CONDITION ?
         BL    OACASE25            YES, A -/SS-
         CLC   8(4,R5),WATREE      NO, A -/S-- CONDITION ?
         BL    OACASE13            YES, A -/S--
         B     OAC13A              NO, A -/--- CONDITION
*
OASUBF44 CLC   16(4,R5),WATREE     A /SSS CONDITION ?
         BL    OARSSS              YES, NOW CHECK IF IN RCD IS REAL ?
         CLC   12(4,R5),WATREE     NO,  A /SS- CONDITION ?
         BL    OARSS               YES, NOW CHECK IF IN RCD IS REAL ?
         CLC   8(4,R5),WATREE      NO, A /S-- CONDITION ?
         BL    OARS                YES, CHECK IF IN RCD IS REAL ?
         B     OAR                 NO, A /--- CHK IF IN IS REAL ?
*
OARSSS   CL    R3,WATREE           REAL OR DUMMY RCD ?
         BNL   OASUB41             RCD IS DUMMY, GOTO CASE -/SSS
         BR    R14                 IN RCD IS REAL, GOTO CASE S/SSS
*
OARSS    CL    R3,WATREE           REAL OR DUMMY RCD ?
         BNL   OACASE25            RCD IS DUMMY, GOTO CASE -/SS-
         LA    R10,96              UPDATE FORMAT
         ST    R10,4(,R5)          SET FORMAT OF S/SS-
         B     OACASE28            GOTO CASE S/SS-
*
OARS     CL    R3,WATREE           REAL OR DUMMY RCD ?
         BC    10,OACASE13         RCD IS DUMMY,  GOTO CASE -/S--
         LA    R10,48              RCD IS REAL, UPDATE FORMAT TO
         ST    R10,4(,R5)          S/S--
         B     OACASE16            BRANCH TO CASE S/S--
*
OAR      CL    R3,WATREE           REAL OR DUMMY IN RCD X/--- ?
         BNL   OAC13A              INPUT RCD IS DUMMY, BR TO CASE -/---
         L     R4,OASAME           UPDATE MODE
         LA    R10,0               INPUT RCD IS REAL, UPDATE FORMAT
         ST    R10,4(,R5)          TO  /---
         B     OANEXT
*
*        CONSTANTS
*
KAINCDEC DC    F'0'                ADDR INC OR DEC OF EXTRACT INC+4
KASWITCH DC    X'00000000'         EXTRACT SWITCH
KAREVSW  DC    X'000000FF'         SWITCH USED WHILE REVERSING SEQUENCE
*                                  THIS SWITCH IS INITIALLY ON
KNOP     DC    X'4700'             NOP
*
*        WORK AREAS
*        THE ORDERING OF THESE WORK AREAS MUST BE MAINTAINED
*
WASAVE   DC    3F'0'               FILLING REGISTER SAVE AREA
WATREE   DC    X'7FFFFFFF'         USED FOR DUMMY RECORDS
WALTNODE DC    F'0'                LAST TEST NODE
         DC    A(16)               FORMAT OF LAST TEST NODE
WATREEAD DC    F'0'                LOCATION OF TREE
*
*        MODIFICATION INSTRUCTIONS
*
OAMODC8  B     OACASE8A            MOD TO CK FOR DUMMY AND HOLD BACK
OAMODC8B B     OACASE8B            MODIFICATION TO SKIP DUMMY CHECK
OACHMVC  MVC   OAMODLOC(4),OAMODC8 MODIFY BRANCH TABLE
OANOSAME L     R4,OAFLUSH          MODIFICATION TO START FLUSHING TREE
OA44FILL BAS   R14,OASUB1          FILE < G CHECK IF R3 A DUMMY
OAMODC27 BAS   R14,OASUB2          FILE < G CHECK IF R3 A DUMMY
OAMODC15 BAS   R14,OASUB3          FILE < G CHECK IF R3 A DUMMY
OA44FLSH BAS   R14,OASUBF44        BR TO FLUSH RTN CASE 44
OA41FLSH BAS   R14,OASUBF41        BR TO FLUSH RTN CASE 41
*
./ ADD NAME=IERROG   0101-20211-20211-1200-00087-00087-00000-RELEASE 00
ROG      TITLE 'IERROG - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERROG
*
*        MODULE FUNCTION/OPERATION -
*        POLYPHASE REPLACEMENT NETWORK FOR VARIABLE LENGTH
*        RECORDS WHICH CONTAIN MULTIPLE CONTROL FIELDS. THIS
*        MODULE GENERATES ASCENDING OR DESCENDING SEQUENCES USING
*        A REPLACEMENT SELECTION TECHNIQUE
*
*        MODULE IN WHICH THIS MODULE APPEARS A DSECT - IERAOG
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM INITIAL WRITE ROUTINE
*                       CALLING SEQUENCE -
*                           L   R11,PPINET
*                           BR  R11       ENTER NETWORK TO FILL TREE
*
*                     - ENTRY FROM DEBLOCK ROUTINE
*                       CALLING SEQUENCE -
*                           L  R11,PPINET
*                           B  X(,R11)
*                              X=  4 ENTRY WHILE FILLING (FIT)
*                               =  8 ENTRY AT EOF
*                               = 12 ENTRY WHILE RUNNING (FIT)
*                               = 16 ENTRY AFTER EOF
*                               = 20 ENTRY FROM ALGORITM
*                                    TO REVERSE SEQUENCE
*                               = 24 ENTRY FROM DEBLOCK
*                                    WHILE FILLING (NO FIT)
*                               = 28 ENTRY FROM DEBLOCK
*                                    WHILE RUNNING (NO FIT)
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPISRTG
*        COMPARES FILE SIZE TO G (PPISRTG)
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED - N/A
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL - ADDR IN PPIDEB+4 (DEBLOCK)
*                                 PLUS DISP= 0 FIRST TIME AFTER
*                                              TREE IS FILLED
*                                 PLUS DISP= 8 WHEN FILLING
*                                              TREE
*
*                       - ADDR IN PPIADSSC
*                                 PLUS DISP=20 TO CLOSE WHEN
*                                              INPUT FILE ZERO
*
*                       - ADDR IN PPIBLK+4 (BLOCK)
*                                 PLUS DISP= 0 TO BLOCK AT EOF
*                                 PLUS DISP= 4 TO BLOCK AT EOS
*                                 PLUS DISP=12 FOR NORMAL BLOCK
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS -
*        WCSAVE   - FILLING REGISTER SAVE AREA
*        WCTREE   - LOCATION OF TREE
*        WCLTNODE - LAST TEST NODE
*
*        NOTES - N/A
*
IERROG   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERROG SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERROGI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERROGI  0101-20211-20211-1200-00372-00372-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERROG SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERROGI
*
         USING *,R11
         USING IERRCA,R13
*
*        ENTRY TABLE
*
IERDOA   B     OCPICK              +00 FILL TREE
         B     OCGOTFIL            +04 DEBLK WHILE FILLING (FIT)
         B     OCEOF               +08 DEBLK AT EOF
         B     OCGOTRUN            +12 DEBLK WHILE RUNNING (FIT)
         B     OCRETEOF            +16 DEBLK AFTER EOF
         B     OCREVERS            +20 ALGORITHM TO REVERSE SEQ
         B     OCNOGOFI            +24 DEBLK WHILE FILLING - NOFIT
         B     OCNOGORN            +28 DEBLK WHILE RUNNING - NOFIT
*
*        ENTRY FROM ALGORITHM TO INDICATE THE SEQUENCE AFTER THIS
*        IS TO BE REVERSED
*
*        REVERSE CONDITIONAL BRANCH WHICH DETERMINES THE RESULT
*        OF COMPARES BETWEEN RECORDS OF THE NEW OR NEXT SEQUENCE
*
OCREVERS XI    OCC14A+1,X'60'      IN CASE 14
*
*        SET A SWITCH ON IN THE END OF SEQUENCE CODE, CASE 6
*
         LA    R10,255             CONSTANT 'FF'
         ST    R10,KCREVSW         SET REVERSAL SWITCH ON IN CASE 6
*
*        INITIAL ENTRY TO START FILLING OR ENTRY TO CONTINUE
*        FILLING TREE
*
OCPICK   L     R11,PPIDEB+4        DEBLOCK BASE REGISTER
*
*        EXIT TO DEBLOCK ROUTINE
*
         B     8(,R11)             GET TO FILL
*
*        SET UP TO FILL THE TREE WITH REAL OR IMAGINARY RECORDS
*        AND DETERMINES WHEN THE TREE IS FILLED
*
*        ENTRY FROM DEBLOCK WHILE FILLING (RECORD FITS)
*
OCGOTFIL LM    R7,R9,WCSAVE        FILLING REGISTERS
         L     R4,OCSAME           UPDATE MODE
         S     R3,KCFOUR           DECREMENT NEW ADDR BY FOUR BYTES
         ST    R9,0(,R3)           ADDR OF TREE WITH RECORD
OCSUBFIT LR    R5,R9               ADDR OF TREE (NEXT LEVEL ADDR)
         BCT   R7,OCGCT            DECREMENT WAY COUNTER
         LA    R7,2                RESET WAY COUNTER
         LA    R9,12(,R9)          INCREMENT TO NEXT NODE
OCGCT    BCT   R8,OCFILREG         DECREMENT G COUNTER
         STM   R7,R9,WCSAVE
         B     OCNEXT2
*
OCFILREG STM   R7,R9,WCSAVE        SAVE FILLING REGISTERS
         B     OCNEXT2
*
*        ENTRY FROM DEBLOCK WHILE FILLING (RECORD DOES NOT FIT)
*
OCNOGOFI LM    R7,R9,WCSAVE        FILLING REGISTERS
         L     R4,OCSTEMP          UPDATE MODE
         LR    R3,R9               USE TREE ADDR AS WINNER
         B     OCSUBFIT
*
*        DETERMINE IF EOF SITUATION IS A NORMAL ONE
*        FILE SIZE LESS THEN G, OR FILE SIZE IS ZERO AND
*        BRANCHES ACCORDINGLY
*
*        ENTRY FROM DEBLOCK AT EOF
*
OCEOF    CLC   PPISRTG(4),WCSAVE+4  COMPARE G COUNT IN PPIA TO FILL NO
         BNE   OCNOZERO
*
*        EXIT TO CLOSE ROUTINE
*
         LA    R1,4                SET UP PARAMETER TO END OF PHASE
         L     R15,PPIADSSC        R15 -> SSC
         BAS   R14,20(,R15)        INPUT FILE WAS ZERO
*
OCNOZERO MVC   OCC7A(8),OCC7EOF    MODIFY CASE7 TO FORCE TREE FLUSHING
         LA    R10,0               CONSTANT OF 0
         CL    R10,WCSAVE+4        COMPARE TO FILL COUNT
         BE    OCRETEOF
*
*        FILE SIZE IS LESS THAN G
*        THE CODING IS MODIFIED TO FILL THE REMAINDER OF THE
*        TREE WITH IMAGINARY RECORDS (T1)
*
         OI    OCC8A+1,X'F0'       INITIALIZE BRANCH INST IN CASE8
         MVC   OCPICK(4),OCMODIFY  MODIFY FILLING RETURN LOCATION
OCMODIFY B     OCNOGOFI
*
*        MODE POSITIONS AND BRANCH TABLE
*
*        THROUGH THE COMBINATION OF MODE AND FORMAT AN INDEXED
*        BRANCH IS PERFORMED WHICH BRANCHES TO THE CASE WHICH
*        HANDLES THE INDICATED SITUATION
*
OCNTEMP  DC    A(OCBTABLE)
OCNEW    DC    A(OCBTABLE+4)
OCSTEMP  DC    A(OCBTABLE+8)
OCSAME   DC    A(OCBTABLE+12)
OCBTABLE DC    A(0)                SPACE TO MAINTAIN POSITIONS IN TABLE
         DC    A(0)                SPACE TO MAINTAIN POSITIONS IN TABLE
         B     OCCASE3
         B     OCCASE4
         B     OCCASE5
         B     OCCASE6
         B     OCCASE7
OCMODLOC B     OCCASE8
         B     OCCASE9
         B     OCCASE10
         B     OCNEXT
         B     OCNEXT
         B     OCCASE13
         B     OCCASE14
         B     OCNEXT
         B     OCNEXT
         B     OCCASE17
         B     OCCASE18
         B     OCNEXT
         B     OCNEXT
         B     OCCASE21
         B     OCCASE22
         B     OCCASE23
         B     OCCASE24
*
*        CASE - AN S1/S1 SITUATION
*
OCCASE24 CLC   0(1,R3),0(R7)       COMPARE WINNER TO LOSER
         BNE   OCC24A
         LR    R2,R7               LOAD ADDR FOR EQUALS
*
*        EXIT TO EQUALS ROUTINE
*
         BASR  R14,R12             LINK TO EQUALS ROUTINE
OCC24A   BNH   OCNEXT
OCEXCH   ST    R3,8(,R5)           WINNER TO LOSER
         LR    R3,R7               LOSER TO WINNER
OCNEXT   L     R5,0(,R5)           ADDR OF NEXT NODE
OCNEXT2  LM    R6,R7,4(R5)         LOAD NODE
         B     0(R4,R6)            GOTO PROPER CASE
*
*        CASE - A T1/S1 SITUATION
*
OCCASE23 L     R4,OCSAME           UPDATE MODE
         LA    R10,64              FORMAT T1
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OCEXCH
*
*        CASE - AN S2/S1 SITUATION
*
OCCASE22 L     R4,OCSAME           UPDATE MODE
         LA    R10,48              FORMAT S2
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OCEXCH
*
*        CASE - A T2/S1 SITUATION
*
OCCASE21 L     R4,OCSAME           UPDATE MODE
         LA    R10,32              FORMAT T2
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OCEXCH
*
*        CASE - AN S2/T1 SITUATION
*
OCCASE18 L     R4,OCSTEMP          UPDATE MODE
         LA    R10,48              FORMAT S2
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OCEXCH
*
*        CASE - A T2/T1 SITUATION
*
OCCASE17 L     R4,OCSTEMP          UPDATE MODE
         LA    R10,32              FORMAT T2
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OCEXCH
*
*        CASE - AN S2/S2 SITUATION
*
OCCASE14 LA    R10,80              FORMAT S1
         ST    R10,4(,R5)          UPDATE FORMAT
         CLC   0(1,R3),0(R7)       COMPARE WINNER TO LOSER
         BNE   OCC14A
         LR    R2,R7               LOAD ADDR FOR EQUALS
*
*        EXIT TO EQUALS ROUTINE
*
         BASR  R14,R12             LINK TO EQUALS ROUTINE
OCC14A   BNL   OCNEXT
         B     OCEXCH
*
*        CASE - A T2/S2 SITUATION
*
OCCASE13 L     R4,OCNEW            UPDATE MODE
*
*        CASE - A T2/T2 SITUATION
*
OCCASE9  LA    R10,64              FORMAT T1
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OCEXCH
*
*        CASE - AN S2/T2 SITUATION
*
OCCASE10 LA    R10,64              FORMAT T1
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OCNEXT
*
*        INDICATES THE TREE IS FILLED AND FORCES THE NETWORK INTO
*        A RUNNING SITUATION
*
OCCASE8  ST    R3,WCLTNODE         SAVE ADDR OF RECD IN LAST TEST NODE
         MVC   OCMODLOC(4),OCMODC8 MODIFY BRANCH TABLE
OCC8A    NOP   OCRETEOF            INITIALIZED TO BRANCH AT FILE < G
         L     R11,PPIDEB+4        DEBLOCK BASE REGISTER
*
*        EXIT TO DEBLOCK ROUTINE
*
         B     0(,R11)     MODIFY AND GET
*
*        INDICATES THERE IS A RECORD TO BE BLOCKED
*
OCCASE8A L     R10,WCLTNODE        ADDR OF RECORD IN LAST TEST NODE
         ST    R3,WCLTNODE         ADDR OF NEXT RECD TO LAST TEST NODE
         LR    R3,R10              ADDR TO WINNER POSITION
         LA    R3,4(,R3)           INCREMENT ADDR BY 4 BYTES
         L     R11,PPIBLK+4        BLOCK BASE REGISTER
*
*        EXIT TO BLOCK ROUTINE
*
         B     12(,R11)            PUT INFERS GET
*
*        INDICATES THAT A T1 (IMAGINARY) HAS BEEN FORCED OUT OF
*        THE TREE
*
OCCASE7  L     R10,WCLTNODE        ADDR OF RECORD IN LAST TEST NODE
         ST    R3,0(,R10)          NODE ADDR (T1) WITH RECORD HELD BACK
         LR    R5,R3               NODE ADDR AS NEXT LEVEL ADDR
OCC7A    L     R10,OCNTEMP         MODE NTEMP
         ST    R10,WCSPECL         SET SPECIAL INDICATOR TO NTEMP
         L     R11,PPIDEB+4        DEBLOCK BASE REGISTER
*
*        EXIT TO DEBLOCK ROUTINE
*
         B     8(,R11)             GET TO FILL (DEBLOCK EXIT MODIFIED)
*
*        INDICATES THAT IT IS THE END OF A SEQUENCE
*
OCCASE6  L     R10,OCSTEMP         MODE STEMP
         ST    R10,WCSPECL         SET SPECIAL INDICATOR TO STEMP
         L     R10,WCLTNODE        ADDR OF RECORD IN LAST TEST NODE
         ST    R3,WCLTNODE         ADDR OF NEXT RECD TO LAST TEST NODE
         LR    R3,R10              ADDR TO WINNER POSITION
         LA    R3,4(,R3)           INCREMENT ADDR BY 4 BYTES
*
*        CHECK SEQUENCE REVERSING SWITCH
*        IF ON COMPLETE THE SEQUENCE REVERSING CYCLE
*
         CLI   KCREVSW+3,X'00'     CHECK REVERSAL SWITCH
         BE    OCSWOFF             OFF, REVERSAL IS NOT IN PROCESS
*
*        TURN OFF REVERSAL SWITCH
*        REVERSE THE CONDITIONAL BRANCH WHICH DETERMINES THE
*        RESULTS OF COMPARES BETWEEN RECORDS OF THE PRESENT
*        SEQUENCE. REVERSE THE CONDITIONAL BRANCH WHICH
*        DETERMINES THE RESULTS OF THE SEQUENCE CHECK OF THE
*        INCOMING RECORD
*
         SR    R10,R10             ZERO REG
         ST    R10,KCREVSW         TURN REVERSAL SWITCH OFF
         XI    OCC24A+1,X'60'      IN CASE 24
         XI    OCSCHECK+1,X'60'    IN SEQUENCE CHECK
OCSWOFF  L     R11,PPIBLK+4        BLOCK BASE REGISTER
*
*        EXIT TO BLOCK ROUTINE
*
         B     4(,R11)             PUT EOS
*
*        INDICATES THAT IT IS END OF FILE
*
OCCASE5  L     R3,WCLTNODE         ADDR OF RECORD IN LAST TEST NODE
         LA    R3,4(0,R3)          INCREMENT ADDR BY 4 BYTES
         L     R11,PPIBLK+4        BLOCK BASE REGISTER
*
*        EXIT TO BLOCK ROUTINE
*
         B     0(,R11)             PUT EOF
*
*        CASE - AN S1/- SITUATION
*
OCCASE4  ST    R3,8(,R5)           WINNER TO LOSER
         LA    R10,80              FORMATS1
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OCPICK
*
*        CASE - A T1/- SITUATION
*
OCCASE3  ST    R3,8(,R5)           WINNER TO LOSER
         LA    R10,64              FORMAT T1
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OCPICK
*
*        ENTRY FROM DEBLOCK WHILE RUNNING (RECORD FITS)
*
*        SEQUENCE CHECKS THE NEW RECORD AND STARTS IT THROUGH
*        THE REPLACEMENT NETWORK
*
OCGOTRUN S     R3,KCFOUR           DECREMENT NEW ADDR BY FOUR BYTES
         L     R10,OCSTEMP         MODE STEMP
         ST    R10,WCSPECL         SET SPECIAL INDICATOR TO STEMP
         L     R2,WCLTNODE         ADDR OF RECORD IN LAST TEST NODE
         L     R5,0(,R2)           NODE ADDR WITH RECORD HELD BACK
         ST    R5,0(,R3)           NODE ADDR WITH NEW RECORD
         CLC   0(1,R3),0(R2)       COMPARE NEW RECORD TO ONE HELD BACK
         BNE   OCSCHECK
*
*        EXIT TO EQUALS ROUTINE
*
         BASR  R14,R12             CALL EQUALS ROUTINE
OCSCHECK BL    OCMODNEW
         L     R4,OCSAME           UPDATE MODE
         B     OCNEXT2
*
OCMODNEW L     R4,OCNEW            UPDATE MODE
         B     OCNEXT2
*
*        SET UP TO FLUSH ANOTHER RECORD FROM THE TREE AFTER END
*        OF FILE OR BECAUSE THE INCOMONG RECORD WILL NOT FIT
*
*        ENTRY FROM DEBLOCK AFTER EOF
*
OCRETEOF L     R4,OCNTEMP          UPDATE MODE
         B     OCSUBNO
*
*        ENTRY FROM DEBLOCK WHILE RUNNING (RECORD DOES NOT FIT)
*
OCNOGORN L     R4,WCSPECL          UPDATE MODE
OCSUBNO  L     R10,WCLTNODE        ADDR OF RECORD IN LAST TEST NODE
         L     R5,0(,R10)          NODE ADDR WITH RECORD HELD BACK
         LR    R3,R5               TREE ADDR AS WINNER
         B     OCNEXT2
*
*        CONSTANTS
*
         DC    0F'0'               FORCE FULL WORD BOUNDARY
KCFOUR   DC    X'00000004'         ADDR DECREMENT
KCREVSW  DC    X'000000FF'         SWITCH USED WHILE REVERSING SEQUENCE
*
*        WORK AREAS
*        THE ORDERING OF THESE WORK AREAS MUST BE MAINTAINED
*
WCSAVE   DC    3F'0'               FILLING REGISTER SAVE AREA
WCTREE   DC    F'0'                LOCATION OF TREE
WCLTNODE DC    F'0'                LAST TEST NODE
         DC    A(16)               FORMAT OF LAST TEST NODE
WCSPECL  DC    A(OCBTABLE+8)       SPECIAL (MODE) INDICATOR
*
*        MODIFICATION INSTRUCTIONS
*        THE ORDERING OF THESE INSTRUCTIONS MUST BE MAINTAINED
*
OCMODC8  B     OCCASE8A            MODIFICATION TO HOLD BACK A RECORD
OCC7EOF  L     R4,OCNTEMP          UPDATE MODE * MODIFICATION TO CASE7
         B     OCNEXT2                         * TO FORCE TREE FLUSHING
*
./ ADD NAME=IERROH   0101-20211-20211-1200-00088-00088-00000-RELEASE 00
ROH      TITLE 'IERROH - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERROH
*
*        MODULE FUNCTION/OPERATION -
*        POLYPHASE REPLACEMENT NETWORK FOR VARIABLE LENGTH
*        RECORDS WHICH CONTAIN SINGLE CONTROL FIELDS AND/OR
*        REQUIRE EXTRACTING
*        THIS MODULE GENERATES ASCENDING OR DESCENDING SEQUENCES
*        USING A REPLACEMENT SELECTION TECHNIQUE
*
*        MODULE IN WHICH THIS MODULE APPEARS A DSECT - IERAOH
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM INITIAL WRITE ROUTINE
*                       CALLING SEQUENCE -
*                           L   R11,PPINET
*                           BR  R11        ENTER NETWORK TO FILL TREE
*
*                     - ENTRY FROM DEBLOCK ROUTINE
*                       CALLING SEQUENCE -
*                           L  R11,PPINET
*                           B  X(,R11)
*                              X= 4  ENTRY WHILE FILLING (FIT)
*                               = 8  ENTRY AT EOF
*                               = 12 ENTRY WHILE RUNNING (FIT)
*                               = 16 ENTRY AFTER EOF
*                               = 20 ENTRY FROM ALGORITHM
*                                    TO REVERSE SEQUENCE
*                               = 24 FOR ENTRY FROM DEBLOCK
*                                    WHILE FILLING (NO FIT)
*                               = 28 FOR ENTRY FROM DEBLOCK
*                                    WHILE RUNNING (NO FIT)
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPISRTG
*        COMPARES FILE SIZE TO G (PPISRTG)
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED - N/A
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL - ADDR IN PPIDEB+4 (DEBLOCK)
*                                 PLUS DISP=8 WHEN FILLING
*                                             TREE
*                                 PLUS DISP=0 FIRST TIME AFTER
*                                             TREE IS FILLED
*
*                       - ADDR IN PPIADSSC
*                                 PLUS DISP=20 TO CLOSE WHEN
*                                              INPUT FILE ZERO
*
*                       - ADDR IN PPIBLK+4 (BLOCK)
*                                 PLUS DISP=0 TO BLOCK AT EOF
*                                 PLUS DISP=4 TO BLOCK AT EOS
*                                 PLUS DISP=12 FOR NORMAL BLOCK
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS -
*        WCSAVE   - FILLING REGISTER SAVE AREA
*        WCTREE   - LOCATION OF TREE
*        WCLTNODE - FORMAT OF LAST TEST NODE
*
*        NOTES - N/A
*
IERROH   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERROH SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERROHI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERROHI  0101-20211-20211-1200-00370-00370-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERROH SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERROHI
*
         USING *,R11
         USING IERRCA,R13
*
*        ENTRY TABLE
*
IERDOA   B     OCPICK              +00 FILL TREE
         B     OCGOTFIL            +04 DEBLK WHILE FILLING (FIT)
         B     OCEOF               +08 DEBLK AT EOF
         B     OCGOTRUN            +12 DEBLK WHILE RUNNING (FIT)
         B     OCRETEOF            +16 DEBLK AFTER EOF
         B     OCREVERS            +20 ALGORITHM TO REVERSE SEQ
         B     OCNOGOFI            +24 DEBLK WHILE FILLING - NOFIT
         B     OCNOGORN            +28 DEBLK WHILE RUNNING - NOFIT
*
*        ENTRY FROM ALGORITHM TO INDICATE THE SEQUENCE AFTER THIS
*        IS TO BE REVERSED
*
*        REVERSE CONDITIONAL BRANCH WHICH DETERMINES THE RESULT
*        OF COMPARES BETWEEN RECORDS OF THE NEW OR NEXT SEQUENCE
*
OCREVERS XI    OCC14A+1,X'60'      IN CASE 14
*
*        SET A SWITCH ON IN THE END OF SEQUENCE CODE, CASE 6
*
         LA    R10,255             CONSTANT 'FF'
         ST    R10,KCREVSW         SET REVERSAL SWITCH ON IN CASE 6
*
*        INITIAL ENTRY TO START FILLING OR ENTRY TO CONTINUE
*        FILLING TREE
*
OCPICK   L     R11,PPIDEB+4        DEBLOCK BASE REGISTER
*
*        EXIT TO DEBLOCK ROUTINE
*
         B     8(,R11)     GET TO FILL
*
*        SET UP TO FILL THE TREE WITH REAL OR IMAGINARY RECORDS
*        AND DETERMINES WHEN THE TREE IS FILLED
*
*        ENTRY FROM DEBLOCK WHILE FILLING (RECORD FITS)
*
OCGOTFIL S     R3,KCINCDEC         DECREMENT NEW ADDR BY EXTRACT INC+4
         CLI   KCSWITCH+3,X'FF'    CHECK EXTRACT SWITCH
         BNE   OCNOTON1            BRANCH IF OFF
*
*        EXIT TO EXTRACT ROUTINE
*
         BAS   R14,4(,R12)         CALL EXTRACT ROUTINE
OCNOTON1 LM    R7,R9,WCSAVE        FILLING REGISTERS
         L     R4,OCSAME           UPDATE MODE
         ST    R9,0(,R3)           ADDR OF TREE WITH RECORD
OCSUBFIT LR    R5,R9               ADDR OF TREE (NEXT LEVEL ADDR)
         BCT   R7,OCGCT            DECREMENT WAY COUNTER
         LA    R7,2                RESET WAY COUNTER
         LA    R9,12(,R9)          INCREMENT TO NEXT NODE
OCGCT    BCT   R8,OCFILREG         DECREMENT G COUNTER
         STM   R7,R9,WCSAVE
         B     OCNEXT2
*
OCFILREG STM   R7,R9,WCSAVE        SAVE FILLING REGISTERS
         B     OCNEXT2
*
*        ENTRY FROM DEBLOCK WHILE FILLING (RECORD DOES NOT FIT)
*
OCNOGOFI LM    R7,R9,WCSAVE        FILLING REGISTERS
         L     R4,OCSTEMP          UPDATE MODE
         LR    R3,R9               USE TREE ADDR AS WINNER
         B     OCSUBFIT
*
*        DETERMINE IF EOF SITUATION IS A NORMAL ONE FILE SIZE
*        LESS THEN G, OR FILE SIZE IS ZERO AND BRANCHES
*        ACCORDINGLY
*
*        ENTRY FROM DEBLOCK AT EOF
*
OCEOF    CLC   PPISRTG(4),WCSAVE+4  COMPARE G COUNT IN PPIA TO FILL NO
         BNE   OCNOZERO
*
*        EXIT TO CLOSE ROUTINE
*
         LA    R1,4                SET UP PARAMETER TO END OF PHASE
         L     R15,PPIADSSC        R15 -> SSC
         BAS   R14,20(,R15)        INPUT FILE WAS ZERO
*
OCNOZERO MVC   OCC7A(8),OCC7EOF    MODIFY CASE 7 TO FORCE TREE FLUSHING
         LA    R10,0               CONSTANT OF 0
         CL    R10,WCSAVE+4        COMPARE TO FILL COUNT
         BE    OCRETEOF
*
*        FILE SIZE IS LESS THAN G
*        THE CODING IS MODIFIED TO FILL THE REMAINDER OF THE
*        TREE WITH IMAGINARY RECORDS (T1)
*
         OI    OCC8A+1,X'F0'       INITIALIZE BRANCH INST IN CASE 8
         MVC   OCPICK(4),OCMODIFY  MODIFY FILLING RETURN LOCATION
OCMODIFY B     OCNOGOFI
*
*        MODE POSITIONS AND BRANCH TABLE
*
*        THROUGH THE COMBINATION OF MODE AND FORMAT AN INDEXED
*        BRANCH IS PERFORMED WHICH BRANCHES TO THE CASE WHICH
*        HANDLES THE INDICATED SITUATION
*
OCNTEMP  DC    A(OCBTABLE)
OCNEW    DC    A(OCBTABLE+4)
OCSTEMP  DC    A(OCBTABLE+8)
OCSAME   DC    A(OCBTABLE+12)
OCBTABLE DC    A(0)                SPACE TO MAINTAIN POSITIONS IN TABLE
         DC    A(0)                SPACE TO MAINTAIN POSITIONS IN TABLE
         B     OCCASE3
         B     OCCASE4
         B     OCCASE5
         B     OCCASE6
         B     OCCASE7
OCMODLOC B     OCCASE8
         B     OCCASE9
         B     OCCASE10
         B     OCNEXT
         B     OCNEXT
         B     OCCASE13
         B     OCCASE14
         B     OCNEXT
         B     OCNEXT
         B     OCCASE17
         B     OCCASE18
         B     OCNEXT
         B     OCNEXT
         B     OCCASE21
         B     OCCASE22
         B     OCCASE23
         B     OCCASE24
*
*        CASE - AN S1/S1 SITUATION
*
OCCASE24 CLC   0(1,R3),0(R7)       COMPARE WINNER TO LOSER
         BNH   OCNEXT
OCEXCH   ST    R3,8(,R5)           WINNER TO LOSER
         LR    R3,R7               LOSER TO WINNER
OCNEXT   L     R5,0(,R5)           ADDR OF NEXT NODE
OCNEXT2  LM    R6,R7,4(R5)         LOAD NODE
         B     0(R4,R6)            GOTO PROPER CASE
*
*        CASE - A T1/S1 SITUATION
*
OCCASE23 L     R4,OCSAME           UPDATE MODE
         LA    R10,64              FORMAT T1
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OCEXCH
*
*        CASE - AN S2/S1 SITUATION
*
OCCASE22 L     R4,OCSAME           UPDATE MODE
         LA    R10,48              FORMAT S2
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OCEXCH
*
*        CASE - A T2/S1 SITUATION
*
OCCASE21 L     R4,OCSAME           UPDATE MODE
         LA    R10,32              FORMAT T2
         ST    R10,4(,R5)         UPDATE FORMAT
         B     OCEXCH
*
*        CASE - AN S2/T1 SITUATION
*
OCCASE18 L     R4,OCSTEMP          UPDATE MODE
         LA    R10,48              FORMAT S2
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OCEXCH
*
*        CASE - A T2/T1 SITUATION
*
OCCASE17 L     R4,OCSTEMP          UPDATE MODE
         LA    R10,32              FORMAT T2
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OCEXCH
*
*        CASE - AN S2/S2 SITUATION
*
         SPACE 1
OCCASE14 LA    R10,80              FORMAT S1
         ST    R10,4(0,R5)         UPDATE FORMAT
         CLC   0(1,R3),0(R7)       COMPARE WINNER TO LOSER
OCC14A   BNL   OCNEXT
         B     OCEXCH
*
*        CASE - A T2/S2 SITUATION
*
OCCASE13 L     R4,OCNEW            UPDATE MODE
*
*        CASE - A T2/T2 SITUATION
*
OCCASE9  LA    R10,64              FORMAT T1
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OCEXCH
*
*        CASE - AN S2/T2 SITUATION
*
OCCASE10 LA    R10,64              FORMAT T1
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OCNEXT
*
*        INDICATES THE TREE IS FILLED AND FORCES THE NETWORK INTO
*        A RUNNING SITUATION
*
OCCASE8  ST    R3,WCLTNODE         SAVE ADDR OF RECD IN LAST TEST NODE
         MVC   OCMODLOC(4),OCMODC8 MODIFY BRANCH TABLE
OCC8A    NOP   OCRETEOF            INITIALIZED TO BRANCH AT FILE < G
         L     R11,PPIDEB+4        DEBLOCK BASE REGISTER
*
*        EXIT TO DEBLOCK ROUTINE
*
         B     0(,R11)     MODIFY AND GET
*
*        INDICATES THERE IS A RECORD TO BE BLOCKED
*
OCCASE8A L     R10,WCLTNODE        ADDR OF RECORD IN LAST TEST NODE
         ST    R3,WCLTNODE         ADDR OF NEXT RECD TO LAST TEST NODE
         LR    R3,R10              ADDR TO WINNER POSITION
         A     R3,KCINCDEC         INC ADDR BY EXTRACT INCREMENT+4
         L     R11,PPIBLK+4        BLOCK BASE REGISTER
*
*        EXIT TO BLOCK ROUTINE
*
         B     12(,R11)            PUT INFERS GET
*
*        INDICATES THAT A T1 (IMAGINARY) HAS BEEN FORCED OUT OF
*        THE TREE
*
OCCASE7  L     R10,WCLTNODE        ADDR OF RECORD IN LAST TEST NODE
         ST    R3,0(,R10)          NODE ADDR (T1) WITH RECORD HELD BACK
         LR    R5,R3               NODE ADDR AS NEXT LEVEL ADDR
OCC7A    L     R10,OCNTEMP         MODE NTEMP
         ST    R10,WCSPECL         SET SPECIAL INDICATOR TO NTEMP
         L     R11,PPIDEB+4        DEBLOCK BASE REGISTER
*
*        EXIT TO DEBLOCK ROUTINE
*
         B     8(,R11)             GET TO FILL (DEBLOCK EXIT MODIFIED)
*
*        INDICATES THAT IT IS THE END OF A SEQUENCE
*
OCCASE6  L     R10,OCSTEMP         MODE STEMP
         ST    R10,WCSPECL         SET SPECIAL INDICATOR TO STEMP
         L     R10,WCLTNODE        ADDR OF RECORD IN LAST TEST NODE
         ST    R3,WCLTNODE         ADDR OF NEXT RECD TO LAST TEST NODE
         LR    R3,R10              ADDR TO WINNER POSITION
         A     R3,KCINCDEC         INC ADDR BY EXTRACT INCREMENT+4
*
*        CHECK SEQUENCE REVERSING SWITCH
*        IF ON COMPLETE THE SEQUENCE REVERSING CYCLE
*
         CLI   KCREVSW+3,X'00'     CHECK REVERSAL SWITCH
         BE    OCSWOFF             IF OFF REVERSAL IS NOT IN PROCESS
*
*        TURN OFF REVERSAL SWITCH
*        REVERSE THE CONDITIONAL BRANCH WHICH DETERMINES THE
*        RESULTS OF COMPARES BETWEEN RECORDS OF THE PRESENT
*        SEQUENCE. REVERSE THE CONDITIONAL BRANCH WHICH
*        DETERMINES THE RESULTS OF THE SEQUENCE CHECK OF THE
*        INCOMING RECORD
*
         SR    R10,R10             ZERO REGISTER
         ST    R10,KCREVSW         TURN REVERSAL SWITCH OFF
         XI    OCCASE24+7,X'60'    IN CASE 24
         XI    OCNOTON2+27,X'60'   IN SEQUENCE CHECK
OCSWOFF  L     R11,PPIBLK+4        BLOCK BASE REGISTER
*
*        EXIT TO BLOCK ROUTINE
*
         B     4(,R11)             PUT EOS
*
*        INDICATES THAT IT IS END OF FILE
*
OCCASE5  L     R3,WCLTNODE         ADDR OF RECORD IN LAST TEST NODE
         A     R3,KCINCDEC         INC ADDR BY EXTRACT INCREMENT+4
         L     R11,PPIBLK+4        BLOCK BASE REGISTER
*
*        EXIT TO BLOCK ROUTINE
*
         B     0(,R11)             PUT EOF
*
*        CASE - AN S1/- SITUATION
*
OCCASE4  ST    R3,8(,R5)           WINNER TO LOSER
         LA    R10,80              FORMATS1
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OCPICK
*
*        CASE - A T1/- SITUATION
*
OCCASE3  ST    R3,8(,R5)           WINNER TO LOSER
         LA    R10,64              FORMAT T1
         ST    R10,4(,R5)          UPDATE FORMAT
         B     OCPICK
*
*        ENTRY FROM DEBLOCK WHILE RUNNING (RECORD FITS)
*
*        SEQUENCE CHECKS THE NEW RECORD AND STARTS IT THROUGH
*        THE REPLACEMENT NETWORK
*
OCGOTRUN S     R3,KCINCDEC         DECREMENT NEW ADDR BY EXTRACT INC +4
         CLI   KCSWITCH+3,X'FF'    CHECK EXTRACT SWITCH
         BNE   OCNOTON2            BRANCH IF OFF
*
*        EXIT TO EXTRACT ROUTINE
*
         BAS   R14,4(,R12)         CALL EXTRACT ROUTINE
OCNOTON2 L     R10,OCSTEMP         MODE STEMP
         ST    R10,WCSPECL         SET SPECIAL INDICATOR TO STEMP
         L     R2,WCLTNODE         ADDR OF RECORD IN LAST TEST NODE
         L     R5,0(,R2)           NODE ADDR WITH RECORD HELD BACK
         ST    R5,0(,R3)           NODE ADDR WITH NEW RECORD
         CLC   0(1,R3),0(R2)       COMPARE NEW RECORD TO ONE HELD BACK
         BL    OCMODNEW
         L     R4,OCSAME           UPDATE MODE
         B     OCNEXT2
*
OCMODNEW L     R4,OCNEW            UPDATE MODE
         B     OCNEXT2
*
*        SET UP TO FLUSH ANOTHER RECORD FROM THE TREE AFTER END
*        OF FILE OR BECAUSE THE INCOMONG RECORD WILL NOT FIT
*
*        ENTRY FROM DEBLOCK AFTER EOF
*
OCRETEOF L     R4,OCNTEMP          UPDATE MODE
         B     OCSUBNO
*
*        ENTRY FROM DEBLOCK WHILE RUNNING (RECORD DOES NOT FIT)
*
OCNOGORN L     R4,WCSPECL          UPDATE MODE
OCSUBNO  L     R10,WCLTNODE        ADDR OF RECORD IN LAST TEST NODE
         L     R5,0(,R10)          NODE ADDR WITH RECORD HELD BACK
         LR    R3,R5               TREE ADDR AS WINNER
         B     OCNEXT2
*
*        CONSTANTS
*
KCSWITCH DC    X'00000000'         EXTRACT SWITCH
KCINCDEC DC    F'0'                ADDRS INC OR DEC OF EXTRACT INC+4
KCREVSW  DC    X'000000FF'         SWITCH USED WHILE REVERSING SEQUENCE
*                                  THIS SWITCH IS INITIALLY ON
*
*        WORK AREAS
*        THE ORDERING OF THESE WORK AREAS MUST BE MAINTAINED
*
WCSAVE   DC    3F'0'               FILLING REGISTER SAVE AREA
WCTREE   DC    F'0'                LOCATION OF TREE
WCLTNODE DC    F'0'                LAST TEST NODE
         DC    A(16)               FORMAT OF LAST TEST NODE
WCSPECL  DC    A(OCBTABLE+8)       SPECIAL (MODE) INDICATOR
*
*        MODIFICATION INSTRUCTIONS
*
*        THE ORDERING OF THESE INSTRUCTIONS MUST BE MAINTAINED
*
OCMODC8  B     OCCASE8A            MODIFICATION TO HOLD BACK A RECORD
OCC7EOF  L     R4,OCNTEMP          UPDATE MODE * MODIFICATION TO CASE7
         B     OCNEXT2                         * TO FORCE TREE FLUSHING
*
./ ADD NAME=IERROI   0101-20211-20211-1200-00086-00086-00000-RELEASE 00
ROI      TITLE 'IERROI - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERROI
*
*        MODULE FUNCTION/OPERATION -
*        SORT PHASE BALN TAPE ALGORITM
*        THE FUNCTION OF THIS MODULE IS TO -
*        (A) DETERMINE OUTPUT UNIT FOR SORT
*        (B) CHECK FOR SORT CAPACITY BEING EXCEEDED
*        (C) SET APPROPRIATE INDICATORS IN THE TAPE TABLE FOR
*            OPEN RTN
*        (D) DETERMINES IF PHASE 2 OR PHASE 3 WILL FOLLOW SORT
*            PHASE TERMINATION
*            1 IF WRONG ORDER FOR PHASE 3 AND ONE OR TWO PASSES
*              OF PHASE TWO IERROI TURNS ON BLOCK FORWARD AND
*              READ FORWARD LATER AND HAS SSC CALL PHASE 2
*            2 IF WRONG ORDER AND NUMBER OF SEQUENCES < FINAL
*              MERGE ORDER AND RECORDS ARE FIXED LENGTH IT SETS
*              DEBLOCK BACKWARD, READ FORWARD AND REWIND SWITCHES
*              AND HAS SSC CALL PHASE 3
*            3 IF ORDER IS CORRECT AND NUMBER OF SEQUENCES <
*              FINAL MERGE ORDER IT HAS SSC CALL PHASE 3
*            4 OTHERWISE,IT DOES NOT SET SWITCHES AND HAS SSC
*              CALL PHASE 2
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM IERRPA
*                       CALLING SEQUENCE
*                       L    R11,PPIALG+4
*                       B    DISP(,R11)
*                            DISP = 0 FOR END OF FILE
*                                 = 4 FOR EOV & NOT EOS
*                                 = 8 FOR EOV & END OF SEQ
*                                 =12 FOR END OF VOLUME
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIDEB    PPIWRT     PPIMRGAL   PPISEQCT
*        PPIRMA    PPIADSSC   PPIMRGMX   PPICNTL
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPICNTL   PPIMRGMX   PPITPPT
*        PPIDEPHO  PPISEQCT   PPITPTBL
*
*        EXTERNAL ROUTINES - EXTRN IERDD1 - DEBLOCK ROUTINE
*        EXTRN IERDPW1 - WRITE ROUTINE
*
*        EXTERNAL PARAMETERS -
*        EXTRN IERRMA - MESSAGE MODULE
*
*        EXITS - NORMAL -
*        EXTRN IERRCV - SORT SYSTEM CONTROL
*
*        EXITS - ERROR -
*        EXTRN IERRCV - SORT SYSTEM CONTROL
*
*        TABLES/WORK AREAS - NONE
*
IERROI   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERROI SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERROII
*
DIERRMA  DSECT
*
*        MODULE NAME - IERRMA
*
*        THIS MODULE CONTAINS ALL OF THE MESSAGES THAT ARE
*        REQUIRED FOR PHASE 1 RUNNING PROGRAM
*
         COPY  RMAMAIN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERROII  0101-20211-20211-1200-00276-00276-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERROI SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERROII
*
         USING *,R11
         USING IERRCA,R13
         USING DIERRMA,R14
*
*        INTERFACE ENTRIES BRANCH TABLE
*
IERDOK   B     ROIEOF              +00 WRITE OF LAST BLK OF FILE
         B     ROIEOTW             +04 END OF TAPE NOT END OF SEQ BLK
         B     ROIEOTD             +08 END OF TAPE END OF SEQ BLK
         B     ROI020              +12 EOV
*
*        SPECIAL EOV ENTRY FROM WRITE ROUTINE
*
*        WHEN TWO OUTPUT BUFFERS ARE PRESENT AND EOS EOV OCCURS
*        ON THE SAME BLOCK, THE EOV IS NOT DETECTED UNTIL AFTER
*        EOS HAS BEEN PROCESSED BY THE ALGORITHM. THIS ENTRY THEN
*        PROCESSES EOV BY RESETTING POINTERS AS THEY WERE PRIOR
*        TO THE LAST EOS AND THEN EXECUTING AS FOR AN EOV. THIS
*        ENTRY EXISTS ONLY IN THE BALANCED ALGORITHM.
*
         MVC   ROIRSW(2),KROIRSC2  SET RSWITCH TO GOTO WRITE RTN
         LH    R4,IERROITL
         CH    R4,IERROILT         COUNT AT UPPER LIMIT ?
         BNL   ROI010              YES, RESET
         LA    R4,1(,R4)           NO, INCREMENT
         STH   R4,IERROITL
         L     R4,IERROITP
         S     R4,KROITWO
         ST    R4,IERROITP
         B     ROI030
*
ROI010   LA    R4,1
         STH   R4,IERROITL
         L     R4,IERROILA
         ST    R4,IERROITP
         B     ROI030
*
*        INTERFACE ENTRY AFTER WRITE OF LAST BLK OF A SEQUENCE
*
ROI020   L     R4,PPISEQCT+4       NUMBER OF GENERATED SEQUENCES
         LA    R4,1(,R4)           INCR NUMBER OF GENERATED SEQUENCES
         ST    R4,PPISEQCT+4
         LH    R4,IERROITL         TAPE TABLE POINTER LIMIT
         BCT   R4,ROIITTP          GOTO INCR TAPE POINTER
         MVC   IERROITL(2),IERROILT  RESET POINTER LIMIT
         LA    R4,PPITPTBL+1
         ST    R4,IERROITP         RESET TABLE POINTER TO FIRST UNIT
         B     ROISOU              GOTO SET DCB INCR FOR WRITE RTN
*
ROIITTP  STH   R4,IERROITL
         L     R4,IERROITP
         LA    R4,2(,R4)           INCR TAPE TABLE POINTER
         ST    R4,IERROITP
ROISOU   MVC   PPIDEPHO+3(1),0(R4) SET DCB INCR FOR WRITE RTN
         L     R11,PPIDEB+4
         B     8(,R11)             EXIT TO THE DEBLOCK RTN
*
*        INTERFACE ENTRIES WHEN END OF TAPE REACHED
*
ROIEOTD  MVC   ROIRSW(2),KROIRSC1  SET RSWITCH TO GOTO DEBLOCK RTN
ROIINGS  L     R4,PPISEQCT+4
         LA    R4,1(,R4)           INCR NUMBER OF GENERATED SEQUENCES
         ST    R4,PPISEQCT+4
*
*        UPDATE OF THE CURRENT NUMBER OF WORKING TAPES CONSTANT
*        AND EXCEED SORT CAPACITY CHECK SECTION
*
ROI030   LH    R4,IERROLMT
         BCT   R4,ROICONT
*
*        EXCEED SORT CAPACITY M FULL TAPES
*        TERMINATE THE SORT
*
         L     R14,PPIRMA+4
         L     R1,IER046
         MVC   PPIABMNO,3(R1)      MOVE MSG NO INTO ABEND MSG
         LM    R0,R1,IER046        IER046A SORT CAPACITY EXCEEDED
         L     R15,PPIADSSC        R15 - > MSG RTN
         BAS   R14,12(,R15)        CALL MSG WRITER RTN
*
*        APROX RCD CNT IS PPICOUNT -G - B
*        WHERE G AND B ARE MAX VALUES
*        IF CNT TURNS NEGATIVE, CNT IS SET TO PPICOUNT-G+B OR
*        JUST B
*        THIS NEGATIVE CONDITION IS MOST LIKELY IF THE BLOCK
*        BEING WRITTEN OUT IS SHORT AND/OR RECORD FORMAT IS
*        VARIABLE
*
         L     R1,PPICOUNT         NO RCD READ IN MINUS G
         A     R1,PPIINSCT         ADD NO OF INSERTED RECORDS
         S     R1,PPIDELCT         SUBTRACT NO DELETED RECORDS
         S     R1,PPISRTG          G - MAX NO OF RCDS IN TREE
         LH    R15,PPISRTBL        B - F = NO RCDS/BLOCK
         PPITEST  PPIFIX               V = BYTES/BLOCK
         BO    ROI031
         LH    R0,PPIRCDL4         B / MIN RCD LENGTH = MAX NO
         SR    R14,R14
         DR    R14,R0              RCDS IN BLOCK
ROI031   CR    R1,R15              CHECK TO MAKE SURE CNT ISN'T
         BH    ROI032              NEGATIVE
         AR    R1,R15              ADD B TO CNT
         CR    R1,R15              CNT STILL NEG  IF YES,
         BNL   ROI033
         LR    R1,R15              SET CNT TO B
         B     ROI033
*
ROI032   SR    R1,R15              APROX RCD CNT = PPICOUNT -G -B
ROI033   CVD   R1,PPIWKARE         CONVERT TO PACKED
         L     R14,PPIRMA+4        R14 -> IERRMA MESSAGE TEXT MODULE
         ED    IER066A,PPIWKARE+4  FORMAT DATA
         LM    R0,R1,IER066        IER066A APPROXIMATE RECORD COUNT
         L     R15,PPIADSSC        R15 -> MSG PRINT RTN
         BAS   R14,12(,R15)
         L     R15,PPIADSSC
         BAS   R14,16(,R15)        TERMINATE THE SORT
*
ROICONT  STH   R4,IERROLMT
         LH    R4,IERROILT
         BCTR  R4,0
         STH   R4,IERROILT
*
*        UPDATING THE TAPE TABLE SECTION
*
         LH    R4,IERROITL         CURRENT VALUE OF TAPE TBL PT LIMIT
         BCTR  R4,0
         SLA   R4,1(0)
         BZ    ROISTC
         BCTR  R4,0
ROISTC   STC   R4,ROIMOV+1
         L     R5,IERROITP         ADDR IN TAPE TBL PT CONSTANT
         LR    R6,R5
         LA    R6,1(,R6)
         BCTR  R5,0
         L     R7,IERROILA         ADDR OF TAPE TBL POINTER LMT
         MVC   ROISVTTE(2),0(R5)   SAVE ENTRY OF TAPE TBL
ROIMOV   MVC   0(1,R5),0(R6)       UPDATE TAPE TABLE
         MVC   0(2,R7),ROISVTTE
*
*        UPDATE ADDR OF TAPE TABLE POINTER LIMIT
*
         S     R7,KROITWO
         ST    R7,IERROILA
         LH    R4,IERROITL         DECREMENT TAPE TABLE POINTER LIMIT
         BCT   R4,ROISDCBI         GOTO SET DCB INCR
         MVC   IERROITL(2),IERROILT  RESET POINTER LMT
         LA    R4,PPITPTBL+1
         ST    R4,IERROITP         RESET TABLE POINTER TO FIRST UNIT
ROIMDCB  MVC   PPIDEPHO+3(1),0(R4) SET DCB INCR FOR WRITE RTN
*
*        CHECK RSWITCH FOR EXIT
*
         TM    ROIRSW+1,X'01'
         BO    ROIEWR
         L     R11,PPIDEB+4
         B     8(,R11)             EXIT TO DEBLOCK RTN
*
ROIEWR   L     R11,PPIWRT+4
         BR    R11                 EXIT TO THE WRITE RTN
*
ROISDCBI STH   R4,IERROITL         SAVE TAPE TBL POINTER LMT
         L     R4,IERROITP         TAPE TABLE POINTER
         B     ROIMDCB             GOTO SET DCB INCR FOR WRITE RTN
*
ROIEOTW  MVC   ROIRSW(2),KROIRSC2  SET RSWITCH TO GOTO WRITE RTN
         B     ROIINGS             GOTO INCR NUMBER OF SEQUENCES
*
*        ENTRY AFTER WRITE OF LAST BLK OF FILE
*
ROIEOF   L     R4,PPISEQCT+4       NUMBER OF GENERATED SEQUENCES
         LA    R4,1(,R4)           INCR NUMBER OF SEQUENCES
         ST    R4,PPISEQCT+4
         MVC   PPITPPT(2),PPIMRGMX  NO UNITS IN 1 HALF OF TAPE TBL
         MVC   PPITPPT+2(2),PPIMRGAL  NO OF UNITS IN 2 HALF OF TP TBL
         CH    R4,PPIMRGMX         COMPARE NUMBER OF GENERATED SEQUENCE
*                                  TO THE MERGE ORDER
*                                  IF GREATER CALL FOR PHASE 2
*                                  IF NOT GREATER  CALL FOR PHASE 3
         BE    ROICASE             BYPASS SETTING OFF OPEN BITS
         BL    ROICALL3            JUMP TO SEE IF PHASE 3 CAN BE CALLED
         LH    R3,PPIMRGMX         DETERMINE IF MAY ENTER PHASE 2
         MH    R3,PPIMRGAL         WITH ONLY ENOUGH SEQUENCES FOR ONE
         CLR   R4,R3               PASS
         BNH   ROIX1PH2            ONE PHASE 2 PASS
         MH    R3,PPIMRGMX
         CLR   R4,R3               CHECK FOR 2 PASS CASE OF PHASE 2
         BNH   ROIX2PH2            TWO PHASE 2 PASSES
*
*        SET THE OPEN BITS OF THE ENTRIES IN THE SECOND HALF OF
*        THE TAPE TBL ON
*
ROILDP2  LA    R4,PPITPTBL
         LH    R3,PPIMRGMX
         SLA   R3,1
         AR    R4,R3               STARTING PT OF 2 HALF OF TP TBL
         LH    R3,PPIMRGAL         ALT MRG ORD FOR TRAVERSE TP TBL
ROISTPTB OI    0(R4),X'40'         STORE A 1 IN OPEN BIT
         LA    R4,2(,R4)           GO DO NEXT ITEM
         BCT   R3,ROISTPTB         IS TABLE TRAVERSED ?
ROIEXCL  PPIFLIP  PPIPH1CO
         L     R15,PPIADSSC
         LA    R1,0                EXIT TO SSC CALLING FOR PHASE 2
         BAS   R14,20(,R15)
*
*        DECIDE IF A REWIND IS POSSIBLE IF DESIRABLE
*
ROIX2PH2 PPITEST  PPIEXTRT+PPIUOSEQ  EXTRACTING OR USER WANTS
         BNO   ROICHK2               ASCENDING SEQUENCE ? GOTO CHK2
ROICHK1  PPITEST  PPIUOSEQ+PPIPH1CO  USER SEQ IS OPPOSITE TO PRES SEQ ?
         BNM   ROILDP2               DO NOT PERFORM SPECIAL ROUTINES
ROISET   PPISETON PPIBLKF+PPIREADB   TURN ON BLOCK FORWARD AND READ
         B     ROILDP2               FORWARD LATER SWITCHES
*
ROICHK2  PPITEST  PPIUOSEQ+PPIPH1CO  USER SEQ AGREES WITH PRES SEQ ?
         BM    ROILDP2               DO NOT PERFORM SPECIAL ROUTINES
         B     ROISET
*
ROIX1PH2 PPITEST  PPIEXTRT+PPIUOSEQ  IF NOT EXTRACTING OR USER WANTS
         BNO   ROICHK1               ASCENDING SEQUENCE GOTO CHK1
         B     ROICHK2               ELSE CHK2
*
ROICALL3 LH    R8,PPIMRGMX         GET MERGE ORDER
         STH   R4,PPIMRGMX         STORE NEW MERGE ORDER (SEQUENCES)
         SR    R4,R8               STRINGS MERGE ORDER (OLD)
         LCR   R4,R4               OLD MERGE ORDER - NUMBER OF STRINGS
         BCTR  R8,0
         MH    R8,KROITWO+2        DOUBLE R8 TO CONVERT IT TO AN INDEX
         LA    R8,PPITPTBL(R8)     POINT AT LAST ENTRY AFFECTED
ROIRON01 NI    0(R8),X'3F'         TURN OFF OPEN + INPUT BITS
         S     R8,KROITWO          SUBTRACT 2 TO INDEX BACK IN TABLE
         BCT   R4,ROIRON01         IF NEXT ENTRY IS AFFECTED, BRANCH
ROICASE  PPITEST  PPIEXTRT+PPIUOSEQ  IF EXTRACTING AND USER WANTS
         BO    ROINOEXT              DESCENDING SEQUENCE GOTO NOEXT
         PPITEST  PPIUOSEQ+PPIPH1CO  INPUT LOOK GOOD FOR PHASE 3 ?
         BM    ROILDP3               YES, GO LOAD PHASE 3
         B     ROITEST               NO, CHECK FOR REWIND POSSIBLE
*
ROINOEXT PPITEST  PPIUOSEQ+PPIPH1CO  INPUT LOOK GOOD FOR PHASE 3 ?
         BNM   ROILDP3               YES, GO LOAD PHASE 3
ROITEST  PPITEST  PPIFIX           FIXED LENGTH RECORDS ?
         BZ    ROILDP2             NO, NOT A PHASE TWO NORMAL PASS
*                                  MUST BE CALLED
         PPISETON PPIDEBB+PPIREADF+PPICLOSR  ELSE SET SWITCHES
         PPIFLIP  PPIPH1CO
ROILDP3  PPIFLIP  PPIPH1CO         SET INPUT SEQ BIT FOR MERGING
         L     R15,PPIADSSC        CALL PHASE 3
         LA    R1,4
         BAS   R14,20(,R15)
*
         DC    0F'0'
IERROITL DC    H'0'                TAPE TABLE POINTER LIMIT THE ASSGN
*                                  RTN SETS THIS EQUAL TO MAX MRG ORD
IERROILT DC    H'0'                TAPE TABLE POINTER LIMIT EQUAL TO
*                                  THE CURRENT NUMBER OF WORK UNITS
IERROLMT DC    F'0'                SORT CAPACITY LIMIT
IERROITP DC    F'0'                TAPE TBL POINTER  AN ADDRESS
IERROILA DC    X'00000000'         ADDRESS OF TAPE TABLE POINTER LIMIT
ROISVTTE DC    F'0'                SAVE TAPE TABLE ENTRY
ROIRSW   DC    X'0000'             RSWITCH
ROICODE  DC    X'0010'             TERMINATE CODE FOR SORT SYS CONTROL
*
KROIRSC1 DC    X'0000'             RSWITCH CONSTANT GOTO DEBLOCK
KROIRSC2 DC    X'0001'             RSWITCH CONSTANT GOTO WRITE
KROITHRE DC    XL4'3'
KROIFOUR DC    XL4'4'
KROIEIGH DC    XL4'8'
KROITWO  DC    XL4'2'
*
./ ADD NAME=IERROJ   0101-20211-20211-1200-00066-00066-00000-RELEASE 00
ROJ      TITLE 'IERROJ - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERROJ
*
*        MODULE FUNCTION/OPERATION-
*        SORT PHASE POLYPHASE ALGORITHM FOR TAPE
*        THIS MODULE CONTROLS THE DISTRIBUTION OF SEQUENCES ON
*        THE WORK TAPES AS REQUIRED TO ACHIEVE AN EFFICIENT
*        POLYPHASE SORT
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM IERRPA
*                       CALLING SEQUENCE -
*                           L    R11,PPIALG+4
*                           B    DISP(0,R11)
*                           DISP = 0 FOR END OF FILE
*                                = 4 FOR EOV & NOT EOS
*                                = 8 FOR END OF VOL& NOT EOS
*                                =16 FOR END OF SEQUENCE
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIADSSC   PPINET   PPIRMA
*        PPIWKARE   PPIDEB
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPIDEPHO   PPICNTL   PPITPTBL
*
*        EXTERNAL ROUTINES - EXTRN IERRCV - SORT SYSTEM CONTROL
*
*        EXTERNAL PARAMETERS - EXTRN IERRMA - MESSAGE MODULE
*
*        EXITS - NORMAL - IERRCV - SORT SYSTEM CONTROL
*
*        EXITS - ERROR - IERRCV - SORT SYSTEM CONTROL
*
*        TABLES/WORK AREAS - NONE
*
*        NOTES - NONE
*
IERROJ   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERROJ SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERROJI
*
*
*        IERRMA - MESSAGE MODULE
*
DIERRMA  DSECT
*
         COPY  RMAMAIN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERROJI  0101-20211-20211-1200-00280-00280-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERROJ SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERROJI
*
         USING *,R11
         USING IERRCA,R13
         USING DIERRMA,R10
*
*        ENTRY TABLE
*
IERDOK   B     OJEOF               +00 WRITE ROUTINE AT EOF
         B     OJEOV               +04 WRITE ROUTINE AT EOV
*                                      EOS HAS NOT BEEN REACHED AND
*                                      MORE WRITES ARE PENDING
         B     OJEOV               +08 WRITE ROUTINE AT EOV
*                                      EOS HAS BEEN REACHED BUT ALL
*                                      THE INPUT HAS NOT BEEN PROCESSED
*
*        ENTRY FROM WRITE ROUTINE AT END OF SEQUENCE
*
*        INCREMENT COUNT OF SEQUENCES ON THIS UNIT
*
         LH    R4,WOJPOINT         TAPE TABLE POINTER(INC WITHIN TABLE)
         LH    R5,PPITPTBL+34(R4)  SEQUENCE COUNTER FOR THIS UNIT
         LA    R5,1(,R5)           INCREMENT COUNTER BY ONE
         STH   R5,PPITPTBL+34(R4)  RESTORE SEQUENCE COUNTER
*
*        DETERMINE IF ENOUGH SEQUENCES HAVE BEEN DISTRIBUTED TO
*        SATISFY THE PRESENT SET OF FIBONACCI NUMBERS
*
         L     R5,WOJTOTAL         COUNT SEQUENCES TO DISTRIBUTE
         BCT   R5,OJNOUPDT         BRANCH IF FIBS DO NOT NEED UPDATING
*
*        CALCULATE NUMBER OF SEQUENCES TO BE DISTRIBUTED AFTER
*        THIS UPDATE OF THE FIBONACCI NUMBERS
*
         LH    R7,WOJINCPT         INCREMENT TO LAST ITEMS IN TABLE
         LH    R7,PPITPTBL+102(R7) LAST OF ORIGINAL OLD FIBONACCI NOS
         LH    R8,WOJCTN2          COUNT OF (N-2)
         MR    R6,R8               MULTIPLY TO DETERMINE NEW SEQ COUNT
         ST    R7,WOJTOTAL         RESET NEW COUNT OF SEQ TO DISTRIBUTE
*
*        UPDATE TO NEXT HIGHER SET OF FIBONACCI NUMBERS
*
OJUPDFIB LH    R5,WOJCTN2          COUNT OF (N-2)
         LH    R4,WOJINCPT         INCREMENT TO LAST ITEMS IN TABLE
         LA    R4,PPITPTBL+102(R4) ADDR OF LAST OF OLD FIB NUMBERS
         LR    R6,R4               ADDR OF LAST OF OLD FIB NUMBERS
         LH    R7,0(,R4)           LAST OF OLD FIBONACCI NUMBERS
         LR    R9,R7               LAST OF OLD FIBONACCI NUMBERS
         LA    R8,2                CONSTANT OF 2
OJNEXFIB SR    R4,R8               DECREMENT ADDR TO PRECEEDING FIB NO
         AH    R7,0(,R4)           LAST OLD FIB PLUS NEXT TO LAST, ETC
         STH   R7,0(,R6)           TOATAL INTO LAST FIBS POSITION ETC
         LR    R7,R9               LAST OF OLD FIBONACCI NUMBERS
         SR    R6,R8               DECREMENT ADDR TO PRECEEDING FIB NO
         BCT   R5,OJNEXFIB         BRANCH IF ALL FIBS NOT UPDATED
         STH   R7,0(,R4)           ORIGINAL OLD LAST FIB AS NEW 1ST FIB
*
*        DETERMINE IF THE UPDATED FIBONACCI NUMBERS ARE ALL ODD
*        IF THEY ARE ALL ODD, ANOTHER UPDATE MUST BE PERFORMED
*        NOW
*
         LH    R4,WOJALODD         ALL ODD COUNTER (EVERY N UPDATES THE
*                                  **FIBONACCI NUMBERS ARE ALL ODD)
         BCT   R4,OJNOTODD         BRANCH IF NOT ALL ODD
         MVC   WOJALODD(2),WOJCTN  RESET ALL ODD COUNTER TO N
*
*        CALCULATE NUMBER OF ADDITIONAL SEQUENCES TO BE
*        DISTRIBUTED AFTER THIS UPDATE AND ADD THEM TO PREVIOUS
*        COUNT
*
         LH    R7,WOJINCPT         INCREMENT TO LAST ITEMS IN TABLE
         LH    R7,PPITPTBL+102(R7) LAST OF ORIGINAL OLD FIBONACCI NOS
         LH    R8,WOJCTN2          COUNT OF (N-2)
         MR    R6,R8               MULTIPLY TO DETERMINE NEW SEQ COUNT
         A     R7,WOJTOTAL         OLD COUNT OF SEQUENCES TO DISTRIBUTE
         ST    R7,WOJTOTAL         RESET NEW COUNT OF SEQ TO DISTRIBUTE
         B     OJUPDFIB            BRANCH TO UPDATE FIBONACCI NUMBERS
*
OJNOTODD STH   R4,WOJALODD         SAVE ALL ODD COUNTER
*
*        MOVE THE UPDATED FIBONACCI NUMBERS TO THE FUTURE NUMBERS
*        POSITION OF TABLE AND PERMUTE THEM AS NECESSARY FOR
*        THIS UPDATE
*
         MVC   PPITPTBL+68(32),PPITPTBL+102 UPDATED FIBS TO FUTURE FIBS
         LH    R4,WOJPERM          COUNT OF TIMES TO PERMUTE THIS SET
         BCT   R4,OJPERMUT         BRANCH IF FUTURE FIBS NEED PERMUTING
         MVC   WOJPERM(2),WOJCTN1  RESET PERMUTING COUNTER TO (N-1)
         B     OJRESET             BRANCH TO RESET TAPE TABLE POINTER
*
OJPERMUT STH   R4,WOJPERM          SAVE PERMUTING COUNTER
         MVC   OJMOVER+1(1),WOJINCPT+1  SET LENGTH FIELD IN MOVE INST
*                                       TO MOVE (N-1) FIB NUMBERS
OJPERONE LH    R7,WOJINCPT         INCREMENT TO LAST ITEMS IN TABLE
         LH    R5,PPITPTBL+68(R7)  LAST OF FUTURE FIBONACCI NUMBERS
         MVC   PPIWKARE+1(32),PPITPTBL+68  SAVE THE UNPERMUTED FUTURE
*                                          FIBS THIS IS DONE TO AVOID
*                                          MOVING OVERLAPPING FIELDS
OJMOVER  MVC   PPITPTBL+69(1),PPIWKARE  MOVE 1ST (N-1) FUTURE FIBS BACK
*                                       TO TABLE,SHIFTED BY 1 POSITION
         STH   R5,PPITPTBL+68      LAST OF FUTURE FIB AS 1ST FUTURE FIB
         BCT   R4,OJPERONE         BRANCH TO PERMUTE ONE MORE POSITION
         B     OJRESET
*
*        SAVE COUNT OF SEQUENCES TO DISTRIBUTE
*
OJNOUPDT ST    R5,WOJTOTAL         SAVE COUNT OF SEQS TO DISTRIBUTE
*
*        DETERMINE NEXT UNIT TO GET A SEQUENCE
*
OJBACK1  LTR   R4,R4               TAPE TABLE POINTER ZERO ?
         BZ    OJRESET             YES, BRANCH
         LA    R5,2                CONSTANT OF 2
         SR    R4,R5               DEC TAPE TABLE POINTER 1 POSITION
         B     OJSTPT
*
OJRESET  LH    R4,WOJINCPT         RESET TAPE TABLE POINTER TO LAST POS
OJSTPT   STH   R4,WOJPOINT         SAVE TAPE TABLE POINTER
         LH    R5,PPITPTBL+34(R4)  COUNT OF SEQUENCES ON THIS TAPE
         LH    R6,PPITPTBL+68(R4)  FUTURE COUNT OF SEQUENCES FOR TAPE
         CLR   R5,R6               COMPARE THE COUNTS
         BE    OJBACK1             DEC POSITION IN TAPE TABLE IF EQUAL
*
*        DETERMINE THE MUNBER OF UNITS THAT STILL REQUIRE
*        SEQUENCES THIS PASS OF THE TAPE TABLE
*
         SR    R5,R5               ZERO REG
         LA    R6,2(,R4)           SAVE TP TBL POINTER+2 AS INC
OJDEC1   LA    R7,2                CONSTANT OF 2
         SR    R6,R7               DECREMENT TAPE TABLE POINTER ONE POS
         LH    R8,PPITPTBL+34(R6)  COUNT OF SEQUENCES ON THIS TAPE
         LH    R9,PPITPTBL+68(R6)  FUTURE COUNT OF SEQS FOR THIS TAPE
         CLR   R8,R9               COMPARE THE COUNTS
         BE    OJCKLAST            EQUAL, DO NOT INC COUNTER
         LA    R5,1(,R5)           INCREMENT COUNTER BY 1
OJCKLAST LTR   R6,R6               TAPE TABLE POINTER ZERO ?
         BNZ   OJDEC1              NOT ZERO, CONTINUE CHECKING
*
*        SET OUTPUT UNIT INDICATOR IN PPIA
*
         IC    R6,PPITPTBL+1(R4)   OUTPUT UNIT DESIGNATOR
         STC   R6,PPIDEPHO+3       SET OUTPUT UNIT DESIGNATOR FOR WRITE
*
*        CHECK COUNT OF TAPES THAT STILL REQUIRE SEQUENCES THIS
*        PASS OF TAPE TABLE AND PROCEED ACCORDINGLY
*
         BCT   R5,OJDEBLCK         CHECK COUNTER
         L     R11,PPINET+4
*
*        EXIT TO REPLACEMENT NETWORK TO REVERSE THE SEQUENCE
*        AFTER THIS
*
         B     20(,R11)            REVERSE THE NEXT SEQUENCE
*
OJDEBLCK L     R11,PPIDEB+4
*
*        EXIT TO DEBLOCK ROUTINE (NO REVERSAL OF SEQUENCES
*        NECESSARY)
*
         B     8(,R11)             DEBLOCK A RECORD
*
*        ENTRY FROM WRITE ROUTINE AT EOV
*
OJEOV    L     R10,PPIRMA+4        R10 -> IERRMA
         L     R1,IER046
         MVC   PPIABMNO,3(R1)      MOVE MSG NO INTO ABEND CODE
         LM    R0,R1,IER046        IER046A SORT CAPACITY EXCEEDED
         L     R15,PPIADSSC        R15 -> MSG PRINT ROUTINE
         BAS   R14,12(,R15)        EXIT TO SSC TO PRINT ERROR MESSAGE
*
*        APROX RCD CNT IS PPICOUNT -G - B, WHERE G AND B ARE MAX
*        VALUES
*        IF CNT TURNS NEGATIVE, CNT IS SET TO PPICOUNT-G+B OR
*        JUST B
*        THIS NEGATIVE CONDITION IS MOST LIKELY IF THE BLOCK
*        BEING WRITTEN OUT IS SHORT AND/OR RECORD FORMAT IS
*        VARIABLE
*
         L     R1,PPICOUNT         NO RCD READ IN MINUS G
         A     R1,PPIINSCT         ADD NO OF INSERTED RECORDS
         S     R1,PPIDELCT         SUBTRACT NO DELETED RECORDS
         S     R1,PPISRTG          G - MAX NO OF RCDS IN TREE
         LH    R15,PPISRTBL        B - F = NO RCDS/BLOCK
         PPITEST  PPIFIX               V = BYTES/BLOCK
         BO    ROI031
         LH    R0,PPIRCDL4         B / MIN RCD LENGTH = MAX NO
         SR    R14,R14
         DR    R14,R0              RCDS IN BLOCK
ROI031   CR    R1,R15              CHECK TO MAKE SURE CNT ISN'T
         BH    ROI032              NEGATIVE
         AR    R1,R15              ADD B TO CNT
         CR    R1,R15              CNT STILL NEG ? YES,
         BNL   ROI033
         LR    R1,R15              SET CNT TO B
         B     ROI033
*
ROI032   SR    R1,R15              APROX RCD CNT = PPICOUNT -G -B
ROI033   CVD   R1,PPIWKARE
         L     R14,PPIRMA+4        R14 -> IERRMA
         ED    IER066A,PPIWKARE+4  FORMAT DATA
         LM    R0,R1,IER066
         L     R15,PPIADSSC        R15 -> PRT MSG RTN
         BAS   R14,12(,R15)        CALL PRINT MSG
         L     R15,PPIADSSC        SSC BASE REGISTER
         BAS   R14,16(,R15)        EXIT TO SSC TO TERMINATE THE SORT
*
*        ENTRY FROM WRITE ROUTINE AT EOF
*
*        INCREMENT COUNT OF SEQUENCES ON THIS UNIT
*
OJEOF    LH    R4,WOJPOINT         TAPE TABLE POINTER(INC WITHIN TABLE)
         LH    R5,PPITPTBL+34(R4)  SEQUENCE COUNTER FOR THIS UNIT
         LA    R5,1(,R5)           INCREMENT COUNTER BY ONE
         STH   R5,PPITPTBL+34(R4)  RESTORE SEQUENCE COUNTER
*
*        SET OPEN BIT ON IN LAST UNIT IN TAPE TABLE
*
         LH    R4,WOJINCPT         INCREMENT TO LAST POSITIONS IN TABLE
         LA    R5,PPITPTBL+2(R4)   ADDR OF BYTE IN TAPE TABLE FOR BIT
         OI    0(R5),X'40'         SET OPEN BIT ON
*
*        TURN OFF OPEN BITS IN FIRST (N-1) UNITS IN TAPE TABLE
*        THAT DID NOT RECEIVE SEQUENCES
*
         LH    R5,WOJCTN1          COUNT OF (N-1)
         LA    R6,PPITPTBL         ADDRESS OF TAPE TABLE
OJMOROFF SR    R7,R7               ZERO THE REGISTER
         SH    R7,34(,R6)          FIRST SEQUENCE COUNTER
         BNE   OJLEAVON            IF NOT ZERO LEAVE OPEN BIT ON
         NI    0(R6),X'BF'         TURN OPEN BIT OFF
OJLEAVON LA    R6,2(,R6)           INCREMENT TO NEXT TABLE POSITION
         BCT   R5,OJMOROFF         BRANCH IF MORE COUNTERS TO CHECK
*
*        SET UP COUNTERS FOR DUMMY SEQUENCES AS NECESSARY FOR
*        PHASE 2 IF FIBONACCI LEVEL IS ALL ONES GOTO NEXT LEVEL
*        BEFORE SETTING DUMMYS
*
         LA    R5,2                CONSTANT OF 2
         LA    R6,1                CONSTANT OF 1
         SH    R6,PPITPTBL+68      FIRST OF FUTURE FIBS
         BNE   OJNOTONE            BRANCH IF COUNT WAS NOT ONE
         LH    R7,WOJCTN2          COUNT OF (N-2)
         LA    R6,PPITPTBL+68      ADDRESS OF FIRST FUTURE FIB
OJSETTWO STH   R5,0(,R6)           SET FUTURE FIB TO TWO
         LA    R6,2(,R6)           INCREMENT TO NEXT FUTURE FIB
         BCT   R7,OJSETTWO         BRANCH IF MORE FIBS TO BE UPDATED
OJNOTONE LH    R6,WOJCTN1          COUNT OF (N-1)
OJMORDUM LH    R7,PPITPTBL+68(R4)  LAST OF FUTURE FIBONACCI NUMBERS,ETC
         SH    R7,PPITPTBL+34(R4)  COUNT OF SEQUENCES ALREADY ON UNIT
         STH   R7,PPITPTBL+68(R4)  COUNT OF DUMMYS FOR THIS UNIT
         SR    R4,R5               DECREMENT INCREMENT POINTER BY 1 POS
         BCT   R6,OJMORDUM         BRANCH IF MORE DUMMYS TO CALCULATE
*
*        REVERSE SEQUENCE INDICATOR BIT AND EXIT TO CLOSE ROUTINE
*        WHICH WILL PRINT A MESSAGE AND EXIT TO SSC TO CALL
*        PHASE 2
*
         PPIFLIP  PPIPH1CO         REVERSE SEQUENCE INDICATOR BIT
         L     R15,PPIADSSC
         LA    R1,0                RETURN TO SSC REQUESTING PHASE 2
         BAS   R14,20(,R15)
*
*        WORK AREAS
*
WOJCTN   DC    H'0'                COUNT OF N
WOJCTN1  DC    H'0'                COUNT OF (N-1)
WOJCTN2  DC    H'0'                COUNT OF (N-2)
WOJALODD DC    H'0'                ALL ODD COUNTER (INITIALLY N)
WOJPERM  DC    H'0'                PERMUTE COUNTER (INITIALLY N-1)
WOJPOINT DC    H'0'                TAPE TABLE POINTER (INCREMENT)
WOJINCPT DC    H'0'                INCREMENT TO LAST ITEMS IN TABLE
WOJTOTAL DC    F'0'                COUNT OF SEQUENCES TO DISTRIBUTE
*
./ ADD NAME=IERROK   0101-20211-20211-1200-00086-00086-00000-RELEASE 00
         TITLE 'IERROK - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERROK
*
*        MODULE FUNCTION/OPERATION -
*        SORT PHASE BALN DISK ALGORITHM
*        THE FUNCTION OF THIS MODULE IS TO CONTROL (VIA A TABLE)
*        WHERE TO WRITE THE NEXT STRING OF SEQUENCED DATA IN DISK
*        AREAS. IT CHECKS FOR END OF AREAS, IF NMAX IS EXCEEDED
*        AND ACTS AS AN AREA MANAGER FOR THE WRITE ROUTINE. IT
*        DETERMINES IF PASSES OF PHASE 2 IS NEEDED AND MAY
*        TERMINATE FOR CERTAIN UNUSUAL CONDITIONS
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM IERRPB (WRITE)
*                       CALLING SEQUENCE -
*                           L     R11,PPIALG+4
*                           B     DISP(,R11)
*                                 DISP = 0 FOR END OF FILE
*                                      = 4 FOR EOA & NOT EOS
*                                      = 8 FOR END OF AREA & EOS
*                                      =12 FOR END OF SEQUENCE
*
*                       ENTRY FROM IERRPB (WRITE)
*                       CALLING SEQUENCE -
*                           L     R11,PPIALG+4
*                           BR    R14 (RETURN ON WRITING
*                                       DIRECTORY)
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIWRT   PPIADSSC   PPIMRGMX   PPIPDWA
*        PPIDEB   PPIDSKED   PPINDSKA
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPIBDSVA   PPIDIRAD   PPIMRGOP   PPIDEPHO
*        PPIENDAR
*
*        EXTERNAL ROUTINES -
*        EXTRN IERRCV - SORT SYSTEM CONTROL
*        EXTRN IERRPB - WRITE ROUTINE
*        EXTRN IERDD1 - DEBLOCK MODULE
*
*        EXTERNAL PARAMETERS - EXTRN IERRMA - MESSAGE MODULE
*
*        EXITS NORMAL - IERRCV - SORT SYSTEM CONTROL
*
*        EXITS - ERROR - IERRCV - SORT SYSTEM CONTROL
*
*        TABLES/WORK AREAS -
*        TABLE IS USED TO CONTROL AREAS
*
*        NOTES -
*        ROUTINE OPERATES IN A MANNER ANALOGOUS TO A BALANCED
*        TAPE ALGORITHM WITH A MINIMUM OF 3 AREAS (WORK TAPES)
*        AND A MAXIMUM OF 6
*
IERROK   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERROK SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERROKI
*
*
DIERRMA  DSECT
*
*        MODULE NAME - IERRMA
*
*        THIS MODULE CONTAINS ALL OF THE MESSAGES THAT ARE
*        REQUIRED FOR PHASE 1 RUNNING PROGRAM
*
         COPY  RMAMAIN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERROKI  0101-20211-20211-1200-00374-00374-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERROK SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERROKI
*
         USING *,R11               SET BASE
         USING IERRCA,R13
         USING DIERRMA,R14
*
IERDOK   B     ROKEOF            * +00 OUTPUT END OF FILE
         B     ROKEOA            | +04 END OF AREA, DETERMINED BY WRITE
         B     ROKEOASQ          | +08 END OF AREA + SEQ, DET BY WRITE
ROKEOSQ  L     R4,WPOINT         V +12 END OF SEQUENCE
*                                  R4 -> CURRENT TABLE ENTRY
         L     R5,0(,R4)           GET AREA KEY(EG 0, 1, 2, 3, OR 4)
*                                  FROM TABLE ENTRY
         AR    R5,R5               CALC DISP (AREA KEY X CTR SIZE)
         LH    R7,PPISEQCT(R5)     GET SEQUENCE COUNTER
         LA    R7,1(,R7)           INCR CTR
         STH   R7,PPISEQCT(R5)     STORE CTR BACK IN PPI
*
*        DECR BLK COUNTER - BLOCK OF ADDR FILLED
*
         L     R4,WBLKCT           R4 = DICT BLK CTR
*                                  DECR BLK CTR
         BCT   R4,ROKDRBLK         BLK FILLED ?
*
*        SAVE ADDR IN TABLE PUT DICT ADDR IN PPI
*        MOVE DICT BLOCK TO PPI
*        WRITE DICT BLOCK OF ADDR
*
         L     R4,WPOINT           R4 -> CURRENT TABLE ENTRY
         MVC   4(8,R4),PPIDEPHO    SAVE NEXT SEQ IN TABLE
         MVC   PPIDIRAD,12(R4)     MOVE NEXT DICT BLOCK ADDR INTO PPI
         MVC   PPIPDWA,WCLBKAR     COPY DICT BLK AREA TO PPI
         L     R11,PPIWRT+4
         BAS   R14,12(,R11)
*
*        RESET DICT BLK CTR TO 8
*
         LA    R4,8                RESET BLK CTR TO 8
         ST    R4,WBLKCT
*
*        DICTIONARY TRACK FILLED ?
*
         L     R6,WPOINT           R6 -> CURRENT TABLE ENTRY
*                                  COMPARE R WITH MAX DICT RECORDS PER
*                                  TRACK
         CLC   19(1,R6),PPIDIRBK+1  TRACK FULL ?
         BNE   ROKSMTK             NO, BRANCH
*
*        TRACK IS FILLED
*        GET PROPER END ADDR IN PPI
*
         L     R7,0(,R6)           R7 = TABLE ENTRY NO FROM CURR ENTRY
         SLL   R7,3                MULT BY 8 TO GET PPIENDAR OFFSET
         LA    R8,PPIENDAR(R7)     R8 -> END ADDR ENTRY IN PPI
*
*        ANOTHER TRACK AVAILABLE ?
*        COMPARE TT FIELDS
         CLC   5(2,R8),PPIDEPHO+5  SEQ AREA REACHED END ADDR IN PPI ?
         BNH   ROKNOTRK            YES, NO TRACKS AVAILABLE
*
*        RESET RCD COUNT FOR NEXT WRITE OF DICT (IN TBL) = 1
*
         MVI   19(R6),X'01'        SET R = 1
*
*        SUPPLY TABLE (NEW DICT ADDR) USING ENDAR IN PPI AND
*        ADDING 1 TRACK TO IT SO AS TO LEAVE THE 1 TRACK BUFFER
*        ALWAYS OPEN (AT ASSIGNMENT TIME THE REAL ENDAR IS PUSHED
*        BACK BY 2 TRACKS) SO NOW BY USING ENDAR AND ADDING 1
*        TRACK, POSITIONED READY TO WRITE THE NEXT OPEN TRACK OF
*        DIRECTORY EG
*        TRK  8 = LAST TRACK FOR STRINGS
*        TRK  9 = EOF BUFFER
*        TRK 10 = DIRECTORY
*        WHEN TRK 10 IS FULL, ALL 3 TRACKS SHIFT DOWN 1 IN THE
*        FOLLOWING MANNER -
*        1. DIRECTORY ADDR (IN TABLE) IS REDUCED 1 TRACK BY
*           ADDING 1 TRACK TO THE ENDAR IN PPI (SINCE IT IS
*           ALREADY 2 TRACKS AWAY FROM THE DIRECTORY TRACK JUST
*           FILLED) AND CLOBBERING OLD DIRECTORY ADDR IN TABLE TO
*           PROVIDE A NEW (THE NEXT OPEN) TRACK TO WRITE
*           DIRECTORY IN
*        2  THEN THE ENDAR IS REDUCED BY 1 TRACK SO THAT
*           PRIOR TO THE FIRST WRITE IN THE NEW DICT TRACK (USING
*           ABOVE EXP) THE TRACKS ARE ASSIGNED -
*           TRK 7 = LAST TRACK FOR STRINGS (ENDAR)
*           TRK 8 = EOF BUFFER
*           TRK 9 = NEW EMPTY DIRECTORY TRK
*           TRK 10 = OLD FILLED DICT TRK USING ADDR AT ENDAR
*           ADD 1 TO HEAD NO AND PLUG INTO TABLE (NEW DIRECTORY)
*
         SR    R7,R7               CLEAR REG
         ICM   R7,B'0011',5(R8)    GET TT FROM PPI (ENDAR)
         LA    R7,1(,R7)           ADD 1
         STCM  R7,B'0011',17(R6)   STORE TT IN TABLE (NEW DICT)
*
*        DECR ENDAR BY 1 TRACK
*
         ICM   R7,B'0011',5(R8)    GET TT
         BCT   R7,ROKBACK          REDUCE BY 1
         B     ROKTERM             SORT CAPACITY REACHED - TERM JOB
*
ROKBACK  STCM  R7,B'0011',5(R8)    STORE TT TO ENDAR IN PPI
         B     ROKGOB              GO INCR TABLE PTR
*
*
*        DICTIONARY TRACK NOT FULL
*        INCR RECORD COUNT FOR NEXT WRITE ON SAME TRACK (IN TABLE)
*
ROKSMTK  IC    R7,19(,R6)          R7 = R
         LA    R7,1(,R7)
         STC   R7,19(,R6)
         B     ROKGOB              GOTO INCREMENT TABLE PTR
*
*        BLOCK THE NEXT SEQ ADDR PASSED BY WRITE
*
ROKDRBLK ST    R4,WBLKCT           STORE UPDATED DICT BLK CTR
         LA    R5,8                CALC DISP TO REACH PROPER ADDR IN
         SR    R5,R4               DICT BLOCK, TO FILL NEXT BLOCK
         SLL   R5,3                MLTPY TIMES ADDR SIZE (8)
         LA    R6,WCLBKAR          GET STRT PTR OF DICT BLK AREA
         AR    R6,R5               DETERMINE WHERE TO INSERT NEXT SEQ
*                                  ADDR IN BLOCK OF DIRECTORY
         MVC   0(8,R6),PPIDEPHO    INSERT ADDR
*
*        DEBLOCK
*
ROKDEBL  L     R11,PPIDEB+4        SET BASE REGISTER TO DEBLOCK ST PTR
         B     8(,R11)             GOTO DEBLOCK
*
*        INCREMENT TABLE POINTER
*
ROKGOB   L     R4,WPOINT           R4 -> CURRENT TABLE ENTRY
         LA    R4,20(,R4)          INCR TABLE POINTER
         ST    R4,WPOINT           STORE UPDATED PTR
*
*        C4 EXCEED LIMIT OF TABLE ?
*
         CL    R4,WTBLLIMT         AT END OF TABLE ?
         BE    ROKSETPT            YES, GO RESET POINTER
*
*        STORE ADDR OF WHERE TO RECORD FIRST OF NEXT SEQUENCES
*
ROKNXT1  L     R4,WPOINT
         MVC   PPIDEPHO,4(R4)      STORE ADDR OF WHERE TO WRITE NEXT
*                                  SEQUENCE INTO PPI
*
*        BLOCK ADDR OF FIRST SEQUENCE
*
         MVC   WCLBKAR(8),4(R4)
*
*        DICT BLOCK
*        IS SWITCH ON ?
*
         TM    KSWA7E4,X'01'       LAST WRITE HAVE ENOUGH AREA ?
         BO    ROKDEBL             YES, SW IS ON
*                                  GET NEXT SQ FROM DEBLK RTN
*        TURN SWITCH ON
*
         OI    KSWA7E4,X'01'       NO, TURN ON SW
*                                  WRITE SEQ IN NEXT AREA
*        GOTO WRITE
*
         L     R11,PPIWRT+4
         BR    R11                 LINK TO BLOCK AFTER WRITE DIRECTORY
*
*        SET POINTER TO FIRST ENTRY IN TABLE
*
ROKSETPT LA    R6,TABLE            SET POINTER TO FIRST ENTRY
         ST    R6,WPOINT           IN TABLE
         B     ROKNXT1             GO BACK TO MAIN FLOW
*
*        OUTPUT END OF FILE
*
*        UPDATE COUNTER OF SEQUENCES FOR CURRENT AREA
*
ROKEOF   L     R4,WPOINT           R4 -> CURRENT TABLE ENTRY
         L     R5,0(,R4)           GET AREA KEY(EG 0, 1, 2, 3, OR 4)
         AR    R5,R5               CALC DISP IN CTR AREA IN PPI
         LH    R7,PPISEQCT(R5)     GET SEQUENCE COUNTER
         LA    R7,1(,R7)           INCR CTR
         STH   R7,PPISEQCT(R5)     STORE SEQUENCE COUNTER
*
*        PUT DIRECTORY ADDR INTO PPI
*
         MVC   PPIDIRAD,12(R4)
*
*        MOVE BLK AREA TO PPI
*
         MVC   PPIPDWA,WCLBKAR
*
*        GO WRITE BLOCK OF DICT ADDR
*
         L     R11,PPIWRT+4
         BAS   R14,12(,R11)        CALL WRITE BLK OF DICT ADDR
*
*        SUM SEQUENCE COUNTERS
*
         LH    R8,PPINDSKA         R8 = NO OF SORKWORK AREAS
         LA    R6,PPISEQCT
         SR    R4,R4               ZERO TOTALS REGS
ROKLOOPD AH    R4,0(,R6)           GET DATA IN PPISEQCT
         LA    R6,2(,R6)           BUMP TO NEXT PPISEQCT ENTRY
         BCT   R8,ROKLOOPD         ADDED ALL CTRS ? NO,LOOP
*
*        RESTORE END ADDR TO PPI FROM PPI SAVE AREA
*
         MVC   PPIENDAR(48),PPIDSKED
         LH    R7,PPIMRGMX
         LA    R7,1(,R7)           PLUS ONE
         STC   R7,PPIBDSVA
*
*        SUM VS M
*
         CH    R4,PPIMRGMX         COMPARE TOTAL OF PPISEQCT CTRS WITH
*                                  MAXIMUM MERGE ORDER
         BH    ROKGOF              TOTAL PPISEQCT CTRS GREATER, BRANCH
         STH   R4,PPIMRGOP         STORE LOWER VALUE
*
*        SET INDICATOR TO PHASE 3
*
         LA    R1,4                SET CODE OF 4
         L     R15,PPIADSSC        R15 -> SSC
         BAS   R14,20(,R15)        RETURN TO SSC CALLING FOR PHASE 3
*
*        CLOSE ROUTINE
*
ROKGOF   SR    R1,R1               SET CODE OF ZERO
         L     R15,PPIADSSC        R15 -> SSC
         BAS   R14,20(,R15)        RETURN TO SSC CALLING FOR PHASE 2
*
*        END OF AREA AS DETERMINED BY WRITE ROUTINE
*
*        TURN SWITCH A7-E4 OFF
*
ROKEOA   NI    KSWA7E4,X'00'
*
*        UPDATE COUNT OF SEQUENCES FOR CURRENT AREA
*
ROKEOASQ L     R4,WPOINT           R4 -> CURRENT TABLE ENTRY
         L     R5,0(,R4)
         AR    R5,R5
         LH    R7,PPISEQCT(R5)
         LA    R7,1(,R7)
         STH   R7,PPISEQCT(R5)
*
*        PUT DIRECTORY ADDR INTO PPI
*
         MVC   PPIDIRAD,12(R4)
*
*        MOVE BLK AREA TO PPI
*
         MVC   PPIPDWA,WCLBKAR
*
*        GOTO WRITE BLOCK OF DICT ADDR
*
         L     R11,PPIWRT+4
         BAS   R14,12(,R11)        GOTO WRITE BLK OF DICT ADDR
*
*        RESET DICT BLK CTR TO 8
*
         LA    R4,8
         ST    R4,WBLKCT
*
*        NO TRACKS AVAILABLE FOR DICTIONARY
*        LAST AREA ? CHECK LIMIT
*
ROKNOTRK LA    R4,TABLE+20         R4 -> SECOND ENTRY IN TABLE
         CL    R4,WTBLLIMT         COMPARE WITH LIMIT
         BE    ROKTERM             NO MORE AREAS, TERMINATE JOB
         B     ROKGOH              GO CHECK LIMIT OF SORT TABLE
*
*        SORT CAPACITY REACHED
*
ROKTERM  L     R14,PPIRMA+4
         L     R1,IER046
         MVC   PPIABMNO,3(R1)      MOVE MSG NO INTO ABEND CODE
         LM    R0,R1,IER046        IER046A SORT CAPACITY EXCEEDED
         L     R15,PPIADSSC        R15 -> PRINT MSG RTN
         BAS   R14,12(,R15)        CALL PRINT MSG RTN
*
*        APROX RCD CNT IS PPICOUNT -G - B, WHERE G AND B ARE MAX
*        VALUES
*        IF CNT TURNS NEGATIVE, CNT IS SET TO PPICOUNT-G+B OR
*        JUST B
*        THIS NEGATIVE CONDITION IS MOST LIKELY IF THE BLOCK
*        BEING WRITTEN OUT IS SHORT AND/OR RECORD FORMAT IS
*        VARIABLE
*
         L     R1,PPICOUNT         NO RCD READ IN MINUS G
         A     R1,PPIINSCT         ADD NO OF INSERTED RECORDS
         S     R1,PPIDELCT         SUBTRACT NO DELETED RECORDS
         S     R1,PPISRTG          G - MAX NO OF RCDS IN TREE
         LH    R15,PPISRTBL        B - F = NO RCDS/BLOCK
         PPITEST  PPIFIX               V = BYTES/BLOCK
         BO    ROI031              GO CHECK CNT FOR NEG
         LH    R0,PPIRCDL4         B / MIN RCD LENGTH = MAX NO
         SR    R14,R14
         DR    R14,R0              RCDS IN BLOCK
ROI031   CR    R1,R15              CHECK TO MAKE SURE CNT ISN'T
         BH    ROI032              NEGATIVE
         AR    R1,R15              ADD B TO CNT
         CR    R1,R15              CNT STILL NEG ? YES,
         BNL   ROI033              GOTO SET CNT FOR PRINTING
         LR    R1,R15              SET CNT TO B
         B     ROI033              GO TO SET CNT FOR PRINTING
*
ROI032   SR    R1,R15              APROX RCD CNT = PPICOUNT -G -B
ROI033   CVD   R1,PPIWKARE
         L     R14,PPIRMA+4
         ED    IER066A,PPIWKARE+4  FORMAT DATA
         LM    R0,R1,IER066        IER066A APPROXIMATE RECORD COUNT
         L     R15,PPIADSSC        R15 -> PRINT MSG ROUTINE
         BAS   R14,12(,R15)        CALL PRINT MSG RTN
         L     R15,PPIADSSC
         BAS   R14,16(,R15)        GOTO SSC, NO RETURN
*
*        LIMIT OF SORT TABLE ?
*
ROKGOH   L     R4,WPOINT           R4 -> CURRENT TABLE ENTRY
         LA    R6,20(,R4)          INCR TO NEXT ENTRY
         CL    R6,WTBLLIMT         EQUAL TO LIMIT ?
         BE    ROKRESET            YES, RESET POINTER TO BEG POS
*
*        PUT LIMIT PORTION OF SORT TABLE IN FILLED AREA'S POS
*
         L     R5,WTBLLIMT
         LA    R6,20
         SLR   R5,R6
         MVC   0(20,R4),0(R5)
*
*        DECR LIMIT OF SORT TABLE BY 1
*
ROKGOG   L     R5,WTBLLIMT
         LA    R4,20
         SLR   R5,R4
         ST    R5,WTBLLIMT
         B     ROKNXT1             GO TO ST ADDR OF WHERE TO WT NXT SEQ
*
*        RESET POINTER TO FIRST POS IN SORT TABLE
*
ROKRESET LA    R6,TABLE
         ST    R6,WPOINT
         B     ROKGOG              GOTO DECREMENT LIMIT OF SORT TABLE
*
WPOINT   DC    A(0)                -> ENTRY IN TABLE
WBLKCT   DC    F'8'                DIRECTORY BLK ENTRY COUNTER
WCLBKAR  DC    16F'0'              DICT BLOCKING AREA = 64 BYTES
WTBLLIMT DC    A(0)                TABLE LIMIT POINTER (SET BY IERAOK)
*
TABLE    DC    F'0'                TABLE - FIRST AREA
         DC    2F'0'               START ADDR MBBCCHHR  (TT)
         DC    2F'0'               END ADDR   MBBCCHHR  (TT)
         DC    F'1'
         DC    2F'0'               START ADDR
         DC    2F'0'               END ADDR
         DC    F'2'
         DC    2F'0'               START ADDR
         DC    2F'0'               END ADDR
         DC    F'3'
         DC    2F'0'               START ADDR
         DC    2F'0'               END ADDR
         DC    F'4'
         DC    2F'0'               START ADDR
         DC    2F'0'               END ADDR
*
KSWA7E4  DC    X'01'               SWITCH A7 - E4 NORMALLY ON
*
./ ADD NAME=IERRON   0101-20211-20211-1200-00135-00135-00000-RELEASE 00
RON      TITLE 'IERRON - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRON
*
*        MODULE FUNCTION/OPERATION -
*        OSCILLATING ALGORITHM
*        THE OSCILLATING ALGORITHM MAINTAINS CONTROL OF THE
*        DISTRIBUTION OF SEQUENCES FOR THE OSCILLATING PHASE OF
*        AN OSCILLATING SORT. IT DETERMINES WHEN THE SORT PORTION
*        MUST BE EXECUTED TO PRODUCE ANOTHER SEQUENCE AND WHEN A
*        MERGE PASS IS NECESSARY TO MERGE SEQUENCES TOGETHER. IT
*        DETERMINES WHICH UNIT IS TO RECEIVE THE NEXT SEQUENCE
*        FOR ANY GIVEN LEVEL, WHICH UNITS ARE INPUT TO A PASS,
*        WHAT THE MERGE ORDER IS, AND WHAT THE COLLATING ORDER
*        IS. IT ALSO RESOLVES RECORD COUNTS AFTER EACH PASS TO BE
*        SURE NO RECORDS ARE LOST. AT RMAX TIME IT OPTIMIZES
*        MERGING OF EXISTING SEQUENCES ONTO A SINGLE UNIT AND
*        PREPARES TO REINITIALIZE AND RESTART THE SORTING
*        PROCESS. AT EOF TIME IT OPTIMIZES MERGING OF EXISTING
*        SEQUENCES, DETERMINES WHAT ORDER THE FINAL MERGE PHASE
*        WILL USE IN READING THE SEQUENCES, AND POSITIONS ALL
*        TAPE UNITS SO THEY CAN BE MADE READY FOR THE FINAL MERGE
*        PHASE
*
*        MODULE IN WHCIH THIS MODULE APPEARS AS A DSECT - IERAON
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - IERRON    - FROM WRITE ON FINAL EOS
*                                   FROM SORT PHASE
*                                   CALLING SEQUENCE -
*                                       L    R11,PPIALG+4
*                                       BR   R11
*
*                     - IERRON+4  - FROM WRITE ON EOV
*                                   CALLING SEQUENCE -
*                                       L    R11,PPIALG+4
*                                       B    4(,R11)
*
*                     - IERRON+8  - FROM WRITE ON EOV, EOS
*                                   CALLING SEQUENCE
*                                       L    R11,PPIALG+4
*                                       B    8(,R11)
*
*                     - IERRON+12 - FROM WRITE ON NORMAL EOS OR
*                                   FROM INIT OF MERGE NET
*                                   CALLING SEQUENCE
*                                       L    R11,PPIALG+4
*                                       B    12(,R11)
*
*        INPUT - PPI FIELDS REFERENCE -
*        PPIBDSVA   PPICOUNT   PPIDEB   PPIDELCT
*        PPIDEPHO   PPIINSCT   PPIINT   PPIMRGMX
*        PPIODOM    PPIRD      PPIRMB   PPICNTL
*        PPITPTBL   PPIUNTCT
*
*        INFORMATION AS MAINTAINED BY ALGORITHM IN SEQUENCE
*        DISTRIBUTION TABLE
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPIDEPHO   PPITPTBL   PPIMRGMX   PPICNTL
*
*        EXTERNAL ROUTINES -
*        IERAMB - MESSAGE MODULE
*        IERRCV - PRINT MESSAGES
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL - INITIALIZATION ROUTINE
*                         DISP=0  SET UP EQUALS ROUTINE FOR MERGE
*                                 TAKEN WHEN CONTROL IS SWITCHED
*                                 FROM SORT TO MERGE PHASE
*                         DISP=8  FORCE FLUSHING OF TREE TAKEN
*                                 AFTER M-1 SEQUENCES HAVE
*                                 BEEN OUTPUTED BY THE SORT PHASE
*                         DISP=4  RESET REPLACEMENT SO SORT PHASE
*                                 CAN BE EXECUTED AGAIN, TAKEN
*                                 WHEN CONTROL IS PASSED FROM
*                                 MERGE TO SORT PHASE
*                       - DEBLOCK ROUTINE
*                         DISP=8  FOR SORT PHASE TO PRODUCE
*                                 ANOTHER SEQUENCE
*                       - READ PRIMING ROUTINE
*                         DISP=4  PRIME INPUT BUFFERS FOR MERGE PASS
*                       - SORT SYSTEM CONTROL
*                         DISP=20 END OF PHASE
*
*        EXITS - ERROR - SORT SYSTEM CONTROL
*                        DISP=12 PRINT MESSAGE
*                        DISP=16 TERMINATE JOB
*
*        TABLES/WORK AREAS -
*        PPITPTBL
*        PPIODOM
*        SEQUENCE DISTRIBUTION TABLE - IN GENERATED CORE
*        WREGSAVE - REGISTER SAVE AREA
*
*        NOTES -
*        THIS MODULE IS USED ONLY IF THE OSCILLATING SORT
*        TECHNIQUE IS SELECTED. THIS TECHNIQUE APPLIES ONLY TO
*        TAPE OPERATION
*
IERRON   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRON SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRONI
*
*        IERRMB
*
IERRMB   DSECT
*
         COPY  RMBMAIN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
*        DCB
*
         PRINT NOGEN
*
         DCBD  DSORG=(PS),DEVD=(TA)
*
         PRINT GEN
*
         SMPPI
*
         END
./ ADD NAME=IERRONI  0101-20211-20211-1200-00808-00808-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERRON SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERRONI
*
         USING *,R11               MODULE BASE REGISTER
         USING IERRCA,R13          PPI BASE REGISTER
         USING IERRMB,R6           MESSAGE MODULE BASE REGISTER
*
         B     RON030              +00 WRITE ON FINAL EOS FROM
*                                      SORT PHASE
         B     RON150              +04 WRITE ON EOV
         B     RON150              +08 WRITE ON EOV, EOS
RON010   STM   R0,R15,WREGSAVE     +12 WRITE ON NORMAL EOS OR
*                                      FROM INITIAL OF MERGE NETWORK
         LM    R4,R8,KATPTBL       R4 -> TAPE TABLE
*                                  R5 -> SEQ DISTRIBUTION TABLE
*                                  R6 -> ODOMETER TABLE
*                                  R7 -> LEVEL MASK TABLE
*                                  R8 =  LEVEL
         SR    R9,R9               R9 =  INCREMENT FOR OUTPUT UNIT
         IC    R9,PPIDEPHO+3
*
*        UPDATE POINTERS TO REFLECT CURRENT LEVEL AND UNIT
*
         SLL   R8,1                R7 + LEVEL*2 = ADDR OF MASK FOR
         AR    R7,R8                              THIS LEVEL
         SLL   R8,1                R6 + LEVEL*4 = ADDR OF ODOMETER
         AR    R6,R8                              ENTRY FOR THIS LEVEL
         SH    R9,K4               R5 + (INCR-4) = ADDR OF SEQ DISTR
         AR    R5,R9                          TABLE ENTRY FOR THIS UNIT
         SRL   R9,1                R4 + ((INCR-4) / 2) = ADDR OF TAPE
         AR    R4,R9                          TABLE ENTRY FOR THIS UNIT
*
*        UPDATE TABLES TO REFLECT SEQUENCE WHICH HAS JUST BEEN
*        WRITTEN
*
         OC    0(2,R5),0(R7)       SET BIT IN SEQ DISTR TABLE TO SHOW
*                                  SEQUENCE PRESENT
         LH    R1,2(,R5)           INCREMENT UNIT TOTAL BY 1
         LA    R1,1(,R1)
         STH   R1,2(,R5)
RON015   PPITEST  PPIPH2           SORT OR MERGE PORTION IN CONTROL ?
         BO    RON040              MERGE, BRANCH
*
*        SORT PORTION IS IN CONTROL
*        PREPARE TO OUTPUT ANOTHER SEQUENCE FROM THE SORT PHASE
*
         BAS   R14,RONSUB2         SUBROUTINE 2 - SET LEVEL ODOMETER TO
*                                  NEXT UNIT
         L     R1,0(,R6)
         MVC   PPIDEPHO+3(1),1(R1)  SET DEPHO TO INDICATE NEXT OUTPUT
*                                  UNIT INCREMENT
         CLC   0(1,R6),KMRG1+1     LEVEL TOTAL = MERGE ORDER - 1 ?
         BNL   RON020              M SEQUENCE COMING UP, TIME
*                                  TO FLUSH THE TREE
         LM    R0,R15,WREGSAVE     RESTORE REGS
         L     R11,PPIDEB+4        LESS, GET ANOTHER SEQUENCE FROM SORT
         B     8(,R11)             EXIT TO DEBLOCK NORMAL
*
RON020   LM    R0,R15,WREGSAVE     RESTORE REGS
         L     R11,PPIINT+4        OVERLAY REPLACEMENT TO FORCE FLUSH
         B     8(,R11)             UPON FIRST RECORD OF NEW SEQUENCE
*
*        FINAL EOS FROM SORT PHASE
*        EOF, RMAX, OR PSEUDO EOF AFTER M SEQUENCE HAS OCCURED
*
RON030   PPIFLIP  PPIPH1+PPIPH2    SET PH2 BIT=1, PH1 BIT = 0
         PPITEST  PPIEQUAL         EQUALS ACTIVE ?
         BZ    RON010              NO, CONTINUE
         L     R11,PPIINT+4        YES, EXIT TO INITIALIZATION RTN TO
         BR    R11                 SET UP EQUALS RTN FOR MERGE
*
*        MERGE PHASE PORTION OF ALGORITHM
*
RON040   SR    R3,R3
         IC    R3,PPIBDSVA         SET OFF ALL INPUT BITS IN TAPE TABLE
         LA    R4,PPITPTBL
RON050   NI    0(R4),X'3F'         SET OFF OPEN BITS TOO
         LA    R4,2(,R4)           INCREMENT TO NEXT ENTRY IN TAPE TAB
         BCT   R3,RON050           CHECK NEXT ENTRY IN TABLE
*
*        RESOLVE RECORD COUNTS
*
         L     R1,PPIUNTCT
         LA    R1,4(,R1)
         IC    R3,PPIBDSVA
         SR    R2,R2               DETERMINE NO RCDS OUTPUT -
RON070   A     R2,0(,R1)           ACCUMULATE RECORD COUNTS FOR EACH
         LA    R1,4(,R1)           UNIT IN R2
         BCT   R3,RON070           CONTINUE ACCUMULATION
         L     R3,PPICOUNT         CALCULATE NO INPUT RECORDS TO SORT
         A     R3,PPIINSCT
         S     R3,PPIDELCT
         PPITEST  PPIPEOF          QSAM REACHED EOF ?
         BZ    RON075              NO
         PPITEST  PPIUEOF          YES, USER REACHED EOF ?
         BO    RON080              YES
         B     RON077              NO, QSAM IS AT EOF, USER IS NOT
*
RON075   BCTR  R3,0                SUBTRACT 1 FOR RCD HELD BACK TO
*                                  FORCE FLUSHING
         PPITEST  PPIUIIP          USER INSERT IN PROCESS ?
         BZ    RON080              NO, CONTINUE
RON077   BCTR  R3,0                YES, SUBTRACT 1 FOR RCD HELD BACK
*                                  TO ALLOW INSERT
RON080   CR    R2,R3               COMPARE RECORDS OUT TO RECORDS IN
         BNE   RON480              UNEQUAL, RECORD COUNT OFF
*
*        CHECK IF CHECKPOINT HAS BEEN REQUESTED
*        THE INSTRUCTION WILL BE MODIFIED BY AON IF CHECKPOINT
*        HAS BEEN INDICATED. THE NEW INSTRUCTION WILL BE A NOP
*
RON0200  B     RON0300
*
*        THE INSTRUCTION WILL BE MODIFIED WHENEVER IT IS TIME TO
*        TAKE A CHECKPOINT. THE NEW INSTRUCTION WILL BE A NOP
*
RON0100  B     RON0300
*
         MVI   RON0100+1,X'F0'     RESET THE CONDITION CODE
         L     R15,PPICHKAD        R15 -> CHECKPOINT MODULE
         BASR  R14,R15             CALL CHECKPOINT MODULE
*
*        NO RECORDS LOST
*        DETERMINE WHETHER IT IS TIME FOR A MERGE PASS
*
RON0300  BAS   R14,RONSUB2         SUBROUTINE 2 - SET LEVEL ODOMETER
*                                  TO NEXT UNIT
         PPITEST  PPIPEOF          QSAM DETECTED INPUT EOF ?
         BO    RON190              YES
RON085   PPITEST  PPIRMAXR         NO, RMAX BEEN REACHED ?
         BO    RON390              YES
         CLC   0(1,R6),KMRGMX+1    PRESENT LEVEL TOTAL = M ?
         BL    RON180              LESS, RETURN TO SORT PHASE
*
*        M SEQUENCES EXIST AT PRESENT LEVEL
*        PREPARE FOR A MERGE PASS
*
RON090   BAS   R14,RONSUB1         SUBROUTINE 1 - SET UP TABLES FOR
*                                  MERGE PASS
         L     R8,KLEVEL           INCREMENT PRESENT LEVEL BY ONE
         LA    R8,1(,R8)
         ST    R8,KLEVEL
         CH    R8,KMAXLEV          PRESENT LEVEL > MAX LEVEL REACHED
         BH    RON130              > MAXIMUM, BRANCH
RON095   LA    R6,PPIODOM
         SLL   R8,2
         AR    R6,R8               SET R6=ENTRY IN ODOMETER TABLE FOR
*                                  THIS LEVEL
RON100   LA    R7,TLEVMSK
         SRL   R8,1                SET R7=ENTRY IN LEVEL MASK TABLE FOR
         AR    R7,R8               THIS LEVEL
         SRL   R8,1
         ST    R8,KLEVEL
         L     R1,0(,R6)           SET PPIDEPHO TO INDICATE NEXT OUTPUT
         MVC   PPIDEPHO+3(1),1(R1)  UNIT INCREMENT
         MVC   PPIMRGMX(2),KMRG    SET MERGE ORDER IN PPI
RON110   LH    R2,0(,R7)           SET COLLATING SEQ FOR MERGE NETWORK
         N     R2,KSEQMSK          DETERMINE SEQ FOR PRESENT LEVEL
         BZ    RON170              RESULT IS 0, BRANCH
         PPISETON PPIPH1CO         RESULT IS 1, SET COLLATING BIT TO 1
RON120   LM    R0,R15,WREGSAVE     RESTORE REGS
         L     R11,PPIRD+4         NO EXIT TO READ PRIME FOR MERGE PASS
         B     4(,R11)             READ ROUTINE
*
RON130   STH   R8,KMAXLEV          SET NEW MAX LEVEL REACHED
RON131   MVI   RON0100+1,X'00'     READY FOR CHECKPOINT
*
*        THIS INSTRUCTION IS MODIFIED IF RMAX HAS BEEN REACHED
*        AND TAKING CHECKPOINTS. THE NEW INSTRUCTION BECOMES MVI
*        RON0100+1,X'F0'
*
         CH    R8,K15              MAX LEVEL > 15
         BNH   RON095              NO, CONTINUE WITH MERGE
*
*        PRINT MESSAGE AND TERMINATE JOB - SORT CAPACITY EXCEEDED
*
RON150   L     R6,PPIRMB+4
         L     R1,IER046           R1 -> MSG TEXT
         MVC   PPIABMNO,3(R1)      MOVE MSG NO INTO ABEND NO
         LM    R0,R1,IER046        IER046A SORT CAPACITY EXCEEDED
         L     R15,PPIADSSC        EXCEEDED
         BAS   R14,12(,R15)        CALL MSG WRITER
*
*        APROX RCD CNT IS SUM OF UNIT COUNTS - B, WHERE B IS A
*        MAX VALUE
*        IF CNT TURNS NEGATIVE, CNT IS SET TO B. THIS NEGATIVE
*        CONDITION IS MOST LIKELY IF THE BLOCK BEING WRITTEN OUT
*        IS SHORT AND/OR RECORD FORMAT IS VARIABLE
*
         L     R1,PPIUNTCT         ADDR OF UNIT COUNTERS - TABLE
         SR    R2,R2               CONTAINS NO OF RCDS PER DEVICE
         SR    R3,R3
         IC    R3,PPIBDSVA
RON155   LA    R1,4(,R1)
         A     R2,0(,R1)           SUM UNIT COUNTERS
         BCT   R3,RON155           CONTINUE ACCUMULATION
         LH    R15,PPISRTBL        B - F = RCDS/BLOCK
         PPITEST  PPIFIX               V = BYTES/BLOCK
         BO    RON157              BYPASS CALC OF RECORDS IN BLOCK
         SR    R14,R14             B / MIN RCD LENGTH = MAX NO
         LH    R0,PPIRCDL4
         DR    R14,R0              RCDS IN BLOCK
RON157   CR    R2,R15              CHECK TO MAKE SURE CNT ISN'T
         BH    RON158              NEGATIVE
         LR    R2,R15              SET RCD CNT TO B
         B     RON159              BYPASS NSI
*
RON158   SR    R2,R15              APROX RCD CNT = SUM UNIT CNTS - B
RON159   CVD   R2,WORKD            SET UP TO PRINT
         ED    IER066A,WORKD+4     FORMAT DATA
         LM    R0,R1,IER066        IER066A APPROXIMATE RECORD COUNT
         B     RON485              PRINT MESSAGE AND TERMINATE JOB
*
RON170   PPISETOF PPIPH1CO         RESULT IS 0, SET COLLATING BIT TO 0
         B     RON120              SET UP EXIT TO READ ROUTINE
*
*        LESS THAN M SEQUENCES EXIST AT THE PRESENT LEVEL
*        RETURN TO SORT PHASE FOR MORE SEQUENCES
*
RON180   TM    KSEQMSK+2,X'80'     SET COLLATING ORDER FOR SORT
         BO    RON187              BRANCH TO SET SWITCH
         PPISETOF PPIPH1CO
RON183   MVI   KLEVEL+3,X'00'      RESET LEVEL TO ZERO
         PPIFLIP  PPIPH1+PPIPH2    SET PH1 BIT = 1, PH2 BIT = 0
         L     R1,PPIODOM          SET DEPHO TO INDICATE NEXT OUTPUT
         MVC   PPIDEPHO+3(1),1(R1)   UNIT
*
*        THIS CODE IS EXECUTED SO THAT THE DCBOFLGS WILL BE
*        CORRECT IF ABEND AND WISH TO RESTART
*
         L     R1,PPISTDCB         LOAD ADDR OF DCB ADDR TABLE
         SR    R3,R3
         IC    R3,PPIBDSVA         INSERT NUMBER OF WORK UNITS
RON184   L     R2,4(R1)            R2 -> DCB
         USING IHADCB,R2
         NI    DCBOFLGS,255-DCBOFLRB  SHUT READ SWITCH OFF
         OI    DCBOFLGS,DCBOFLWR      SET OUTPUT BIT
         LA    R1,4(,R1)           INCREMENT FOR NEXT DCB ADDR
         BCT   R3,RON184           N TIMES
         LM    R0,R15,WREGSAVE     RESTORE REGS
         L     R11,PPIINT+4        EXIT TO INITIALIZATION RTN TO RESET
         B     4(,R11)             SORT PHASE
*
RON187   PPISETON PPIPH1CO
         B     RON183              GOTO RESET SWITCHES
*
*        QSAM HAS DETECTED EOF ON THE INPUT UNIT
*
RON190   PPITEST  PPIUEOF          USER REACHED EOF ALSO ?
         BZ    RON085              NO, CONTINUE PROCESSING
         TM    KSW,X'01'           YES, EOF PROCEDURES BEEN STARTED ?
         BO    RON360              YES, BYPASS PARTIAL REEL PROCESSING
*                                       GOTO FULL REEL PROCESSING
         SR    R0,R0
         SR    R1,R1
         IC    R1,PPIBDSVA         NO
         L     R2,KASEQTAB
RON200   CLI   3(R2),X'01'         A SINGLE SEQUENCE ON EACH UNIT ?
         BH    RON420              NO, MUST MAKE ANOTHER MERGE PASS
         BL    RON205              BYPASS NSI
         AH    R0,K1               THERE IS A SEQ ON THIS UNIT
RON205   LA    R2,4(,R2)           CHECK NEXT UNIT
         BCT   R1,RON200           CONTINUE CHECK ON OTHER UNITS
         CH    R0,KMRGMX           NO SEQ > MRG ORDER
         BH    RON420              YES, NEED ANOTHER PASS
         OI    KSW,X'01'           YES, SET SW TO INDICATE EOF PROCESS
*                                  HAS STARTED
*
*        EOF PROCEDURES ARE STARTED
*        EACH WORK UNIT CONTAINS ONLY A SINGLE SEQUENCE. SOME
*        UNITS MAY BE EMPTY. THE SEQUENCE MAY BE A FULL REEL
*        WHICH WAS SAVED BECAUSE OF AN RMAX CONDITION, OR A
*        PARTIAL REEL RESULTING FROM MERGING AFTER EOF WAS
*        REACHED. SEQUENCES ARE NOT NECESSARILY IN THE SAME
*        COLLATING ORDER
*
*        THE ALGORITHM MUST NOW DETERMINE WHETHER THE FINAL
*        MERGE PHASE SHOULD READ FORWARD OR BACKWARD IN MERGING
*        SEQUENCES ONTO THE OUTPUT UNIT. IT THEN MUST BE SURE ALL
*        EXISTING SEQUENCES ARE IN PROPER COLLATING ORDER AND
*        CORRECTLY POSITIONED FOR INPUT TO THE FINAL MERGE PHASE
*
*        SET COLLATING SEQUENCE BIT AND SEQUENCE PRESENT BIT FOR
*        EACH UNIT IN TAPE TABLE
*
         SR    R0,R0
         SR    R1,R1
         IC    R1,PPIBDSVA         R1 = NO WORK UNITS
         L     R14,KSEQMSK
         L     R5,KASEQTAB
         LA    R4,PPITPTBL
         SR    R9,R9
RON210   IC    R9,1(,R4)           ACCESS INCR FOR THIS UNIT
         SH    R9,K4
         CH    R0,2(R9,R5)         THIS UNIT HAVE A SEQUENCE ?
         BZ    RON220              NO
         OI    0(R4),X'08'         YES, SET SEQUENCE PRESENT BIT
         L     R15,0(R9,R5)        SET COLLATING ORDER BIT
         SRL   R15,16
         NR    R15,R14
         BNZ   RON220              BYPASS NSI IF NOT ZERO
         OI    0(R4),X'10'
RON220   LA    R4,2(,R4)           INCREMENT TO NEXT UNIT
         BCT   R1,RON210           DECREMENT NUMBER WORK UNITS
*
*        WHEN EXTRACTING DESCENDING FIELDS, REVERSE USERS OUTPUT
*        SEQUENCE IN PREPARING FOR FINAL MERGE PHASE
*
         PPITEST  PPIEXTRT+PPIUOSEQ
         BNO   RON225              BRANCH UNLESS ONE
         MVI   KUSEROUT,X'00'
RON225   PPITEST  PPIVAR           FIXED OR VARIABLE LENGTH RECORDS ?
         BO    RON280              VARIABLE, ALWAYS USE READ BACKWARD
*
*        FIXED - DETERMINE ORDER OF READ TO BE USED BY FINAL
*        MERGE PHASE BASED ON WHICH WILL REQUIRE THE LEAST AMOUNT
*        OF COPYING IN THIS PHASE
*
*        DETERMINE NUMBER OF FULL REELS IN SAME SEQUENCE AS
*        OUTPUT.
*
         SR    R2,R2
         IC    R1,PPIBDSVA
         LA    R4,PPITPTBL
RON230   TM    0(R4),X'20'         FULL REEL ?
         BZ    RON240              NO
         MVI   PPIWKARE,X'10'      YES, ISOLATE COLLATING ORDER OF THIS
         NC    PPIWKARE(1),0(R4)   SEQUENCE
         CLC   PPIWKARE(1),KUSEROUT  COMPARE TO USERS OUTPUT SEQUENCE
         BNE   RON240              OPPOSITE, BRANCH
         LA    R2,1(,R2)           SAME, INCREMENT COUNT BY 1
RON240   LA    R4,2(,R4)           EXAMINE NEXT UNIT
         BCT   R1,RON230           CONTINUE UNIT EXAMINATION
         SLL   R2,1                COMPARE COUNT * 2 TO TOTAL NUMBER OF
         CH    R2,KFULLCT          FULL REELS
         BL    RON270              <, SET UP FOR READ FORWARD
         BH    RON280              >, LEAVE AS IS FOR READ BACKWARDS
*
*        DETERMINE NUMBER OF RECORDS ON PARTIAL REELS IN SAME
*        SEQUENCE AS OUTPUT
*
         IC    R1,PPIBDSVA         EQUAL, CHECK PARTIAL REELS
         L     R3,PPIUNTCT         R3 -> UNIT COUNT TABLE
         SR    R0,R0               NO PART REELS IN SAME SEQ AS OUTPUT
         SR    R2,R2               NO PART REELS IN OPP SEQ TO OUTPUT
         LA    R4,PPITPTBL
RON250   TM    0(R4),X'08'         THIS UNIT HAVE A SEQUENCE ?
         BZ    RON260              NO, TRY NEXT UNIT
         IC    R9,1(,R4)
         MVI   PPIWKARE,X'10'      YES, ISOLATE COLLATING ORDER OF THIS
         NC    PPIWKARE(1),0(R4)   SEQUENCE
         CLC   PPIWKARE(1),KUSEROUT  COMPARE TO USERS OUTPUT SEQUENCE
         BE    RON350              SAME, BRANCH
         A     R2,0(R3,R9)         ADD RECORD COUNT TO OPPOSITE COUNTER
RON260   LA    R4,2(,R4)           INCREMENT TO NEXT UNIT
         BCT   R1,RON250           ANY MORE UNITS
         CR    R0,R2               COMPARE SAME COUNT TO OPPOSITE COUNT
         BH    RON280              >, LEAVE AS IS FOR READ BACKWARDS
*
*        SET UP FOR READ FORWARD
*
RON270   PPISETON PPIDEBB+PPIREADF+PPICLOSR       READ FORWARD IN PH3
*
*        PREPARE TO MERGE PARTIAL REELS WHICH ARE IN WRONG
*        SEQUENCE FOR FINAL MERGE PHASE. IF READ FORWARD IS TO BE
*        USED, REELS IN SEQUENCE OPPOSITE TO USERS OUTPUT
*        SEQUENCE MUST BE COPIED. IF READ BACKWARD IS TO BE USED,
*        REELS IN SAME SEQUENCE AS USERS OUTPUT SEQUENCE MUST BE
*        COPIED
*
RON280   LA    R4,PPITPTBL
         SR    R0,R0
         SR    R1,R1
         SR    R2,R2
         IC    R1,PPIBDSVA         NUMBER OF WORK UNITS
         L     R5,KASEQTAB         ADDRS OF SEQ DISTR TABLE
RON290   TM    0(R4),X'08'         PARTIAL REEL ?
         BZ    RON310              NO, CHECK NEXT UNIT
         MVI   PPIWKARE,X'10'      ISOLATE COLLATING ORDER OF THIS REEL
         NC    PPIWKARE(1),0(R4)
         CLC   PPIWKARE(1),KUSEROUT  COMPARE TO USERS OUTPUT SEQUENCE
         BE    RON330              SAME
         PPITEST  PPIREADF         OPPOSITE CHECK FWD OR BKWD READ ?
         BO    RON310              FORWARD, ON TO NEXT UNIT NO COPY
RON300   OI    0(R4),X'80'         THIS REEL IS TO BE COPIED SET INPUT
*                                  BIT IN TAPE TABLE
         ST    R0,0(,R5)           REMOVE ENTRY FROM SEQ DISTR TABLE
         LA    R2,1(,R2)           INCREMENT COUNT
RON310   LA    R4,2(,R4)           NEXT UNIT
         LA    R5,4(,R5)
         BCT   R1,RON290           CONTINUE UNIT EXAMINATION
         LA    R4,PPITPTBL
         ST    R4,KATPTBL
         LTR   R2,R2               ANY SEQUENCES TO BE MERGED ?
         BZ    RON360              NO
         STH   R2,PPIMRGMX         YES, SET MERGE ORDER
         L     R8,KLEVEL           SET DEPHO
         LA    R8,1(,R8)
         ST    R8,KLEVEL           INCR TO NEXT LEVEL
         SLL   R8,2
         LA    R4,PPITPTBL         LOOK FOR EMPTY UNIT
RON320   TM    0(R4),X'28'         A SEQ ON THIS UNIT ?
         BZ    RON325              NO, BRANCH
         LA    R4,2(,R4)           YES, CHECK NEXT UNIT
         B     RON320              CONTINUE UNIT EXAMINATION
*
RON325   MVC   PPIDEPHO+3(1),1(R4)  SET DEPHO
         LA    R7,TLEVMSK
         SRL   R8,1
         AR    R7,R8               ACCESS APPROPRIATE LEVEL MASK
         B     RON110              GOTO SET SEQUENCE
*
RON330   PPITEST  PPIREADF         SAME, CHECK FRWD OR BKWD READ
         BZ    RON310              BACKWARD, ON TO NEXT UNIT NO COPY
         B     RON300              COPY REEL IN NEXT MERGE PASS
*
*        ADD RECORD COUNT TO SAME COUNTER
*
RON350   A     R0,0(R3,R9)
         B     RON260              GOTO CHECK NEXT UNIT
*
*        EOF PROCEDURES HAVE BEEN STARTED
*        ALL PARTIAL REELS ARE NOW IN PROPER ORDER FOR FINAL
*        MERGE PHASE. ALL FULL REELS WHICH ARE NOT IN PROPER
*        ORDER MUST BE COPIED.
*
RON360   CLC   KTTCNT+2(2),K0      MORE TAPES TO COPY ?
         BE    RON490              NO MORE TAPES LEFT
         L     R4,KTTSV            R4 -> TAPE TBL NEXT ENTRY
         L     R1,KTTCNT           R1 = COUNT OF NO UNITS LEFT
RON365   TM    0(R4),X'20'         FULL REEL ?
         BO    RON373              YES
RON370   LA    R4,2(,R4)           NO, CHECK NEXT UNIT
         BCT   R1,RON365           CONTINUE CHECKING UNITS
         B     RON490              NO MORE FULL REELS PREPARE FOR EOP
*
RON373   MVI   PPIWKARE,X'10'      FULL REEL, NEED TO BE COPIED ?
         NC    PPIWKARE(1),0(R4)   ISOLATE COLLATING ORDER
         CLC   PPIWKARE(1),KUSEROUT  COMPARE TO USERS OUTPUT SEQUENCE
         BE    RON380              SAME, BRANCH
         PPITEST  PPIREADF         OPPOSITE, CHECK FORWARD OR BKWD READ
         BO    RON379              FORWARD, ON TO NEXT UNIT NO COPY
RON375   MVI   0(R4),X'80'         THIS REEL TO BE COPIED SET INPUT
         LA    R2,1
         STH   R2,PPIMRGMX
         TM    0(R4),X'10'
         BO    RON385              SET COLLATING ORDER TO 1
         PPISETOF PPIPH1CO         SET COLLATING ORDER TO 0
RON376   LA    R4,2(,R4)
         ST    R4,KTTSV
         BCTR  R1,0                DECREMENT NUMBER WORK UNITS
         ST    R1,KTTCNT
         SR    R3,R3               LOOK FOR EMPTY UNIT AND USE
         L     R5,KASEQTAB         AS NEXT OUTPUT
         SR    R1,R1
RON377   CH    R1,2(R3,R5)
         BE    RON378              GOTO CHECK TAPE TABLE
         LA    R3,4(,R3)
         B     RON377              CHECK NEXT ENTRY
*
RON378   LR    R2,R3
         LA    R3,4(,R3)
         SRL   R2,1                CHECK TAPE TABLE TO SEE IF UNIT
         L     R4,KATPTBL          CONTAINS A FULL REEL
         AR    R4,R2
         TM    0(R4),X'A0'
         BM    RON377              TRY AGAIN, THIS REEL FULL
         STC   R3,PPIDEPHO+3       UNIT IS EMPTY - SET DEPHO
         LM    R0,R15,WREGSAVE     RESTORE REGS
         L     R11,PPIRD+4         EXIT TO READ PRIME RTN
         B     4(,R11)             READ ROUTINE
*
RON379   SR    R14,R14
         IC    R14,1(,R4)          PUT SEQ IN SEQ DISTR TABLE
         SH    R14,K4
         L     R5,KASEQTAB
         LA    R15,1
         STH   R15,2(R14,R5)
         B     RON370              GOTO CHECK FOR FULL REEL
*
RON380   PPITEST  PPIREADF         SAME, CHECK FRWD OR BKWD READ
         BZ    RON379              BACKWARD, NO COPY
         B     RON375              FORWARD, COPY THIS REEL
*
RON385   PPISETON PPIPH1CO
         B     RON376              SET UP FOR MERGE
*
*        RMAX HAS BEEN REACHED
*        MERGE ALL EXISTING SEQUENCES ONTO A SINGLE UNIT
*
RON390   L     R8,KLEVEL
         MVI   RON131+1,X'F0'      RESET CONDITION CODE TO BRANCH
         CH    R8,KMAXLEV          PRESENT LEVEL = MAX LEVEL RCHD ?
         BL    RON420              NO, PERFORM ANOTHER MERGE PASS
         CLI   0(R6),X'01'         YES, IS THERE ONLY 1 SEQ AT THIS LEV
         BNE   RON410              NO, PREPARE FOR ANOTHER MERGE PASS
RON391   B     RON392
*
*        THIS INSTRUCTION WILL BE MODIFIED BY AON IF CHECKPOINT
*        HAS BEEN INDICATED. THE NEW INSTRUCTION WILL BE A NOP
*
         L     R15,PPICHKAD        R15 -> CHECKPOINT MODULE
         BASR  R14,R15             TAKE CHECKPOINT
         MVI   RON131+1,X'00'      RESET CONDITION CODE TO NOOP
RON392   SR    R1,R1
         STH   R1,KMAXLEV
         LA    R4,PPITPTBL         SET FULL BIT ON IN TAPE TABLE
         AR    R4,R9               FOR THIS UNIT
         OI    0(R4),X'20'
         L     R5,KASEQTAB         SET COLLATING ORDER OF THIS SEQ
         L     R14,KSEQMSK
         SLL   R9,1                GET FULL WORD INCREMENT
         L     R15,0(R9,R5)
         SRL   R15,16
         NR    R15,R14
         BNZ   RON395              ASC
         OI    0(R4),X'10'         DEC
RON395   LH    R1,KFULLCT          ADD 1 TO FULL COUNT
         LA    R1,1(,R1)
         STH   R1,KFULLCT
         CH    R1,KNM2             FULL CNT > N-2
         BNL   RON150              YES, SORT CAPACITY EXCEEDED
         SR    R1,R1
         IC    R1,PPIBDSVA         NO, REDUCE MERGE ORDER
         SH    R1,KFULLCT
         BCTR  R1,0                DECREMENT R1
         STH   R1,PPIMRGMX
         STH   R1,KMRG             RESET CONSTANT
         STH   R1,KMRGMX
         BCTR  R1,0                DECREMENT R1
         STH   R1,KMRG1
         L     R1,KASEQTAB
         MVI   0(R1),X'00'
RON400   MVC   1(1,R1),0(R1)       ZERO OUT SEQUENCE DSTR TABLE
         PPISETOF PPIRMAXR         RESET RMAX SW
         LA    R3,PPIODOM          RESET ODOMETER TABLE
         LA    R1,16               SET LOWER LIMIT OF TAPE TABLE
         L     R4,KLOWLMT          FOR ALL EVEN LEVELS AND UPPER
         L     R5,KUPLMT           LIMIT OF TAPE TABLE FOR ALL
*                                  ODD LEVELS
RON401   TM    0(R4),X'20'         THIS UNIT FULL ?
         BO    RON408              YES, TRY ANOTHER
RON402   TM    0(R5),X'20'         THIS UNIT FULL ?
         BO    RON409              YES, TRY ANOTHER
         ST    R4,KLOWLMT
         ST    R5,KUPLMT
RON403   ST    R4,0(,R3)
         LA    R3,4(,R3)
         BCT   R1,RON405           IF MORE LEVELS BRANCH
         B     RON180              IF NO LEVELS LEFT GO TO RESET ORDER
*
RON405   ST    R5,0(,R3)
         LA    R3,4(,R3)
         BCT   R1,RON403           BRANCH FOR NEXT LEVEL
         B     RON180              IF NO LEVELS LEFT GO TO RESET ORDER
*
RON408   LA    R4,2(,R4)
         B     RON401              BRANCH TO TEST NEXT UNIT
*
RON409   SH    R5,K2
         B     RON402              BRANCH TO TEST NEXT UNIT
*
RON410   MVC   KMRG+1(1),0(R6)     SET MERGE ORDER
         B     RON090              GOTO PREPARE FOR MERGE PASS
*
*
*        OPTIMIZE MERGING OF REMAINING DEQUENCES AFTER EOF OR
*        RMAX HAS BEEN DETECTED
*
RON420   CLC   0(1,R6),KMRGMX+1    LEVEL TOTAL = M ?
         BNL   RON090              >=, BRANCH
         L     R8,KLEVEL
         STH   R8,KSCHLEV          SET SEARCH LEVEL=PRESENT LEVEL
         MVC   KSCHTOT+1(1),0(R6)  SET SCH TOTAL= PRESENT LEVEL TOTAL
RON430   BAS   R14,RONSUB1         SUBROUTINE1 - SET UP TABLES FOR
*                                  MERGE PASS
         MVC   KMRG(2),KSCHTOT
RON440   LH    R8,KSCHLEV          INCR SEARCH LEVEL BY 1
         LA    R8,1(,R8)
         STH   R8,KSCHLEV
         CH    R8,KMAXLEV          SEARCH LEVEL > MAX LEVEL ?
         BH    RON095              YES, EXECUTE A MERGE PASS
         LA    R6,PPIODOM          CHECK ODOMETER TABLE
         SLL   R8,2
         AR    R6,R8
         CLI   0(R6),X'00'         ANY SEQUENCES AT THIS LEVEL
         BNE   RON100              YES, MERGE SEQ PRIOR TO THIS LEVEL
         LH    R8,KSCHLEV
         LA    R8,1(,R8)           NO, INCR SEARCH LEVEL BY 1
         STH   R8,KSCHLEV
         LA    R6,PPIODOM
         SLL   R8,2
         AR    R6,R8
         CLI   0(R6),X'00'         ANY SEQUENCES AT THIS LEVEL ?
         BE    RON440              NO
         SR    R1,R1
         IC    R1,0(,R6)
         AH    R1,KSCHTOT          YES, ADD TO SEARCH TOTAL
         STH   R1,KSCHTOT
RON445   CH    R1,KMRGMX
         BH    RON460              >, MERGE SEQ PRIOR TO THIS LEVEL
         BL    RON540              IF LEVEL SKIPPED
         SRL   R8,1                SET UP R7 FOR SUBRTN1
         L     R7,KALEVMSK
         AR    R7,R8
         BAS   R14,RONSUB1         EQUAL MERGE SEQ UPT TO THIS LEVEL
         MVC   KMRG(2),KSCHTOT
         LH    R8,KSCHLEV
         LA    R8,1(,R8)
         ST    R8,KLEVEL
         B     RON095              GO TO MERGE SET UP RTN
*
RON460   LH    R8,KSCHLEV
         BCTR  R8,0                DECR TO PREVIOUS LEVEL
         B     RON095              GOTO MERGE SET UP RTN
*
*        RECORD COUNT IS OFF. PRINT MESSAGE AND TERMINATE JOB
*        R3 = COUNT OF RECORDS IN
*        R2 = COUNT OF RECORDS OUT
*
RON480   L     R6,PPIRMB+4
         L     R1,IER047           R1 -> MSG TEXT
         MVC   PPIABMNO,3(R1)      MOVE MSG NO INTO ABEND NO
         LM    R0,R1,IER047        IER047A RECORD COUNT ERROR
         CVD   R3,WORKD            CONVERT RECORDS IN TO DECIMAL
         ED    IER047I,WORKD+4     FORMAT DATA
         CVD   R2,WORKD            CONVERT RECORDS OUT TO DECIMAL
         ED    IER047O,WORKD+4     FORMAT DATA
RON485   L     R15,PPIADSSC        R15 -> SSC
         BAS   R14,12(,R15)        CALL MSG WRITER
         L     R15,PPIADSSC        R15 -> SSC
         BAS   R14,16(,R15)        EXIT TO SORT SYSTEM CONTROL, NO RET
*
*        ALL SEQUENCES ARE READY FOR FINAL MERGE PHASE
*
RON490   SR    R1,R1
         SR    R2,R2               DETERMINE TOTAL NO SEQUENCES
         IC    R1,PPIBDSVA         INTO PH 3 AND SET MERGE ORDER
         L     R5,KASEQTAB         ACCORDINGLY
         LA    R4,PPITPTBL
RON495   CLC   2(2,R5),K0
         BE    RON496              BRANCH IF SAME ADDR
         AH    R2,2(,R5)
         OI    0(R4),X'C0'
RON496   LA    R4,2(,R4)
         LA    R5,4(,R5)
         BCT   R1,RON495           DECREMENT BEFORE TESTING NEW ADDR
         STH   R2,PPIMRGMX
         CLI   KUSEROUT,X'00'
         BE    RON530              ASCENDING ORDER DESIRED
RON500   PPISETON PPIPH1CO         SET COLLATING ORDER FOR DESC
         LA    R1,4                SET R1 TO LOAD PH 3 INDICATION
RON510   L     R15,PPIADSSC
         BAS   R14,20(,R15)        EXIT TO SORT SYSTEM CONTROL
*
RON530   PPISETOF PPIPH1CO         SET COLLATING ORDER TO ASCENDING
         B     RON510
*
RON540   SRL   R8,1                IN CASE A LEVEL WAS SKIPPED
         L     R7,KALEVMSK
         AR    R7,R8
         B     RON430              LESS, SEARCH FOR MORE SEQ
*
*        SUBROUTINE 1
*        UPDATE ALL TABLES FOR EXECUTION OF A MERGE PASS
*
RONSUB1  SR    R1,R1
         IC    R1,PPIBDSVA         SET R1 = NO WORK UNITS
         LA    R4,PPITPTBL
         L     R5,KASEQTAB         R5 -> SEQ DISTR TABLE
RONSUB12 IC    R9,1(,R4)           R9 = DCB INCREMENT
         SH    R9,K4
         LH    R2,0(,R7)           R2 = LEVEL MASK
         LH    R3,0(R5,R9)
         NR    R2,R3               SEQ PRES ON THIS UNIT AT THIS LEV ?
         BZ    RONSUB13            NO
         OI    0(R4),X'C0'         YES, SET INPUT & OPEN BITS IN TP TAB
         LH    R2,32(,R7)
         NR    R3,R2
         STH   R3,0(R5,R9)
         LH    R2,2(R5,R9)         DECREMENT UNIT COUNT BY 1
         BCTR  R2,0                DECREMENT R2
         STH   R2,2(R5,R9)
RONSUB13 LA    R4,2(,R4)           CHECK NEXT UNIT IN TAPE TABLE
         BCT   R1,RONSUB12         CONTINUE CHECKING UNITS
         IC    R1,0(,R6)
         STC   R1,KMRG+1
         MVI   0(R6),X'00'         RESET LEVEL COUNT TO ZERO
         BR    R14                 RETURN
*
*        SUBROUTINE 2
*        UPDATE LEVEL ODOMETER TO INDICATE NEXT UNIT TO BE USED
*        AS OUTPUT FOR THIS LEVEL
*
RONSUB2  L     R1,0(,R6)
RONSUB21 TM    KLEVEL+3,X'01'      THIS LEVEL ?
         BO    RONSUB25            YES, ODD LEVEL
         CLC   1(3,R6),KUPLMT+1    EVEN, UPPER LIMIT BEEN REACHED ?
         BE    RONSUB23            YES, RESET
         AH    R1,K2
         ST    R1,0(,R6)           SET NEW UNIT IN ODDMETER
RONSUB22 TM    0(R1),X'20'         UNIT ALREADY FULL ?
         BO    RONSUB21            YES, TRY NEXT UNIT
         SR    R1,R1
         IC    R1,0(,R6)           INCREMENT LEVEL TOTAL BY 1
         LA    R1,1(,R1)
         STC   R1,0(,R6)
         BR    R14                 RETURN
*
RONSUB23 MVC   1(3,R6),KLOWLMT+1
RONSUB24 L     R1,0(R6)
         B     RONSUB22            CHECK UNIT IN ODDMETER
*
RONSUB25 CLC   1(3,R6),KLOWLMT+1   ODD LEVEL LOWER LIMIT BEEN RCHD ?
         BE    RONSUB26            YES, RESET
         SH    R1,K2               NO, DECR TO NEXT UNIT
         ST    R1,0(,R6)
         B     RONSUB22            CHECK UNIT IN ODDMETER
*
RONSUB26 MVC   1(3,R6),KUPLMT+1
         B     RONSUB24            GOTO CHECK A NEW UNIT IN ODDMETER
*
*        CONSTANTS
*
         DC    0D'0'
KATPTBL  DC    F'0'                ADDR OF TAPE TABLE SET BY ASSGN RTN
KASEQTAB DC    F'0'                ADDR OF SEQUENCE DISTRIBUTION
*                                  TABLE, SET BY ASSGN RTN
KAODOM   DC    F'0'                ADDR OF ODOMETER TABLE
KALEVMSK DC    A(TLEVMSK)          ADDR OF LEVEL MASK TABLE
KLEVEL   DC    A(0)                LEVEL
KINCR    DC    A(0)                DCB INCR FOR OUTPUT UNIT
KUPLMT   DC    F'0'                UPPER LIMIT OF TAPE TABLE
*                                  ADDR SET BY ASSGN RTN
KLOWLMT  DC    F'0'                LOWER LIMIT OF TAPE TABLE
*                                  SET BY ASSGN RTN
KWKUNTS  DC    H'0'                NUMBER OF ACTIVE WORK UNITS
KMRG     DC    H'0'                CURRENT MERGE ORDER
KMRG1    DC    H'0'                MERGE ODER - 1
KMRGMX   DC    H'0'                MAX MERGE ORDER FOR CURRENT NUMBER
*                                  OF WORK UNITS
KMAXLEV  DC    AL2(0)              MAXIIMUM LEVEL REACHED
KSEQMSK  DC    F'0'                SEQUENCE MASK, SET BY ASSGN RTN
*                                  ACCORDING TO COLLATING ORDER OF
*                                  EACH LEVEL
KTTSV    DC    F'0'                PTR TO TAPE TABLE SET BY ASSGN
KTTCNT   DC    F'0'                NUMBER OF WORK UNITS SET BY ASSGN
KFULLCT  DC    AL2(0)              NUMBER OF FULL REELS IN EXISTENCE
KSCHTOT  DC    AL2(0)              SEARCH TOTAL USED TO OPTIMIZE MERGES
KSCHLEV  DC    AL2(0)              SEARCH LEVEL USED TO SCAN SEQ DISTR
*                                  TABLE TO OPTIMIZE MERGE PASSES
K0       DC    AL2(0)              CONSTANT OF ZERO
K1       DC    AL2(1)              CONSTANT OF ONE
K2       DC    AL2(2)              CONSTANT OF TWO
K4       DC    AL2(4)              CONSTANT OF FOUR
K15      DC    AL2(15)             CONSTANT OF FIFTEEN
KNM2     DC    H'0'                NUMBER OF WORK UNITS - 2, SET BY ASG
KSW      DC    X'00'               EOF PROCESS SWITCH
KUSEROUT DC    X'00'               USERS OUTPUT SEQUENCE
*                                  SET BY ASSGN RTN
*                                  X'00'=ASC    X'10'=DESC
*
*        WORK AREAS
*
WREGSAVE DC    16F'0'              REGISTER SAVE AREA
WORKD    DC    D'0'
*
*        LEVEL MASK TABLE
*
TLEVMSK  DC    X'8000'             LEVEL MASK TABLE
         DC    X'4000'
         DC    X'2000'
         DC    X'1000'
         DC    X'0800'
         DC    X'0400'
         DC    X'0200'
         DC    X'0100'
         DC    X'0080'
         DC    X'0040'
         DC    X'0020'
         DC    X'0010'
         DC    X'0008'
         DC    X'0004'
         DC    X'0002'
         DC    X'0001'
         DC    X'7FFF'
         DC    X'BFFF'
         DC    X'DFFF'
         DC    X'EFFF'
         DC    X'F7FF'
         DC    X'FBFF'
         DC    X'FDFF'
         DC    X'FEFF'
         DC    X'FF7F'
         DC    X'FFBF'
         DC    X'FFDF'
         DC    X'FFEF'
         DC    X'FFF7'
         DC    X'FFFB'
         DC    X'FFFD'
         DC    X'FFFE'
*
./ ADD NAME=IERROO   0101-20211-20211-1200-00065-00065-00000-RELEASE 00
ROO      TITLE 'IERROO - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERROO - NOT SUPPORTED
*
*        MODULE FUNCTION/OPERATION -
*
*        APPEARS AS A DSECT IN - IERAOO
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS -
*
*        INPUT - PPI FIELDS REFERENCED -
*
*        OUTPUT - PPI FIELDS ALTERED OR INITIALIZED -
*        THIS MODULE CONSISTS PRIMARILY IN A SORT TABLE WHICH IS
*        USED TO CONTROL WHERE TO WRITE THE NEXT STRING OF
*        SEQUENCED DATA IN DISK AREAS AND CHECKING FOR ENDS OF
*        AREA, NMAX, ETC. IT ACTS AS THE AREA MANAGER FOR THE
*        WRITE ROUTINE, AND DETERMINES IF PHASE 2 OF THE SORT IS
*        NEEDED, AND ALSO MAY TERMINATE THE SORT FOR CERTAIN ABNORMAL
*        CONDITIONS
*
*        EXTERNAL ROUTINES -
*
*        EXTERNAL PARAMETERS -
*
*        EXITS - NORMAL -
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS - N/A
*
*        NOTES -
*        THIS MODULE IS RESTRICTED TO 2301 DRUM OPERATIONS ONLY
*
IERROO   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERROO SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERROOI
*
*
DIERRMA  DSECT
*
*        MODULE NAME - IERRMA
*
*        THIS MODULE CONTAINS ALL OF THE MESSAGES THAT ARE
*        REQUIRED FOR PHASE 1 RUNNING PROGRAM
*
         COPY  RMAMAIN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERROOI  0101-20211-20211-1200-00221-00221-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERROO SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERROOI - NOT SUPPORTED - 2301 DEVICE
*
         USING DIERRMA,R14
         USING *,R11               SET BASE R6
         USING IERRCA,R13
*
IERDOK   B     ROOEOF              +00 OUTPUT END OF FILE
         B     ROOEOA              +04 END OF AREA
         B     ROOEOASQ            +08 END OF AREA END OF SEQUENCE
ROOEOSQ  L     R4,WPOINT           GET TABLE AREA ADDR
         L     R5,0(,R4)           GET AREA KEY (0, 1, 2, 3, 4, OR 5)
         SLL   R5,1                CALC DISP (AREA KEY X CTR SIZE)
         LA    R6,PPISEQCT         GET ST PT OF COUNTERS
         LH    R7,0(R5,R6)         GET DATA FROM COUNTER
         LA    R7,1(,R7)           INCR CTR
         STH   R7,0(R5,R6)         RESTORE CTR TO PPI
         L     R4,WBLKCT           GET DIRECTORY BLOCKING COUNTER
         BCT   R4,ROODRBLK         REDUCE BLOCKING COUNTER
         L     R4,WPOINT
         MVC   4(8,R4),PPIDEPHO    SAVE NEXT SEQ IN TBL
         MVC   PPIDIRAD(8),12(R4)  PUT NEXT DICT BLOCK ADDR IN PPI
         MVC   PPIPDWA(64),WCLBKAR   PUT DICT BLK AREA IN PPI
         L     R11,PPIWRT+4        SET WRITE ROUTINE BASE REGESTER
         BAS   R14,12(,R11)        CALL WRITE ROUTINE
         LA    R4,8                RESET BLK CTR TO 8
         ST    R4,WBLKCT           RESET BLK CTR TO 8
         L     R6,WPOINT           GET AREA ADDR FROM TABLE
         CLI   19(R6),82           82 DIRECTORIES BEEN WRITTEN ?
         BNE   ROOSMTK             NO, BRANCH
         L     R7,0(,R6)           YES, TRACK IS FILLED
         SLL   R7,3                CALC DISP (AREA X DSK ADDR SIZE -8)
         LA    R8,PPIENDAR         GET START ADDR IN PPI
         AR    R8,R7               ADD DISP
         CLC   4(3,R8),PPIDEPHO+4  SEQ AREA REACHED END ADDR IN PPI ?
         BNH   ROONOTRK            NO TRACKS AVAILABLE, BRANCH
         MVI   19(R6),X'01'
         CLI   6(R8),X'00'         TRACK NO = 0 ?
         BE    ROOTERM             YES, TERMINATE JOB
         IC    R7,6(,R8)           GET HD NO FROM PPI (ENDAR)
         LA    R7,1(,R7)           ADD 1
         STC   R7,18(,R6)          STORE IN TABLE (NEW DICT)
         IC    R6,6(,R8)           GET PPIENDAR TRACK NUMBER
         BCTR  R6,0                REDUCE TRACK NUMBER
         STC   R6,6(,R8)           STOW NEW TRACK IN PPIENDAR
         B     ROOGOB              GO INCREMENT POINTER
*
ROOSMTK  IC    R7,19(,R6)          GET RECORD NUMBER
         LA    R7,1(,R7)           INCREMENT BY 1
         STC   R7,19(,R6)          STOW NEW RECORD NUMBER
         B     ROOGOB              GO INCREMENT POINTER
*
ROODRBLK ST    R4,WBLKCT           RESTORE DIRECTORY BLOCKING COUNTER
         LA    R5,8                CALC DISP TO REACH PROPER ADDR IN
         SR    R5,R4               DICT BLOCK, TO FILL NEXT BLOCK
         SLL   R5,3                MLTPY TIMES ADDR SIZE (8)
         LA    R6,WCLBKAR          GET ST PT OF DICT BLK AREA
         AR    R6,R5               DECIDE NEXT SEQ ADDR AREA IN TABLE
         MVC   0(8,R6),PPIDEPHO    INSERT ADDR
ROODEBL  L     R11,PPIDEB+4        GET DEBLOCK ROUTINE ADDR
         B     8(,R11)             CALL DEBLOCK
*
ROOGOB   L     R4,WPOINT           GET TABLE POINTER
         LA    R4,20(,R4)          INCR TABLE POINTER
         ST    R4,WPOINT           INCR TABLE POINTER
         CL    R4,WTBLLIMT         TABLE FINISHED ?
         BE    ROOSETPT            YES, BRANCH TO RESET POINTER
ROONXT1  L     R4,WPOINT           GET TABLE POINTER
         MVC   PPIDEPHO(8),4(R4)   STOW NEXT SEQ ADDR IN PPI
         MVC   WCLBKAR(8),4(R4)
         TM    KSWA7E4,X'01'       LAST WRITE HAVE ENOUGH AREA ?
         BO    ROODEBL             GET NEXT SEQ FOR DEBLK IF SW IS ON
         OI    KSWA7E4,X'01'       TURN SWITCH ON
         L     R11,PPIWRT+4        LOAD ADDRESS OF WRITE ROUTINE
         B     0(,R11)             CALL WRITE ROUTINE
*
ROOSETPT LA    R6,TABLE            SET POINTER TO 1ST POS IN SORT
         ST    R6,WPOINT           TABLE
         B     ROONXT1             GOTO MAIN LINE
*
ROOEOF   L     R4,WPOINT           GET AREA ADDR FROM TABLE
         L     R5,0(,R4)           GET AREA KEY
         SLL   R5,1                CALC DISP IN CTR AREA IN PPI
         LA    R6,PPISEQCT         GET ST PT OF CTRS
         LH    R7,0(R5,R6)         GET NO FR CTR
         LA    R7,1(,R7)           INCR CTR
         STH   R7,0(R5,R6)         RESTORE CTR TO PPI
         MVC   PPIDIRAD(8),12(R4)  PUT DIRECTORY ADDR IN PPI
         MVC   PPIPDWA(64),WCLBKAR  PUT BLOCKING AREA IN PPI
         L     R11,PPIWRT+4        LOAD ADDR OF WRITE ROUTINE
         BAS   R14,12(,R11)        CALL WRITE DIRECTORY
         LH    R8,PPINDSKA
         SR    R4,R4
         LA    R6,PPISEQCT
ROOLOOPD LH    R5,0(,R6)           GET SEQUENCE COUNT
         AR    R4,R5               SUM THE SEQUENCE COUNTS
         LA    R6,2(,R6)           BUMP TO NEXT CTR
         BCT   R8,ROOLOOPD         BRANCH IF ALL NOT ADDED
         MVC   PPIENDAR(48),PPIDSKED
         LH    R7,PPIMRGMX
         LA    R7,1(,R7)           PLUS ONE
         STC   R7,PPIBDSVA
         CH    R4,PPIMRGMX         SUM HIGHER THAN MERGE MAX ?
         BH    ROOGOF              YES, BRANCH TO CLOSE
         STH   R4,PPIMRGOP
         LA    R1,4                SET TO 4
         B     ROOBYPAS
*
ROOGOF   SR    R1,R1               CLEAR REG
ROOBYPAS L     R15,PPIADSSC        LOAD ADDRESS OF SSC
         BAS   R14,20(,R15)        EXIT TO SORT SYSTEM CONTROL
*
ROOEOA   NI    KSWA7E4,X'00'       TURN SWITCH OFF
ROOEOASQ L     R4,WPOINT           GET POINTER
         L     R5,0(,R4)
         SLL   R5,1
         LA    R6,PPISEQCT
         LH    R7,0(R5,R6)
         LA    R7,1(,R7)
         STH   R7,0(R5,R6)
         MVC   PPIDIRAD(8),12(R4)  PUT DIRECTORY ADDR IN PPI
         MVC   PPIPDWA(64),WCLBKAR
         L     R11,PPIWRT+4        LOAD ADDR OF WRITE ROUTINE
         BAS   R14,12(,R11)        CALL WRITE ROUTINE
         LA    R4,8
         ST    R4,WBLKCT
ROONOTRK LA    R5,20               SET UP TO CHECK FOR LAST AREA
         LA    R4,TABLE
         ALR   R4,R5
         CL    R4,WTBLLIMT
         BNE   ROOGOH              BRANCH ON MORE AREAS REMAINING
ROOTERM  L     R14,PPIRMA+4        SET MESSAGE BASE
         LM    R0,R1,IER046        IER046A SORT CAPACITY EXCEEDED
         L     R15,PPIADSSC
         BAS   R14,12(0,R15)       CALL PRINT MESSAGE
*
*        SORT CAPACITY REACHED
*
*        APROX RCD CNT IS PPICOUNT -G - B, WHERE G AND B ARE MAX
*        VALUES
*        IF CNT TURNS NEGATIVE, CNT IS SET TO PPICOUNT-G+B OR
*        JUST B
*        THIS NEGATIVE CONDITION IS MOST LIKELY IF THE BLOCK
*        BEING WRITTEN OUT IS SHORT AND/OR RECORD FORMAT IS
*        VARIABLE
*
         L     R1,PPICOUNT         NO RCD READ IN MINUS G
         A     R1,PPIINSCT         ADD NO OF INSERTED RECORDS
         S     R1,PPIDELCT         SUBTRACT NO DELETED RECORDS
         S     R1,PPISRTG          G - MAX NO OF RCDS IN TREE
         LH    R15,PPISRTBL        B - F = NO RCDS/BLOCK
         PPITEST  PPIFIX               V = BYTES/BLOCK
         BO    ROI031
         LH    R0,PPIRCDL4         B / MIN RCD LENGTH = MAX NO
         SR    R14,R14
         DR    R14,R0              RCDS IN BLOCK
ROI031   CR    R1,R15              CHECK TO MAKE SURE CNT ISN'T
         BH    ROI032              NEGATIVE
         AR    R1,R15              ADD B TO CNT
         CR    R1,R15              CNT STILL NEG ? YES
         BNL   ROI033
         LR    R1,R15              SET CNT TO B
         B     ROI033
*
ROI032   SR    R1,R15              APROX RCD CNT = PPICOUNT -G -B
ROI033   CVD   R1,PPIWKARE
         L     R14,PPIRMA+4
         MVC   IER066A,EPATTERN    MOVE IN ZERO SUPPRESS ED PATTERN
         ED    IER066A,PPIWKARE+4  FORMAT DATA
         LM    R0,R1,IER066        IER066A APPROXIMATE RECORD COUNT
         L     R15,PPIADSSC        R15 -> PRINT MSG RTN
         BAS   R14,12(,R15)        CALL PRINT MSG RTN
         L     R1,IER066
         MVC   PPIABMNO,3(R1)      MOVE MSG NO INTO ABEND CODE
         L     R15,PPIADSSC
         BAS   R14,16(,R15)        EXIT TO SSC, TERM JOB, NO RETURN
*
ROOGOH   L     R4,WPOINT           GET POINTER
         L     R6,WPOINT
         LA    R6,20(,R6)
         CL    R6,WTBLLIMT         TABLE LIMIT REACHED ?
         BE    ROORESET            GO RESET TABLE POINTER
         L     R5,WTBLLIMT         GET TABLE LIMIT
         LA    R6,20
         SLR   R5,R6               SET LIMIT OF TABLE
         MVC   0(20,R4),0(R5)
ROOGOG   L     R5,WTBLLIMT         GET TABLE LIMIT
         LA    R4,20
         SLR   R5,R4
         ST    R5,WTBLLIMT         STORE TABLE LIMIT MINUS 1
         B     ROONXT1
*
ROORESET LA    R6,TABLE            GET TABLE ADDR TO RESET TO 1ST POS
         ST    R6,WPOINT
         B     ROOGOG
*
WPOINT   DC    A(0)                SET UP POINTER
WBLKCT   DC    A(8)                SET UP DIRECTORY BLK CTR
WCLBKAR  DC    16F'0'              DICT BLOCKING AREA = 64 BYTES
WTBLLIMT DC    A(0)                SET UP TABLE LIMIT POINTER
*
TABLE    DC    A(0)                SET UP TABLE - FIRST AREA
         DC    4F'0'               SET UP TABLE - FIRST AREA
         DC    A(1)                SET UP TABLE - SECOND AREA
         DC    4F'0'               SET UP TABLE - SECOND AREA
         DC    A(2)                SET UP TABLE - THIRD AREA
         DC    4F'0'               SET UP TABLE - THIRD AREA
         DC    A(3)                SET UP TABLE - FOURTH AREA
         DC    4F'0'               SET UP TABLE - FOURTH AREA
         DC    A(4)                SET UP TABLE - FIFTH AREA
         DC    4F'0'               SET UP TABLE - FIFTH AREA
*
KSWA7E4  DC    X'01'               SWITCH A7 - E4 NORMALLY ON
EPATTERN DC    XL8'4020202020202020'   XERO SUPPRESS ED PATTERN
*
./ ADD NAME=IERROP   0101-20211-20211-1200-00078-00078-00000-RELEASE 00
ROP      TITLE 'IERROP - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERROP
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 2 & 3 - 1 TO 16 WAY MERGE NETWORK - BALN
*        THE FUNCTION OF THIS MODULE IS TO MERGE FIXED OR
*        VARIABLE LENGTH RECORDS IN ASCENDING OR DECENDING
*        SEQUENCES FOR PHASE 2 AND 3. IERROP INITIALLY SEQUENCES
*        THE INPUT RECORDS IN PHASE TO PHASE INFORMATION AREA,
*        CUTBACKS THE NETWORK FOR SPECIFIED MERGE ORDER AND THEN
*        UTILIZES A BINARY INSERTION TECHNIQUE. THIS IS
*        ACCOMPLISHED USING THE ADDRESSES OF THE RECORDS IN
*        GENERAL REGISTERS R4 THRU R10. THE LOW ORDER 3 BYTES OF
*        THE REGISTER CONTAIN THE ADDRESS OF THE RECORD. THE HIGH
*        ORDER BYTE HAS THE FILE IDENTIFICATION FOR THE DEBLOCK
*        ROUTINE
*
*        MACROS USED -
*
*        USED AS A DSECT IN - IERAOP
*
*        ENTRY POINTS - ENTRY FROM DEBLOCK OR ALGORITHM
*                       CALLING SEQUENCE -
*                           L    R15,PPINET+4
*                           B    DISP(,R15)
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIADSSC   PPIMRGMX   PPIDOUA   PPICNTL
*        PPIBLK2    PPIDOOBA   PPIPDWA   PPIPSVA
*        PPIBLK     PPIRMC
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED - PPICNTL
*
*        EXTERNAL ROUTINES -
*        EXTRN IERRMC  - MESSAGE MODULE
*        EXTRN IERDB2  - BLOCK ROUTINE PHASE 2
*        EXTRN IERDB34 - BLOCK ROUTINE PHASE 3
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL -
*        IERDB2  - PHASE TWO BLOCK ROUTINE
*        IERDB34 - PHASE THREE BLOCK ROUTINE
*
*        EXITS - ERROR - IERRMC - ERROR MESSAGE MODULE
*
*        TABLES/WORK AREAS -
*        ROPMRGAU - SAVES ADDR OF FIRST 7 RECORDS
*        ROPMRGAL - SAVES ADDR OF LAST 7 RECORDS
*
*        NOTES - N/A
*
IERROP   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERROP SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERROPI
*
*        IERRMC
*
DIERRMC  DSECT
*
         COPY  RMCMAIN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERROPI  0101-20211-20211-1200-00815-00815-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERROP SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERROPI
*
         USING *,R11               PROGRAM BASE
         USING IERRCA,R13          PPI BASE
         USING DIERRMC,R14         MESSAGE MODULE BASE
*
IERDO1   B     ROPSINIT            +00 READ PRIME ENTRY
*                                      BRANCH TO INITIALIZATION
         B     ROPCUTEN            +04 READ + ALGORITHM ENTRY
*                                      BRANCH TO CUTBACK
*        NETWORK ENTRANCE SWITCH
*
ROPNTENS NOP   ROPLF8              FOR MRG ORDER > 8, FALL THRU
*
*        DETERMINATION OF WHICH HALF OF MERGE NETWORK RECORDS
*        THE NEW RECORD MUST COMPARE
*
         L     R2,ROPMRGAM         ADDR OF ITEM 8
IERROPWH CLC   0(1,R3),0(R2)       CMP NEW ITEM WITH ITEM 8
         BNE   ROPWHB              NOT EQUAL, BRANCH
         BASR  R14,R12             SET NETWORK RETURN REG FOR EQ RTN
*
*        THIS INSTR IS BNH/BNL DEPENDING ON THE INPUT SEQUENCE
*
ROPWHB   BNH   ROPLF8              NEW <= ITEM 8, FALL THRU
ROPLF16  LM    0,0,ROPMRGAL        LOAD NETWK REG WITH THOSE NECESSARY
*                                  RCD FROM ITEMS 9 THRU 15 INSTR IS
*                                  SET BY THE CUTBACK RTN
*
*        PARTIAL NETWORK FOR CMP NEW AGAINST ITEMS 9 THRU 15
*
ROPPNELA B     IERROPL4            PARTIAL NETWORK ENTR SWITCH SET BY
*                                  CUTBACK RTN
*
*        ENTRANCE FOR A 14, 15, 16 WAY MERGE
*
IERROPL4 CLC   0(1,R3),0(R7)       COMPARE NEW ITEM WITH ITEM 12
         BNE   ROP12B              IF EQUAL GOTO EQUALS RTN
         LR    R2,R7               LOAD EQ RTN COMPARE REG WITH ITEM 12
         BASR  R14,R12             SET NETWORK RETURN REG FOR EQ RTN
*
*        THIS INSTR IS BH OR BL DEPENDING ON THE INPUT SEQUENCE
*
ROP12B   BH    IERROC14            IF HI/LO GOTO CMP ITEM 14 OR 13
*
*        ENTRANCE FOR 11, 12, 13 WAY MERGE
*
IERROPL2 CLC   0(1,R3),0(R5)       COMPARE NEW ITEM WITH ITEM 10
         BNE   ROP10B              IF EQUAL GOTO EQUALS RTN
         LR    R2,R5               LOAD EQ RTN COMPARE REG WITH ITEM 10
         BASR  R14,R12             SET NETWORK RETURN REG FOR EQ RTN
*
*        THIS INSTR IS BH OR BL DEPENDING ON THE INPUT SEQUENCE
*
ROP10B   BH    IERROC11            IF HI/LO GOTO CMP ITEM 11,12/UPDATE
*
*        ENTRANCE FOR A 10 WAY MERGE
*
IERROPL1 CLC   0(1,R3),0(R4)       COMPARE NEW ITEM WITH ITEM 9
         BNE   ROP9B               IF EQUAL GOTO EQUALS RTN
         LR    R2,R4               LOAD EQ RTN COMPARE REG WITH ITEM 9
         BASR  R14,R12             SET NETWORK RETURN REG FOR EQ RTN
*
*        THIS INSTR IS BH OR BL DEPENDING ON THE INPUT SEQUENCE
*
ROP9B    BH    ROPMOV9             INSERT ITEM IN COLLATING SEQUENCE
*
*        ENTRANCE FOR A 9 WAY MERGE AND NEW ITEM COLLATES AFT
*        ITEM 8
*
ROP9WMRG LR    R2,R3
         LM    R3,R10,ROPMRGAU
         STM   R4,R10,ROPMRGAU
         ST    R2,ROPMRGAM
*
*        PUTTING OUT THE NETWORK WINNER
*        SEQUENCE CHECKING IS NOT NECESSARY
*        THE ASSIGNMENT RTN SETS THE BRANCH INSTR ACCORDING TO
*        THE PHASE
*
IERDOBWR NOP   ROPPH3NS            DROP THRU FOR PHASE 2
         L     R11,PPIBLK2+4
         B     16(,R11)            EXIT TO BLK RTN WANT NEXT RCD
*
ROPPH3NS L     R11,PPIBLK+4
         B     4(,R11)             EXIT TO BLK RTN WANT NEXT RCD
*
IERROC14 CLC   0(1,R3),0(R9)       COMPARE NEW ITEM WITH ITEM 14
         BNE   ROP14B              IF EQUAL GOTO EQUALS RTN
         LR    R2,R9               LOAD EQ RTN COMPARE REG WITH ITEM 14
         BASR  R14,R12             SET NETWORK RETURN REG FOR EQ RTN
*
*        THIS INSTR IS BH OR BL DEPENDING ON THE INPUT SEQUENCE
*
ROP14B   BH    IERROC15            IF HI/LO GOTO CMP ITM 15 OR UPDATE
IERROC13 CLC   0(1,R3),0(R8)       COMPARE NEW ITEM WITH ITEM 13
         BNE   ROP13B              IF EQUAL GOTO THE EQUALS RTN
         LR    R2,R8               LOAD EQ RTN COMPARE REG WITH ITEM 13
         BASR  R14,R12             SET NETWORK RETURN REG FOR EQ RTN
*
*        THIS INSTR IS BH OR BL DEPENDING ON THE INPUT SEQUENCE
*
ROP13B   BH    ROPMOV13            IF HI/LO NEW COLLATES AFTER ITEM 13
*
*        UPDATING WHERE NEW ITEM COLLATES AFT ITEM 12 + BEFORE
*        ITEM 13
*
ROPMOV12 L     R10,ROPMRGAM
         LR    R8,R3
         STM   R4,R8,ROPMRGAM
         LM    R3,R9,ROPMRGAU
         STM   R4,R10,ROPMRGAU
         B     IERDOBWR            BRANCH TO OUTPUT WINNER
*
*        UPDATING WHERE NEW ITEM COLLATES AFT ITEM 13 + BEFORE
*        ITEM 14
*
ROPMOV13 L     R10,ROPMRGAM
         LR    R9,R3
         STM   R4,R9,ROPMRGAM
         LM    R3,R9,ROPMRGAU
         STM   R4,R10,ROPMRGAU
         B     IERDOBWR            BRANCH TO OUTPUT WINNER
*
IERROC15 CLC   0(1,R3),0(R10)      COMPARE NEW ITEM WITH ITEM 15
         BNE   ROP15B              IF EQUAL GOTO EQUALS RTN
         LR    R2,R10              LOAD EQ RTN COMPARE REG WITH ITEM 15
         BASR  R14,R12             SET NETWORK RETURN REG FOR EQ RTN
*
*        THIS INSTR IS BH OR BL DEPENDING ON THE INPUT SEQUENCE
*
ROP15B   BH    ROPMOV15            IF HI/LO NEW COLLATES AFTER ITEM 15
*
*        UPDATING WHERE NEW ITEM COLLATES AFT ITEM 14 + BEFORE
*        ITEM 15
*
ROPMOV14 L     R2,ROPMRGAM
         LR    R10,R3
         STM   R4,R10,ROPMRGAM
         LM    R3,R9,ROPMRGAU
         LR    R10,R2
         STM   R4,R10,ROPMRGAU
         B     IERDOBWR            BRANCH TO OUTPUT WINNER
*
*        UPDATING WHERE NEW ITEM COLLATES AFTER ITEM 15
*
ROPMOV15 L     R2,ROPMRGAM
         STM   R4,R10,ROPMRGAM
         ST    R3,ROPMRGAL+24
         LR    R10,R2
         LM    R3,R9,ROPMRGAU
         STM   R4,R10,ROPMRGAU
         B     IERDOBWR            BRANCH TO OUTPUT WINNER
*
IERROC11 CLC   0(1,R3),0(R6)       COMPARE NEW ITEM WITH ITEM 11
         BNE   ROP11B              IF EQUAL GOTO EQUALS RTN
         LR    R2,R6               LOAD EQ RTN COMPARE REG WITH ITEM 11
         BASR  R14,R12             SET NETWORK RETURN REG FOR EQ RTN
*
*        THIS INSTR IS BH OR BL DEPENDING ON THE INPUT SEQUENCE
*
ROP11B   BH    ROPMOV11            INSERT NEW ITEM IN SEQUENCE
*
*        UPDATING WHERE NEW ITEM COLLATES AFT ITEM 10 + BEFORE
*        ITEM 11
*
ROPMOV10 L     R10,ROPMRGAM
         LR    R6,R3
         STM   R4,R6,ROPMRGAM
         LM    R3,R9,ROPMRGAU
         STM   R4,R10,ROPMRGAU
         B     IERDOBWR            BRANCH TO OUTPUT WINNER
*
*        UPDATING WHERE NEW ITEM COLLATES AFT ITEM 11 + BEFORE
*        ITEM 12
*
ROPMOV11 L     R10,ROPMRGAM
         LR    R7,R3
         STM   R4,R7,ROPMRGAM
         LM    R3,R9,ROPMRGAU
         STM   R4,R10,ROPMRGAU
         B     IERDOBWR            BRANCH TO OUTPUT WINNER
*
*        UPDATING WHERE NEW ITEM COLLATES AFT ITEM 9 + BEFORE
*        ITEM 10
*
ROPMOV9  L     R10,ROPMRGAM
         LR    R5,R3
         STM   R4,R5,ROPMRGAM
         LM    R3,R9,ROPMRGAU
         STM   R4,R10,ROPMRGAU
         B     IERDOBWR            BRANCH TO OUTPUT WINNER
*
*        SPECIAL ITEM 12 COMPARE FOR 13 WAY MERGE
*
IERROPS4 CLC   0(1,R3),0(R7)       COMPARE NEW ITEM WITH ITEM 12
         BNE   ROPS12B             IF EQUAL GOTO EQUALS RTN
         LR    R2,R7               LOAD EQ RTN COMPARE REG WITH ITEM 12
         BASR  R14,R12             SET NETWORK RETURN REG FOR EQ RTN
*
*        THIS INSTR IS BH OR BL DEPENDING ON THE INPUT SEQUENCE
*
ROPS12B  BH    ROPMOV12            IF HI/LO GOTO UPDATE
         B     IERROC11            GOTO CMP NEW ITEM WITH ITEM 11
*
ROPLF8   LM    0,0,ROPMRGAU        LOAD NTWK REG WITH THOSE NECESSARY
*                                  RCD FROM ITEMS 1 THRU 7. INSTR IS
*                                  SET BY THE CUTBACK RTN
*
*        PARTIAL NETWORK FOR CMP NEW AGAINST ITEMS 1 THRU 7
*
ROPPNEL9 B     IERROPU4            PARTIAL NETWORK ENTR SWITCH SET BY
*                                  CUTBACK RTN
*
*        ENTRANCE FOR A 6, 7, 8 WAY MERGE
*
IERROPU4 CLC   0(1,R3),0(R7)       COMPARE NEW ITEM WITH ITEM 4
         BNE   ROP4B               IF EQUAL GOTO EQUALS RTN
         LR    R2,R7               LOAD EQ RTN COMPARE REG WITH ITEM 4
         BASR  R14,R12             SET NETWORK RETURN REG FOR EQ RTN
*
*        THIS INSTR IS BH OR BL DEPENDING ON THE INPUT SEQUENCE
*
ROP4B    BH    IERROC6             IF HI/LO GOTO CMP ITEM 6 OR 5
*
*        ENTRANCE FOR A 3,4,5 WAY MERGE
*
IERROPU2 CLC   0(1,R3),0(R5)       COMPARE NEW ITEM WITH ITEM 2
         BNE   ROP2B               IF EQUAL GOTO EQ RTN
         LR    R2,R5               LOAD EQ RTN COMPARE REG WITH ITEM 2
         BASR  R14,R12             SET NETWORK RETURN REG FOR EQ RTN
*
*        THIS INSTR IS BH OR BL DEPENDING ON THE INPUT SEQUENCE
*
ROP2B    BH    IERROC3             IF HI/LO GOTO CMP ITEM 3,4/UPDATE
*
*        ENTRANCE FOR A 2 WAY MERGE
*
IERROPU1 CLC   0(1,R3),0(R4)       COMPARE NEW ITEM WITH ITEM 1
         BNE   ROP1B               IF EQUAL GOTO EQ RTN
         LR    R2,R4               LOAD EQ RTN COMPARE REG WITH ITEM 1
         BASR  R14,R12             SET NETWORK RETURN REG FOR EQ RTN
*
*        THIS INSTR IS BH OR BL DEPENDING ON THE INPUT SEQUENCE
*
ROP1B    BH    ROPMOV1             INSERT NEW ITEM IN SEQUENCE
*
*        ENTRANCE FOR A 1 WAY MERGE AND NEW IS WINNER
*
*        IF PHASE 2 EXIT TO THE BLOCK RTN
*        IF PHASE 3 OR MERGE ONLY PERFORM SEQUENCE CHECK IF
*        REQUESTED THE ASSIGNMENT ROUTINE SETS THE BRANCH INSTR
*        ACCORDING TO THE PHASE
*
IERDOM1  NOP   ROPPH3              DROP THRU FOR PHASE 2
         L     R11,PPIBLK2+4
         B     16(,R11)            EXIT TO BLK RTN WANT NEXT RECORD
*
*        SEQUENCE CHECK OF CURRENT NETWORK WINNER AND PREVIOUS
*        NETWORK WINNER. CHECK DONE USING R3 AND R2
*
ROPPH3   ICM   R2,B'1111',PPICOUNT  RECORDS GONE THROUGH ?
         BZ    ROPOUT              NO SEQUENCE CHECK
         PPITEST PPIVSEQ           SEQUENCE CHECK OPTION ON ?
         BO    ROPSCK              YES, PERFORM SEQUENCE CHECK
*
*        NO SEQUENCE CHECK
*
ROPOUT   L     R11,PPIBLK+4        NO SEQUENCE CHECK
         B     4(,R11)             EXIT TO BLK RTN WANT NEXT RECORD
*
*        SEQUENCE CHECK
*
ROPSCK   L     R2,PPIDOOBA         R2 -> RECORD IN OUTPUT BUFFER
*
*               ___________________UPDATE BY IERAOP TO OFFSET INTO REC
*              |
*              |  _________________UPDATE BY IERAOP TO L'MAJOR CNTL FLD
*              | |
*              | |      ___________UPDATE BY IERAOP TO OFFSET INTO REC
*              | |     |
*              V V     V
IERDOSCK CLC   0(1,R3),0(R2)
         BNE   ROPSCB              IF EQUAL GOTO EQ RTN
         BASR  R14,R12             SET NETWORK RETURN REG FOR EQ RTN
*
*        THIS INSTR IS BNL OR BNH DEPENDING ON THE INPUT SEQUENCE
*
*         _________________________UPDATE BY IERAOP DEPENDING ON THE
*        |                         USER SELECTING ASCEND OR DESCEND
*        V
ROPSCB   BNL   ROPOUT              BLOCK RTN
*
*        OUT OF SEQUENCE ERROR
*
         L     R14,PPIRMC+4
         PPITEST  PPIMERGO         MERGE ONLY ?
         BO    ROPMERG             YES, BRANCH
         L     R1,IER053           R1 -> MSG TEXT
         MVC   PPIABMNO,3(R1)      MOVE MSG NO INTO ABEND NO
         LM    R0,R1,IER053        IER053A OUT OF SEQUENCE ERROR
         L     R15,PPIADSSC        R15 -> SSC
         BAS   R14,12(,R15)        CALL MSG WRITER
*
*        WRITE INFORMATION MESSAGES IDENTIFYING THE RECORDS BEING
*        COMPARED
*
         LR    R15,R2              R15 -> RECORD IN OUTPUT BUFFER
         AH    R15,PPIDD0L1        ADD OFFSET TO MAJOR CONTROL FIELD
         L     R14,PPIRMC+4        RESTORE ADDRESSABILITY
         MVC   IER053DS,=C'Out Buffer '  SET MESSAGE
         BAL   R14,FMTMAJ          FORMAT MAJOR CONTROL AND WRITE MSG
         L     R14,PPIRMC+4        RESTORE ADDRESSABILITY
         MVC   IER053DS,=C'From Merge '  SET MESSAGE
         LR    R15,R3              R15 -> RECORD FROM MERGE
         AH    R15,PPIDD0L1        ADD OFFSET TO MAJOR CONTROL FIELD
         BAL   R14,FMTMAJ          FORMAT MAJOR CONTROL AND WRITE MSG
         L     R15,PPIADSSC
         BAS   R14,16(,R15)        TERMINATE THE SORT, NO RETURN
*
ROPMERG  SRL   R3,26               CONVERT DCB INDEX TO UNIT NUMBER
         CVD   R3,ROPCONV          CONVERT INDEX TO DECIMAL
         UNPK  ROPTEMP(2),ROPCONV+6(2) UNPACK FOR PRINTING
         OI    ROPTEMP+1,X'F0'     SET SIGN POSITIVE
         MVC   IER068A,ROPTEMP     MOVE UNIT NUMBER INTO MESSAGE
         L     R1,IER068           R1 -> MSG TEXT
         MVC   PPIABMNO,3(R1)      MOVE MSG NO INTO ABEND NO
         LM    R0,R1,IER068        IER068A OUT OF SEQUENCE IN SORTIN
         L     R15,PPIADSSC        R15 -> SSC
         BAS   R14,12(,R15)        CALL MSG WRITER
         L     R15,PPIADSSC
         BAS   R14,16(,R15)        TERMINATE THE SORT, NO RETURN
*
IERROC6  CLC   0(1,R3),0(R9)       COMPARE NEW ITEM WITH ITEM 6
         BNE   ROP6B               IF EQUAL GOTO EQUALS RTN
         LR    R2,R9               LOAD EQ RTN COMPARE REG WITH ITEM 6
         BASR  R14,R12             SET NETWORK RETURN REG FOR EQ RTN
*
*        THIS INSTR IS BH OR BL DEPENDING ON THE INPUT SEQUENCE
*
ROP6B    BH    IERROC7             IF HI/LO GOTO CMP ITEM 7 OR UPDATE
IERROC5  CLC   0(1,R3),0(R8)       COMPARE NEW ITEM WITH ITEM 5
         BNE   ROP5B               IF EQ GOTO EQ RTN
         LR    R2,R8               LOAD EQ RTN CMP REG WITH ITEM 5
         BASR  R14,R12             SET NETWORK RETURN REG FOR EQ RTN
*
*        THIS INSTR IS BH OR BL DEPENDING ON THE INPUT SEQUENCE
*
ROP5B    BH    ROPMOV5             IF HI/LO NEW COLLATES AFTER ITEM 5
*
*        UPDATING WHERE NEW ITEM COLLATES AFT ITEM 4 + BEFORE
*        ITEM 5
*
ROPMOV4  LR    R8,R3
         LR    R3,R4
         STM   R5,R8,ROPMRGAU
         B     IERDOBWR            BRANCH TO OUTPUT WINNER
*
*        UPDATING WHERE NEW ITEM COLLATES AFT ITEM 5 + BEFORE
*        ITEM 6
*
ROPMOV5  LR    R9,R3
         LR    R3,R4
         STM   R5,R9,ROPMRGAU
         B     IERDOBWR            BRANCH TO OUTPUT WINNER
*
IERROC7  CLC   0(1,R3),0(R10)      COMPARE NEW ITEM WITH ITEM 7
         BNE   ROP7B               IF EQ GOTO EQ RTN
         LR    R2,R10              LOAD EQ RTN COMPARE REG WITH ITEM 7
         BASR  R14,R12             SET NETWORK RETURN REG FOR EQ RTN
*
*        THIS INSTR IS BH OR BL DEPENDING ON THE INPUT SEQUENCE
*
ROP7B    BH    ROPMOV7             IF HI/LO NEW COLLATES AFTER ITEM 7
*
*        UPDATING WHERE NEW ITEM COLLATES AFT ITEM 6 + BEFORE
*        ITEM 7
*
ROPMOV6  LR    R10,R3
         LR    R3,R4
         STM   R5,R10,ROPMRGAU
         B     IERDOBWR            BRANCH TO OUTPUT WINNER
*
*        UPDATING WHERE NEW ITEM COLLATES AFTER ITEM 7
*
ROPMOV7  ST    R3,ROPMRGAM-4
         LR    R3,R4
         STM   R5,R10,ROPMRGAU
         B     IERDOBWR            BRANCH TO OUTPUT WINNER
*
IERROC3  CLC   0(1,R3),0(R6)       COMPARE NEW ITEM WITH ITEM 3
         BNE   ROP3B               IF EQ GOTO EQ RTN
         LR    R2,R6               LOAD EQ RTN COMPARE REG WITH ITEM 3
         BASR  R14,R12             SET NETWORK RETURN REG FOR EQ RTN
*
*        THIS INSTR IS BH OR BL DEPENDING ON THE INPUT SEQUENCE
*
ROP3B    BH    ROPMOV3             INSERT NEW ITEM IN SEQUENCE
*
*        UPDATING WHERE NEW ITEM COLLATES AFT ITEM 2 + BEFORE
*        ITEM 3
*
ROPMOV2  LR    R6,R3
         LR    R3,R4
         STM   R5,R6,ROPMRGAU
         B     IERDOBWR            BRANCH TO OUTPUT WINNER
*
*        UPDATING WHERE NEW ITEM COLLATES AFT ITEM 3 + BEFORE
*        ITEM 4
*
ROPMOV3  LR    R7,R3
         LR    R3,R4
         STM   R5,R7,ROPMRGAU
         B     IERDOBWR            BRANCH TO OUTPUT WINNER
*
*        UPDATING WHERE NEW ITEM COLLATES AFT ITEM 1 + BEFORE
*        ITEM 2
*
ROPMOV1  ST    R3,ROPMRGAU
         LR    R3,R4
         B     IERDOBWR            BRANCH TO OUTPUT WINNER
*
*        SPECIAL ITEM 4 COMPARE FOR A 5 WAY MERGE
*
IERROP4S CLC   0(1,R3),0(R7)       COMPARE NEW ITEM WITH ITEM 4
         BNE   ROPS4B              IF EQ GOTO EQ RTN
         LR    R2,R7               LOAD EQ RTN COMPARE REG WITH ITEM 4
         BASR  R14,R12             SET NETWORK RETURN REG FOR EQ RTN
*
*        THIS INSTR IS BH OR BL DEPENDING ON THE INPUT SEQUENCE
*
ROPS4B   BH    ROPMOV4             IF HI/LO GOTO UPDATE
         B     IERROC3             GOTO COMPARE NEW ITEM WITH ITEM 3
*
*        THE NETWORK CUTBACK SECTION
*
*        TAILORS THE NETWORK FOR THE MERGE ORDER
*
*        THE INITIAL ENTRANCE TO THE CUTBACK SECTION
*
*        SET NETWORK FOR A 16 WAY MERGE
*
ROPCSSWM MVC   ROPNTENS(4),ROPSESC8  SET NTWK ENTR SW FOR NEW/ITM 8 CMP
         MVI   ROPLF16+1,X'4A'     LOAD NTWK REG WITH ITEMS 9 THRU 15
         MVI   ROPLF8+1,X'4A'      LOAD NETWORK REG WITH ITEMS 1 THRU 7
         MVC   ROP12B(4),ROP12SB   SET BR TO CMP ITEM 14 AFT ITEM 12
         MVC   ROP4B(4),ROPST4B    SET BR TO CMP ITEM 6 AFT ITEM 4 CMP
         MVC   ROP14B(4),ROPS14B   SET BR TO CMP ITEM 15 AFT ITEM 14
         MVC   ROP6B(4),ROPS6B     SET BR TO CMP ITEM 7 AFT ITEM 6 CMP
         MVC   ROP10B(4),ROPS10B   SET BR TO CMP ITEM 11 AFT ITEM 10
         MVC   ROP2B(4),ROPS2B     SET BR TO CMP ITEM 3 AFT ITEM 2 CMP
         MVC   ROPPNELA(4),ROPSPNS1  SET NETWORK ENTR FOR ITEMS 9 TO 15
         MVC   ROPPNEL9(4),ROPSPNS2  SET NETWORK ENTR FOR ITEMS 1 TO 7
         BAS   R2,ROPFMUDS         SAVE ADDR OF NEXT CUTBACK SECTION
*
*        SET NETWORK FOR A 15 WAY MERGE
*
         MVC   ROP14B(4),ROPFTWM   SET BR TO UPDATE AFTER ITEM 14 CMP
         MVI   ROPLF16+1,X'49'     LOAD NTWK REG WITH ITEMS 9 THRU 14
         BAS   R2,ROPFMUDS         SAVE ADDR OF NEXT CUTBACK SECTION
*
*        SET NETWORK FOR A 14 WAY MERGE
*
         MVC   ROP12B(4),ROP14WM   SET BR TO CMP ITEM 13 AFT ITEM 12
         MVI   ROPLF16+1,X'48'     LOAD NETWORK REG WITH ITEMS 9 TO 13
         BAS   R2,ROPFMUDS         SAVE ADDR OF NEXT CUTBACK SECTION
*
*        SET NETWORK FOR A 13 WAY MERGE
*
         MVC   ROP10B(4),ROP13WM   SET BR TO CMP ITEM 12 AFT ITM 10 CMP
         MVI   ROPLF16+1,X'47'     LOAD NETWORK REG WITH ITEMS 9 TO 12
         MVC   ROPPNELA(4),ROPE13WM SET NETWORK ENTR FOR A 13 WAY MERGE
         BAS   R2,ROPFMUDS         SAVE ADDR OF NEXT CUTBACK SECTION
*
*        SET NETWORK FOR A 12 WAY MERGE
*
         MVC   ROP10B(4),ROPS10B   SET BR TO CMP ITEM 11 AFT ITM 10 CMP
         MVI   ROPLF16+1,X'46'     LOAD NETWORK REG WITH ITEMS 9 TO 11
         BAS   R2,ROPFMUDS         SAVE ADDR OF NEXT CUTBACK SECTION
*
*        SET NETWORK FOR AN 11 WAY MERGE
*
         MVC   ROP10B(4),ROP11WM   SET BR TO UPDATE AFT ITEM 10 CMP
         MVI   ROPLF16+1,X'45'     LOAD NETWORK REG WITH ITEMS 9 + 10
         BAS   R2,ROPFMUDS         SAVE ADDR OF NEXT CUTBACK ADDR
*
*        SET NETWORK FOR A 10 WAY MERGE
*
         MVC   ROPPNELA(4),ROPE10WM SET NETWORK ENTR FOR A 10 WAY MRG
         MVI   ROPLF16+1,X'44'     LOAD NETWORK REG WITH ITEM 9
         BAS   R2,ROPFMUDS         SAVE ADDR OF NEXT CUTBACK SECTION
*
*        SET NETWORK FOR A 9 WAY MERGE
*
         MVC   ROPPNELA(4),ROPE9WM SET NETWORK ENTR FOR A 9 WAY MERGE
         BAS   R2,ROPFMUDS         SAVE ADDR OF NEXT CUTBACK ADDR
*
*        SET NETWORK FOR AN 8 WAY MERGE
*
         XI    ROPNTENS+1,X'F0'    SET NTWK ENTR SW FOR 8/LESS MRG ORD
         BAS   R2,ROPFMUDS         SAVE ADDR OF NEXT CUTBACK ADDR
*
*        SET NETWORK FOR A 7 WAY MERGE
*
         MVC   ROP6B(4),ROP7WM     BR TO UPDATE IF GT ITEM 7
         MVI   ROPLF8+1,X'49'      LOAD NETWORK REG WITH ITEMS 1 TO 6
         BAS   R2,ROPFMUDS         SAVE ADDR OF NEXT CUTBACK ADDR
*
*        SET NETWORK FOR A 6 WAY MERGE
*
         MVC   ROP4B(4),ROP6WM     BR TO CMP ITEM 5 IF GT ITEM 4
         MVI   ROPLF8+1,X'48'      LOAD NETWORK REG WITH ITEMS 1 TO 5
         BAS   R2,ROPFMUDS         SAVE ADDR OF NEXT CUTBACK ADDR
*
*        SET NETWORK FOR A 5 WAY MERGE
*
         MVC   ROP2B(4),ROP5WM     BR TO CMP ITEM 4 IF GT ITEM 2
         MVI   ROPLF8+1,X'47'      LOAD NETWORK REG WITH ITEMS 1 TO 4
         MVC   ROPPNEL9(4),ROPE5WM SET NETWORK ENTR FOR A 5 WAY MRG
         BAS   R2,ROPFMUDS         SAVE ADDR OF NEXT CUTBACK ADDR
*
*        SET NETWORK FOR A 4 WAY MERGE
*
         MVC   ROP2B(4),ROPS2B     BR TO CMP ITEM 3 IF GT ITEM 2
         MVI   ROPLF8+1,X'46'      LOAD NETWORK REG WITH ITEMS 1 TO 3
         BAS   R2,ROPFMUDS         SAVE ADDR OF NEXT CUTBACK ADDR
*
*        SET NETWORK FOR A 3 WAY MERGE
*
         MVC   ROP2B(4),ROP3WM     BR TO UPDATE IF GT ITEM 2
         MVI   ROPLF8+1,X'45'      LOAD NETWORK REG WITH ITEMS 1 + 2
         BAS   R2,ROPFMUDS         SAVE ADDR OF NEXT CUTBACK ADDR
*
*        SET NETWORK FOR A 2 WAY MERGE
*
         MVC   ROPPNEL9(4),ROPE2WM SET NETWORK ENTR FOR A 2 WAY MERGE
         MVI   ROPLF8+1,X'44'      LOAD NETWORK REG WITH ITEM 1
         BAS   R2,ROPFMUDS         SAVE ADDR OF NEXT CUTBACK ADDR
*
*        SET NETWORK FOR A 1 WAY MERGE
*
         MVC   ROPPNEL9(4),ROPE1WM SET NETWORK ENTR FOR A 1 WAY MERGE
         BAS   R2,ROPFMUDS         SAVE ADDR OF NEXT CUTBACK ADDR
*
*        A ZERO WAY MERGE
*
IERDOCPS NOP   ROPCPH3             FALL THRU IF PHASE 2
         L     R11,PPIBLK2+4
         BR    R11                 EXIT TO BLK RTN RELEASE BLK TO WRIT
*
ROPCPH3  L     R11,PPIBLK+4
         BR    R11                 EXIT TO BLK RTN (END OF JOB)
*
*        ENTRY TO THE CUTBACK RTN FROM READ RTN + THE ALGORITHM
*
ROPCUTEN L     R2,ROPSVCBA         SET APPROPRIATE CUTBACK SECTION ADDR
         BR    R2                  GOTO NEXT CUTBACK ADDR
*
*        COMPLETION OF A CUTBACK OPERATON
*
*        INITIALLY CHECKS FOR THE NETWORK BEING SET FOR THE
*        MERGE ORDER. SUBSEQUENTLY AN UPDATE IS EXECUTED
*
ROPFMUDS NOP   ROPFDMO             SET TO BRANCH BY INITIALIZATION RTN
*
*        FALL THRU FOR UPDATING NETWORK AFTER A CUTBACK OPERATION
*
         ST    R2,ROPSVCBA
         L     R3,ROPMRGAU
         L     R4,ROPACMO          MERGE ORDER LESS 1 MINUS 1
         S     R4,KROONE
         ST    R4,ROPACMO
         SLL   R4,2                TOTAL NO BYTES TO BE UPDATED
         EX    R4,ROPUPDT          EXECUTE MOVE INSTR
         B     IERDOBWR            BRANCH TO OUTPUT WINNER
*
ROPFDMO  L     R5,ROPIDMO          SET TO 16 BY INITIALIZATION RTN
         C     R5,ROPACMO          SET TO ACTUAL MERGE ORDER BY INITIAL
         BE    ROPSFTTU            SET FALL THRU TO UPDATE
         S     R5,KROONE
         ST    R5,ROPIDMO
         BR    R2                  BRANCH BACK TO CUTBACK RTN
*
ROPSFTTU XI    ROPFMUDS+1,X'F0'    SET ROPFMUDS BRANCH TO FALL THRU
         ST    R2,ROPSVCBA         SAVE ADDRESS OF NEXT CUTBACK CODE
         B     ROPINTSQ            GOTO INIT SEQ THE RECORDS
*
*        INITIAL SEQUENCING OF RECORDS SECTION EXECUTED AT THE
*        BEGINNING OF EACH MERGE OPERATION
*
*        A RELATIVE POSITION METHOD IS EMPLOYED FOR THE
*        SEQUENCING
*
*        THIS METHOD CAN BE DESCRIBED AS COMPARING ONE ITEM OF A
*        LIST WITH THE REMAINDER OF THE ITEMS AND, THEREBY,
*        DETERMINING ITS PROPER POSITION IN THE LIST. TO
*        ACCOMPLISH THIS A TWO AREA SYSTEM IN PPI IS UTILIZED
*
ROPINTSQ SR    R8,R8               INDEX USED TO GET ITEMS TO BE SEQD
         L     R1,ROPACMO          DETERMINES WHEN ALL ITEMS ARE SEQD
         LA    R6,PPIPDWA          BEGINNING ADDR OF RCD ADDR IN PPI
ROPRETRN L     R5,ROPACMO          USED TO CHECK WHEN AN ITEM HAS BEEN
*                                  CHECKED WITH ALL THE OTHER ITEMS
         L     R3,0(R8,R6)         THE ITEM BEING POSITIONED
         LA    R4,PPIPSVA-4        ADDR WHERE ITEM IS STORED AFT POS FD
         SR    R7,R7               INDEX USED TO COMPARE ALL OTHER ITEM
ROPANOTH L     R2,0(R7,R6)         ADDR OF ITEMS CMP TO ITEM IN R2
IERDOICP CLC   0(1,R3),0(R2)
*
*        BRANCH INSTR IS BNL OR BNH DEPENDING ON THE INPUT SEQ
*
ROPISNLH BNL   ROPHIEQ             HI/LO AND EQUAL CASE TREATED SAME
ROPDECR  LA    R7,4(,R7)
         BCT   R5,ROPANOTH         TRY NEXT ITEM
ROPCHEK  CLC   0(4,R4),KROZERO     STORAGE AREA OF ITEMS IS INITIALLY
*                                  ZERO CHECKED TO INSURE THAT ANOTHER
*                                  ITEM DOES NOT OCCUPY THIS POSITION
         BE    ROPINSRT            IF ZERO STORE ITEM
         S     R4,KROFOUR          IF EQUAL CHECK NEXT LOWER POSITION
         B     ROPCHEK             CONTINUE CHECKING FOR ZEROS
*
ROPINSRT ST    R3,0(,R4)           STORE POSITIONED ITEM
         BCT   R1,ROPINCR          IF NOT DONE GET NEXT ITEM TO POSITIN
         B     ROPOUTIS            BRANCH TO SET NETWORK ADDR
*
*        BRANCH INSTR IS BH OR BL DEPENDING ON THE INPUT SEQUENCE
*
ROPHIEQ  BH    ROPRND              IF NOT EQ INCR STORE POS POINTER
         BASR  R14,R12             SET NETWORK RETURN REG FOR EQ RTN
*
*        BRANCH INSTR IS BH OR BL DEPENDING ON THE INPUT SEQUENCE
*
ROPLOHI  BL    ROPDECR             CHECK NEXT ITEM
ROPRND   LA    R4,4(,R4)
         B     ROPDECR             DECREMENT R5 AND CHECK FOR ZEROS
*
ROPINCR  LA    R8,4(,R8)
         B     ROPRETRN            LAST COMPARE
*
*        SET NETWORK AREA WITH ADDRS OF PRIMED RECORDS
*
ROPOUTIS L     R3,PPIPSVA          SET REG WITH WINNING RECORD ADDR
         L     R4,ROPACMO
         S     R4,KROONE
         LR    R5,R4
         SLL   R4,2
         LTR   R4,R4
         BZ    ROPSTM              BYPASS NSI
         S     R4,KROONE           DET NO BYTES TO BE MOVED TO MRG ARA
         EX    R4,ROPSANW
ROPSTM   ST    R5,ROPACMO          SET ACTUAL MERGE ORDER MINUS ONE FOR
*                                  UPDATING AFTER A CUTBACK OPERATION
IERDOIP3 NOP   ROPINSP3            FALL THRU IF PHASE 2
         L     R11,PPIBLK2+4
         B     12(,R11)            EXIT TO BLK RTN WANT NEXT RECORD
*
ROPINSP3 L     R11,PPIBLK+4
         B     4(,R11)             EXIT TO BLK RTN WANT NEXT RECORD
*
*        SELF INITIALIZATION SECTION PERFORMED AT THE BEGINNING
*        OF EACH PASS OR SUB PASS
*
ROPSINIT MVC   ROPIDMO(4),KROSXTN  SET MAX MERGE ORDER TO 16
         LH    R4,PPIMRGMX         SET ACTUAL MRG ORD FROM PPI
         ST    R4,ROPACMO
         SR    R4,R4
         ST    R4,PPIPSVA
         MVC   PPIPSVA+4(60),PPIPSVA  ZERO INT SEQ STORE AREA
         XI    ROPFMUDS+1,X'F0'    SET ROPFMUDS TO BRANCH
         PPITEST  PPIPH1CO         INPUT SEQ ASCENDING OR DESCENDING ?
         BO    ROPISD              FALL THRU IF INPUT SEQ IS ASCENDING
         TM    ROP12B+1,X'20'      ROUTINE SET FOR ASCENDING ?
ROPFDSQ  BO    ROPCSSWM            IF THE ROUTINE IS SET FOR THE INPUT
*
*        FLIP BNH/BNL BRANCH CONDITION INSTRUCTION MASKS
*
         XI    ROPWHB+1,X'60'      SEQUENCE BRANCH TO THE CUTBACK
         XI    ROP12B+1,X'60'      SECTION. IF THE ROUTINE IS NOT SET
         XI    ROP10B+1,X'60'      FOR THE INPUT CHANGE THE MASK OF
         XI    ROP9B+1,X'60'       THE BRANCH ON CONDITION INSTR
         XI    ROP14B+1,X'60'
         XI    ROP13B+1,X'60'
         XI    ROP15B+1,X'60'
         XI    ROP11B+1,X'60'
         XI    ROPS12B+1,X'60'
         XI    ROP4B+1,X'60'
         XI    ROP2B+1,X'60'
         XI    ROP1B+1,X'60'
         XI    ROPSCB+1,X'60'
         XI    ROP6B+1,X'60'
         XI    ROP5B+1,X'60'
         XI    ROP7B+1,X'60'
         XI    ROP3B+1,X'60'
         XI    ROPS4B+1,X'60'
         XI    ROPISNLH+1,X'60'
         XI    ROPHIEQ+1,X'60'
         XI    ROPLOHI+1,X'60'
         XI    ROP12SB+1,X'60'
         XI    ROPST4B+1,X'60'
         XI    ROPS14B+1,X'60'
         XI    ROPS6B+1,X'60'
         XI    ROPS10B+1,X'60'
         XI    ROPS2B+1,X'60'
         XI    ROPFTWM+1,X'60'
         XI    ROP14WM+1,X'60'
         XI    ROP13WM+1,X'60'
         XI    ROP11WM+1,X'60'
         XI    ROP7WM+1,X'60'
         XI    ROP6WM+1,X'60'
         XI    ROP5WM+1,X'60'
         XI    ROP3WM+1,X'60'
         B     ROPCSSWM            BRANCH TO CUTBACK SECTION
*
*        INPUT IS IN DESCENDING ORDER
*
ROPISD   TM    ROP12B+1,X'40'      ROUTINE SET FOR DESCG ?
         B     ROPFDSQ             CHANGE BRANCHES IF NECCESSARY
*
*        FORMAT MAJOR CONTROL FIELD AND WRITE IER053 MESSAGE
*
*        INPUT -
*        R15 -> CONTROL FIELD
*        R11  - RETURN ADDR
*        IERDOSCK+1 = L'MAJOR CONTROL FIELD - 1
*
FMTMAJ   PPITEST  PPIDIAG+PPIDSIM  GENERATE DIAGNOSTIC MESSAGES ?
         BZR   R14                 NO, BYPASS MSG GENERATION
         STM   R0,R15,FMTMAJRS     SAVE REGS
         L     R14,PPIRMC+4        ADDRESSABILITY TO MESSAGE
         LA    R14,IER053DD        R14 -> MESSAGE AREA
         SR    R1,R1
         ICM   R1,B'0001',IERDOSCK+1  GET L'CONTROL FIELD FROM CLC INST
         LA    R1,1(,R1)           COUNT EACH BYTE
         CLI   IERDOSCK+1,20       L'CONTROL FIELD > 20 ?
         BL    FMTMAJA             NO, USE CURRENT LENGTH
         LA    R1,20               SET MAX LENGTH TO 20
FMTMAJA  IC    R0,0(,R15)          R0 = INPUT BYTE FROM CONTROL FIELD
         STC   R0,1(,R14)          STORE RIGHT NIBBLE
         NI    1(R14),X'0F'        MAKE ZONE X'0'
         SRL   R0,4                MOVE ZONE TO NUMERIC
         STC   R0,0(,R14)          STORE LEFT NIBBLE
         NI    0(R14),X'0F'        MAKE ZONE X'0'
         LA    R14,2(,R14)         INCR MESSAGE LOCATION
         LA    R15,1(,R15)         INCR MAJOR FIELD LOCATION
         BCT   R1,FMTMAJA          LOOP TO PROCESS NEXT BYTE
         ICM   R1,B'0001',IERDOSCK+1  GET L'CONTROL FIELD FROM CLC INST
         LA    R1,1(R1,R1)         DOUBLE IT PLUS 1
         L     R14,PPIRMC+4        RESTORE ADDRESSABILITY
         EX    R1,FMTMAJEX         TRANSLATE TO PRINTABLE CHARS
         LM    R0,R1,IER053D       IER053I MAJOR CONTROL FIELD DATA
         L     R15,PPIADSSC
         BAS   R14,12(,R15)        CALL MSG WRITER
         LM    R0,R15,FMTMAJRS     RESTORE REGS
         BR    R14                 RETURN TO CALLER
*
*        EXECUTED MOVE INSTRUCTIONS
*
ROPUPDT  MVC   ROPMRGAU(1),ROPMRGAU+4  UPDATING NETWORK ADDRESSES
ROPSANW  MVC   ROPMRGAU(1),PPIPSVA+4   SET NETWORK WITH PRIMED ADDRS
FMTMAJEX TR    IER053DD(0),HEXTAB  TRANSLATE TO PRINTABLES
*
ROPMRGAU DC    7F'0'               ADDR OF FIRST 7 RCDS FOR MRG NETWORK
ROPMRGAM DC    F'0'                ADDR OF RECORD 8 OF MRG NETWORK
ROPMRGAL DC    7F'0'               ADDR OF LAST 7 RCDS FOR MRG NETWORK
ROPSVCBA DC    F'0'                SAVE NEXT CUTBACK ADDRESS WORD
ROPIDMO  DC    F'0'                MAX MRG ORD SET BY INITIAL
ROPACMO  DC    F'0'                ACTUAL MRG ORD SET BY INITIAL
FMTMAJRS DC    16F'0'
*
KROSXTN  DC    X'00000010'         MAX MERGE ORDER
KROONE   DC    XL4'1'              CONSTANT OF ONE
KROZERO  DC    XL4'0'              CONSTANT OF ZERO
KROFOUR  DC    XL4'4'              CONSTANT OF FOUR
ROPTEMP  DC    H'0'                TEMP STORAGE FOR UNIT NUMBER
ROPCONV  DC    D'0'                CONVERSION AREA FOR UNIT NUMBER
HEXTAB   DC    C'0123456789ABCDEF'  FOR TRANSLATION TO PRINTABLES
*
ROPSESC8 NOP   ROPLF8              SET NTWK ENTR SW TO CMP NEW VS ITM 8
*
*        THESE INSTRUCTIONS ARE SET DEPENDING ON THE INPUT
*        SEQUENCE
*
ROP12SB  BH    IERROC14            BR TO CMP ITEM 14 AFT ITEM 12 CMP
ROPST4B  BH    IERROC6             BR TO CMP ITEM 6 AFT ITEM 4 CMP
ROPS14B  BH    IERROC15            BR TO CMP ITEM 15 AFT ITEM 14 CMP
ROPS6B   BH    IERROC7             BR TO CMP ITEM 7 AFT ITEM 6 CMP
ROPS10B  BH    IERROC11            BR TO CMP ITEM 11 AFT ITEM 10 CMP
ROPS2B   BH    IERROC3             BR TO CMP ITEM 3 AFT ITEM 2 CMP
ROPFTWM  BH    ROPMOV14            BR TO UPDATE IF > ITEM 14
ROP14WM  BH    IERROC13            BR TO CMP ITEM 13 AFT ITEM 12 CMP
ROP13WM  BH    IERROPS4            BR TO CMP ITEM 12 AFT ITEM 10 CMP
ROP11WM  BH    ROPMOV10            BR TO UPDATE AFT ITEM 10 CMP
ROP7WM   BH    ROPMOV6             BR TO UPDATE IF > ITEM 7
ROP6WM   BH    IERROC5             BR TO CMP ITEM 5 AFT ITEM 4 CMP
ROP5WM   BH    IERROP4S            BR TO CMP ITEM 4 IF > ITEM 2
ROP3WM   BH    ROPMOV2             BR TO UPDATE AFT ITEM 10 CMP
*
ROPSPNS1 B     IERROPL4            SET ENTR SW FOR PARTIAL NETWORK
ROPSPNS2 B     IERROPU4            SET ENTR SW FOR PARTIAL NETWORK
ROPE13WM B     IERROPL2            ENTR FOR A 11, 12, 13 WAY MRG
ROPE10WM B     IERROPL1            ENTR FOR A 10 WAY MRG
ROPE9WM  B     ROP9WMRG            ENTR FOR A 9 WAY MRG
ROPE5WM  B     IERROPU2            ENTR FOR A 3, 4, 5 WAY MRG
ROPE2WM  B     IERROPU1            ENTR FOR A 2 WAY MRG
ROPE1WM  B     IERDOM1             ENTR FOR A 1 WAY MRG
*
         LTORG
*
./ ADD NAME=IERROQ   0101-20211-20211-1200-00084-00084-00000-RELEASE 00
ROQ      TITLE 'IERROQ - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERROQ
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 2 AND 3 1-16 WAY MERGE NETWORK WITH A SINGLE
*        CONTROL FIELD
*        THE FUNCTION OF THIS MODULE IS TO MERGE FIXED OR
*        VARIABLE LENGTH RECORDS IN ASCENDING OR DECENDING
*        SEQUENCE INITIALLY IERROQ SEQUENCES THE INPUT RECORDS IN
*        THE PHASE TO PHASE INFORMATION AREA, CUTS BACK THE
*        NETWORK FOR SPECIFIED MERGE ORDER AND THEN UTILIZES A
*        BINARY INSERTION TECHNIQUE. THIS IS ACCOMPLISHED BY
*        USING THE ADDRESSES OF THE RECORDS IN REGISTERS R4 THRU
*        R10. THE LOW ORDER 3 BYTES OF THE REGISTER CONTAIN THE
*        ADDRESS OF THE RECORD. THE HIGH ORDER BYTE HAS A FILE
*        INDENTIFIER FOR THE DEBLOCK ROUTINE. R3 IS THE NEW
*        RECORD CONVEYER FROM DEBLOCK AND COMMUNICATES TO
*        BLOCK
*
*        USED AS A DSECT IN - IERAOQ
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - CALLING SEQUENCE -
*                           LA   R15,PPINETM+4
*                           BR   R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIDOOBA   PPIMRGMX
*        PPIPSVA    PPIBLK
*        PPIRMC     PPIDOUA
*        PPIPDWA    PPICNTL
*        PPIBLK2
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPIPSVA
*
*        EXTERNAL ROUTINES -
*        EXTRN IERRMC  - MESSAGE MODULE
*        EXTRN IERDR2  - PHASE TWO BLOCK ROUTINE
*        EXTRN IERDB34 - PHASE THREE BLOCK ROUTINE
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL -
*        IERDB2  - BLOCK PHASE 2
*        IERDB34 - BLOCK PHASE 3
*
*        EXITS - ERROR -
*        IERRMC - MESSAGE MODULE
*
*        TABLES/WORK AREAS - N/A
*
*        NOTES - N/A
*
IERROQ   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERROQ SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERROQI
*
*        IERRMC
*
*        THIS DSECT CONTAINS ALL OF THE MESSAGES THAT ARE
*        REQUIRED FOR PHASE 3 OR MERGE ONLY RUNNING PROGRAM
*
DIERRMC  DSECT
*
         COPY  RMCMAIN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERROQI  0101-20211-20211-1200-00814-00814-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERROQ SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERROQI
*
         USING *,R11               MODULE USING REG
         USING IERRCA,R13          R13 -> PPI
         USING DIERRMC,R14         MESSAGE MODULE
*
IERDO1   B     ROQSINIT            +00 READ PRIME ENTRY BR TO INITIAL
         B     ROQCUTEN            +04 READ + ALGTM ENTRY BR TO CUTBACK
IERDOET  B     ROQNTENS            +08 DEBLOCK FALL THRU IF EXTRACT
         L     R2,ROQSVEXA         +12 SET REG WITH EXTRACT ADDR
         ST    R3,0(,R2)           +16 ST REC ADDR IN EXTRACT POS ADDR
         LR    R0,R2
         LR    R2,R3               SET FROM AND TO REG FOR EXTRACT RTN
         LR    R3,R0
         BAS   R14,4(,R12)         EXIT TO EXTRACT ROUTINE
*
*        NETWORK ENTRANCE SWITCH
*
ROQNTENS NOP   ROQLF8              FOR MRG ORD > 8, FALL THRU
*
*        DETERMINE WHICH HALF OF MRG NTWK RCDS THE NEW RCD MUST CMP
*
         L     R2,ROQMRGAM         ADDR OF ITEM 8
IERROQWH CLC   0(1,R3),0(R2)
*
*        THIS INSTR IS BNH/BNL DEPENDING ON THE INPUT SEQUENCE
*
ROQWHB   BNH   ROQLF8              IF NEW GT / LT ITEM 8, FALL THRU
ROQLF16  LM    0,0,ROQMRGAL        LOAD NTWK REG WITH THOSE NECESSARY
*                                  RCD FROM ITEMS 9 THRU 15 INSTR IS
*                                  SET BY THE CUTBACK RTN
*
*        PARTIAL NETWORK FOR CMP NEW AGAINST ITEMS 9 THRU 15
*
ROQPNELA B     IERROQL4            PARTIAL NTWK ENTR SWITCH SET BY
*                                  CUTBACK RTN
*
*        ENTRANCE FOR A 14, 15, 16 WAY MERGE
*
IERROQL4 CLC   0(1,R3),0(R7)       COMPARE NEW ITEM WITH ITEM 12
*
*        THIS INSTR IS BH OR BL DEPENDING ON THE INPUT SEQUENCE
*
ROQ12B   BH    IERROC14            IF HI/LO GOTO CMP ITEM 14 OR 13
*
*        ENTRANCE FOR 11, 12, 13 WAY MERGE
*
IERROQL2 CLC   0(1,R3),0(R5)       COMPARE NEW ITEM WITH ITEM 10
*
*        THIS INSTR IS BH OR BL DEPENDING ON THE INPUT SEQUENCE
*
ROQ10B   BH    IERROC11            IF HI/LO GOTO CMP ITEM 11,12/ UPDAT
*
*        ENTRANCE FOR A 10 WAY MERGE
*
IERROQL1 CLC   0(1,R3),0(R4)       COMPARE NEW ITEM WITH ITEM 9
*
*        THIS INSTR IS BH OR BL DEPENDING ON THE INPUT SEQUENCE
*
ROQ9B    BH    ROQMOV9             FIT INTO COLLATING SEQUENCE
*
*        ENTRANCE FOR A 9 WAY MERGE AND NEW ITEM COLLATES AFT
*        ITEM 8
*
ROQ9WMRG LR    R2,R3
         LM    R3,R10,ROQMRGAU
         STM   R4,R10,ROQMRGAU
         ST    R2,ROQMRGAM
*
*        COMMUNICATE THE NETWORKS WINNING RECORD ADDR TO THE
*        BLOCK ROUTINE AFTER TAKING APPROPRIATE ACTION IF
*        EXTRACTING AND IF THERE IS TO BE A SEQUENCE CHECK. THE
*        PHASE AND EXTRACT SWITCHES ARE SET BY THE ASSGN RTN
*
IERROBWR NOP   IERNEXTR            IF EXTRACTING FALL THRU
IERROBB1 NOP   ROQEPH3P            FALL THRU FOR PHASE 2
         ST    R3,ROQSVEXA         SAVE EXTRACT POSITION ADDR
         L     R3,0(0,R3)          LOAD ACTUAL ADDR OF WINNING RCD
ROQBBFIS NOP   ROQISOUT            CHANGED FROM NOP TO UNCONDITIONAL
         L     R11,PPIBLK2+4
         B     16(,R11)            EXIT TO BLK RTN WANT NEXT RCD
*
ROQISOUT XI    ROQBBFIS+1,X'F0'
         L     R11,PPIBLK2+4
         B     12(,R11)            BLOCK ROUTINE
*
*        PHASE 3 + MERGE ONLY PROCEDURE IF EXTRACTING
*
ROQEPH3P L     R2,ROQSQCWD         AVAIL EXTRACT POS ADDR
         ST    R2,ROQSVEXA         SAVE AVAIL EXTRACT POS ADDR
         ST    R3,ROQSQCWD         SAVE WIN EXTRACT POS ADDR FOR SEQ CK
*
*        SWITCH SET BY INITIAL SEQUENCING RTN TO BYPASS CHK FOR
*        SEQ CHK
*
ROQFRSW1 NOP   ROQFR1              FALL THRU IF NOT FIRST RECORD
*
*        IF THE NEW RECORD IS THE WINNER, A SEQUENCE CHECK WILL
*        BE PERFORMED IF REQUESTED. IF THE NEW RECORD IS NOT THE
*        WINNER, NO SEQUENCE CHECK IS NECESSARY
*
ROQSCSW  NOP   ROQNIW              FALL THRU IF NEW IS NOT WINNER
IERXTRT1 NOP   ROQEPH3             FALL THRU IF EXTRACTING
ROQSAA   L     R3,0(,R3)           LOAD ACTUAL ADDR OF WINNING RECORD
ROQEPH3  L     R11,PPIBLK+4
         B     4(,R11)             EXIT TO BLK RTN WANT NEXT RECORD
*
ROQFR1   XI    ROQFRSW1+1,X'F0'    SET FIRST RCD SWITCH 1 TO FALL THRU
         B     ROQSAA              BRANCH TO SET ACTUAL ADDR
*
ROQNIW   XI    ROQSCSW+1,X'F0'     SET ROQSCSW TO FALL THRU
*
*        SEQUENCE CHECK OF CURRENT NETWORK WINNER AND PREVIOUS
*        NETWORK WINNER. CHECK DONE USING R3 AND R2
*
         ICM   R1,B'1111',PPICOUNT  RECORDS GONE THROUGH ?
         BZ    IERXTRT2            NO, NO SEQUENCE CHECK
         PPITEST PPIVSEQ           SEQUENCE CHECKING ?
         BO    IERDOSCK            YES, BRANCH
*
*        NO SEQUENCE CHECK
*
IERXTRT2 B     ROQSAA              IF EXTRACTING BRANCH TO ROQSAA
         B     ROQEPH3             IF NOT EXTRACTING BRANCH TO ROQEPH3
*
*               ___________________UPDATE BY IERAOU TO OFFSET INTO REC
*              |
*              |  _________________UPDATE BY IERAOU TO L'MAJOR CNTL FLD
*              | |
*              | |      ___________UPDATE BY IERAOU TO OFFSET INTO REC
*              | |     |
*              V V     V
IERDOSCK CLC   0(1,R3),0(R2)
*
*        THIS BRANCH INSTR IS BNL OR BNH DEPENDING ON THE INPUT
*        SEQUENCE
*         _________________________UPDATE BY IERAOQ DEPENDING ON THE
*        |                         USER SELECTING ASCEND OR DESCEND
*        V
ROQSCB   BNL   IERXTRT1            EXTRACT
*
*        OUT OF SEQUENCE ERROR
*
         L     R14,PPIRMC+4
         PPITEST  PPIMERGO         MERGE ?
         BO    ROQMERG             YES, BRANCH
         L     R1,IER053           R1 -> MSG TEXT
         MVC   PPIABMNO,3(R1)      MOVE MSG NO INTO ABEND NO
         LM    R0,R1,IER053        IER053A OUT OF SEQUENCE ERROR
         L     R15,PPIADSSC
         BAS   R14,12(,R15)        CALL WRITE MESSAGE
*
*        WRITE INFORMATION MESSAGE IDENTIFYING THE RECORDS BEING
*        COMPARED
*
         LR    R15,R2              R15 -> RECORD IN OUTPUT BUFFER
         AH    R15,PPIDD0L1        ADD OFFSET TO MAJOR CONTROL FIELD
         L     R14,PPIRMC+4        RESTORE ADDRESSABILITY
         MVC   IER053DS,=C'Out Buffer '  SET MESSAGE
         BAL   R14,FMTMAJ          FORMAT MAJOR CONTROL AND WRITE MSG
         L     R14,PPIRMC+4        RESTORE ADDRESSABILITY
         MVC   IER053DS,=C'From Merge '  SET MESSAGE
         LR    R15,R3              R15 -> RECORD FROM MERGE
         AH    R15,PPIDD0L1        ADD OFFSET TO MAJOR CONTROL FIELD
         BAL   R14,FMTMAJ          FORMAT MAJOR CONTROL AND WRITE MSG
         L     R15,PPIADSSC
         BAS   R14,16(,R15)        TERMINATE THE SORT
*
ROQMERG  NOP   ROQ100              FALL THRU IF EXTRACTING
         L     R3,0(,R3)           LOAD RECORD ADDR FROM EXTRACT
*                                  WORK AREA
ROQ100   SRL   R3,26               CONVERT DCB INDEX TO UNIT NUMBER
         CVD   R3,ROQCONV          CONVERT INDEX TO DECIMAL
         UNPK  ROQTEMP(2),ROQCONV+6(2)  UNPACK FOR PRINTING
         OI    ROQTEMP+1,X'F0'     SET SIGN POSITIVE
         MVC   IER068A,ROQTEMP     MOVE UNIT NUMBER INTO MESSAGE
         L     R1,IER068           R1 -> MSG TEXT
         MVC   PPIABMNO,3(R1)      MOVE MSG NO INTO ABEND NO
         LM    R0,R1,IER068        IER068A OUT OF SEQUENCE IN SORTIN
         L     R15,PPIADSSC
         BAS   R14,12(,R15)        CALL WRITE MESSAGE
         L     R15,PPIADSSC
         BAS   R14,16(,R15)        TERMINATE THE SORT
*
*        NOT EXTRACTING
*
IERNEXTR B     ROQBBFIS            IF PHASE 2 BRANCH
ROQFRSW2 NOP   ROQFR2              IF FIRST RCD BRANCH
         L     R2,PPIDOOBA         ADDR OF RCD IN OUTPUT BUFFER
         B     ROQSCSW             BRANCH TO CHK IF SEQ CHK REQUIRED
*
ROQFR2   XI    ROQFRSW2+1,X'F0'    SET FIRST RCD SW 2 TO FALL THRU
         B     ROQEPH3             BRANCH TO BLOCK RECORD
*
IERROC14 CLC   0(1,R3),0(R9)       COMPARE NEW ITEM WITH ITEM 14
*
*        THIS INSTR IS BH OR BL DEPENDING ON THE INPUT SEQUENCE
*
ROQ14B   BH    IERROC15            IF HI/LO GOTO CMP ITM 15 OR UPDATE
IERROC13 CLC   0(1,R3),0(R8)       COMPARE NEW ITEM WITH ITEM 13
*
*        THIS INSTR IS BH OR BL DEPENDING ON THE INPUT SEQUENCE
*
ROQ13B   BH    ROQMOV13            IF HI/LO NEW COLLATES AFTER ITEM 13
*
*        UPDATING WHERE NEW ITEM COLLATES AFT ITEM 12 + BEFORE
*        ITEM 13
*
ROQMOV12 L     R10,ROQMRGAM
         LR    R8,R3
         STM   R4,R8,ROQMRGAM
         LM    R3,R9,ROQMRGAU
         STM   R4,R10,ROQMRGAU
         B     IERROBWR            BRANCH TO OUTPUT WINNER
*
*        UPDATING WHERE NEW ITEM COLLATES AFT ITEM 13 + BEFORE
*        ITEM 14
*
ROQMOV13 L     R10,ROQMRGAM
         LR    R9,R3
         STM   R4,R9,ROQMRGAM
         LM    R3,R9,ROQMRGAU
         STM   R4,R10,ROQMRGAU
         B     IERROBWR            BRANCH TO OUTPUT WINNER
*
IERROC15 CLC   0(1,R3),0(R10)      COMPARE NEW ITEM WITH ITEM 15
*
*        THIS BRANCH INSTR IS BH OR BL DEPENDING ON THE INPUT
*        SEQUENCE
*
ROQ15B   BH    ROQMOV15            IF HI/LO NEW COLLATES AFTER ITEM 15
*
*        UPDATING WHERE NEW ITEM COLLATES AFT ITEM 14 + BEFORE
*        ITEM 15
*
ROQMOV14 L     R2,ROQMRGAM
         LR    R10,R3
         STM   R4,R10,ROQMRGAM
         LM    R3,R9,ROQMRGAU
         LR    R10,R2
         STM   R4,R10,ROQMRGAU
         B     IERROBWR            BRANCH TO OUTPUT WINNER
*
*        UPDATING WHERE NEW ITEM COLLATES AFTER ITEM 15
*
ROQMOV15 L     R2,ROQMRGAM
         STM   R4,R10,ROQMRGAM
         ST    R3,ROQMRGAL+24
         LR    R10,R2
         LM    R3,R9,ROQMRGAU
         STM   R4,R10,ROQMRGAU
         B     IERROBWR            BRANCH TO OUTPUT WINNER
*
IERROC11 CLC   0(1,R3),0(R6)       COMPARE NEW ITEM WITH ITEM 11
*
*        THIS INSTR IS BH OR BL DEPENDING ON THE INPUT SEQUENCE
*
ROQ11B   BH    ROQMOV11            FIT INTO COLLATING SEQUENCE
*
*        UPDATING WHERE NEW ITEM COLLATES AFT ITEM 10 + BEFORE
*        ITEM 11
*
ROQMOV10 L     R10,ROQMRGAM
         LR    R6,R3
         STM   R4,R6,ROQMRGAM
         LM    R3,R9,ROQMRGAU
         STM   R4,R10,ROQMRGAU
         B     IERROBWR            BRANCH TO OUTPUT WINNER
*
*        UPDATING WHERE NEW ITEM COLLATES AFT ITEM 11 + BEFORE
*        ITEM 12
*
ROQMOV11 L     R10,ROQMRGAM
         LR    R7,R3
         STM   R4,R7,ROQMRGAM
         LM    R3,R9,ROQMRGAU
         STM   R4,R10,ROQMRGAU
         B     IERROBWR            BRANCH TO OUTPUT WINNER
*
*        UPDATING WHERE NEW ITEM COLLATES AFT ITEM 9 + BEFORE
*        ITEM 10
*
ROQMOV9  L     R10,ROQMRGAM
         LR    R5,R3
         STM   R4,R5,ROQMRGAM
         LM    R3,R9,ROQMRGAU
         STM   R4,R10,ROQMRGAU
         B     IERROBWR            BRANCH TO OUTPUT WINNER
*
*        SPECIAL ITEM 12 COMPARE FOR 13 WAY MERGE
*
IERROQS4 CLC   0(1,R3),0(R7)       COMPARE NEW ITEM WITH ITEM 12
*
*        THIS INSTR IS BH OR BL DEPENDING ON THE INPUT SEQUENCE
*
ROQS12B  BH    ROQMOV12            IF HI/LO GOTO UPDATE
         B     IERROC11            GOTO COMPARE NEW ITEM WITH ITEM 11
*
ROQLF8   LM    0,0,ROQMRGAU        LOAD NTWK REG WITH THOSE NECESSARY
*                                  RCD FROM ITEMS 1 THRU 7. INSTR IS
*                                  SET BY THE CUTBACK RTN
*
*        PARTIAL NETWORK FOR CMP NEW AGAINST ITEMS 1 THRU 7
*
ROQPNEL9 B     IERROQU4            PARTIAL NTWK ENTR SWITCH SET BY
*                                  CUTBACK RTN
*
*        ENTRANCE FOR A 6, 7, 8 WAY MERGE
*
IERROQU4 CLC   0(1,R3),0(R7)       COMPARE NEW ITEM TO ITEM 4
*
*        THIS INSTR IS BH OR BL DEPENDING ON THE INPUT SEQUENCE
*
ROQ4B    BH    IERROC6             IF HI/ LO GOTO CMP ITEM 6 OR 5
*
*        ENTRANCE FOR A 3, 4, 5 WAY MERGE
*
IERROQU2 CLC   0(1,R3),0(R5)       COMPARE NEW ITEM WITH ITEM 2
*
*        THIS INSTR IS BH OR BL DEPENDING ON THE INPUT SEQUENCE
*
ROQ2B    BH    IERROC3             IF HI/LO GOTO CMP ITEM 3,4 / UPDATE
*
*        ENTRANCE FOR A 2 WAY MERGE
*
IERROQU1 CLC   0(1,R3),0(R4)       COMPARE NEW ITEM WITH ITEM 1
*
*        THIS INSTR IS BH OR BL DEPENDING ON THE INPUT SEQUENCE
*
ROQ1B    BH    ROQMOV1             FIT INTO COLLATING SEQUENCE
*
*        ENTRANCE FOR A 1 WAY MERGE AND NEW IS WINNER
*
ROQ1WMRG XI    ROQSCSW+1,X'F0'     SET SEQ CHK SWITCH TO YES
         B     IERROBWR            BRANCH TO OUTPUT WINNER
*
IERROC6  CLC   0(1,R3),0(R9)       COMPARE NEW ITEM WITH ITEM 6
*
*        THIS BRANCH INSTR IS BH OR BL DEPENDING ON THE INPUT
*        SEQUENCE
*
ROQ6B    BH    IERROC7             IF HI/LO GOTO CMP ITEM 7 OR UPDATE
IERROC5  CLC   0(1,R3),0(R8)       COMPARE NEW ITEM WITH ITEM 5
*
*        THIS INSTR IS BH OR BL DEPENDING ON THE INPUT SEQUENCE
*
ROQ5B    BH    ROQMOV5             IF HI/ LO NEW COLLATES AFTER ITEM 5
*
*        UPDATING WHERE NEW ITEM COLLATES AFT ITEM 4 + BEFORE
*        ITEM 5
*
ROQMOV4  LR    R8,R3
         LR    R3,R4
         STM   R5,R8,ROQMRGAU
         B     IERROBWR            BRANCH TO OUTPUT WINNER
*
*        UPDATING WHERE NEW ITEM COLLATES AFT ITEM 5 + BEFORE
*        ITEM 6
*
ROQMOV5  LR    R9,R3
         LR    R3,R4
         STM   R5,R9,ROQMRGAU
         B     IERROBWR            BRANCH TO OUTPUT WINNER
*
IERROC7  CLC   0(1,R3),0(R10)      COMPARE NEW ITEM WITH ITEM 7
*
*        THIS INSTR IS BH OR BL DEPENDING ON THE INPUT SEQUENCE
*
ROQ7B    BH    ROQMOV7             IF HI/LO NEW COLLATES AFTER ITEM 7
*
*        UPDATING WHERE NEW ITEM COLLATES AFT ITEM 6 + BEFORE
*        ITEM 7
*
ROQMOV6  LR    R10,R3
         LR    R3,R4
         STM   R5,R10,ROQMRGAU
         B     IERROBWR            BRANCH TO OUTPUT WINNER
*
*        UPDATING WHERE NEW ITEM COLLATES AFTER ITEM 7
*
ROQMOV7  ST    R3,ROQMRGAM-4
         LR    R3,R4
         STM   R5,R10,ROQMRGAU
         B     IERROBWR            BRANCH TO OUTPUT WINNER
*
IERROC3  CLC   0(1,R3),0(R6)       COMPARE NEW ITEM WITH ITEM 3
*
*        THIS INSTR IS BH OR BL DEPENDING ON THE INPUT SEQUENCE
*
ROQ3B    BH    ROQMOV3             FIT INTO COLLATING SEQUENCE
*
*        UPDATING WHERE NEW ITEM COLLATES AFT ITEM 2 + BEFORE
*        ITEM 3
*
ROQMOV2  LR    R6,R3
         LR    R3,R4
         STM   R5,R6,ROQMRGAU
         B     IERROBWR            BRANCH TO OUTPUT WINNER
*
*        UPDATING WHERE NEW ITEM COLLATES AFT ITEM 3 + BEFORE
*        ITEM 4
*
ROQMOV3  LR    R7,R3
         LR    R3,R4
         STM   R5,R7,ROQMRGAU
         B     IERROBWR            BRANCH TO OUTPUT WINNER
*
*        UPDATING WHERE NEW ITEM COLLATES AFT ITEM 1 + BEFORE
*        ITEM 2
*
ROQMOV1  ST    R3,ROQMRGAU
         LR    R3,R4
         B     IERROBWR            BRANCH TO OUTPUT WINNER
*
*        SPECIAL ITEM 4 COMPARE FOR 5 WAY MERGE
*
IERROQ4S CLC   0(1,R3),0(R7)       COMPARE NEW ITEM WITH ITEM 4
*
*        THIS INSTR IS BH OR BL DEPENDING ON THE INPUT SEQUENCE
*
ROQS4B   BH    ROQMOV4             IF HI/LO GOTO UPDATE
         B     IERROC3             GOTO COMPARE NEW ITEM WITH ITEM 3
*
*        NETWORK CUTBACK SECTION
*        TAILOR THE NETWORK FOR THE MERGE ORDER
*
*        INITIAL ENTRANCE TO THE CUTBACK SECTION
*
*        SET NETWORK FOR A 16 WAY MERGE
*
ROQCSSWM MVC   ROQNTENS(4),ROQSESC8  SET NTWK ENTR SW FOR NEW/ITM 8 CMP
         MVI   ROQLF16+1,X'4A'     LOAD NTWK REG WITH ITEMS 9 THRU 15
         MVI   ROQLF8+1,X'4A'      LOAD NTWK REG WITH ITEMS 1 THRU 7
         MVC   ROQ12B(4),ROQ12SB   SET BR TO CMP ITEM 14 AFT ITEM 12
         MVC   ROQ4B(4),ROQST4B    SET BR TO CMP ITEM 6 AFT ITEM 4 CMP
         MVC   ROQ14B(4),ROQS14B   SET BR TO CMP ITEM 15 AFT ITEM 14
         MVC   ROQ6B(4),ROQS6B     SET BR TO CMP ITEM 7 AFT ITEM 6 CMP
         MVC   ROQ10B(4),ROQS10B   SET BR TO CMP ITEM 11 AFT ITEM 10
         MVC   ROQ2B(4),ROQS2B     SET BR TO CMP ITEM 3 AFT ITEM 2 CMP
         MVC   ROQPNELA(4),ROQSPNS1  SET NTWK ENTRANCE FOR ITMS 9 TO 15
         MVC   ROQPNEL9(4),ROQSPNS2  SET NTWK ENTRANCE FOR ITMS 1 TO 7
         BAS   R2,ROQFMUDS         SAVE ADDR OF NEXT CUTBACK SECTION
*
*        SET NETWORK FOR A 15 WAY MERGE
*
         MVC   ROQ14B(4),ROQFTWM   SET BR TO UPDATE AFTER ITEM 14 CMP
         MVI   ROQLF16+1,X'49'     LOAD NTWK REG WITH ITEMS 9 THRU 14
         BAS   R2,ROQFMUDS         SAVE ADDR OF NEXT CUTBACK SECTION
*
*        SET NETWORK FOR A 14 WAY MERGE
*
         MVC   ROQ12B(4),ROQ14WM   SET BR TO CMP ITEM 13 AFT ITEM 12
         MVI   ROQLF16+1,X'48'     LOAD NTWK REG WITH ITEMS 9 TO 13
         BAS   R2,ROQFMUDS         SAVE ADDR OF NEXT CUTBACK SECTION
*
*        SET NETWORK FOR A 13 WAY MERGE
*
         MVC   ROQ10B(4),ROQ13WM   SET BR TO CMP ITEM 12 AFT ITM 10 CMP
         MVI   ROQLF16+1,X'47'     LOAD NTWK REG WITH ITEMS 9 TO 12
         MVC   ROQPNELA(4),ROQE13WM  SET NTWK ENTR FOR A 13 WAY MERGE
         BAS   R2,ROQFMUDS         SAVE ADDR OF NEXT CUTBACK SECTION
*
*        SET NETWORK FOR A 12 WAY MERGE
*
         MVC   ROQ10B(4),ROQS10B   SET BR TO CMP ITEM 11 AFT ITM 10 CMP
         MVI   ROQLF16+1,X'46'     LOAD NTWK REG WITH ITEMS 9 TO 11
         BAS   R2,ROQFMUDS         SAVE ADDR OF NEXT CUTBACK SECTION
*
*        SET NETWORK FOR AN 11 WAY MERGE
*
         MVC   ROQ10B(4),ROQ11WM   SET BR TO UPDATE AFT ITEM 10 CMP
         MVI   ROQLF16+1,X'45'     LOAD NTWK REG WITH ITEMS 9 + 10
         BAS   R2,ROQFMUDS         SAVE ADDR OF NEXT CUTBACK ADDR
*
*        SET NETWORK FOR A 10 WAY MERGE
*
         MVC   ROQPNELA(4),ROQE10WM SET NTWK ENTR FOR A 10 WAY MRG
         MVI   ROQLF16+1,X'44'     LOAD NTWK REG WITH ITEM 9
         BAS   R2,ROQFMUDS         SAVE ADDR OF NEXT CUTBACK ADDR
*
*        SET NETWORK FOR A 9 WAY MERGE
*
         MVC   ROQPNELA(4),ROQE9WM SET NTWK ENTR FOR A 9 WAY MERGE
         BAS   R2,ROQFMUDS         SAVE ADDR OF NEXT CUTBACK ADDR
*
*        SET NETWORK FOR AN 8 WAY MERGE
*
         XI    ROQNTENS+1,X'F0'    SET NTWK ENTR SW FOR 8/LESS MRG ORD
         BAS   R2,ROQFMUDS         SAVE ADDR OF NEXT CUTBACK ADDR
*
*        SET NETWORK FOR A 7 WAY MERGE
*
         MVC   ROQ6B(4),ROQ7WM     BR TO UPDATE IF GT ITEM 7
         MVI   ROQLF8+1,X'49'      LOAD NTWK REG WITH ITEMS 1 TO 6
         BAS   R2,ROQFMUDS         SAVE ADDR OF NEXT CUTBACK ADDR
*
*        SET NETWORK FOR A 6 WAY MERGE
*
         MVC   ROQ4B(4),ROQ6WM     BR TO CMP ITEM 5 IF GT ITEM 4
         MVI   ROQLF8+1,X'48'      LOAD NETWORK REG WITH ITEMS 1 TO 5
         BAS   R2,ROQFMUDS         SAVE ADDR OF NEXT CUTBACK ADDR
*
*        SET NETWORK FOR A 5 WAY MERGE
*
         MVC   ROQ2B(4),ROQ5WM     BR TO CMP ITEM 4 IF GT ITEM 2
         MVI   ROQLF8+1,X'47'      LOAD NTWK REG WITH ITEMS 1 TO 4
         MVC   ROQPNEL9(4),ROQE5WM SET NTWK ENTR FOR A 5 WAY MRG
         BAS   R2,ROQFMUDS         SAVE ADDR OF NEXT CUTBACK ADDR
*
*        SET NETWORK FOR A 4 WAY MERGE
*
         MVC   ROQ2B(4),ROQS2B     BR TO CMP ITEM 3 IF GT ITEM 2
         MVI   ROQLF8+1,X'46'      LOAD NTWK REG WITH ITEMS 1 TO 3
         BAS   R2,ROQFMUDS         SAVE ADDR OF NEXT CUTBACK ADDR
*
*        SET NETWORK FOR A 3 WAY MERGE
*
         MVC   ROQ2B(4),ROQ3WM     BR TO UPDATE IF GT ITEM 2
         MVI   ROQLF8+1,X'45'      LOAD NTWK REG WITH ITEMS 1 + 2
         BAS   R2,ROQFMUDS         SAVE ADDR OF NEXT CUTBACK ADDR
*
*        SET NETWORK FOR A 2 WAY MERGE
*
         MVC   ROQPNEL9(4),ROQE2WM SET NTWK ENTR FOR A 2 WAY MERGE
         MVI   ROQLF8+1,X'44'      LOAD NTWK REG WITH ITEM 1
         BAS   R2,ROQFMUDS         SAVE ADDR OF NEXT CUTBACK ADDR
*
*        SET NETWORK FOR A 1 WAY MERGE
*
         MVC   ROQPNEL9(4),ROQE1WM SET NTWK ENTR FOR A 1 WAY MERGE
         BAS   R2,ROQFMUDS         SAVE ADDR OF NEXT CUTBACK ADDR
*
*        A ZERO WAY MERGE
*
*        PHASE 2 - EXIT TO THE BLOCK RTN (RELEASE CURRENT BLK TO WRITE)
*        PHASE 3 OR MERGE ONLY - EXIT TO THE BLOCK RTN (END OF JOB)
*
IERDOCPS NOP   ROQCPH3             FALL THRU IF PHASE 2
         L     R11,PPIBLK2+4
         BR    R11                 BLOCK/DEBLOCK
*
ROQCPH3  L     R11,PPIBLK+4
         BR    R11                 BLOCK
*
*        ENTRY TO THE CUTBACK RTN FROM READ RTN + THE ALGORITHM
*
ROQCUTEN L     R2,ROQSVCBA         SET APPROPRIATE CUTBACK SECTION ADDR
         BR    R2                  NEXT WORD OF CUTBACK
*
*        ENTRY UPON COMPLETION OF A CUTBACK OPERATION
*        CHECK FOR THE NETWORK BEING SET FOR THE MERGE ORDER.
*        SUBSEQUENTLY AN UPDATE IS EXECUTED
*
ROQFMUDS NOP   ROQFDMO             SET TO BRANCH BY INITIALIZATION RTN
*
*        FALL THRU FOR UPDATING NETWORK AFTER A CUTBACK OPERATION
*
         ST    R2,ROQSVCBA
         L     R3,ROQMRGAU
         L     R4,ROQACMO          MERGE ORDER LESS 1 MINUS 1
         S     R4,KROONE
         ST    R4,ROQACMO
         SLL   R4,2                TOTAL NO BYTES TO BE UPDATED
         EX    R4,ROQUPDT          EXECUTE MOVE INSTR
         B     IERROBWR            BRANCH TO OUTPUT WINNER
*
ROQFDMO  L     R5,ROQIDMO          SET TO 16 BY INITIALIZATION RTN
         C     R5,ROQACMO          SET TO ACTUAL MERGE ORDER BY INITIAL
         BE    ROQSFTTU            SET FALL THRU TO UPDATE
         S     R5,KROONE
         ST    R5,ROQIDMO
         BR    R2                  BRANCH BACK TO CUTBACK RTN
*
ROQSFTTU XI    ROQFMUDS+1,X'F0'    SET ROQFMUDS BRANCH TO FALL THRU
         ST    R2,ROQSVCBA         SAVE ADDR OF NEXT CUTBACK CODE
         B     ROQINTSQ            GOTO INIT SEQ THE RECORDS
*
*        INITIAL SEQUENCING OF RECORDS SECTION EXECUTED AT THE
*        BEGINNING OF EACH MERGE OPERATION
*
*        A RELATIVE POSITION METHOD IS EMPLOYED FOR THE
*        SEQUENCING
*        THIS METHOD CAN BE DESCRIBED AS COMPARING ONE ITEM OF A
*        LIST WITH THE REMAINDER OF THE ITEMS THEREBY
*        DETERMINING ITS PROPER POSITION IN THE LIST. TO
*        ACCOMPLISH THIS A TWO AREA SYSTEM IN PPI IS UTILIZED
*
ROQINTSQ SR    R8,R8               INDEX USED TO GET ITEMS TO BE SEQD
         L     R1,ROQACMO          DETERMINES WHEN ALL ITEMS ARE SEQD
         LA    R6,PPIPDWA          BEGINNING ADDR OF RCD ADDR IN PPI
ROQRETRN L     R5,ROQACMO          USED TO CHECK WHEN AN ITEM HAS BEEN
*                                  CHECKED WITH ALL THE OTHER ITEMS
         L     R3,0(R8,R6)         THE ITEM BEING POSITIONED
         LA    R4,PPIPSVA-4        ADDR WHERE ITEM IS STORED AFT POS FD
         SR    R7,R7               INDEX USED TO COMPARE ALL OTHER ITEM
ROQANOTH L     R2,0(R7,R6)         ADDR OF ITEMS CMP TO ITEM IN R2
IERDOICP CLC   0(1,R3),0(R2)
*
*        THIS BRANCH INSTR IS BNL OR BNH DEPENDING ON THE INPUT
*        SEQUENCE
*
ROQISNLH BNL   ROQHIEQ             HI/LO AND EQUAL CASE TREATED SAME
ROQDECR  LA    R7,4(,R7)
         BCT   R5,ROQANOTH         DECREMENT MERGE ORDER
ROQCHEK  CLC   0(4,R4),KROZERO     STORAGE AREA OF ITEMS IS INITIALLY
*                                  ZERO CHECKED TO INSURE THAT ANOTHER
*                                  ITEM DOES NOT OCCUPY THIS POSITION
         BE    ROQINSRT            ZERO, STORE ITEM
         S     R4,KROFOUR          IF EQUAL CHECK NEXT LOWER POSITION
         B     ROQCHEK             CHECK NEXT ITEM
*
ROQINSRT ST    R3,0(,R4)           STORE POSITIONED ITEM
         BCT   R1,ROQINCR          LOOP, GET NEXT ITEM TO POSITION
         B     ROQOUTIS            BRANCH TO SET NETWORK ADDR
*
ROQHIEQ  LA    R4,4(,R4)
         B     ROQDECR             GOTO DECREMENT MERGE ORDER
*
ROQINCR  LA    R8,4(,R8)
         B     ROQRETRN            BRANCH FOR END OF COMPARE
*
*        SET NETWORK AREA WITH ADDRS OF PRIMED RECORDS
*
ROQOUTIS L     R3,PPIPSVA          SET REG WITH WINNING RECORD ADDR
         L     R4,ROQACMO
         S     R4,KROONE
         LR    R5,R4
         SLL   R4,2
         LTR   R4,R4
         BZ    ROQSTM              ZERO, BYPASS NSI
         S     R4,KROONE           DET NO BYTES TO BE MOVED TO MRG ARA
         EX    R4,ROQSANW          EXECUTE MOVE OF ADDR TO MOVE AREA
ROQSTM   ST    R5,ROQACMO          SET ACTUAL MERGE ORDER MINUS ONE FOR
*                                  UPDATING AFTER A CUTBACK OPERATION
         XI    ROQFRSW1+1,X'F0'    SETTING OF FIRST RCD SW TO BRANCH
         XI    ROQFRSW2+1,X'F0'
         XI    ROQBBFIS+1,X'F0'
         B     IERROBWR            BRANCH TO OUTPUT WINNER
*
*        SELF INITIALIZATION SECTION PERFORMED AT THE BEGINNING
*        OF EACH PASS OR SUB PASS
*
ROQSINIT MVC   ROQIDMO(4),KROSXTN  SET MAX MERGE ORDER TO 16
         LH    R4,PPIMRGMX         SET ACTUAL MRG ORD FROM PPI
         ST    R4,ROQACMO
         SR    R4,R4
         ST    R4,PPIPSVA
         MVC   PPIPSVA+4(60),PPIPSVA   ZERO INT SEQ STORE AREA
         XI    ROQFMUDS+1,X'F0'    SET ROQFMUDS TO BRANCH
         PPITEST  PPIPH1CO         INPUT SEQ DESCENDING ?
         BO    ROQISD              FALL THRU IF INPUT SEQ IS ASCENDING
         TM    ROQ12B+1,X'20'      ROUTINE SET FOR ASDNG ?
ROQFDSQ  BO    IERDOSET            THE ROUTINE IS SET FOR THE INPUT
         XI    ROQWHB+1,X'60'      SEQUENCE, BRANCH TO EXTRACT TEST. IF
         XI    ROQ12B+1,X'60'      THE ROUTINE IS NOT SET FOR THE INPUT
         XI    ROQ10B+1,X'60'      CHANGE THE MASK OF THE BRANCH ON
         XI    ROQ9B+1,X'60'       CONDITION INSTR
         XI    ROQSCB+1,X'60'
         XI    ROQ14B+1,X'60'
         XI    ROQ13B+1,X'60'
         XI    ROQ15B+1,X'60'
         XI    ROQ11B+1,X'60'
         XI    ROQS12B+1,X'60'
         XI    ROQ4B+1,X'60'
         XI    ROQ2B+1,X'60'
         XI    ROQ1B+1,X'60'
         XI    ROQ6B+1,X'60'
         XI    ROQ5B+1,X'60'
         XI    ROQ7B+1,X'60'
         XI    ROQ3B+1,X'60'
         XI    ROQS4B+1,X'60'
         XI    ROQISNLH+1,X'60'
         XI    ROQ12SB+1,X'60'
         XI    ROQST4B+1,X'60'
         XI    ROQS14B+1,X'60'
         XI    ROQS6B+1,X'60'
         XI    ROQS10B+1,X'60'
         XI    ROQS2B+1,X'60'
         XI    ROQFTWM+1,X'60'
         XI    ROQ14WM+1,X'60'
         XI    ROQ13WM+1,X'60'
         XI    ROQ11WM+1,X'60'
         XI    ROQ7WM+1,X'60'
         XI    ROQ6WM+1,X'60'
         XI    ROQ5WM+1,X'60'
         XI    ROQ3WM+1,X'60'
IERDOSET NOP   ROQCSSWM            FALL THRU IF EXTRACTING
*                                  IF NOT EXTRACTING, GOTO CUTBACK CODE
         LM    R3,R4,IERDOAGE      ADDR + LGH OF EXTRACT INFO
         LA    R10,PPIPDWA         ADDR OF RCDS IN PPI
         L     R6,KROONE           INDEX TO DETERMINE WHEN DONE
         LR    R8,R6
         L     R9,ROQACMO
ROQRLD   L     R2,0(,R10)          SET FROM ADDR FOR EXTR RTN
         STM   R4,R10,ROQSVREG     SAVE MERGE REG
         BAS   R14,4(,R12)         EXTRACT THIS RECORD
         LM    R4,R10,ROQSVREG     RESTORE MERGE REG
         ST    R2,0(,R3)           STORE ADDR OF RCD AT EXTR POS
         ST    R3,0(,R10)          STORE EXTR POS ADDR IN PPIPDWA AREA
         AR    R3,R4               INCR EXTR POS LENGTH
         A     R10,KROFOUR         INCR TO NEXT RCD ADDR IN PPIPDWA
         BXLE  R6,R8,ROQRLD        DONE EXTR THE RCDS IN PPIPDWA ?
         ST    R3,ROQSQCWD         SAVE NEXT EXTR POS ADDR
         B     ROQCSSWM            BRANCH TO CUTBACK SECTION
*
*        THE INPUT SEQUENCE IS IN DESCENDING ORDER
*
ROQISD   TM    ROQ12B+1,X'40'      ROUTINE SET FOR DESCG ?
         B     ROQFDSQ             GOTO CHANGE BRANCHES
*
*        FORMAT MAJOR CONTROL FIELD AND WRITE IER053 MESSAGE
*
*        INPUT -
*        R15 -> CONTROL FIELD
*        R11  - RETURN ADDR
*        IERDOSCK+1 = L'MAJOR CONTROL FIELD - 1
*
FMTMAJ   PPITEST  PPIDIAG+PPIDSIM  GENERATE DIAGNOSTIC MESSAGES ?
         BZR   R14                 NO, BYPASS MSG GENERATION
         STM   R0,R15,FMTMAJRS     SAVE REGS
         L     R14,PPIRMC+4        ADDRESSABILITY TO MESSAGE
         LA    R14,IER053DD        R14 -> MESSAGE AREA
         SR    R1,R1
         ICM   R1,B'0001',IERDOSCK+1  GET L'CONTROL FIELD FROM CLC INST
         LA    R1,1(,R1)           COUNT EACH BYTE
         CLI   IERDOSCK+1,20       L'CONTROL FIELD > 20 ?
         BL    FMTMAJA             NO, USE CURRENT LENGTH
         LA    R1,20               SET MAX LENGTH TO 20
FMTMAJA  IC    R0,0(,R15)          R0 = INPUT BYTE FROM CONTROL FIELD
         STC   R0,1(,R14)          STORE RIGHT NIBBLE
         NI    1(R14),X'0F'        MAKE ZONE X'0'
         SRL   R0,4                MOVE ZONE TO NUMERIC
         STC   R0,0(,R14)          STORE LEFT NIBBLE
         NI    0(R14),X'0F'        MAKE ZONE X'0'
         LA    R14,2(,R14)         INCR MESSAGE LOCATION
         LA    R15,1(,R15)         INCR MAJOR FIELD LOCATION
         BCT   R1,FMTMAJA          LOOP TO PROCESS NEXT BYTE
         ICM   R1,B'0001',IERDOSCK+1  GET L'CONTROL FIELD FROM CLC INST
         LA    R1,1(R1,R1)         DOUBLE IT PLUS 1
         L     R14,PPIRMC+4        RESTORE ADDRESSABILITY
         EX    R1,FMTMAJEX         TRANSLATE TO PRINTABLE CHARS
         LM    R0,R1,IER053D       IER053I MAJOR CONTROL FIELD DATA
         L     R15,PPIADSSC
         BAS   R14,12(,R15)        CALL MSG WRITER
         LM    R0,R15,FMTMAJRS     RESTORE REGS
         BR    R14                 RETURN TO CALLER
*
*        EXECUTED MOVE INSTRUCTIONS
*
ROQUPDT  MVC   ROQMRGAU(1),ROQMRGAU+4  UPDATING NETWORK ADDRS
ROQSANW  MVC   ROQMRGAU(1),PPIPSVA+4   SET NETWORK WITH PRIMED ADDRS
FMTMAJEX TR    IER053DD(0),HEXTAB  TRANSLATE TO PRINTABLES
*
ROQSVREG DC    7F'0'               REGISTER SAVE AREA FOR INTERFACING
ROQMRGAU DC    7F'0'               ADDR OF FIRST 7 RCDS FOR MRG NTWK
ROQMRGAM DC    F'0'                ADDR OF RECORD 8 OF MRG NTWK
ROQMRGAL DC    7F'0'               ADDR OF LAST 7 RCDS FOR MRG NTWK
ROQSVEXA DC    F'0'                SAVE AREA FOR ADDR OF EXTR POS
ROQSQCWD DC    F'0'                WORD TO SAVE ADDR OF EXTRACT POS
*                                  OF RCD FOR SEQUENCE CHECK
ROQSVCBA DC    F'0'                SAVE NEXT CUTBACK ADDR WORD
IERDOAGE DC    F'0'                BEGIN ADDR FOR GENERATED EXTRACT POS
IERDOEXL DC    F'0'                LGH OF EXTR CTRL FLDS + 4 ADDR BYTES
ROQIDMO  DC    F'0'                MAXIMUM MERGE ORDER SET BY INITIAL
ROQACMO  DC    F'0'                ACTUAL MERGE ORDER SET BY INITIAL
*
KROSXTN  DC    X'00000010'         MAXIMUM MERGE ORDER
KROONE   DC    XL4'1'              CONSTANT OF ONE
KROZERO  DC    XL4'0'              CONSTANT OF ZERO
KROFOUR  DC    XL4'4'              CONSTANT OF FOUR
ROQTEMP  DC    H'0'                TEMP STORAGE FOR UNIT NUMBER
ROQCONV  DC    D'0'                CONVERSION AREA FOR UNIT NUMBER
FMTMAJRS DC    16F'0'
*
ROQSESC8 NOP   ROQLF8              SET NTWK ENTR SW TO CMP NEW VS ITM 8
*
*        THE FOLLOWING 14 INSTR ARE SET DEPENDING ON THE INPUT
*        SEQUENCE TO BH OR BL
*
ROQ12SB  BH    IERROC14            BR TO CMP ITEM 14 AFT ITEM 12 CMP
ROQST4B  BH    IERROC6             BR TO CMP ITEM 6 AFT ITEM 4 CMP
ROQS14B  BH    IERROC15            BR TO CMP ITEM 15 AFT ITEM 14 CMP
ROQS6B   BH    IERROC7             BR TO CMP ITEM 7 AFT ITEM 6 CMP
ROQS10B  BH    IERROC11            BR TO CMP ITEM 11 AFT ITEM 10 CMP
ROQS2B   BH    IERROC3             BR TO CMP ITEM 3 AFT ITEM 2 CMP
ROQFTWM  BH    ROQMOV14            BR TO UPDATE IF GT ITEM 14
ROQ14WM  BH    IERROC13            BR TO CMP ITEM 13 AFT ITEM 12 CMP
ROQ13WM  BH    IERROQS4            BR TO CMP ITEM 12 AFT ITEM 10 CMP
ROQ11WM  BH    ROQMOV10            BR TO UPDATE AFT ITEM 10 CMP
ROQ7WM   BH    ROQMOV6             BR TO UPDATE IF GT ITEM 7
ROQ6WM   BH    IERROC5             BR TO CMP ITEM 5 AFT ITEM 4 CMP
ROQ5WM   BH    IERROQ4S            BR TO CMP ITEM 4 IF GT ITEM 2
ROQ3WM   BH    ROQMOV2             BR TO UPDATE AFT ITEM 10 CMP
*
ROQSPNS1 B     IERROQL4            SET ENTRANCE SW FOR PARTIAL NTWK
ROQSPNS2 B     IERROQU4            SET ENTRANCE SW FOR PARTIAL NTWK
ROQE13WM B     IERROQL2            ENTRANCE FOR A 11,12,13 WAY MRG
ROQE10WM B     IERROQL1            ENTRANCE FOR A 10 WAY MERGE
ROQE9WM  B     ROQ9WMRG            ENTRANCE FOR A 9 WAY MERGE
ROQE5WM  B     IERROQU2            ENTRANCE FOR A 3,4,5 WAY MERGE
ROQE2WM  B     IERROQU1            ENTRANCE FOR A 2 WAY MRG
ROQE1WM  B     ROQ1WMRG            ENTRANCE FOR A 1 WAY MRG
*
HEXTAB   DC    C'0123456789ABCDEF'  FOR TRANSLATION TO PRINTABLES
*
         LTORG
*
./ ADD NAME=IERROR   0101-20211-20211-1200-00106-00106-00000-RELEASE 00
ROR      TITLE 'IERROR - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERROR
*
*        MODULE FUNCTION/OPERATION -
*        MERGE PHASE BALANCED TAPE ALGORITM
*        THE FUNCTION OF THIS MODULE IS TO CONTROL -
*        A. POINTERS FOR OUTPUT UNITS DURING MERGE
*        B. COUNTERS CONTROLLING TAPE TABLE
*        C. NUMBER OF STRINGS PUT OUT
*        D. SET OPEN AND CLOSE BITS FOR DCB'S
*        E. CHECKING FOR NMAX EXCEEDED OR UNENDING MERGE. IF
*           CONDITIONS OCCUR IT ISSUES A MESSAGE AND RETURNS
*           TO SORT SYSTEM CONTROL
*        F. SUPPLYING DISPLACEMENT TO DCB TABLE
*        G. DECIDES IF PHASE 2 OR TO GOTO PHASE 3
*           1 IF STILL PHASE TWO AND END OF PASS IT TURNS OFF
*             SWITCHES THAT CONTROL BLOCKING DIRECTION AND
*             REWINDING
*           2 IF STILL PHASE TWO AND END OF PASS AND READ
*             FORWARD LATER BIT IS ON IT SETS READ FORWARD SWITCH
*             ON AND REWIND ON
*           3 IF STILL PHASE TWO AND END OF PASS AND PHASE 3
*             SEQUENCE WOULD BE IN WRONG ORDER AND WITHIN TWO
*             PASSES OF END OF PHASE 2, IT TURNS ON BLOCK FORWARD
*             AND READ FORWARD LATER SWITCHES
*
*        USED AS A DSECT IN - IERAOR
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM IERRPD
*                       CALLING SEQUENCE -
*                           LA   R11,PPIALG+4
*                           B    DISP(,R11
*                                DISP = O FOR DUMMY LINK TO
*                                         READ PRIME
*                                     = 4 FOR END OF VOL AND
*                                         NOT END OF SEQ
*                                     = 8 FOR END OF VOL AND
*                                         END OF SEQUENCE
*                                     =16 FOR END OF SEQ
*
*                     - ENTRY FROM IERRGB
*                       CALLING SEQUENCE -
*                           LA   R11,PPIALG+4
*                           BAL  R14,12(,R11) LOAD POINT REACHED
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIRD     PPIADSSC   PPIMRGMX
*        PPICNTL   PPIWRT     PPIMRGAL
*        PPISEQCT
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPICNTL   PPIMRGAL   PPISEQCT
*        PPIDEPHO  PPIMRGMX
*
*        EXTERNAL ROUTINES -
*        EXTRN IERRMB - MESSAGE PROGRAM
*        EXTRN IERRGB - READ PROGRAM
*        EXTRN IERRGB - WRITE PPOGRAM
*        EXTRN IERRCV - CONTROL PROGRAM
*
*        EXTERNAL PARAMETERS - NONE
*
*        EXITS - NORMAL -
*        IERRCV - LOAD END OF PHASE EXIT IN CALLER
*        IERRGB - READ PROGRAM USED AT PRIMING AND LOAD POINT RETURN
*        IERRPD - WRITE PROGRAM
*
*        EXITS - ERROR -
*        IERRCV - ERROR EXITS AFTER NMAX EXCEEDED OR UNENDING
*        MERGE MESSAGES
*
*        TABLES/WORK AREAS - N/A
*
*        NOTES - NONE
*
IERROR   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERROR SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRORI
*
*        IERRMB
*
*        THIS DSECT CONTAINS ALL OF THE MESSAGES THAT ARE
*        REQUIRED FOR PHASE 2 RUNNING PROGRAM
*
DIERRMB  DSECT
*
         COPY  RMBMAIN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERRORI  0101-20211-20211-1200-00266-00266-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERROR SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERRORI
*
         USING *,R11
         USING IERRCA,R13
*
IERDOT   B     RORSKIP             +00
         B     RORNLST             +04
         B     RORLST              +08
         B     RORLDPT             +12
ROREOSQ  L     R4,PPISEQCT+4       +16 END OF SEQUENCE - ENTRY
         LA    R4,1(,R4)           BUMP NO SEQ OUT BY 1
         ST    R4,PPISEQCT+4
RORNORM  LH    R4,KLIMITX          POINTER AT LIMIT OF TABLE ?
         BCT   R4,RORGOB
         MVC   KTBLPTBX(4),KTBLPTAX  SET POINTER TO STARTING POINT
         LH    R4,PPIMRGAL         RESET TABLE LIMIT CTR =
         STH   R4,KLIMITX          CHANGING ALT MERGE ORDER
RORGOC   L     R4,KTBLPTBX
         TM    0(R4),X'40'         OPEN BYTE OFF IN THIS NEW UNIT ?
         BZ    RORNORM             YES, BYTE OFF, SKIP UNIT
         MVC   PPIDEPHO+3(1),1(R4)  PUT 'X' IN PPIDEPHO
*                                  'S' SWITCH ON ?
RORSSW   NOP   RORSWOFF            YES, BRANCH
RORSKIP  L     R11,PPIRD+4         EXIT TO READ PRIME ROUTINE
         B     4(,R11)
*
RORGOB   STH   R4,KLIMITX          RESTORE DECREMENTED COUNTER
*                                  INCREMENT TAPE POINTER
         L     R5,KTBLPTBX         GET TRVLG PTR
         LA    R5,2(0,R5)          BUMP BY 2
         ST    R5,KTBLPTBX
         B     RORGOC
*
*        THIS ROUTINE HAS THE RESPONSIBILITY OF DETERMINING IF
*        PHASE 3 SHOULD BE CALLED. IF NOT, IT DETERMINES WHETHER
*        TO ENTER EITHER THE LAST PASS OR THE NEXT TO LAST PASS
*        OF PHASE 2 AND SETS SWITCHES IN PPI TO INDICATE IF
*        FORWARD BLOCKING, REWINDING AND FORWARD READING IS
*        REQUIRED TO ELIMINATE A PHASE 3 COPY PASS. THE TEST USED
*        HERE CAN FAIL IF ANY REEL(S) CONTAINS A SINGLE SEQUENCE
*        WHICH COMPLETELY FILLS THE REEL. IN THIS CASE, NEEDLESS
*        REWINDING COULD OCCUR, BUT THE FINAL RESULT WILL BE
*        CORRECT ANYWAY. THIS UNUSUAL CONDITION IS CONSIDERED
*        UNLIKELY, SINCE SUCH FILES NORMALLY WILL BE HANDLED BY
*        OSCILLATING, NOT BALANCED TAPE SORTS
*
RORGOA   CLC   PPISEQCT+4(4),PPISEQCT  NUMBER OF STRINGS OUT >=
*                                      NO OF STRINGS IN ?
         BNL   RORGOE              BRANCH TO UNENDING MERGE TEST
         LA    R4,2                SINCE COUNT OF SEQS WAS REDUCED
         STH   R4,PPISEQCT+8       RESET ERROR COUNTER FOR 2 RETRY
RORGOF   PPISETOF PPIREADF-PPICLOSR-PPIBLKF  OFF READF, REWIND & BLKF
         MVC   PPIMRGMX(2),KSVMAX  RESET M
         PPITEST  PPIREADB         READ BACKWORD ON ?
         BZ    RORX1               NO, BRANCH
         PPIFLIP  PPIREADF+PPICLOSR+PPIREADB  ON READF, REWIND, READB
         PPIFLIP  PPIPH1CO         INVERT SEQUENCE FLAG
*
*        READY TO ENTER FINAL MERGE
*        (IS SEQCT <= MRGAL)
*
RORX1    LH    R4,PPIMRGAL
         CL    R4,PPISEQCT+4       ALTERNATE MERGE >= STRINGS OUT ?
         BNL   RORPH3              YES, BRANCH TO ENTER PHASE 3
         MH    R4,KSVMAX           FORM MRGAL*KSVMAX (MAX SIZE OF ANY
         CL    R4,PPISEQCT+4       CASE WHERE S/M IS ABOUT TO ENTER
         BNL   RORLPASS            THE LAST PASS OF PHASE 2)
         MH    R4,PPIMRGAL         FORM MRGAL*KSVMAX*MRGAL (MAX SIZE
         CL    R4,PPISEQCT+4       CASE WHERE S/M IS ABOUT TO ENTER
         BNL   RORNXT2L            THE NEXT TO LAST PASS OF PHASE 2)
RORPH2NM NOP   RORPH2NM            THIS WAS CHANGED TO CORRECT COPY
*                                  PASS TROUBLE
         B     RORGOG              GO EXIT TO SSC
*
RORNXT2L PPITEST  PPIEXTRT+PPIUOSEQ  NOT EXTRACTING OR ASCENDING SEQ ?
         BNO   RORCHK2             YES, BRANCH TO CHK2
RORCHK1  PPITEST  PPIUOSEQ+PPIPH1CO  USER SEQ IS OPPOSITE TO PRES SEQ ?
         BNM   RORPH2NM            DO NOT PERFORM SPECIAL ROUTINES
RORSET   PPISETON PPIBLKF+PPIREADB  SET ON READB AND BLKF
         B     RORGOG              GO SET UP FOR PHASE 2
*
RORCHK2  PPITEST  PPIUOSEQ+PPIPH1CO   USER SEQ SAME AS PRESENT SEQ ?
         BM    RORPH2NM            DO NOT PERFORM SPECIAL ROUTINES
         B     RORSET
*
RORLPASS PPITEST  PPIEXTRT+PPIUOSEQ  NOT EXTRACTING OR USER REQUESTED
         BNO   RORCHK1             ASCENDING SEQUENCE GOTO CHK1
         B     RORCHK2             ELSE GOTO CHK2
*
*        CALL PHASE 2
*        EXIT TO CLOSE RTN
*
RORCLOSE PPIFLIP  PPIPH1CO         REVERSE SEQUENCE INDICATOR BIT
         L     R15,PPIADSSC
         LA    R1,0                RETURN TO SSC REQUESTING PHASE 2
         BAS   R14,20(,R15)
*
*        SET MERGE ORDER
*        (REVERSE MAX AND ALT FOR ANOTHER PHASE 2)
*
RORGOG   LH    R4,PPIMRGMX
         MVC   PPIMRGMX(2),PPIMRGAL
         STH   R4,PPIMRGAL
         B     RORCLOSE
*
*        CALL PHASE 3
*
RORPH3   MVC   PPIMRGMX(2),PPISEQCT+6  SET CORRECT MERGE ORDER
         PPITEST  PPIEXTRT+PPIUOSEQ    NOT EXTRACTING OR USER WANTS
         BNO   RORA                  ASCENDING SEQUENCE GOTO RORA
         PPITEST  PPIUOSEQ+PPIPH1CO  USER SEQ = INPUT SEQ ?
         BM    RORCLOSE              NO, GOTO PHASE TWO
RORB     L     R5,KTBLPTCX
         XI    0(R5),X'80'         TURN ON BIT FOR PHASE 3 TO INDICATE
*                                  INPUT SIDE OF TABLE
         PPIFLIP  PPIPH1CO         REVERSE SEQUENCE INDICATOR BIT
         L     R15,PPIADSSC
         LA    R1,4                RETURN TO SSC REQUESTING PHASE 3
         BAS   R14,20(,R15)
*
RORA     PPITEST  PPIUOSEQ+PPIPH1CO   USER SEQ = INPUT SEQ ?
         BM    RORB                NO, GOTO PHASE THREE
         B     RORCLOSE            ELSE GOTO PHASE TWO
*
*                                  DECREMENT ERROR CTR BY 1
RORGOE   LH    R4,PPISEQCT+8       COUNT = ZERO ?
         BCT   R4,RORGOJ           NO, BRANCH + RESTORE CTR FR REG
*
*        EXIT TO SSC - UNENDING MERGE
*
         USING DIERRMB,R14
         L     R14,PPIRMB+4
         L     R1,IER051           R1 -> MSG TEXT
         MVC   PPIABMNO,3(R1)      MOVE MSG NO INTO ABEND NO
         LM    R0,R1,IER051        IER051A UNENDING MERGE
         L     R15,PPIADSSC
         BAS   R14,12(,R15)
         L     R15,PPIADSSC
         BAS   R14,16(,R15)        RETURN TO SSC REQUESTING TERMINATION
*
RORGOJ   STH   R4,PPISEQCT+8       RESTORE ERROR CTR FROM REG
         B     RORGOF
*
*        ENTRY FROM READ RTN - REACHED LOAD POINT
*        FIND UNIT AT LOAD PT AND TURN OFF INPUT BIT VIA INCR IN R3
*        REG D
*
RORLDPT  LH    R4,KSVMAX
         L     R5,KTBLPTCX
         STC   R3,KINCRMT
RORSCAN  CLC   KINCRMT(1),1(R5)
         BE    RORDROP
         LA    R5,2(,R5)           BUMP TO NEXT UNIT
         BCT   R4,RORSCAN          NOT AT END OF TBL, LOOK AT NEXT UNIT
*
*        IF FALL THRU, INCRMT NOT IN TBL = ERROR
*
RORDROP  XI    0(R5),X'80'         TURN OFF INPUT BYTE
*
*        CUTBACK MERGE ORDER, IF ZERO, DECIDE ABOUT ENTRY INTO
*        COPY PASS ELIM ROUTINES, NORMAL PHASE TWO ROUTINES OR
*        INTO PHASE 3
*
         LH    R4,PPIMRGMX
         BCT   R4,RORREAD          SOME UNIT(S) POSSIBLY NOT AT LD PT
         B     RORGOA              ALL UNITS AT LOAD POINT, HENCE EOP
*
*        EXIT BACK TO READ PRIME TO SEE IF MORE INPUTS AT EOF
*        (LOAD POINT)
*
RORREAD  L     R11,PPIRD+4
         STH   R4,PPIMRGMX
         BR    R14
*
*        ENTRY FROM WRITE RTN - EOV DETECT
*        MIDDLE OF A STRING
*        SET 'S' SWITCH ON
*
RORNLST  XI    RORSSW+1,X'F0'
         B     RORGOM
*
*        ENTRY FROM WRITE RTN - EOV DETECT
*        END OF STRING
*        NOT END OF PASS
*        SET 'S' SWITCH OFF
*
RORLST   NI    RORSSW+1,X'F0'
RORGOM   L     R4,PPISEQCT+4       INCREMENT NO OF STRINGS OUT BY 1
         LA    R4,1(,R4)
         ST    R4,PPISEQCT+4
*                                  DECREMENT EOV CTR
         L     R5,KEOVCTX          CTR = ZERO ? (NMAX EXCEEDED)
         BCT   R5,RORUPDT          NO, BRANCH TO UPDATE
*
*        EXIT TO SSC NMAX EXCEEDED
*
         L     R14,PPIRMB+4
         L     R1,IER046           R1 -> MSG TEXT
         MVC   PPIABMNO,3(R1)      MOVE MSG NO INTO ABEND NO
         LM    R0,R1,IER046        IER046A SORT CAPACITY EXCEEDED
         L     R15,PPIADSSC
         BAS   R14,12(,R15)        CALL MSG WRITER
*
*        APROX RCD CNT IS PPICOUNT - B
*        WHERE B IS A MAX VALUE
*        IF CNT TURNS NEGATIVE, CNT IS SET TO B
*        THIS NEGATIVE CONDITION IS MOST LIKELY IF THE BLOCK
*        BEING WRITTEN OUT IS SHORT AND/OR RECORD FORMAT IS
*        VARIABLE
*
         L     R1,PPICOUNT         NO RCD BLOCKED
         LH    R15,PPISRTBL        B - F = NO RCDS/BLOCK
         PPITEST  PPIFIX               V = BYTES/BLOCK
         BO    RORGOM1             FIXED LEN RECORDS, BRANCH
         LH    R0,PPIRCDL4         B / MIN RCD LENGTH = MAX NO
         SR    R14,R14
         DR    R14,R0              RCDS IN BLOCK
RORGOM1  CR    R1,R15              CHECK TO MAKE SURE CNT ISN'T
         BH    RORGOM2             NEGATIVE
         LR    R1,R15              SET CNT TO B
         B     RORGOM3
*
RORGOM2  SR    R1,R15              APROX RCD CNT = PPICOUNT - B
RORGOM3  CVD   R1,PPIWKARE         USUALLY - SET UP CNT FOR
         L     R14,PPIRMB+4
         ED    IER066A,PPIWKARE+4
         LM    R0,R1,IER066        IER066A APPROXIMATE RECORD COUNT
         L     R15,PPIADSSC
         BAS   R14,12(,R15)        CALL MSG WRITER
         L     R15,PPIADSSC
         BAS   R14,16(,R15)        EXIT TO SSC AFTER NMAX EXCEEDED
*
*        UPDATE TAPE TABLE - SET OPEN BYTE OFF ON FULL UNIT
*
RORUPDT  ST    R5,KEOVCTX
         L     R5,KTBLPTBX
         XI    0(R5),X'40'
         B     RORNORM
*
RORSWOFF XI    RORSSW+1,X'F0'      TURN OFF S SWITCH
*
*        EXIT TO WRITE RTN - MORE WRITES PENDING
*
         L     R11,PPIWRT+4
         B     0(,R11)
*
         DC    0F'0'
KMRGCTRX DC    X'0000'             COUNTER=MAX MRG TO DET EOP (LOAD PT)
         DC    0F'0'
KTBLPTAX DC    X'00000000'         START POINT (TO RESET TRVLG PTR)
KLIMITX  DC    X'0000'             COUNTER TO DETERMINE LIMIT OF TABLE
         DC    0F'0'
KTBLPTBX DC    X'00000000'         TRAVELING PTR
KTBLPTCX DC    X'00000000'         POINTER TO INPUT SIDE OF TABLE
KEOVCTX  DC    X'00000000'         SORT CAP EXCEEDED CTR
*                                  ARE FILLED AND MORE INPUT TO GO
KINCRMT  DC    X'0000'             HOLD AREA FOR DCB INCRMT PASSED
KSVMAX   DC    X'0000'             HOLD AREA FOR RESETTING A CUT BK MRG
*
./ ADD NAME=IERROS   0101-20211-20211-1200-00092-00092-00000-RELEASE 00
ROS      TITLE 'IERROS - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERROS
*
*        MODULE FUNCTION/OPERATION -
*        POLYPHASE MERGE ALGORITM FOR TAPE
*        THE FUNCTION OF THIS MODULE CONTROLS -
*        (A) POINTERS FOR INPUT AND OUTPUT UNITS
*        (B) COUNT OF THE NUMBER OF STRINGS OUT
*        (C) COUNT OF THE NUMBER OF DUMMY RECORDS IN
*        (D) COUNT OF THE NUMBER OF DUMMY RECORDS OUT
*        (E) CHECKING NMAX AND ISSUEING A MESSAGE IF IT IS EXCEEDED
*        (F) DECIDES WHEN TO GOTO PHASE 3
*        (G) SUPPLING INCREMENTS TO DCB TABLE
*
*        USED AS A DSECT IN - IERAOS
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM INITIALIZATION
*                       CALLING SEQUENCE -
*                           L    R11,PPIALG+4
*                           BR   R11 (DUMMY LINK READ PRIME)
*
*                     - ENTRY FROM IERRPD (WRITE)
*                       CALLING SEQUENCE -
*                           L    R11,PPIALG+4
*                           B    DISP(,R11)
*                                DISP = 4  FOR EOV & NOT EOS
*                                     = 8  FOR EOV & EOS
*                                     = 16 FOR END OF SEQUENCE
*
*                     - ENTRY FROM IERRGB (READ)
*                       CALLING SEQUENCE -
*                           L    R11,PPIALG+4
*                           BAL  R14,12(,R11) (LOAD POINT REACHED
*                                             DUMMY ENTRY)
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIADSSC   PPIRD     PPIRMB
*        PPIBDSVA   PPIWRT
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPIDEPHO   PPICNTL   PPIMRGMX
*
*        EXTERNAL ROUTINES -
*        EXTRN IERRCV - SORT SYSTEM CONTROL
*        EXTRN IERRGB - READ MODULE
*        EXTRN IERRPD - WRITE MODULE
*
*        EXTERNAL PARAMETERS -
*        EXTRN IERRMA - MESSAGE MODULE
*
*        EXITS - NORMAL -
*        IERRCV - SORT SYSTEM CONTROL
*
*        EXITS - ERROR -
*        IERRCV - SORT SYSTEM CONTROL
*
*        TABLES/WORK AREAS - NONE
*
*        NOTES - NONE
*
*
IERROS   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERROS SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERROSI
*
*        IERRMB
*
*        THIS DSECT CONTAINS ALL OF THE MESSAGES THAT ARE
*        REQUIRED FOR PHASE 2 RUNNING PROGRAM
*
DIERRMB  DSECT
*
         COPY  RMBMAIN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERROSI  0101-20211-20211-1200-00267-00267-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERROS SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERROSI
*
         USING *,R11
         USING IERRCA,R13
*
IERDOT   B     ROS100              +00 READ ROUTINE
         B     ROSNLST             +04 OUTPUT EOV FROM WRITE RTN
         B     ROSNLST             +08 OUTPUT EOV FROM WRITE RTN
         B     ROSLDPT             +12 REACHED LOAD POINT FR READ RTN
*
*        END OF SEQUENCE (FROM WRITE RTN)
*        SET LIMIT OF TAPE TABLE
*
         SR    R8,R8
         IC    R8,PPIBDSVA
*
*        SET MRGMX=ZERO
*
         SR    R4,R4
         STH   R4,PPIMRGMX
*
*        GET STARTING POINT OF TABLE AREAS
*
         LA    R4,PPITPTBL
*
ROSAGAIN CLC   1(1,R4),PPIDEPHO+3  THIS UNIT THE OUTPUT UNIT ?
         BE    ROSOUTPT            YES, OUTPUT UNIT
         CLC   68(2,R4),KZERO      THIS UNIT HAVE ANY ENDING DUMMY'S ?
         BNE   ROSENDUM            YES, THERE ARE DUMMY'S BRANCH
         CLC   102(2,R4),KZERO     THIS UNIT HAVE ANY BEGIN DUMMY'S ?
         BNE   ROSBEGDM            YES, THERE ARE BEGIN DUMMY'S BRANCH
         LH    R5,34(,R4)          DECREMENT THE SEQ CTR FOR THIS UNIT
         BCTR  R5,0                DECR BY 1
         STH   R5,34(,R4)
         CLC   34(2,R4),KZERO      CTR = ZERO ?
         BNE   ROSGOG              NO, BRANCH
ROSGON   OI    KNXTPASS,X'01'      TURN ON NEXT PASS BIT
         B     ROSGOC              THIS TAPE EMPTY = NEXT OUTPUT
*
*        BUMP NO OF REAL STRINGS ON THIS UNIT
*
ROSOUTPT LH    R6,34(,R4)          GET SEQ CT FOR THIS UNIT
         LA    R6,1(,R6)           ADD 1
         STH   R6,34(,R4)          STORE
         B     ROSGOE              GET NEXT UNIT ADDR
*
*        DECREMENT ENDING DUMMYS BY 1 FOR THIS UNIT
*
ROSENDUM LH    R5,68(,R4)
         BCTR  R5,0                DECR
         STH   R5,68(,R4)
         CLC   68(2,R4),KZERO      CTR = ZERO ?
         BNE   ROSGOE              NO, BRANCH
*
*        NO DUMMY'S = ZERO (END OF TAPE)
*
ROSINPON MVI   0(R4),X'C0'         SET INPUT BIT ON FOR THIS UNIT
         B     ROSGOG              GOTO UP MERGE ORDER
*
ROSGOC   MVI   0(R4),X'40'         SET INPUT BIT OFF FOR THIS UNIT
         B     ROSGOE              GET NEXT UNIT ADDR
*
ROSGOG   LH    R6,PPIMRGMX         BUMP MERGE ORDER BY 1
         LA    R6,1(,R6)
         STH   R6,PPIMRGMX
ROSGOE   LA    R4,2(,R4)           BUMP TABLE INCREMENT BY 2
         BCT   R8,ROSAGAIN         END OF TABLE ? NO, BRANCH
         B     ROSGOH              YES, END OF TABLE TEST FOR NEXT PASS
*
ROSBEGDM CLC   34(2,R4),KZERO      REAL STRINGS = ZERO ?
         BE    ROSGOI              YES, BRANCH
         LH    R5,34(,R4)          DECR NO REAL STRINGS FOR THIS UNIT
         BCTR  R5,0
         STH   R5,34(,R4)
         CLC   34(2,R4),KZERO      NO OF REAL STRINGS = ZERO ?
         BE    ROSGOC              YES, ZERO TURN OFF INPUT INDICATOR
         B     ROSINPON            ELSE TURN INDICATOR ON
*
ROSGOH   TM    KNXTPASS,X'01'      NEXT PASS BIT ON ?
         BZ    ROSCALL2            NO, BRANCH
ROSSKIP  B     ROS200              NO CHKPT SPECIFIED
*
*        THE ABOVE INSTRUCTION WILL BE MODIFIED IF CHECKPOINT HAS
*        BEEN INDICATED. THE NEW INSTRUCTION WILL BE A NOP
*        LINK TO THE CHECKPOINT MODULE AND RETURN
*
         L     R15,PPICHKAD        LOAD BASE REGISTER FOR THE
*                                  CHECKPOINT MODULE
         BASR  R14,R15             LINK TO CHECKPOINT MODULE
ROS200   NI    KNXTPASS,X'00'      TURN NEXT PASS BIT OFF
*
*        DESIGNATE A NEW OUTPUT UNIT
*        TURN OLD OUTPUT UNIT INTO A NEW INPUT UNIT
*        SET TABLE LIMIT
*
         SR    R8,R8
         IC    R8,PPIBDSVA
         LA    R4,PPITPTBL         INITIALIZE TABLE POINTER
*
*        FIND OLD OUTPUT UNIT
*
ROSTRYNX CLC   1(1,R4),PPIDEPHO+3
         BE    ROSFOUND            WHEN FOUND
ROSNOTOT LA    R4,2(,R4)
         BCT   R8,ROSTRYNX         NOT END/TBL AND HAVEN'T FOUND YET
*
*        NO FALL THRU POSSIBLE, MUST BE ABLE TO LOCATE THE OLD OUTPUT
*
*        FOUND OLD OUTPUT UNIT, MAKE IT AN INPUT
*
ROSFOUND XI    0(R4),X'80'         TURN INPUT BIT ON
*
*        FIND NEW OUTPUT BASED ON UNIT WITH NO OF REAL STRINGS = ZERO
*
         LA    R4,PPITPTBL         RESET PTR
         SR    R8,R8
         IC    R8,PPIBDSVA         SET TABLE LIMIT
ROSLOOK  CLC   34(2,R4),KZERO
         BE    ROSGOL              THIS UNIT = 0 REAL STRGS-CHK DUMMYS
ROSNOGO  LA    R4,2(,R4)           BUMP INCRMT
         BCT   R8,ROSLOOK          NOT THIS UNIT, TRY NEXT ONE
*
*        NO FALL THRU POSSIBLE, MUST FIND A ZERO CTR = EMPTY TAPE
*
*        PASS DCB INCR FOR THIS UNIT TO PPIDEPHO
*
ROSNWOUT LA    R4,1(,R4)           GET 2ND BYTE
         MVC   PPIDEPHO+3(1),0(R4)
*
*        DETERMINE IF PHASE 3 OR ANOTHER SUB-PASS OF PHASE 2 BE
*        CALLED
*        SET TBL LIMIT AND SET DISPLC FOR MOVE THRU TBL=0 AND
*        WIPE OUT MERGE ORDER
*
         SR    R8,R8
         IC    R8,PPIBDSVA
         LA    R4,PPITPTBL
         LH    R5,KZERO            ZERO OUT MAX
         STH   R5,PPIMRGMX
ROSBEGIN CLC   68(2,R4),KZERO      ANY ENDING DUMMY'S FOR THIS UNIT ?
         BNE   ROSBUMP             YES, THERE ARE ENDING DUMMIES,BRANCH
*
*        NO ENDING DUMMY'S FOR THIS UNIT
*        GET COUNTER OF REAL STRINGS AND SEE IF = ONE
*
         CLC   34(2,R4),KONE
         BH    ROSTWORL            GO INCREMENT MERGE ORDER
         BL    ROSNORL             NO REAL STRINGS, TURN OFF INDICATOR
*
*        THERE IS ONE REAL LEFT
*        INCR MERGE ORDER
*
         LH    R5,PPIMRGMX
         LA    R5,1(,R5)
         STH   R5,PPIMRGMX
         MVI   0(R4),X'C0'         SET INPUT BIT ON IN THIS UNIT
         CLC   102(2,R4),KONE      BEGINNING DUMMY FOR THIS UNIT= ONE ?
         BL    ROSBUMP             CHECK NEXT UNIT
ROSPH2   MVI   KPH2SWX,X'01'       TURN ON PHASE 2 SWITCH
         B     ROSBUMP             CHECK NEXT UNIT
*
ROSGOL   CLC   68(2,R4),KZERO      THIS UNIT HAVE END DUMMY'S = ZERO ?
         BNE   ROSNOGO             UNIT HAS END DUMMY'S, NOT OUTPUT
*                                  GO BACK AND LOOK AT NEXT UNIT
*
*        UNIT HAS NO END DUMMY'S LOOK AT BEGIN DUMMY CTR FOR ZERO
*
         CLC   102(2,R4),KZERO
         BNE   ROSNOGO             UNIT HAS BEG DUMMY'S,NOT OUTPUT
*
*        UNIT HAS NO STRINGS AT ALL = OUTPUT UNIT
*
         B     ROSNWOUT            GOTO RESET FOR UNIT
*
*        NO OF REAL STRINGS = 2 OR MORE
*        SET INPUT BIT ON
*        INCR MERGE ORDER
*
ROSTWORL LH    R5,PPIMRGMX
         LA    R5,1(,R5)
         STH   R5,PPIMRGMX
         MVI   0(R4),X'C0'
         B     ROSPH2              PHASE 2 NEEDED
*
*        NO OF REAL STRINGS = 0
*
ROSNORL  MVI   0(R4),X'40'         TURN INPUT BIT OFF
         CLC   102(2,R4),KONE      BEGIN DUMMY FOR THIS UNIT = ONE ?
         BH    ROSPH2              PHASE 2 NEEDED
ROSBUMP  LA    R4,2(,R4)           BUMP DISPLACEMENT TO NEXT UNIT
         BCT   R8,ROSBEGIN         END OF TABLE, NO, BRANCH
         TM    KPH2SWX,X'01'       YES, END OF TABLE, PH 2 SWITCH ON ?
         BO    ROSCALL2            YES, CALL PHASE 2 AGAIN
         PPIFLIP  PPIPH1CO         REVERSE SEQ INDICATOR
         LA    R1,4                TO SSC ASKING FOR PHASE 3
         L     R15,PPIADSSC
         BAS   R14,20(,R15)        EXIT TO SORT SYSTEM CONTROL
*
ROSCALL2 PPIFLIP  PPIPH1CO         REVERSE SEQ INDICATOR
         MVI   KPH2SWX,X'00'       TURN PHASE 2 SW OFF
ROS100   L     R11,PPIRD+4         CALL ANOTHER PHASE 2
         B     4(,R11)             READ ROUTINE
*
ROSGOI   LH    R5,102(,R4)         DECR BEG DUMMY FOR THIS UNIT
         BCTR  R5,0
         STH   R5,102(,R4)
         CLC   102(2,R4),KZERO     CTR = ZERO ?
         BNE   ROSGOC              NO, BRANCH
         B     ROSGON              GO SET NEXT PASS INDICATOR
*
*        OUTPUT EOV
*        HIT REFLECTIVE SPOT TAPE TOO SHORT
*        NMAX EXCEEDED
*
         USING DIERRMB,R2
ROSNLST  L     R2,PPIRMB+4
         L     R1,IER046           R1 -> MSG TEXT
         MVC   PPIABMNO,3(R1)      MOVE MSG NO INTO ABEND NO
         LM    R0,R1,IER046        IER046A SORT CAPACITY EXCEEDED
         L     R15,PPIADSSC
         BAS   R14,12(,R15)        SORT SYSTEM CONTROL
*
*        CALCULATE AND PRINT OUT APPROX RECORD COUNT FOR TAPE
*        THAT HIT EOV MODAL RECORD LENGTH IS USED FOR VARIABLE
*        LENGTH RECORDS TO ESTIMATE THE NUMBER OF RECORDS PER
*        BLOCK
*
         L     R1,PPISTDCB         DCB TABLE
         SR    R15,R15
         IC    R15,PPIDEPHO+3      LAST OUTPUT TAPE INCR
         L     R1,0(R15,R1)        EOV DCB
         L     R1,12(,R1)          BLOCK COUNT
         LH    R15,PPISRTBL        SORT BLOCKING FACTOR
         PPITEST  PPIFIX           FIXED LENGTH RECORDS ?
         BO    ROSCALC             YES, BRANCH
         SR    R14,R14             VARIABLE, CALC AVERAGE RCDS
         LH    R0,PPIRCDL5         PER BLOCK
         DR    R14,R0
ROSCALC  SR    R14,R14             BLOCK COUNT * RCDS/BLK=
         MR    R14,R1              APPROX RCD CNT
         CVD   R15,PPIWKARE
         ED    IER066A,PPIWKARE+4
         LM    R0,R1,IER066        IER066A APPROXIMATE RECORD COUNT
         L     R15,PPIADSSC
         BAS   R14,12(,R15)        CALL PRINT MESSAGE
         L     R15,PPIADSSC
         BAS   R14,16(,R15)        GOTO SSC TO TERM JOB, NO RETURN
*
*        REACHED LOAD POINT
*        IMPOSSIBLE IN POLYPHASE BUT DUMMY MAINTAINED
*
ROSLDPT  L     R11,PPIRD+4
         BR    R14                 READ ROUTINE
*
         DC    0F'0'
KZERO    DC    H'0'
KONE     DC    H'1'
KNXTPASS DC    X'00'               INDICATE NEXT PASS
KPH2SWX  DC    X'00'               PHASE 2 SWITCH
*
./ ADD NAME=IERROT   0101-20211-20211-1200-00090-00090-00000-RELEASE 00
ROT      TITLE 'IERROT - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERROT
*
*        MODULE FUNCTION/OPERATION -
*        BALN TECHNIQUE MERGE PHASE DISK ALGORITHM
*        THE FUNCTION OF THIS MODULE IS TO OPERATE UPON A MERGE
*        TABLE WHICH IS USED TO CONTROL WHERE TO WRITE THE MERGED
*        SEQUENCES ON DISK AREAS. IN ADDITION IT COUNTS NUMBER
*        OF STRINGS AND KEEPS A DIRECTORY OF ADDRESSES WHERE EACH
*        STRING BEGINS. IT DETERMINES IF PHASE 2 WILL BE NEEDED
*        FOR CONTINUED MERGING OR IF S/M IS READY FOR PHASE 3
*        FINAL MERGE. IT MAY CAUSE S/M TO TERMINATE THE SORT FOR
*        CERTAIN ABNORMAL CONDITIONS
*
*        USED AS A DSECT IN - IERAOT
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM INITIALIZATION
*                       CALLING SEQUENCE -
*                           L    R11,PPIALG+4
*                           BR   R11
*                           ENTRIES FOR DISPLACEMENTS OF
*                           4,8 AND 12 ARE DUMMIES
*
*                     - ENTRY FROM IERRPE (WRITE)
*                       CALLING SEQUENCE -
*                           L    R11,PPIALG+4
*                           B    16(,R11) (END OF SEQUENCE)
*
*                     - ENTRY FROM IERROT (READ)
*                       CALLING SEQUENCE -
*                           L    R11,PPIALG+4
*                           BR   R14 (RETURN ON READING DIRECTORY)
*
*                     - ENTRY FROM IERRPE (WRITE DIRECTORY)
*                       CALLING SEQUENCE -
*                           L    R11,PPIALG+4
*                           BR   R14 (RETURN ON WRITING DIRECTORY)
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIADSSC   PPIWRT    PPIMRGAL
*        PPIWKARE   PPIRD     PPILAB01
*        PPINDSKA
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPIDEPHO   PPIMRGMX  PPISEQCT
*        PPIRD      PPIMRGOP  PPICNTL
*
*        EXTERNAL ROUTINES -
*        EXTRN IERRPE - WRITE ROUTINE
*        EXTRN IERRGC - READ ROUTINE
*        EXTRN IERRCV - SORT SYSTEM CONTROL
*
*        EXTERNAL PARAMETERS -
*        EXTRN IERRMA - MESSAGE MODULE
*
*        EXITS - NORMAL -
*        IERRCV - RETURN TO SSC
*
*        EXITS - ERROR -
*        IERRCV - RETURN TO SSC FOR TERMINATE
*
*        TABLES/WORK AREAS -
*        WTABLE - CONTROL AREA USAGE
*
*        NOTES -
*        THIS MODULE USES A BALANCED TECHNIQUE ANALOGOUS TO
*        BALANCED TAPE
*
IERROT   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERROT SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERROTI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERROTI  0101-20211-20211-1200-00319-00319-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERROT SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERROTI
*
         USING *,R11               SET BASE REG FOR THIS PROGRAM
         USING IERRCA,R13
*
IERDOT   B     ROTSTART            +00 ENTRY
         DC    A(0)                +04 NO ENTRY PT
         DC    A(0)                +08 NO ENTRY PT
         DC    A(0)                +12 NO ENTRY PT
         B     ROTEOS              +16 GOTO EOS ROUTINE
*
*        SET R8 TO NTH POSITION OF TABLE
*
ROTSTART LA    R8,WTABLE           R8 -> WTABLE
         LH    R5,WNODSKA          R5 = NO DISK AREAS FROM PPINDSKA
         BCTR  R5,0                REDUCE NO OF AREAS BY 1
         STH   R5,WNODSKA          SET UP COUNTER TO DETERMINE END/PASS
         LA    R6,36               MULTIPLIER CONST (L'WTABLE ENTRY)
         MR    R4,R6               DISPLACEMENT TO NTH POS/TABLE
         LA    R7,0(R5,R8)         R7 -> NTH POS IN TABLE
         LR    R8,R7               HENCEFORTH R8 = ADDR/NTH POS
         SR    R7,R6               HENCEFORTH R7 = ADDR/N-1 POS
*
*        SEQ COUNT AT N-1 = 0
*
         LH    R4,34(,R7)          GET SEQ COUNT IN
         LTR   R4,R4
         BNZ   ROTGOA              NOT ZERO, BRANCH
         L     R4,0(,R8)           GET 'N' AREA KEY
         SLL   R4,1                MULTIPLY BY 2
         LA    R5,PPISEQCT         GET START POINT OF PPI SEQUENCE CTRS
         AR    R5,R4               GET PPI SEQ CT LOCATION
         MVC   0(2,R5),34(R7)      STORE IN PPI
         B     ROTGOB              GOTO GET N CT
*
ROTGOA   LA    R4,4(,R8)           GET NEXT SEQ ADDR FROM NTH POS
         MVC   WCLBKAR(8),0(R4)    BLOCK ONE ADDR
         MVC   PPIDEPHO,0(R4)      MOVE NEXT SEQ ADDR FOR WRITE IN PPI
ROTGON   CLC   PPIMRGOP,34(R7)     OPT MRG ORD = NO SEQ IN AREA N-1 ?
         BNL   ROTGOC              GOTO STORE NO SEQ
         MVC   PPIMRGMX,PPIMRGOP   STOW OPT MRG ORDER IN MAX MRG ORD
*
*        DECREMENT NO SEQS IN POS N-1 BY MAX MRG ORD
*
ROTGOE   LH    R4,34(,R7)          GET NO SEQ IN N-1 POS
         SH    R4,PPIMRGMX
         STH   R4,34(,R7)          PUT BACK
         B     ROTGOF              GOTO READ ROUTINE
*
*        STORE NO SEQ IN N-1 POS IN MAX
*
ROTGOC   MVC   PPIMRGMX,34(R7)
         B     ROTGOE              GOTO DECREMENT NO SEQ
*
ROTGOF   ST    R8,WSAVERI
*
*        GET ADDR OF PPI SEQ WORK AREA - 'TO' ADDR
*
         LA    R6,PPIWKARE        R6 -> WORK AREA
*
*        GET ADDR NEXT POS IN BLK RETRIEVED, FOR N-1 POS - 'FROM ADDR'
*
         L     R5,28(,R7)
*
*        PUT ADDR NEXT DICT BLK FROM TABLE INTO PPI FOR 'READ'
*
         MVC   PPIDIRAD,20(R7)
         STM   R5,R7,WSAVERF       SAVE R5,R6,R7
*
*        READ ROUTINE
*
         L     R11,PPIRD+4         R11- > READ DIRECTORY ENTRY POINT
         BASR  R14,R11             CALL READ DIRECTORY
         LM    R5,R7,WSAVERF       RESTORE R5,R6,R7
         LH    R1,PPIMRGMX         GET MAX MERGE ORDER
*
*        MOVE 1 DISK ADDR FROM 'FROM' TO 'TO' IN WORK AREA (PPI)
*
ROTGOK   MVC   0(8,R6),0(R5)       MOVE TO WORK AREA
         LA    R5,8(,R5)           BUMP 'FROM' ADDR
         LA    R6,8(,R6)           BUMP 'TO' ADDR
         B     ROTGOG              GOTO COMPARE LIMIT OF NEW BLK
*
*        DECREMENT MERGE ORDER COUNT CHECK IF ZERO
*
ROTGOX   BCT   R1,ROTGOK           GOTO MOVE DISK ADDR IN WORK AREA
*
*        STORE INDEXED 'FROM' ADDR INTO TABLE (NXT-POS-IN-BLK)
*
         ST    R5,28(,R7)
         ST    R7,WSAVERH          SAVE REG R7 (N-1)
         L     R11,PPIRD+4
         B     4(,R11)             GOTO READ PH2 AND PH3
*
ROTGOG   LA    R4,PPILAB01+64
         CLR   R5,R4               LIMIT OF NEW BLOCK ?
         BL    ROTGOX              NO
*
         LA    R5,PPILAB01         RESET 'FROM' ADDR TO BEG/BLK
*
*        LAST BLOCK, LAST ON TRACK ?
*
ROT100   CLC   27(1,R7),PPIDIRBK+1   TRACK FULL ?
         BE    ROTNEWTK            YES, BRANCH
*
*        INCREMENT TO NEXT BLK ADDR (RECD CT) BY 1 (IN TABLE)
*
         IC    R4,27(,R7)          GET RECORD COUNT
         LA    R4,1(,R4)           INCR RECORD COUNT
         STC   R4,27(,R7)          STORE UPDATED RECORD COUNT
ROTGOH   LA    R4,1
         CLR   R1,R4               ANOTHER BLOCK OF DIRCT BE READ ?
         BE    ROTGOX              NO
         MVC   PPIDIRAD,20(R7)     YES,SET UP PPIDIRAD FOR ANOTHER READ
         STM   R5,R7,WSAVERF       SAVE R5,R6,R7
         ST    R1,WSAVERB          SAVE DECREMENTED MRG ORDER
*
*        READ ROUTINE
*
         L     R11,PPIRD+4         TO READ DIRECTORY
         BASR  R14,R11             GOTO READ DIRECTORY
         LM    R5,R7,WSAVERF       RESTORE R5,R6,R7
         L     R1,WSAVERB          RESTORE DECREMENTED MRG ORDER
         B     ROTGOX              GOTO DECREMENT MERGE ORDER
*
*        DECREMENT NEXT BLOCK ADDR BACK 1 TRK AND RESET RECORD CNT TO 1
*
ROTNEWTK MVI   27(R7),X'01'        SET RECORD NO TO 1
         SR    R4,R4
         ICM   R4,B'0011',25(R7)   R4 = TT
         BCTR  R4,0                DECR 1 TRACK
         STCM  R4,B'0011',25(R7)   STORE UPDATED TT
         B     ROTGOH              GOTO CHK IF ANOTHER DICT TO BE READ
*
*        EOS ROUTINE
*
ROTEOS   LM    R7,R8,WSAVERH       RESET REGS R7,R8 = N-1,N
*
*        BUMP NO NEW SEQS IN TABLE
*
         LH    R4,32(,R8)          GET NO NEW SEQ
         LA    R4,1(,R4)           INCR BY 1
         STH   R4,32(,R8)          STORE
*
*        DECR BLKG CTR FOR DICT BY 1
*        BLOCK FILLED ?
*
         LH    R4,WBLKCT
         BCT   R4,ROTGOL           NO,BRANCH
         B     ROTGOM              GOTO SAVE ADDR OF NXT SEQ
*
*        BLOCK NEXT OUTPUT SEQ DISK ADDR
*
ROTGOL   LA    R5,8                GET DISPLCMT IN BLKG AREA VIA BLKCTR
         SR    R5,R4
         STH   R4,WBLKCT           STORE DECRM'TD BLOCK COUNT
         SLL   R5,3
         LA    R6,WCLBKAR          GET STARTING ADDR
         AR    R6,R5
         MVC   0(8,R6),PPIDEPHO    MOVE INTO BLOCK
         LH    R4,34(,R7)          ALL SEQS FOR TABLE POS N-1 PASSED ?
         LTR   R4,R4
         BNE   ROTGON              GOTO CHK OPT MRG ORD
*
*        WRITE A PARTIALLY FILLED BLOCK OF DIRECTORY
*
         BAS   R14,ROTSETDR        CALL DIRECTORY SET UP RTN
         L     R11,PPIWRT+4        R11 -> WRITE ROUTINE (IERRPE)
         BAS   R14,12(,R11)        CALL WRITE A BLOCK OF DIRECTORY
         LM    R7,R8,WSAVERH       RESTORE REGS
*
*        STORE NO NEW SEQS FOR POS N IN ITS COUNTER IN PPI
*
ROTGOR   L     R4,0(,R8)           GET N AREA KEY
         AR    R4,R4               MULTPY BY 2
         LA    R5,PPISEQCT(R4)     GET ST PT
         MVC   0(2,R5),32(R8)      MOVE IN SEQUENCE COUNT
ROTGOB   LA    R4,1                CONSTANT 1
         LH    R5,WNODSKA          R5 = NO OF DISK AREAS
*
*        END OF PASS ? NO AREA CTR = 1
*
         CLR   R5,R4
         BNE   ROT300              NO, LOOP TO BEG PT AND CONT PASS
*
*        STORE A ZERO IN POS 1'S AREA IN PPI COUNTERS
*
         L     R4,0(,R7)           GET 'N' 1 AREA KEY
         AR    R4,R4               MULTPY BY 2
         LA    R5,PPISEQCT(R4)     GET ST PT
         MVC   0(2,R5),32(R7)
*
*        SUM SEQUENCE COUNTERS
*
         SR    R5,R5               ZERO COUNT
         LH    R4,PPINDSKA         R4 = NO OF DISK AREAS
         LA    R6,PPISEQCT         R6 -> SEQUENCE COUNTERS
ROTLOOPH AH    R5,0(,R6)           SUM IN R5
         LA    R6,2(,R6)           BUMP TO NXT CTR
         BCT   R4,ROTLOOPH         BRANCH BACK TO THE LOOP
*
*        SUM VS ALT
*
         LH    R6,PPIMRGAL
         CLR   R5,R6
         BH    ROTPHAS2            GO SET INDICATOR TO PHASE 2
*
*        CLOSE ROUTINE
*
         STH   R5,PPIMRGOP         STORE NO STRINGS FOR MERGE
         STH   R5,PPIMRGMX         UPDATE MRGMX WITH SUM OF SEQ CNTS
ROTGOP   LA    R1,4                TO SSC ASKING FOR PHASE 3
         L     R15,PPIADSSC        R15 -> SSC
         BAS   R14,20(,R15)        EXIT TO SSC
*
ROTPHAS2 PPIFLIP  PPIDMCO          REVERSE ASCENDING/DESCENDING FLAG
*
*        SET INDICATOR TO PHASE 2
*
         SR    R1,R1               RETURN TO SSC ASKING FOR PHASE 2
         L     R15,PPIADSSC
         BAS   R14,20(,R15)        EXIT TO SSC
*
ROT300   B     ROTSTART ÝMAYBE NOP¨GO SET R8 TO NTH POS OF TABLE
*
*        THE ABOVE INSTRUCTION WILL BE MODIFIED TO A NO OP IF
*        CHECKPOINT HAS BEEN INDICATED. IF CHECKPOINTS ARE BEING
*        TAKEN LINK TO THE CHECKPOINT MODULE
*
         L     R15,PPICHKAD        LOAD BASE ADDR
         BASR  R14,R15             ISSUE CHECKPOINT
         B     ROTSTART            GO SET R8 TO NTH POS OF TABLE
*
*        SAVE THE ADDR OF WHERE TO WRITE NEXT SEQ IN TABLE
*
ROTGOM   MVC   4(8,R8),PPIDEPHO    PUT IN 'N' POS
*
*        STORE ADDR OF WHERE TO RECD NEXT DICTY BLK IN PPI FOR 'N' POS
*
*        WRITE A FULL BLOCK OF DIRECTORY
*
         BAS   R14,ROTSETDR        BRANCH TO DIRECTORY SET UP SUBRTN
         L     R11,PPIWRT+4        LOAD ADDR OF WRITE ROUTINE (IERRPE)
         BAS   R14,12(,R11)        CALL WRITE A BLOCK OF DIRECTORY
         LM    R7,R8,WSAVERH       RESTORE REGS
         LH    R4,34(,R7)          ALL SEQ'S FROM TAB (POS N-1) PASSED?
         LTR   R4,R4
         BE    ROTGOR              GO STORE NO OF NEW SEQS
*
*        TRACK OF DICT FILLED ?
*
         CLC   19(1,R8),PPIDIRBK+1  TRACK FULL ? (LAST POSS RECORD) ?
         BNE   ROTGOS              NO, BRANCH
*
*        TRACK FULL, RESET RECORD COUNT FOR POS 'N' IN TABLE TO 1
*
         MVI   19(R8),X'01'        SET RECORD NO TO 1
*
*        DECREMENT TRACK NO BY 1 TO 'N' POS IN TABLE
*
         SR    R4,R4
         ICM   R4,B'0011',17(R8)   R4 = TT
         BCTR  R4,0                DECR TT
         STCM  R4,B'0011',17(R8)   STORE UPDATED TT
         B     ROTGOA              GO SET NEXT SEQ ADDR
*
*        INCR RECORD COUNT FOR POS 'N' CONT TO WRITE ON SAME TRACK
*
ROTGOS   IC    R4,19(,R8)          GET RECORD COUNT
         LA    R4,1(,R4)           ADD 1
         STC   R4,19(,R8)          STORE
         B     ROTGOA              GO GET NEXT SEQ ADDR
*
*        WRITE A DIRECTORY BLOCK
*
*        MOVE THE DIRECTORY TO PPI, STORE THE DISK ADDR IN
*        PPI, RESET THE DIRECTORY BLOCKING COUNTER
*
ROTSETDR MVC   PPIDIRAD,12(R8)     MOVE DIRECTORY ADDR INTO PPI
         MVC   PPIWKARE(64),WCLBKAR  PUT BLOCK OF DIRECTORY IN PPI
         STM   R7,R8,WSAVERH       SAVE REGS
         LA    R4,8
         STH   R4,WBLKCT           RESET DIRECTORY BLOCKING COUNTER
         BR    R14                 RETURN TO MAIN LINE
*
WTABLE   DC    F'0'            +00 MERGE TABLE - FIRST AREA
         DC    2F'0'           +04               PPISTAR
         DC    2F'0'           +12               PPIENDAR WRITE DICT
         DC    2F'0'           +20               PPIENDAR READ DICT
         DC    F'0'            +28               -> PPILAB01
         DC    H'0'            +32               SEQUENCE COUNT
         DC    H'0'            +34               PPISEQCT
         DC    F'1'                            - SECOND AREA
         DC    8F'0'                             ENTRY
         DC    F'2'                            - THIRD AREA
         DC    8F'0'                             ENTRY
         DC    F'3'                            - FOURTH AREA
         DC    8F'0'                             ENTRY
         DC    F'4'                            - FIFTH AREA
         DC    8F'0'                             ENTRY
         DC    F'5'                            - SIXTH AREA
         DC    8F'0'                             ENTRY
*
WSAVERB  DC    F'0'                SAVE AREA FOR R1 WHEN LINKING
WSAVERF  DC    F'0'                SAVE AREA FOR R5 WHEN LINKING
WSAVERG  DC    F'0'                SAVE AREA FOR R6 WHEN LINKING
WSAVERH  DC    F'0'                SAVE AREA FOR R7 WHEN LINKING
WSAVERI  DC    F'0'                SAVE AREA FOR R8 WHEN LINKING
WCLBKAR  DC    16F'0'              DICT BLOCKING AREA=64 BYTES
WBLKCT   DC    H'8'                DICT BLOCKING COUNTER
WNODSKA  DC    H'0'                NO DISK AREAS COUNT - DET END/PASS
*
./ ADD NAME=IERROU   0101-20211-20211-1200-00081-00081-00000-RELEASE 00
ROU      TITLE 'IERROU - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERROU
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 2 AND 3, 1-8 WAY MERGE NETWORK WITH MULTIPLE
*        CONTROL FIELDS
*        THE FUNCTION OF THIS MODULE IS TO MERGE FIXED OR
*        VARIABLE LENGTH RECORDS IN ASCENDING OR DECENDING
*        SEQUENCE INITIALLY IERROU SEQUENCES THE INPUT RECORDS IN
*        THE PHASE TO PHASE INFORMATION AREA, CUTS BACK THE
*        NETWORK FOR SPECIFIED MERGE ORDER, AND THEN UTILIZES A
*        BINARY INSERTION TECHNIQUE. THIS IS ACCOMPLISHED BY
*        USING THE ADDRESSES OF THE RECORDS IN REGISTERS R4 THRU
*        R10. THE LOW ORDER 3 BYTES OF THE REGISTER CONTAIN THE
*        ADDRESS OF THE RECORD. THE HIGH ORDER BYTE HAS A FILE
*        INDENTIFIER FOR THE DEBLOCK ROUTINE. R3 IS THE NEW
*        RECORD CONVEYER FROM DEBLOCK AND COMMUNICATES TO BLOCK
*
*        USED AS A DSECT IN - IERAOU
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - CALLING SEQUENCE -
*                           LA   R15,PPINETM+4
*                           BR   R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIDOOBA   PPIMRGMX   PPIPSVA
*        PPIBLK     PPIRMC     PPIDOUA
*        PPIPDWA    PPICNTL    PPIBLK2
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPIPSVA
*
*        EXTERNAL ROUTINES -
*        EXTRN IERRMC  - MESSAGE MODULE
*        EXTRN IERDB2  - PHASE TWO BLOCK ROUTINE
*        EXTRN IERDB34 - PHASE THREE BLOCK ROUTINE
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL -
*        IERDB2  - BLOCK PHASE 2
*        IERDB34 - BLOCK PHASE 3
*
*        EXITS - ERROR -
*        IERRMC - MESSAGE MODULE
*
*        TABLES/WORK AREAS - N/A
*
*        NOTES - N/A
*
IERROU   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERROU SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERROUI
*
*        IERRMC
*
*        THIS DSECT CONTAINS ALL OF THE MESSAGES THAT ARE
*        REQUIRED FOR PHASE 3 OR MERGE ONLY RUNNING PROGRAM
*
DIERRMC  DSECT
*
         COPY  RMCMAIN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERROUI  0101-20211-20211-1200-00581-00581-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERROU SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERROUI
*
         USING *,R11               SETTING MODULE USING REGISTER
         USING IERRCA,R13          SETTING PPI DSECT USING REG
         USING DIERRMC,R14         MESSAGE MODULE USING REG
*
IERDO1   B     ROUSINIT            +00 READ PRIME ENTRY BR TO INITIAL
         B     ROUCUTEN            +04 READ + ALGTM ENTRY BR TO CUTBACK
         LM    R4,R10,ROUSVREG     +08 DEBLOCK ENTRY - RESTORE REGS
ROUNTENS B     IERDOM8             +12 NETWORK ENTR SW SET BY CUTBACK
*
*        FIND THE WINNER LOOP
*
*        ENTRANCE FOR A 6, 7, 8 WAY MERGE
*
*                 _________________UPDATE BY IERAOU TO L'MAJOR CNTL FLD
*                |
*                V
IERDOM8  CLC   0(1,R3),0(R7)       +16 COMPARE NEW ITEM WITH ITEM 4
         BNE   ROUNOEQ8            IF EQUAL GOTO EQUALS ROUTINE
         LR    R2,R7               LOAD EQ RTN COMPARE REG WITH ITEM 4
         BASR  R14,R12             SET NETWORK RETURN REG FOR EQ RTN
*
*        THIS BRANCH INSTR IS BH OR BL DEPENDING ON THE INPUT
*        SEQUENCE
*
ROUNOEQ8 BH    IERDOCK6            IF HI/LO GOTO CMP ITEM 6 OR 5
*
*        ENTRANCE FOR A 3, 4, 5 WAY MERGE
*
IERDOM4  CLC   0(1,R3),0(R5)       COMPARE NEW ITEM WITH ITEM 2
         BNE   ROUNOEQ4            IF EQUAL GOTO EQUALS ROUTINE
         LR    R2,R5               LOAD EQ RTN COMPARE REG WITH ITEM 2
         BASR  R14,R12             SET NETWORK RETURN REG FOR EQ RTN
*
*        THIS BRANCH INSTR IS BH OR BL DEPENDING ON THE INPUT
*        SEQUENCE
*
ROUNOEQ4 BH    IERDOCK3            IF HI/LO GOTO CMP ITEM 3,4 OR UPDATE
*
*        ENTRANCE FOR A 2 WAY MERGE
*
IERDOM2  CLC   0(1,R3),0(R4)       COMPARE NEW ITEM WITH ITEM 1
         BNE   ROUNOEQ2            IF EQUAL GOTO EQUALS ROUTINE
         LR    R2,R4               LOAD EQ RTN COMPARE REG WITH ITEM 1
         BASR  R14,R12             SET NETWORK RETURN REG FOR EQ RTN
*
*        THIS BRANCH INSTR IS BH OR BL DEPENDING ON THE INPUT
*        SEQUENCE
*
ROUNOEQ2 BH    ROUMOV1             IF HI/LO NEW COLLATES AFTER ITEM 1
*
*        ENTRANCE FOR A 1 WAY MERGE AND NEW ITEM IS THE WINNER
*
*        PHASE 2 - EXIT TO THE BLOCK RTN
*        PHASE 3 OR MERGE ONLY - PERFORM RECORD SEQUENCE CHECK
*        THE ASSIGNMENT ROUTINE SETS THE BRANCH INSTR ACCORDING
*        TO THE PHASE
*
IERDOM1  NOP   ROUPH3              DROP THRU FOR PHASE 2
         STM   R4,R10,ROUSVREG     SAVE NETWORK REGISTERS
         L     R11,PPIBLK2+4
         B     16(,R11)            EXIT TO BLK RTN WANT NEXT RECORD
*
*        SEQUENCE CHECK OF CURRENT NETWORK WINNER AND PREVIOUS
*        NETWORK WINNER. CHECK DONE USING R3 AND R2
*
*
ROUPH3   ICM   R2,B'1111',PPICOUNT  RECORDS GONE THROUGH ?
         BZ    ROUOUT              ZERO, NO SEQUENCE CHECK
         PPITEST PPIVSEQ           SEQUENCE CHECKING ?
         BO    ROUSCK              YES, BRANCH
*
*        NO SEQUENCE CHECK
*
ROUOUT   STM   R4,R10,ROUSVREG     SAVE NETWORK REGISTERS
         L     R11,PPIBLK+4
         B     4(,R11)             EXIT TO BLOCK RTN WANT NEXT RECORD
*
ROUSCK   L     R2,PPIDOOBA         R2 -> RECORD IN OUTPUT BUFFER
*
*               ___________________UPDATE BY IERAOU TO OFFSET INTO REC
*              |
*              |  _________________UPDATE BY IERAOU TO L'MAJOR CNTL FLD
*              | |
*              | |      ___________UPDATE BY IERAOU TO OFFSET INTO REC
*              | |     |
*              V V     V
IERDOSCK CLC   0(1,R3),0(R2)
*                                  TO SET OFFSETS AND L'COMPARE
         BNE   ROUSCB              IF UNEQUAL BYPASS NSI
         BASR  R14,R12             SET NETWORK RETURN REG FOR EQ RTN
*
*        THIS BRANCH INSTR IS BNL OR BNH DEPENDING ON THE INPUT
*        SEQUENCE
*         _________________________UPDATE BY IERAOU DEPENDING ON THE
*        |                         USER SELECTING ASCEND OR DESCEND
*        V
ROUSCB   BNL   ROUOUT              BLOCK RTN
*
*        OUT OF SEQUENCE ERROR
*
         L     R14,PPIRMC+4
         PPITEST  PPIMERGO         MERGE RUN ?
         BO    ROUMERG             YES, BRANCH
         L     R1,IER053           R1 -> MSG TEXT
         MVC   PPIABMNO,3(R1)      MOVE MSG NO INTO ABEND NO
         LM    R0,R1,IER053        IER053A OUT OF SEQUENCE ERROR
         L     R15,PPIADSSC
         BAS   R14,12(,R15)        CALL MSG WRITER
*
*        WRITE INFORMATION MESSAGE IDENTIFYING THE RECORDS BEING
*        COMPARED
*
         LR    R15,R2              R15 -> RECORD IN OUTPUT BUFFER
         AH    R15,PPIDD0L1        ADD OFFSET TO MAJOR CONTROL FIELD
         L     R14,PPIRMC+4        RESTORE ADDRESSABILITY
         MVC   IER053DS,=C'Out Buffer '  SET MESSAGE
         BAL   R14,FMTMAJ          FORMAT MAJOR CONTROL AND WRITE MSG
         L     R14,PPIRMC+4        RESTORE ADDRESSABILITY
         MVC   IER053DS,=C'From Merge '  SET MESSAGE
         LR    R15,R3              R15 -> RECORD FROM MERGE
         AH    R15,PPIDD0L1        ADD OFFSET TO MAJOR CONTROL FIELD
         BAL   R14,FMTMAJ          FORMAT MAJOR CONTROL AND WRITE MSG
         L     R15,PPIADSSC
         BAS   R14,16(,R15)        TERMINATE THE SORT
*
ROUMERG  SRL   R3,26               CONVERT DCB INDEX TO UNIT NUMBER
         CVD   R3,ROUCONV          CONVERT INDEX TO DECIMAL
         UNPK  ROUTEMP(2),ROUCONV+7(1)  UNPACK FOR PRINTING
         OI    ROUTEMP+1,X'F0'     SET SIGN POSITIVE
         L     R1,IER068           R1 -> MSG TEXT
         MVC   PPIABMNO,3(R1)      MOVE MSG NO INTO ABEND NO
         MVC   IER068A,ROUTEMP     MOVE UNIT NUMBER INTO MESSAGE
         LM    R0,R1,IER068        IER068A OUT OF SEQUENCE IN SORTIN
         L     R15,PPIADSSC
         BAS   R14,12(,R15)        CALL MSG WRITER
         L     R15,PPIADSSC
         BAS   R14,16(,R15)        TERMINATE THE SORT
*
IERDOCK6 CLC   0(1,R3),0(R9)       COMPARE NEW ITEM WITH ITEM 6
         BNE   ROUNOEQ6            IF EQUAL GOTO EQUALS ROUTINE
         LR    R2,R9               LOAD EQ RTN COMPARE REG WITH ITEM 6
         BASR  R14,R12             SET NETWORK RETURN REG FOR EQ RTN
*
*        THIS BRANCH INSTR IS BH OR BL DEPENDING ON THE INPUT
*        SEQUENCE
*
ROUNOEQ6 BH    IERDOCK7            IF HI/LO GOTO CMP ITEM 7 OR UPDATE
IERDOCK5 CLC   0(1,R3),0(R8)       COMPARE NEW ITEM WITH ITEM 5
         BNE   ROUNOEQ5            IF EQUAL GOTO EQUALS ROUTINE
         LR    R2,R8               LOAD EQ RTN COMPARE REG WITH ITEM 5
         BASR  R14,R12             SET NETWORK RETURN REG FOR EQ RTN
*
*        THIS BRANCH INSTR IS BH OR BL DEPENDING ON THE INPUT
*        SEQUENCE
*
ROUNOEQ5 BH    ROUMOV5             IF HI/LO NEW COLLATES AFTER ITEM 5
*
*        UPDATING WHERE NEW ITEM COLLATES AFTER ITEM 4 + BEFORE
*        ITEM 5
*
ROUMOV4  LR    R2,R3
         LR    R3,R4
         LR    R4,R5
         LR    R5,R6
         LR    R6,R7
         LR    R7,R2
         B     IERDOBWR            BRANCH TO OUTPUT WINNER
*
*        UPDATING WHERE NEW ITEM COLLATES AFTER ITEM 5 + BEFORE
*        ITEM 6
*
ROUMOV5  LR    R2,R3
         LR    R3,R4
         LR    R4,R5
         LR    R5,R6
         LR    R6,R7
         LR    R7,R8
         LR    R8,R2
         B     IERDOBWR            BRANCH TO OUTPUT WINNER
*
IERDOCK7 CLC   0(1,R3),0(R10)      COMPARE NEW ITEM WITH ITEM 7
         BNE   ROUNOEQ7            IF EQUAL GOTO EQUALS ROUTINE
         LR    R2,R10              LOAD EQ RTN COMPARE REG WITH ITEM 7
         BASR  R14,R12             SET NETWORK RETURN REG FOR EQ RTN
*
*        THIS BRANCH INSTR IS BH OR BL DEPENDING ON THE INPUT
*        SEQUENCE
*
ROUNOEQ7 BH    ROUMOV7             IF HI/LO NEW COLLATES AFTER ITEM 7
*
*        UPDATING WHERE NEW ITEM COLLATES AFTER ITEM 6 + BEFORE
*        ITEM 7
*
ROUMOV6  LR    R2,R3
         LR    R3,R4
         LR    R4,R5
         LR    R5,R6
         LR    R6,R7
         LR    R7,R8
         LR    R8,R9
         LR    R9,R2
         B     IERDOBWR            BRANCH TO OUTPUT WINNER
*
*        UPDATING WHERE NEW ITEM COLLATES AFTER ITEM 7
*
ROUMOV7  LR    R2,R3
ROUMMOV7 LR    R3,R4               UPDATE EXECUTED AFT CUTBACK OPERAT
         LR    R4,R5
         LR    R5,R6
         LR    R6,R7
         LR    R7,R8
         LR    R8,R9
         LR    R9,R10
         LR    R10,R2
         B     IERDOBWR            BRANCH TO OUTPUT WINNER
*
IERDOCK3 CLC   0(1,R3),0(R6)       COMPARE NEW ITEM WITH ITEM 3
         BNE   ROUNOEQ3            IF EQUAL GOTO EQUALS ROUTINE
         LR    R2,R6               LOAD EQ RTN COMPARE REG WITH ITEM 3
         BASR  R14,R12             SET NETWORK RETURN REG FOR EQ RTN
*
*        THIS BRANCH INSTR IS BH OR BL DEPENDING ON THE INPUT
*        SEQUENCE
*
ROUNOEQ3 BH    ROUMOV3             IF HI/LO NEW COLLATES AFTER ITEM 3
*
*        UPDATING WHERE NEW ITEM COLLATES AFTER ITEM 2 + BEFORE
*        ITEM 3
*
ROUMOV2  LR    R2,R3
         LR    R3,R4
         LR    R4,R5
         LR    R5,R2
         B     IERDOBWR            BRANCH TO OUTPUT WINNER
*
*        UPDATING WHERE NEW ITEM COLLATES AFTER ITEM 3 + BEFORE
*        ITEM 4
*
ROUMOV3  LR    R2,R3
         LR    R3,R4
         LR    R4,R5
         LR    R5,R6
         LR    R6,R2
         B     IERDOBWR            BRANCH TO OUTPUT WINNER
*
*        UPDATING WHERE NEW ITEM COLLATES AFTER ITEM 1 + BEFORE
*        ITEM 2
*
ROUMOV1  LR    R2,R3
         LR    R3,R4
         LR    R4,R2
         B     IERDOBWR            BRANCH TO OUTPUT WINNER
*
*        SPECIAL ITEM 4 COMPARE FOR 5 WAY MERGE
*
IERDOCK4 CLC   0(1,R3),0(R7)       COMPARE NEW ITEM WITH ITEM 4
         BNE   ROUNOEQS            IF EQUAL GOTO EQUALS ROUTINE
         LR    R2,R7               LOAD EQ RTN COMPARE REG WITH ITEM 4
         BASR  R14,R12             SET NETWORK RETURN REG FOR EQ RTN
*
*        THIS BRANCH INSTR IS BH OR BL DEPENDING ON THE INPUT
*        SEQUENCE
*
ROUNOEQS BH    ROUMOV4             IF HI/LO GOTO UPDATE
         B     IERDOCK3            IF NOT HI/LO GOTO CMP ITEM 3
*
*        COMPLETION OF THE FIND THE LOW LOOP
*
*        PUTTING OUT THE NETWORK WINNER
*        SEQUENCE CHECKING IS NOT NECESSARY
*        IF PHASE 2 EXIT TO THE BLOCK ROUTINE
*        THE ASSIGNMENT ROUTINE SETS THE BRANCH INSTR ACCORDING
*        TO THE PHASE
*
IERDOBWR NOP   ROUPH3NS            DROP THRU FOR PHASE 2
         STM   R4,R10,ROUSVREG     SAVE NETWORK REGISTERS
         L     R11,PPIBLK2+4
         B     16(,R11)            EXIT TO BLK RTN WANT NEXT RECORD
*
ROUPH3NS STM   R4,R10,ROUSVREG     SAVE NETWORK REGISTERS
         L     R11,PPIBLK+4
         B     4(,R11)             EXIT TO BLOCK RTN WANT NEXT RECORD
*
*        COMPLETION OF A CUTBACK OPERATION
*
*        THIS SECTION INITIALLY CHECKS FOR THE NETWORK BEING SET
*        FOR THE MERGE ORDER. SUBSEQUENTLY A BRANCH TO UPDATE IS
*        EXECUTED
*
ROUFMUDS NOP   ROUFDMO             SET TO BRANCH BY INITIALIZATION RTN
*
*        FALL THROUGH FOR UPDATING NETWORK AFTER A CUTBACK
*        OPERATION
*
         ST    R2,ROUSVCBA         SAVE NEXT CUTBACK ADDRESS
         B     ROUMMOV7            MODIFIED MOVE AFTER ITEM 7 NOTE BELO
*                                  ALL REGISTERS EXCEPT R2 INVOLVED
*
ROUFDMO  L     R5,ROUIDMO          SET TO 8 BY INITIALIZATION RTN
         C     R5,ROUACMO          SET TO ACTUAL MERGE ORDER BY INITIAL
         BE    ROUSFTTU            SET FALL THRU TO UPDATE
         S     R5,KF1              CONSTANT OF ONE
         ST    R5,ROUIDMO
         BR    R2                  BRANCH BACK TO CUTBACK RTN
*
ROUSFTTU XI    ROUFMUDS+1,X'F0'    SET ROUFMUDS BRANCH TO FALL THRU
         ST    R2,ROUSVCBA         SAVE ADDR OF NEXT CUTBACK CODE
         B     ROUINTSQ            EXIT TO INIT SEQ THE RECORDS
*
*        NETWORK CUTBACK SECTION
*        TAILOR THE NETWORK FOR THE MERGE ORDER
*
*        THE INITIAL ENTRANCE TO THE CUTBACK SECTION
*        SET NETWORK FOR AN 8 WAY MERGE
*
ROUCSEWM MVC   ROUNOEQ8(4),ROUEGW1  SET BR TO CMP ITEM 6 AFT ITEM 4 CMP
         MVC   ROUNOEQ6(4),ROUEGW2  SET BR TO CMP ITEM 7 AFT ITEM 6 CMP
         MVC   ROUNOEQ4(4),ROUEGW3  SET BR TO CMP ITEM 3 AFT ITEM 2 CMP
         MVC   ROUNTENS(4),ROUANT8  SET NETWORK ENTRANCE FOR 8 WAY MERG
         BAS   R2,ROUFMUDS         SAVE ADDR OF NEXT CUTBACK SECTION
*
*        SET NETWORK FOR AN 7 WAY MERGE
*
         MVC   ROUNOEQ6(4),ROUSVWM  SET BR TO UPDATE AFTER ITEM 6 CMP
         BAS   R2,ROUFMUDS          SAVE ADDR OF NEXT CUTBACK SECTION
*
*        SET NETWORK FOR A 6 WAY MERGE
*
         MVC   ROUNOEQ8(4),ROUSXWM  SET BR TO CMP ITEM 5 AFT ITEM 4 CMP
         BAS   R2,ROUFMUDS          SAVE ADDR OF NEXT CUTBACK SECTION
*
*        SET NETWORK FOR A 5 WAY MERGE
*
         MVC   ROUNOEQ4(4),ROUFVWM  SET BR TO CMP ITEM 4 AFT ITEM 2 CMP
         MVC   ROUNTENS(4),ROUANT4  SET NETWORK ENTRANCE FOR 5 WAY MERG
         BAS   R2,ROUFMUDS          SAVE ADDR OF NEXT CUTBACK SECTION
*
*        SET NETWORK FOR A 4 WAY MERGE
*
         MVC   ROUNOEQ4(4),ROUEGW3  SET BR TO CMP ITEM 3 AFT ITEM 2 CMP
         BAS   R2,ROUFMUDS          SAVE ADDR OF NEXT CUTBACK SECTION
*
*        SET NETWORK FOR A 3 WAY MERGE
*
         MVC   ROUNOEQ4(4),ROUTHWM  SET BR TO UPDATE AFTER ITEM 2 CMP
         BAS   R2,ROUFMUDS          SAVE ADDR OF NEXT CUTBACK SECTION
*
*        SET NETWORK FOR A 2 WAY MERGE
*
         MVC   ROUNTENS(4),ROUANT2  SET NETWORK ENTRANCE FOR 2 WAY MERG
         BAS   R2,ROUFMUDS          SAVE ADDR OF NEXT CUTBACK SECTION
*
*        SET NETWORK FOR A 1 WAY MERGE
*
         MVC   ROUNTENS(4),ROUANT1  SET NETWORK ENTRANCE FOR 1 WAY MERG
         BAS   R2,ROUFMUDS          SAVE ADDR OF NEXT CUTBACK SECTION
*
*        ZERO WAY MERGE
*
*        PHASE 2 - EXIT TO THE BLOCK RTN (RELEASE CURRENT BLK TO
*        WRITE)
*        PHASE 3 OR MERGE ONLY - EXIT TO THE BLOCK RTN (END OF
*        JOB)
*        THIS BRANCH INSTR IS SET BY THE ASSIGNMENT ROUTINE
*        ACCORD TO PHASE
*
IERDOCPS NOP   ROUCPH3             FALL THRU FOR PHASE 2
         L     R11,PPIBLK2+4
         BR    R11                 EXIT TO BLOCK RTN (WRITE THE BLK)
*
ROUCPH3  L     R11,PPIBLK+4
         BR    R11                 EXIT TO BLOCK RTN (END OF JOB)
*
*        ENTRY TO THE CUTBACK RTN FROM READ RTN + THE ALGORITHM
*
ROUCUTEN LM    R4,R10,ROUSVREG     RESTORE NETWORK REGISTERS
         L     R2,ROUSVCBA         SET APPROPRIATE CUTBACK SECTION ADDR
         BR    R2                  BRANCH TO APPROPRIATE CUTBACK SECTN
*
*        END OF THE CUTBACK SECTION
*
*        INITIAL SEQUENCING OF RECORDS SECTION EXECUTED AT THE
*        BEGINNING OF EACH MERGE OPERATION
*        A RELATIVE POSITION METHOD IS EMPLOYED FOR THE
*        SEQUENCING THIS METHOD CAN BE DESCRIBED AS COMPARING ONE
*        ITEM OF A LIST WITH THE REMAINDER OF THE ITEMS AND,
*        THEREBY, DETERMINING ITS PROPER POSITION IN THE LIST. TO
*        ACCOMPLISH THIS, A TWO AREA SYSTEM IN PPI IS UTILIZED
*
ROUINTSQ SR    R8,R8               INDEX USED TO GET ITEMS TO BE SEQD
         L     R1,ROUACMO          DETERMINES WHEN ALL ITEMS ARE SEQD
         LA    R6,PPIPDWA          BEGINNING ADDR OF REC ADDR IN PPI
ROURETRN L     R5,ROUACMO          USED TO CHECK WHEN AN ITEM HAS BEEN
*                                  CHECKED WITH ALL THE OTHER ITEMS
         L     R3,0(R8,R6)         THE ITEM BEING POSITIONED
         LA    R4,PPIPSVA-4        ADDR WHERE ITEM IS STORED AFT POS FD
         SR    R7,R7               INDEX USED TO CMP ALL OTHER ITEMS
ROUANOTH L     R2,0(R7,R6)         ADDR OF ITEMS CMP TO ITEM IN R2
IERDOICP CLC   0(1,R3),0(R2)
*
*        THIS BRANCH INSTR IS BNL OR BNH DEPENDING ON THE INPUT
*        SEQUENCE
*
ROUISNLH BNL   ROUHIEQ             HI/LO AND EQUAL CASE TREATED SAME
ROUDECR  LA    R7,4(,R7)
         BCT   R5,ROUANOTH         TRY NEXT ITEM
ROUCHEK  CLC   0(4,R4),KF0         STORAGE AREA OF ITEMS IS INITIALLY
*                                  ZERO CHECK TO INSURE ANOTHER ITEM
*                                  DOES NOT OCCUPY THIS POSITION
         BE    ROUINSRT            IF ZERO STORE ITEM
         S     R4,KF4              IF EQUAL CHECK NEXT LOWER POSITION
         B     ROUCHEK             CONTINUE CHECKING FOR ZEROS
*
ROUINSRT ST    R3,0(,R4)           STORE POSITIONED ITEM
         BCT   R1,ROUINCR          IF NOT DONE GET NEXT ITEM TO POSITIN
         B     ROUOUTIS            BRANCH TO SET NETWORK REG IF DONE
*
*        THIS BRANCH INSTR IS BH OR BL DEPENDING ON THE INPUT
*        SEQUENCE
*
ROUHIEQ  BH    ROURND              IF NOT EQ INCR STORE POS POINTER
         BASR  R14,R12             SET NETWORK RETURN REG FOR EQ RTN
*
*        THIS BRANCH INSTR IS BL OR BH DEPENDING ON THE INPUT
*        SEQUENCE
*
ROULOHI  BL    ROUDECR             CHECK NEXT ITEM
ROURND   LA    R4,4(,R4)
         B     ROUDECR             DECREMENT AND CHECK FOR ZEROS
*
ROUINCR  LA    R8,4(,R8)
         B     ROURETRN            LAST COMPARE
*
*        END OF THE INITIAL SEQUENCING SECTION
*
*        MOVE ADDRS OF SEQUENCED ITEMS TO MERGE NETWORK REGISTERS
*
ROUOUTIS LA    R1,PPIPSVA          ADDR OF FIRST SEQUENCED ITEM
         L     R2,ROUACMO          MERGE ORDER
         A     R2,KF2
         EX    R2,ROULODMR         EXECUTE LOAD REGISTERS INSTR
*
*        THIS BRANCH INSTR SET BY THE ASSIGN RTN ACCORDING TO THE
*        PHASE
*
IERDOIP3 NOP   ROUINSP3            FALL THRU IF PHASE 2
         STM   R4,R10,ROUSVREG     SAVE NETWORK REGISTERS
         L     R11,PPIBLK2+4
         B     12(,R11)            EXIT TO BLK RTN WANT NEXT RCD
*
*        PHASE 3 PROCEDURE
*
ROUINSP3 STM   R4,R10,ROUSVREG     SAVE NETWORK REGISTERS
         L     R11,PPIBLK+4
         B     4(,R11)            EXIT TO BLOCK RTN WANT NEXT RCD
*
*        SELF INITIALIZATION SECTION
*        PERFORMED AT THE BEGINNING OF EACH PASS OR SUB PASS
*
ROUSINIT MVC   ROUIDMO(4),KF8      SET MAX MRG ORD TO 8 A FIND M PARAM
         LH    R4,PPIMRGMX         SET ACTUAL MRG ORD FROM PPI
         ST    R4,ROUACMO
         SR    R4,R4
         ST    R4,PPIPSVA
         MVC   PPIPSVA+4(60),PPIPSVA  ZERO INT SEQ STORE AREA
         XI    ROUFMUDS+1,X'F0'    SET ROUFMUDS TO BRANCH
         PPITEST  PPIPH1CO         INPUT SEQ ASCENDING OR DESCENDING ?
         BO    ROUISD              FALL THRU IF INPUT SEQ IS ASCENDING
         TM    ROUNOEQ8+1,X'20'    RTN SET FOR ASCENDING ?
ROUFDSQ  BO    ROUCSEWM            IF THE ROUTINE IS SET FOR THE INPUT
         XI    ROUNOEQ8+1,X'60'    SEQUENCE BRANCH TO THE CUTBACK
         XI    ROUNOEQ4+1,X'60'    SECTION. IF THE ROUTINE IS NOT SET
         XI    ROUNOEQ2+1,X'60'    FOR THE INPUT CHANGE THE MASK OF
         XI    ROUSCB+1,X'60'      THE BRANCH ON CONDITION INSTR
         XI    ROUNOEQ6+1,X'60'
         XI    ROUNOEQ5+1,X'60'
         XI    ROUNOEQ7+1,X'60'
         XI    ROUNOEQ3+1,X'60'
         XI    ROUNOEQS+1,X'60'
         XI    ROUISNLH+1,X'60'
         XI    ROUHIEQ+1,X'60'
         XI    ROULOHI+1,X'60'
         XI    ROUEGW1+1,X'60'
         XI    ROUEGW2+1,X'60'
         XI    ROUEGW3+1,X'60'
         XI    ROUSVWM+1,X'60'
         XI    ROUSXWM+1,X'60'
         XI    ROUFVWM+1,X'60'
         XI    ROUTHWM+1,X'60'
         B     ROUCSEWM            BRANCH TO CUTBACK SECTION
*
*        THE INPUT SEQUENCE IS IN DESCENDING ORDER
*
ROUISD   TM    ROUNOEQ8+1,X'40'    IS ROUTINE SET FOR DESCG ?
         B     ROUFDSQ             MODIFY BRANCHES IF NECESSARY
*
*        FORMAT MAJOR CONTROL FIELD AND WRITE IER053D MESSAGE
*
*        INPUT -
*        R15 -> CONTROL FIELD
*        R11  - RETURN ADDR
*        IERDOSCK+1 = L'MAJOR CONTROL FIELD - 1
*
FMTMAJ   PPITEST  PPIDIAG+PPIDSIM  GENERATE DIAGNOSTIC MESSAGES ?
         BZR   R14                 NO, BYPASS MSG GENERATION
         STM   R0,R15,FMTMAJRS     SAVE REGS
         L     R14,PPIRMC+4        ADDRESSABILITY TO MESSAGE
         LA    R14,IER053DD        R14 -> MESSAGE AREA
         SR    R1,R1
         ICM   R1,B'0001',IERDOSCK+1  GET L'CONTROL FIELD FROM CLC INST
         LA    R1,1(,R1)           COUNT EACH BYTE
         CLI   IERDOSCK+1,20       L'CONTROL FIELD > 20 ?
         BL    FMTMAJA             NO, USE CURRENT LENGTH
         LA    R1,20               SET MAX LENGTH TO 20
FMTMAJA  IC    R0,0(,R15)          R0 = INPUT BYTE FROM CONTROL FIELD
         STC   R0,1(,R14)          STORE RIGHT NIBBLE
         NI    1(R14),X'0F'        MAKE ZONE X'0'
         SRL   R0,4                MOVE ZONE TO NUMERIC
         STC   R0,0(,R14)          STORE LEFT NIBBLE
         NI    0(R14),X'0F'        MAKE ZONE X'0'
         LA    R14,2(,R14)         INCR MESSAGE LOCATION
         LA    R15,1(,R15)         INCR MAJOR FIELD LOCATION
         BCT   R1,FMTMAJA          LOOP TO PROCESS NEXT BYTE
         ICM   R1,B'0001',IERDOSCK+1  GET L'CONTROL FIELD FROM CLC INST
         LA    R1,1(R1,R1)         DOUBLE IT PLUS 1
         L     R14,PPIRMC+4        RESTORE ADDRESSABILITY
         EX    R1,FMTMAJEX         TRANSLATE TO PRINTABLE CHARS
         LM    R0,R1,IER053D       IER053I MAJOR CONTROL FIELD DATA
         L     R15,PPIADSSC
         BAS   R14,12(,R15)        CALL MSG WRITER
         LM    R0,R15,FMTMAJRS     RESTORE REGS
         BR    R14                 RETURN TO CALLER
*
*        EXECUTED INSTRUCTIONS
*
ROULODMR LM    R3,0,0(R1)          LOAD NETWORK REGISTERS
FMTMAJEX TR    IER053DD(0),HEXTAB  TRANSLATE TO PRINTABLES
*
ROUSVREG DC    7F'0'               REGISTER SAVE AREA FOR INTERFACING
FMTMAJRS DC    16F'0'
*
ROUANT8  B     IERDOM8             NETWORK ENTR ADDR FOR 6,7,8 WAY MRG
ROUANT4  B     IERDOM4             NETWORK ENTR ADDR FOR 3,4,5 WAY MRG
ROUANT2  B     IERDOM2             NETWORK ENTR ADDR FOR 2 WAY MERGE
ROUANT1  B     IERDOM1             NETWORK ENTR ADDR FOR 1 WAY MERGE
*
ROUIDMO  DC    F'0'                MAXIMUM MERGE ORDER SET BY INITIAL
ROUACMO  DC    F'0'                ACTUAL MERGE ORDER SET BY INITIAL
ROUSVCBA DC    F'0'                SAVE NEXT CUTBACK ADDR WORD
*
*        THE FOLLOWING 7 INSTR ARE BH OR BL DEPENDING ON THE
*        INPUT SEQUENCE
*
ROUEGW1  BH    IERDOCK6            BRANCH TO COMPARE TIME 6 SET BY INIT
ROUEGW2  BH    IERDOCK7            BRANCH TO COMPARE ITEM 7 SET BY INIT
ROUEGW3  BH    IERDOCK3            BRANCH TO COMPARE ITEM 3 SET BY INIT
ROUSVWM  BH    ROUMOV6             BRANCH TO UPDATE R3 TO R8 SET BY INT
ROUSXWM  BH    IERDOCK5            BRANCH TO COMPARE ITEM 5 SET BY INIT
ROUFVWM  BH    IERDOCK4            BRANCH TO COMPARE ITEM 4 SET BY INIT
ROUTHWM  BH    ROUMOV2             BRANCH TO UPDATE R4 TO R5 SET BY INT
*
KF0      DC    F'0'                CONSTANT OF ZERO
KF4      DC    F'4'                CONSTANT OF FOUR
KF8      DC    F'8'                CONSTANT OF EIGHT
KF2      DC    F'2'                CONSTANT OF TWO
KF1      DC    F'1'                CONSTANT OF ONE
ROUTEMP  DC    H'0'                TEMP STORAGE FOR UNIT NUMBER
ROUCONV  DC    D'0'                CONVERSION AREA FOR UNIT NUMBER
HEXTAB   DC    C'0123456789ABCDEF'  FOR TRANSLATION TO PRINTABLES
*
         LTORG
*
./ ADD NAME=IERROV   0101-20211-20211-1200-00081-00081-00000-RELEASE 00
ROV      TITLE 'IERROV - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERROV
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 2 AND 3, 1-8 WAY MERGE NETWORK WITH A SINGLE
*        CONTROL FIELD
*        THE FUNCTION OF THIS MODULE IS TO MERGE FIXED OR
*        VARIABLE LENGTH RECORDS IN ASCENDING OR DECENDING
*        SEQUENCE. INITIALLY IERROV SEQUENCES THE INPUT RECORDS
*        IN THE PHASE TO PHASE INFORMATION AREA, CUTSBACK THE
*        NETWORK FOR SPECIFIED MERGE ORDER AND THEN UTILIZES A
*        BINARY INSERTION TECHNIQUE. THIS IS ACCOMPLISHED BY
*        USING THE ADDRS OF THE RECORDS IN THE GENERAL
*        REGISTERS R4 THRU R10. THE LOW ORDER 3 BYTES OF THE
*        REGISTER CONTAIN THE ADDRESS OF THE RECORD. THE HIGH
*        ORDER BYTE HAS A FILE INDENTIFIER FOR THE DEBLOCK
*        ROUTINE. R3 IS THE NEW RECORD CONVEYER FROM
*        DEBLOCK AND COMMUNICATES TO BLOCK
*
*        MACROS USED -
*        SMPPI
*
*        ENTRY POINTS - CALLING SEQUENCE -
*                           LA   R15,PPINETM+4
*                           BR   R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIDOOBA   PPIMRGMX   PPIPSVA
*        PPIBLK     PPIRMC     PPIDOUA
*        PPIPDWA    PPICNTL    PPIBLK2
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPIPSVA
*
*        EXTERNAL ROUTINES -
*        EXTRN IERRMC  - MESSAGE MODULE
*        EXTRN IERDB2  - PHASE TWO BLOCK ROUTINE
*        EXTRN IERDB34 - PHASE THREE BLOCK ROUTINE
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL -
*        IERDB2  - BLOCK PHASE 2
*        IERDB34 - BLOCK PHASE 3
*
*        EXITS - ERROR -
*        IERRNC - MESSAGE MODULE
*
*        TABLES/WORK AREAS - N/A
*
*        NOTES - N/A
*
IERROV   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERROV SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERROVI
*
*        IERRMC
*
*        THIS DSECT CONTAINS ALL OF THE MESSAGES THAT ARE
*        REQUIRED FOR PHASE 3 OR MERGE ONLY RUNNING PROGRAM
*
DIERRMC  DSECT
*
         COPY  RMCMAIN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERROVI  0101-20211-20211-1200-00589-00589-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERROV SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERROVI
*
         USING *,R11               MODULE USING REGISTER
         USING IERRCA,R13          SETTING PPI DSECT USING REGISTER
         USING DIERRMC,R14         MESSAGE MODULE
*
IERDO1   B     ROVSINIT            +00 READ PRIME ENTRY BR TO INITIAL
         B     ROVCUTEN            +04 READ + ALGTM ENTRY BR TO CUTBACK
         LM    R4,R10,ROVSVREG     +08 DEBLOCK ENTRY - RESTORE REGS
IERDOET  B     ROVNTENS            FALL THRU IF EXTRACTING
*
         L     R2,ROVSVEXA         SET R2 WITH EXTR POS ADDR
         ST    R3,0(,R2)           STORE RCD ADDR IN EXTRACT POS ADDR
         LR    R0,R2
         LR    R2,R3               SET FROM AND TO REG FOR EXTRACT RTN
         LR    R3,R0
         BAS   R14,4(,R12)         EXIT TO EXTRACT ROUTINE
         LM    R4,R10,ROVSVREG     RESTORE MERGE REGS
ROVNTENS B     IERDOM8             NETWORK ENTRY SWITCH SET BY CUTBACK
*
*        FIND THE WINNER LOOP
*
*        ENTRANCE FOR A 6, 7, 8 WAY MERGE
*
IERDOM8  CLC   0(1,R3),0(R7)       COMPARE NEW ITEM WITH ITEM 4
*
*        THIS BRANCH INSTR IS BH BL DEPENDING ON THE INPUT
*        SEQUENCE
*
ROVI4B   BH    IERDOCK6            IF HI/LO GOTO CMP ITEM 6 OR 5
*
*        ENTRANCE FOR A 3, 4, 5 WAY MERGE
*
IERDOM4  CLC   0(1,R3),0(R5)       COMPARE NEW ITEM WITH ITEM 2
*
*        THIS BRANCH INSTR IS BH OR BL DEPENDING ON THE INPUT
*        SEQUENCE
*
ROVI2B   BH    IERDOCK3            IF HI/LO GOTO CMP ITEM 3,4 OR UPDAT
*
*        ENTRANCE FOR A 2 WAY MERGE
*
IERDOM2  CLC   0(1,R3),0(R4)       COMPARE NEW ITEM WITH ITEM 1
*
*        THIS BRANCH INSTR IS BH OR BL DEPENDING ON THE INPUT
*        SEQUENCE
*
ROVI1B   BH    ROVMOV1             IF HI/LO NEW COLLATES AFTER ITEM 1
*
*        ENTRANCE FOR A ONE WAY MERGE AND NEW ITEM IS THE WINNER
*
ROV1WM   XI    ROVSCSW+1,X'F0'     SET SEQ CHK SWITCH TO YES
*
*        COMMUNICATE THE NETWORKS WINNING RECORD ADDR TO THE
*        BLOCK ROUTINE AFTER TAKING APPROPRIATE ACTION
*        IF EXTRACTING AND IF THERE IS TO BE A SEQUENCE CHECK.
*        THE PHASE AND EXTRACT SWITCHES ARE SET BY THE ASSGN RTN
*
IERDOBWR NOP   IERNEXTR            IF EXTRACTING FALL THRU
IERDOBB1 NOP   ROVEPH3P            FALL THRU FOR PHASE 2
         ST    R3,ROVSVEXA         SAVE EXTRACT POS ADDR
         L     R3,0(,R3)           LOAD ACTUAL ADDR OF WINNING RCD
ROVBBLK2 STM   R4,R10,ROVSVREG     SAVE NETWORK REGISTERS
ROVBBFIS NOP   ROVISOUT            IF RCD FROM INT SEQ BRANCH
         L     R11,PPIBLK2+4
         B     16(,R11)            EXIT TO BLK RTN WANT NEXT RCD
*
ROVISOUT XI    ROVBBFIS+1,X'F0'
         L     R11,PPIBLK2+4
         B     12(,R11)            EXIT TO BLK RTN WANT NEXT RCD
*
*        PHASE 3 + MERGE ONLY PROCEDURE IF EXTRACTING
*
ROVEPH3P L     R2,ROVSQCWD         PUT EXTRACT POS ADDR IN R2
         ST    R2,ROVSVEXA
         ST    R3,ROVSQCWD         SAVE WIN EXTRACT POS ADDR FOR SEQ CK
*
*        SWITCH SET BY INITIAL SEQUENCING RTN TO BYPASS CHK FOR
*        SEQ CHK
*
ROVFRSW1 NOP   ROVFR1              FALL THRU IF NOT FIRST RECORD
*
*        IF THE NEW RECORD IS THE WINNER, A SEQUENCE CHECK WILL
*        BE PERFORMED IF REQUESTED. IF THE NEW RECORD IS NOT THE
*        WINNER, NO SEQUENCE CHECK IS NECESSARY
*
ROVSCSW  NOP   ROVNIW              FALL THRU IF NEW IS NOT WINNER
IERXTRT1 NOP   ROVSVR              FALL THRU IF EXTRACTING
ROVSAA   L     R3,0(,R3)           LOAD ACTUAL ADDR OF WINNING RCD
ROVSVR   STM   R4,R10,ROVSVREG     SAVE NETWORK REGISTERS
         L     R11,PPIBLK+4
         B     4(,R11)             EXIT TO BLK RTN WANT NEXT RECORD
*
ROVFR1   XI    ROVFRSW1+1,X'F0'    SET FIRST RCD SWITCH 1 TO FALL THRU
         B     ROVSAA              BRANCH TO SET ACTUAL ADDR
*
ROVNIW   XI    ROVSCSW+1,X'F0'     SET ROVSCSW TO FALL THRU
*
*        SEQUENCE CHECK OF CURRENT NETWORK WINNER AND PREVIOUS
*        NETWORK WINNER. CHECK DONE USING R3 AND R2
*
         ICM   R1,B'1111',PPICOUNT  RECORDS GONE THROUGH ?
         BZ    IERXTRT2            NO, NO SEQUENCE CHECK
         PPITEST PPIVSEQ           SEQUENCE CHECK ?
         BO    IERDOSCK            YES, BRANCH
*
*        NO SEQUENCE CHECK
*
IERXTRT2 B     ROVSAA              EXTRACTING - BRANCH TO ROVSAA
         B     ROVSVR              NOT EXTRACTING - BRANCH TO ROVSVR
*
*               ___________________UPDATE BY IERAOV TO OFFSET INTO REC
*              |
*              |  _________________UPDATE BY IERAOV TO L'MAJOR CNTL FLD
*              | |
*              | |      ___________UPDATE BY IERAOV TO OFFSET INTO REC
*              | |     |
*              V V     V
IERDOSCK CLC   0(1,R3),0(R2)
*
*        THIS BRANCH INSTR IS BNL OR BNH DEPENDING ON THE INPUT
*        SEQUENCE
*         _________________________UPDATE BY IERAOV DEPENDING ON THE
*        |                         USER SELECTING ASCEND OR DESCEND
*        V
ROVSCB   BNL   IERXTRT1            GET NEXT RECORD FROM BLOCK RTN
*
*        OUT OF SEQUENCE ERROR
*
         L     R14,PPIRMC+4
         PPITEST  PPIMERGO         MERGE OPERATION ?
         BO    ROVMERG             YES, BRANCH
         L     R1,IER053           R1 -> MSG TEXT
         MVC   PPIABMNO,3(R1)      MOVE MSG NO INTO ABEND NO
         LM    R0,R1,IER053        IER053A OUT OF SEQUENCE ERROR
         L     R15,PPIADSSC
         BAS   R14,12(,R15)        CALL WRITE MESSAGE
*
*        WRITE INFORMATION MESSAGE IDENTIFYING THE RECORDS BEING
*        COMPARED
*
IERDOSCL LR    R15,R2              R15 -> RECORD IN OUTPUT BUFFER
         AH    R15,PPIDD0L1        ADD OFFSET TO MAJOR CONTROL FIELD
         L     R14,PPIRMC+4        RESTORE ADDRESSABILITY
         MVC   IER053DS,=C'Out Buffer '  SET MESSAGE
         BAL   R14,FMTMAJ          FORMAT MAJOR CONTROL AND WRITE MSG
         L     R14,PPIRMC+4        RESTORE ADDRESSABILITY
         MVC   IER053DS,=C'From Merge '  SET MESSAGE
         LR    R15,R3              R15 -> RECORD FROM MERGE
         AH    R15,PPIDD0L1        ADD OFFSET TO MAJOR CONTROL FIELD
         BAL   R14,FMTMAJ          FORMAT MAJOR CONTROL AND WRITE MSG
         L     R15,PPIADSSC
         BAS   R14,16(,R15)        TERMINATE THE SORT
*
ROVMERG  NOP   ROV100              FALL THRU IF EXTRACTING
         L     R3,0(,R3)           LOAD RECORD ADDR FROM EXTRACT
*                                  WORK AREA
ROV100   SRL   R3,26               CONVERT DCB INDEX TO UNIT NUMBER
         CVD   R3,ROVCONV          CONVERT INDEX TO DECIMAL
         UNPK  ROVTEMP(2),ROVCONV+7(1)  UNPACK FOR PRINTING
         OI    ROVTEMP+1,X'F0'     SET SIGN POSITIVE
         MVC   IER068A,ROVTEMP     MOVE UNIT NUMBER INTO MESSAGE
         L     R1,IER068           R1 -> MSG TEXT
         MVC   PPIABMNO,3(R1)      MOVE MSG NO INTO ABEND NO
         LM    R0,R1,IER068        IER068A OUT OF SEQUENCE IN SORTIN
         L     R15,PPIADSSC
         BAS   R14,12(,R15)        CALL WRITE MESSAGE
         L     R15,PPIADSSC
         BAS   R14,16(,R15)        TERMINATE THE SORT
*
*        NOT EXTRACTING
*
IERNEXTR B     ROVBBLK2            IF PHASE 2 BRANCH
ROVFRSW2 NOP   ROVFR2              IF FIRST RECORD BRANCH
         L     R2,PPIDOOBA         ADDR OF RCD IN OUTPUT BUFFER
         B     ROVSCSW             BRANCH TO CHK IF SEQ CHK REQUIRED
*
ROVFR2   XI    ROVFRSW2+1,X'F0'    SET FIRST RCD SW 2 TO FALL THRU
         B     ROVSVR              BRANCH TO BLOCK RECORD
*
IERDOCK6 CLC   0(1,R3),0(R9)       COMPARE NEW ITEM WITH ITEM 6
*
*        THIS BRANCH INSTR IS BH OR BL DEPENDING ON THE INPUT
*        SEQUENCE
*
ROVI6B   BH    IERDOCK7            IF HI/LO GO TO CMP ITEM 7 OR UPDATE
IERDOCK5 CLC   0(1,R3),0(R8)       COMPARE NEW ITEM WITH ITEM 5
*
*        THIS BRANCH INSTR IS BH OR BL DEPENDING ON THE INPUT
*        SEQUENCE
*
ROVI5B   BH    ROVMOV5             IF HI/LO NEW COLLATES AFTER ITEM 5
*
*        UPDATING WHERE NEW ITEM COLLATES AFTER ITEM 4 + BEFORE
*        ITEM 5
*
ROVMOV4  LR    R2,R3
         LR    R3,R4
         LR    R4,R5
         LR    R5,R6
         LR    R6,R7
         LR    R7,R2
         B     IERDOBWR            BRANCH TO OUTPUT WINNER
*
*        UPDATING WHERE NEW ITEM COLLATES AFTER ITEM 5 + BEFORE
*        ITEM 6
*
ROVMOV5  LR    R2,R3
         LR    R3,R4
         LR    R4,R5
         LR    R5,R6
         LR    R6,R7
         LR    R7,R8
         LR    R8,R2
         B     IERDOBWR            BRANCH TO OUTPUT WINNER
*
IERDOCK7 CLC   0(1,R3),0(R10)      COMPARE NEW ITEM WITH ITEM 7
*
*        THIS BRANCH INSTR IS BH OR BL DEPENDING ON THE INPUT
*        SEQUENCE
*
ROVI7B   BH    ROVMOV7             IF HI/LO NEW COLLATES AFTER ITEM 7
*
*        UPDATING WHERE NEW ITEM COLLATES AFTER ITEM 6 + BEFORE
*        ITEM 7
*
ROVMOV6  LR    R2,R3
         LR    R3,R4
         LR    R4,R5
         LR    R5,R6
         LR    R6,R7
         LR    R7,R8
         LR    R8,R9
         LR    R9,R2
         B     IERDOBWR            BRANCH TO OUTPUT WINNER
*
*        UPDATING WHERE NEW ITEM COLLATES AFTER ITEM 7
*
ROVMOV7  LR    R2,R3
ROVMMOV7 LR    R3,R4               UPDATE EXECUTED AFTER CUTBACK OPER
         LR    R4,R5
         LR    R5,R6
         LR    R6,R7
         LR    R7,R8
         LR    R8,R9
         LR    R9,R10
         LR    R10,R2
         B     IERDOBWR            BRANCH TO OUTPUT WINNER
*
IERDOCK3 CLC   0(1,R3),0(R6)       COMPARE NEW ITEM WITH ITEM 3
*
*        THIS BRANCH INSTR IS BH OR BL DEPENDING ON THE INPUT
*        SEQUENCE
*
ROVI3B   BH    ROVMOV3             INSERT INTO COLLATING SEQUENCE
*
*        UPDATING WHERE NEW ITEM COLLATES AFTER ITEM 2 + BEFORE
*        ITEM 3
*
ROVMOV2  LR    R2,R3
         LR    R3,R4
         LR    R4,R5
         LR    R5,R2
         B     IERDOBWR            BRANCH TO OUTPUT WINNER
*
*        UPDATING WHERE NEW ITEM COLLATES AFTER ITEM 3 + BEFORE
*        ITEM 4
*
ROVMOV3  LR    R2,R3
         LR    R3,R4
         LR    R4,R5
         LR    R5,R6
         LR    R6,R2
         B     IERDOBWR            BRANCH TO OUTPUT WINNER
*
*        UPDATING WHERE NEW ITEM COLLATES AFTER ITEM 1 + BEFORE
*        ITEM 2
*
ROVMOV1  LR    R2,R3
         LR    R3,R4
         LR    R4,R2
         B     IERDOBWR            BRANCH TO OUTPUT WINNER
*
*        SPECIAL ITEM 4 COMPARE FOR 5 WAY MERGE
*
IERDOCK4 CLC   0(1,R3),0(R7)       COMPARE NEW ITEM WITH ITEM 4
*
*        THIS BRANCH INSTR IS BH OR BL DEPENDING ON THE INPUT
*        SEQUENCE
*
ROVSI4B  BH    ROVMOV4             IF HI/LO GO TO UPDATE
         B     IERDOCK3            GO TO COMPARE NEW ITEM WITH ITEM 3
*
*        NETWORK CUTBACK SECTION
*
*        TAILOR THE NETWORK FOR THE MERGE ORDER
*
*        THE INITIAL ENTRANCE TO THE CUTBACK SECTION
*
*        SET NETWORK FOR AN 8 WAY MERGE
*
ROVCSEWM MVC   ROVI4B(4),ROVEGW1   SET BR TO CMP ITEM 6 AFT ITEM 4 CMP
         MVC   ROVI6B(4),ROVEGW2   SET BR TO CMP ITEM 7 AFT ITEM 6 CMP
         MVC   ROVI2B(4),ROVEGW3   SET BR TO CMP ITEM 3 AFT ITEM 2 CMP
         MVC   ROVNTENS(4),ROVANT8 SET NETWORK ENTRANCE FOR 8 WAY MERGE
         BAS   R2,ROVFMUDS         SAVE ADDR OF NEXT CUTBACK SECTION
*
*        SET NETWORK FOR AN 7 WAY MERGE
*
         MVC   ROVI6B(4),ROVSVWM   SET BR TO UPDATE AFTER ITEM 6 CMP
         BAS   R2,ROVFMUDS         SAVE ADDR OF NEXT CUTBACK SECTION
*
*        SET NETWORK FOR A 6 WAY MERGE
*
         MVC   ROVI4B(4),ROVSXWM   SET BR TO CMP ITEM 5 AFT ITEM 4 CMP
         BAS   R2,ROVFMUDS         SAVE ADDR OF NEXT CUTBACK SECTION
*
*        SET NETWORK FOR A 5 WAY MERGE
*
         MVC   ROVI2B(4),ROVFVWM   SET BR TO CMP ITEM 4 AFT ITEM 2 CMP
         MVC   ROVNTENS(4),ROVANT4 SET NETWORK ENTRANCE FOR A 5 WAY MRG
         BAS   R2,ROVFMUDS         SAVE ADDR OF NEXT CUTBACK SECTION
*
*        SET NETWORK FOR A 4 WAY MERGE
*
         MVC   ROVI2B(4),ROVEGW3   SET BR TO CMP ITEM 3 AFT ITEM 2 CMP
         BAS   R2,ROVFMUDS         SAVE ADDR OF NEXT CUTBACK SECTION
*
*        SET NETWORK FOR A 3 WAY MERGE
*
         MVC   ROVI2B(4),ROVTHWM   SET BR TO UPDATE AFTER ITEM 2 CMP
         BAS   R2,ROVFMUDS         SAVE ADDR OF NEXT CUTBACK SECTION
*
*        SET NETWORK FOR A 2 WAY MERGE
*
         MVC   ROVNTENS(4),ROVANT2 SET NETWORK ENTRANCE FOR A 2 WAY MRG
         BAS   R2,ROVFMUDS         SAVE ADDR OF NEXT CUTBACK SECTION
*
*        SET NETWORK FOR A 1 WAY MERGE
*
         MVC   ROVNTENS(4),ROVANT1 SET NETWORK ENTRANCE FOR A 1 WAY MRG
         BAS   R2,ROVFMUDS         SAVE ADDR OF NEXT CUTBACK SECTION
*
*        A ZERO WAY MERGE
*
*        PHASE 2 - EXIT TO THE BLOCK RTN (RELEASE CURRENT BLK TO WRITE)
*
*        PHASE 3 OR MERGE ONLY - EXIT TO THE BLOCK RTN (END OF JOB)
*
IERDOCPS NOP   ROVCPH3             FALL THRU FOR PHASE 2
         L     R11,PPIBLK2+4
         BR    R11                 PH2 BLOCK/DEBLOCK
*
ROVCPH3  L     R11,PPIBLK+4
         BR    R11                 BLOCK RTN
*
*        ENTRY TO THE CUTBACK ROUTINE FROM READ ROUTINE
*        AND THE ALGORITHM
*
ROVCUTEN LM    R4,R10,ROVSVREG     RESTORE NETWORK REGISTERS
         L     R2,ROVSVCBA         SET APPROPRIATE CUTBACK SECTION ADDR
         BR    R2                  CUTBACK
*
*        THIS SECTION OF CODE ENTERED UPON COMPLETION OF A
*        CUTBACK OPERTION
*
*        INITIALLY CHECKS FOR THE NETWORK BEING SET FOR THE
*        MERGE ORDER
*        SUBSEQUENTLY A BRANCH TO UPDATE IS EXECUTED
*
ROVFMUDS NOP   ROVFDMO             SET TO BRANCH BY INITIALIZATION RTN
*
*        FALL THRU FOR UPDATING NETWORK AFTER A CUTBACK OPERATION
*
         ST    R2,ROVSVCBA         SAVE NEXT CUTBACK ADDR
         B     ROVMMOV7            MODIFIED MOVE AFTER ITEM 7
*
ROVFDMO  L     R5,ROVIDMO          SET TO 8 BY INITIALIZATION RTN
         C     R5,ROVACMO          SET TO ACTUAL MERGE ORDER BY INITIAL
         BE    ROVSFTTU            SET FALL THRU TO UPDATE
         S     R5,KROONE           CONSTANT OF ONE
         ST    R5,ROVIDMO
         BR    R2                  BRANCH BACK TO CUTBACK RTN
*
ROVSFTTU XI    ROVFMUDS+1,X'F0'    SET ROVFMUDS BRANCH TO FALL THRU
         ST    R2,ROVSVCBA         SAVE ADDR OF NEXT CUTBACK CODE
         B     ROVINTSQ            EXIT TO INIT SEQ THE RECORDS
*
*        INITIAL SEQUENCING OF RECORDS SECTION EXECUTED AT THE
*        BEGINNING OF EACH MERGE OPERATION
*
*        A RELATIVE POSITION METHOD IS EMPLOYED FOR THE
*        SEQUENCING
*        THIS METHOD CAN BE DESCRIBED AS COMPARING ONE ITEM OF A
*        LIST WITH THE REMAINDER OF THE ITEMS AND, THEREBY,
*        DETERMINING ITS PROPER POSITION IN THE LIST. TO
*        ACCOMPLISH THIS, A TWO AREA SYSTEM IN PPI IS UTILIZED
*
ROVINTSQ SR    R8,R8               INDEX USED TO GET ITEMS TO BE SEQD
         L     R1,ROVACMO          DETERMINES WHEN ALL ITEMS ARE SEQD
         LA    R6,PPIPDWA          BEGINNING ADDR OF RCD ADDR IN PPI
ROVRETRN L     R5,ROVACMO          USED TO CHECK WHEN AN ITEM HAS BEEN
*                                  CHECKED WITH ALL THE OTHER ITEMS
         L     R3,0(R8,R6)         THE ITEM BEING POSITIONED
         LA    R4,PPIPSVA-4        ADDR WHERE ITEM IS STORED AFT POS FD
         SR    R7,R7               INDEX USED TO CMP ALL OTHER ITEMS
ROVANOTH L     R2,0(R7,R6)         ADDR OF ITEMS CMP TO ITEM IN R2
IERDOICP CLC   0(1,R3),0(R2)
*
*        THIS BRANCH INSTR IS BNL OR BNH DEPENDING ON THE INPUT
*        SEQUENCE
*
ROVISNLH BNL   ROVHIEQ             HI/LO AND EQUAL CASE TREATED SAME
ROVDECR  LA    R7,4(,R7)
         BCT   R5,ROVANOTH         CHECK NEXT ITEM
ROVCHEK  CLC   0(4,R4),KROZERO     STORAGE AREA OF ITEMS IS INITIALLY
*                                  ZERO CHECKED TO INSURE THAT ANOTHER
*                                  ITEM DOES NOT OCCUPY THIS POSITION
         BE    ROVINSRT            IF ZERO STORE ITEM
         S     R4,KROFOUR          IF EQUAL CHECK NEXT LOWER POSITION
         B     ROVCHEK             CHECK NEXT POSITION
*
ROVINSRT ST    R3,0(,R4)           STORE POSITIONED ITEM
         BCT   R1,ROVINCR          IF NOT DONE GET NEXT ITEM TO POSITIN
         B     ROVOUTIS            BRANCH TO SET NETWORK REG
*
ROVHIEQ  LA    R4,4(,R4)
         B     ROVDECR             CHECK NEXT ITEM
*
ROVINCR  LA    R8,4(0,R8)
         B     ROVRETRN            BRANCH FOR LAST CHECK
*
*        END OF THE INITIAL SEQUENCING SECTION
*
*        MOVE ADDRS OF SEQUENCED ITEMS TO MERGE NETWORK
*        REGISTERS
*
ROVOUTIS LA    R1,PPIPSVA          ADDR OF FIRST SEQUENCED ITEM
         L     R2,ROVACMO          MERGE ORDER
         A     R2,KROTWO
         EX    R2,ROVLODMR         EXECUTE LOAD REGISTERS INSTR
         XI    ROVFRSW1+1,X'F0'    SETTING FIRST RCD SWITCHES TO BRANCH
         XI    ROVFRSW2+1,X'F0'
         XI    ROVBBFIS+1,X'F0'    SET INT SEQ BRANCH FOR BLK INTERFACE
         B     IERDOBWR            BRANCH TO OUTPUT WINNER
*
*        SELF INITIALIZATION SECTION PERFORMED AT THE BEGINNING
*        OF EACH PASS OR SUB PASS
*
ROVSINIT MVC   ROVIDMO(4),KROEIGHT SET MAX MERGE ORDER TO 8
         LH    R4,PPIMRGMX         SET ACTUAL MRG ORD FROM PPI
         ST    R4,ROVACMO
         SR    R4,R4
         ST    R4,PPIPSVA
         MVC   PPIPSVA+4(60),PPIPSVA    ZERO INT SEQ STORE AREA
         XI    ROVFMUDS+1,X'F0'    SET ROVFMUDS TO BRANCH
         PPITEST  PPIPH1CO         INPUT SEQ ASCENDING OR DSCENDING ?
         BO    ROVISD              FALL THRU IF INPUT SEQ IS ASCENDING
         TM    ROVI4B+1,X'20'      ROUTINE SET FOR ASCENDING ?
ROVFDSQ  BO    IERDOSET            IF THE ROUTINE IS SET FOR THE INPUT
         XI    ROVI4B+1,X'60'      SEQUENCE, BRANCH TO EXTRACT TEST. IF
         XI    ROVI2B+1,X'60'      THE ROUTINE IS NOT SET FOR THE INPUT
         XI    ROVI1B+1,X'60'      CHANGE THE MASK OF THE BRANCH ON
         XI    ROVSCB+1,X'60'      CONDITION INSTR
         XI    ROVI6B+1,X'60'
         XI    ROVI5B+1,X'60'
         XI    ROVI7B+1,X'60'
         XI    ROVI3B+1,X'60'
         XI    ROVSI4B+1,X'60'
         XI    ROVISNLH+1,X'60'
         XI    ROVEGW1+1,X'60'
         XI    ROVEGW2+1,X'60'
         XI    ROVEGW3+1,X'60'
         XI    ROVSVWM+1,X'60'
         XI    ROVSXWM+1,X'60'
         XI    ROVFVWM+1,X'60'
         XI    ROVTHWM+1,X'60'
IERDOSET NOP   ROVCSEWM            FALL THRU IF EXTRACTING
*                                  IF NOT EXTRACTING, GOTO CUTBACK CODE
         LM    R3,R4,IERDOAGE      ADDR + LEN OF EXTRACT INFO
         LA    R10,PPIPDWA         ADDR OF RCDS IN PPI
         L     R6,KROONE           INDEX TO DETERMINE WHEN DONE
         LR    R8,R6
         L     R9,ROVACMO
ROVRLD   L     R2,0(,R10)          SET FROM ADDR FOR EXTR RTN
         STM   R4,R10,ROVSVREG     SAVE MERGE REG
         BAS   R14,4(0,R12)        EXTRACT THIS RECORD
         LM    R4,R10,ROVSVREG     RESTORE MERGE REG
         ST    R2,0(0,R3)          STORE ADDR OF RCD AT EXTR POS
         ST    R3,0(0,R10)         STORE EXTR POS ADDR IN PPIPDWA AREA
         AR    R3,R4               INCR EXTR POS LENGTH
         A     R10,KROFOUR         INCR TO NEXT RCD ADDR IN PPIPDWA
         BXLE  R6,R8,ROVRLD        DONE EXTR THE RCDS IN PPIPDWA ?
         ST    R3,ROVSQCWD         SAVE NEXT EXTR POS ADDR
         B     ROVCSEWM            BRANCH TO CUTBACK SECTION
*
*        THE INPUT SEQUENCE IS IN DESCENDING ORDER
*
ROVISD   TM    ROVI4B+1,X'40'      ROUTINE SET FOR DESCENDING ?
         B     ROVFDSQ             MODIFY BRANCH INSTRUCTIONS
*
*        FORMAT MAJOR CONTROL FIELD AND WRITE IER053 MESSAGE
*
*        INPUT -
*        R15 -> CONTROL FIELD
*        R11  - RETURN ADDR
*        IERDOSCK+1 = L'MAJOR CONTROL FIELD - 1
*
FMTMAJ   PPITEST  PPIDIAG+PPIDSIM  GENERATE DIAGNOSTIC MESSAGES ?
         BZR   R14                 NO, BYPASS MSG GENERATION
         STM   R0,R15,FMTMAJRS     SAVE REGS
         L     R14,PPIRMC+4        ADDRESSABILITY TO MESSAGE
         LA    R14,IER053DD        R14 -> MESSAGE AREA
         SR    R1,R1
         ICM   R1,B'0001',IERDOSCK+1  GET L'CONTROL FIELD FROM CLC INST
         LA    R1,1(,R1)           COUNT EACH BYTE
         CLI   IERDOSCK+1,20       L'CONTROL FIELD > 20 ?
         BL    FMTMAJA             NO, USE CURRENT LENGTH
         LA    R1,20               SET MAX LENGTH TO 20
FMTMAJA  IC    R0,0(,R15)          R0 = INPUT BYTE FROM CONTROL FIELD
         STC   R0,1(,R14)          STORE RIGHT NIBBLE
         NI    1(R14),X'0F'        MAKE ZONE X'0'
         SRL   R0,4                MOVE ZONE TO NUMERIC
         STC   R0,0(,R14)          STORE LEFT NIBBLE
         NI    0(R14),X'0F'        MAKE ZONE X'0'
         LA    R14,2(,R14)         INCR MESSAGE LOCATION
         LA    R15,1(,R15)         INCR MAJOR FIELD LOCATION
         BCT   R1,FMTMAJA          LOOP TO PROCESS NEXT BYTE
         ICM   R1,B'0001',IERDOSCK+1  GET L'CONTROL FIELD FROM CLC INST
         LA    R1,1(R1,R1)         DOUBLE IT PLUS 1
         L     R14,PPIRMC+4        RESTORE ADDRESSABILITY
         EX    R1,FMTMAJEX         TRANSLATE TO PRINTABLE CHARS
         LM    R0,R1,IER053D       IER053I MAJOR CONTROL FIELD DATA
         L     R15,PPIADSSC
         BAS   R14,12(,R15)        CALL MSG WRITER
         LM    R0,R15,FMTMAJRS     RESTORE REGS
         BR    R14                 RETURN TO CALLER
*
*        EXECUTED MOVE INSTRUCTIONS
*
ROVLODMR LM    R3,0,0(R1)          LOAD NETWORK REGISTERS
FMTMAJEX TR    IER053DD(0),HEXTAB  TRANSLATE TO PRINTABLES
*
ROVSVREG DC    7F'0'               REGISTER SAVE AREA FOR INTERFACING
ROVSQCWD DC    F'0'                WORD TO SAVE ADDR OF EXTRACT POS
*                                  OF RCD FOR SEQUENCE CHECK
IERDOAGE DC    F'0'                BEGIN ADDR FOR GENERATED EXTRACT POS
IERDOEXL DC    F'0'                LGH OF EXTR CTRL FLDS + 4 ADDR BYTES
FMTMAJRS DC    16F'0'
*
*        THE FOLLOWING 7 INSTR ARE BH OR BL DEPENDING ON THE
*        INPUT SEQUENCE
*
ROVEGW1  BH    IERDOCK6            BRANCH TO COMPARE ITEM 6 SET BY INIT
ROVEGW2  BH    IERDOCK7            BRANCH TO COMPARE ITEM 7 SET BY INIT
ROVEGW3  BH    IERDOCK3            BRANCH TO COMPARE ITEM 3 SET BY INIT
ROVSVWM  BH    ROVMOV6             BRANCH TO UPDATE R3 TO R8 SET BY INT
ROVSXWM  BH    IERDOCK5            BRANCH TO COMPARE ITEM 5 SET BY INIT
ROVFVWM  BH    IERDOCK4            BRANCH TO COMPARE ITEM 4 SET BY INIT
ROVTHWM  BH    ROVMOV2             BRANCH TO UPDATE R4 TO R5 SET BY INT
*
ROVANT8  B     IERDOM8             NETWORK ENTR ADDR FOR 6,7,8 WAY MRG
ROVANT4  B     IERDOM4             NETWORK ENTR ADDR FOR 3,4,5 WAY MRG
ROVANT2  B     IERDOM2             NETWORK ENTR ADDR FOR 2 WAY MERGE
ROVANT1  B     ROV1WM              NETWORK ENTR ADDR FOR 1 WAY MERGE
*
ROVSVCBA DC    F'0'                SAVE NEXT CUTBACK ADDR WORD
ROVIDMO  DC    F'0'                MAXIMUM MERGE ORDER SET BY INITIAL
ROVACMO  DC    F'0'                ACTUAL MERGE ORDER SET BY INITIAL
ROVSVEXA DC    F'0'                EXT POS ADDR SAVE AREA
KROONE   DC    XL4'1'              CONSTANT OF ONE
KROZERO  DC    XL4'0'              CONSTANT OF ZERO
KROTWO   DC    XL4'2'              CONSTANT OF TWO
KROFOUR  DC    XL4'4'              CONSTANT OF FOUR
KROEIGHT DC    XL4'8'              CONSTANT OF EIGHT
ROVTEMP  DC    H'0'                TEMP STORAGE FOR UNIT NUMBER
ROVCONV  DC    D'0'                CONVERSION AREA FOR UNIT NUMBER
*
HEXTAB   DC    C'0123456789ABCDEF'  FOR TRANSLATION TO PRINTABLES
*
         LTORG
*
./ ADD NAME=IERROW   0101-20211-20211-1200-00094-00094-00000-RELEASE 00
ROW      TITLE 'IERROW - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERROW
*
*        MODULE FUNCTION/OPERATION -
*        INITIALIZE THE REPLACEMENT NETWORK TO ALLOW THE SORT
*        PHASE TO BE REEXECUTED.
*        RESET ALL CODE WHICH IS OVERLAID DURING THE EXECUTION
*        OF A SORT PHASE AND RESETS ADDRESSES IN THE TREE TO
*        ALLOW RSA TO BE FILLED AGAIN. IT FORCES FLUSHING OF THE
*        TREE TO FORM THE MTH SEQUENCE EACH TIME THE SORT PHASE
*        IS EXECUTED. IT ALSO ADJUSTS THE EQUALS ROUTINE FOR THE
*        SORT OR MERGE PHASE BY RESPECTIVELY INCREMENTING OR
*        DECREMENTING THE DISPLACEMENT FIELDS IN THE COMPARE
*        INSTRUCTIONS BY 4 BYTES
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - IERAOW
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM ALGORITHM IERRON
*                       CALLING SEQUENCE -
*                            L    R11,PPIINT+4
*                            BR   R11
*
*                     - ENTRY FROM ALGORITHM IERRON
*                       CALLING SEQUENCE -
*                           L    R11,PPIINT+4
*                           B    4(,R11)
*
*                     - ENTRY FROM ALGORITHM IERRON
*                       CALLING SEQUENCE
*                           L    R11,PPIINT+4
*                           B    8(,R11)
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIDEB   PPIAXERT   PPIALG   PPISRTG
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED - N/A
*
*        DISPLACEMENT FIELDS IN EQUALS ROUTINE ARE ADJUSTED FOR
*        PHASE TO BE EXECUTED NEXT
*        CODE IS OVERLAID TO FORCE FLUSHING OF TREE
*        OVERLAID CODE IN SORT NETWORK IS RESET
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS -
*        PPINET - ADDR TO SET DSECT
*
*        EXITS - NORMAL -
*        DEBLOCK   - DSPL =  8 AFTER OVERLAY TO FORCE FLUSHING
*        ALGORITHM - DSPL = 12 NORMAL - AFTER INIT EQUALS FOR MERGE
*        DEBLOCK   - DSPL = 12 RESET SO SORT PH CAN BE REEXECUTED
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS - N/A
*
*        NOTES -
*        THIS MODULE IS USED ONLY WHEN THE OSCILLATING TECHNIQUE
*        IS USED
*        IT IS USED IN CONJUNCTION WITH SORT NETWORK IERROA -
*        MCF, FIXED LENGTH RECORDS
*
IERROW   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERROW SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERROWI
*
IERROA   DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERROA SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERROAI
*
         SMPPI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         END
./ ADD NAME=IERROWI  0101-20211-20211-1200-00119-00119-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERROW SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERROWI
*
*
         USING *,R11
         USING IERRCA,R13
         USING IERROA,R15
*
         B     ROW010              +00 FROM ALG AFTER SORT PORTION,
*                                      INITIALIZE EQUALS RTN FOR MERGE
         B     ROW030              +04 FROM ALG AFTER MERGE PORTION,
*                                      INITIALIZE NETWORK, EQUALS,
*                                      TREE FOR SORT
         L     R15,PPINET+4        +08 SET BASE REG FOR NETWORK
         MVC   OAMODNEW(8),KICON1  FROM ALG, FORCE FLUSHING OF TREE
         L     R11,PPIDEB+4        FOR MTH SEQUENCE
         B     8(,R11)             EXIT TO DEBLOCK NORMAL
*
*        INITIALIZE EQUALS ROUTINE FOR MERGE NETWORK
*        DECREMENT THE DISPLACEMENT FIELDS IN THE COMPARE
*        INSTRUCTIONS BY FOUR BYTES
*
ROW010   LA    R1,11               COUNT OF 11
         LA    R2,4                CONSTANT OF 4
         L     R3,PPIAXERT         R3 -> EQUALS ROUTINE
ROW020   LH    R4,2(,R3)           BASE AND DISP OF FIRST OPERAND
         SR    R4,R2               DECREMENT DISP OF 1ST OPERAND BY 4
         STH   R4,2(,R3)           RESTORE BASE AND DISPLACEMENT
         LH    R4,4(,R3)           BASE AND DISP OF 2ND OPERAND
         SR    R4,R2               DECREMENT DISP OF 2ND OPERAND BY 4
         STH   R4,4(,R3)           RESTORE BASE AND DISPLACEMENT
         LA    R3,8(,R3)           INCREMENT TO CLC, BCR OF NEXT CF
         BCT   R1,ROW020
         L     R11,PPIALG+4        EXIT TO ALGORITHM (NORMAL)
         B     12(R11)
*
*        INITIALIZE FOR SORT PHASE
*
ROW030   L     R15,PPINET+4        SET BASE REG FOR NETWORK
*
*        RESET ADDRESSES IN THE TREE FOR SORT NETWORK
*
         LA    R10,1
         L     R6,WATREEAD         ADDRESS OF TREE
         L     R8,PPISRTG          SET UP OTHER CONSTANTS NEEDED
         LA    R3,3
         LA    R2,20
         LR    R9,R6               NEXT LEVEL ADDR FOR PREVIOUS LEVEL
         LA    R7,4                WAY OR NODE COUNTER
         LA    R4,WALTNODE         ADDR OF LAST TEST NODE
         SR    R5,R5               SET FORMAT OF THIS NODE TO ZERO
ROW040   STM   R4,R5,0(R6)         STORE NLA AND FORMAT OF NODE
         AR    R10,R3              INC RECORD COUNTER BY 3 EACH NODE
         CR    R10,R8              RECORDS TREE HOLDS NOW TO REQD NO
         BNL   ROW050              NO MORE NODES REQUIRED
         AR    R6,R2               INCREMENT TO LOCATION OF NEXT NODE
         LR    R4,R9               SET NEXT LEVEL ADDRESS
         BCT   R7,ROW040           BRANCH IF NODE COUNTER NOT ZERO
         LA    R7,4                RESET NODE OR WAY COUNTER
         AR    R9,R2               INCREMENT NEXT LEVEL ADDRESS
         B     ROW040
*
ROW050   STM   R7,R9,WASAVE        SAVE TREE INFORMATION FOR NETWORK
*
*        INITIALIZE EQUALS ROUTINE FOR SORT NETWORK
*        INCREMENT THE DISPLACEMENT FIELDS IN THE COMPARE
*        INSTRUCTIONS BY FOUR BYTES
*
         PPITEST  PPIEQUAL         EQUALS ACTIVE ?
         BZ    ROW070              NO, BRANCH
         LA    R1,11               COUNT OF 11
         LA    R2,4                CONSTANT OF 4
         L     R3,PPIAXERT         ADDRS OF EQUALS RTN
ROW060   LH    R4,2(,R3)           BASE AND DISP OF FIRST OPERAND
         AR    R4,R2               INCREMENT DISP OF 1ST OPERAND BY 4
         STH   R4,2(,R3)           RESTORE BASE AND DISPLACEMENT
         LH    R4,4(,R3)           BASE AND DISP OF 2ND OPERAND
         AR    R4,R2               INCREMENT DISP OF 2ND OPERAND BY 4
         STH   R4,4(,R3)           RESTORE BASE AND DISPLACEMENT
         LA    R3,8(,R3)           INCREMENT TO CLC, BCR OF NEXT CF
         BCT   R1,ROW060
*
*        INITIALIZE ANY CODE IN SORT NETWORK WHICH MAY HAVE BEEN
*        OVERLAID
*
ROW070   MVC   OACASE44(4),KICON2
         MVC   OACAS27(4),KICON3
         MVC   OACAS15(4),KICON4
         MVC   OACASE41(4),KICON5
         MVC   OAC8A(10),KICON6
         MVC   OAGCT+4(4),KICON7
         MVC   OAPICK(12),KICON8
         MVC   OAMODLOC(4),KICON9
         MVC   OAMODNEW(8),KICON10
         MVI   OACSUB8+1,0
         L     R11,PPIDEB+4        EXIT TO DEBLOCK TO RESET ITSELF
         B     12(,R11)
*
*        CONSTANTS
*
KICON1   L     R11,PPIDEB+4        EXIT TO DEBLOCK EOF (PSEUDO)
         B     4(,R11)
*
KICON2   DC    CL4' '              INSTRUCTION CONSTANTS ARE TAKEN FROM
KICON3   DC    CL4' '              THE SORT NETWORK AND SET IN HERE
KICON4   DC    CL4' '              BY THIS MODULES ASSIGNMENT RTN
KICON5   DC    CL4' '
KICON6   DC    CL10' '
KICON7   DC    CL4' '
KICON8   DC    CL12' '
KICON9   DC    CL4' '
KICON10  DC    CL8' '
*
./ ADD NAME=IERROX   0101-20211-20211-1200-00083-00083-00000-RELEASE 00
ROX      TITLE 'IERROX - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERROX
*
*        MODULE FUNCTION/OPERATION -
*        THIS MODULE INITIALIZES THE REPLACEMENT NETWORK TO
*        ALLOW THE SORT PHASE TO BE REEXECUTED. IT RESETS ALL
*        CODE WHICH IS OVERLAID DURING THE EXECUTION OF A SORT
*        PHASE AND RESETS ADDRESSES IN THE TREE TO ALLOW RSA TO
*        BE FILLED AGAIN. IT FORCES FLUSHING OF THE TREE TO FORM
*        THE MTH SEQUENCE EACH TIME THE SORT PHASE IS EXECUTED
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - IERAOX
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM ALGORITHM - IERRON
*                       CALLING SEQUENCE -
*                           L    R11,PPIINT+4
*                           B    4(,R11)
*
*                     - ENTRY FROM ALGORITHM - IERRON
*                       CALLING SEQUENCE -
*                           L    R11,PPIINT+4
*                           B    8(,R11)
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIDEB   PPIALG
*        PPISRTG
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        CODE IS OVERLAID TO FORCE FLUSHING OF TREE
*        OVERLAID CODE IN SORT NETWORK IS RESET
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS -
*        PPINET - ADDR TO SET DSECT
*
*        EXITS - NORMAL -
*        DEBLOCK - DSPL= 8 - AFTER OVERLAY TO FORCE FLUSHING
*        DEBLOCK - DSPL=12 - RESET SO SORT PH CAN BE REEXECUTED
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS - N/A
*
*        NOTES -
*        THIS MODULE IS USED ONLY WHEN THE OSCILLATING TECHNIQUE
*        IS USED. IT IS USED IN CONJUNCTION WITH SORT NETWORK
*        IERROB -SCF, FIXED LENGTH RECORDS
*
IERROX   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERROX SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERROXI
*
*        IERROB
*
IERROB   DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERROB SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERROBI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERROXI  0101-20211-20211-1200-00079-00079-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERROX SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERROXI
*
         USING *,R11
         USING IERRCA,R13
         USING IERROB,R15
         B     *                   +00 DUMMY ENTRY
         B     ROW030              +04 FROM ALG AFTER MERGE PORTION,
*                                      INITIALIZE NTWK, EQUALS, TREE
*                                      FOR SORT
         L     R15,PPINET+4        +08 SET BASE REG FOR NETWORK
         MVC   OAMODNEW(8),KICON1  FROM ALG, FORCE FLUSHING OF TREE
         L     R11,PPIDEB+4        FOR MTH SEQUENCE
         B     8(,R11)             EXIT TO DEBLOCK NORMAL
*
*        INITIALIZE FOR SORT PHASE
*
ROW030   L     R15,PPINET+4        SET BASE REG FOR NETWORK
*
*        RESET ADDRS IN THE TREE FOR SORT NETWORK
*
         LA    R10,1
         L     R6,WATREEAD         ADDR OF TREE
         L     R8,PPISRTG          SET UP OTHER CONSTANTS NEEDED
         LA    R3,3
         LA    R2,20
         LR    R9,R6               NEXT LEVEL ADDR FOR PREVIOUS LEVEL
         LA    R7,4                WAY OR NODE COUNTER
         LA    R4,WALTNODE         ADDRS OF LAST TEST NODE
         SR    R5,R5               SET FORMAT OF THIS NODE TO ZERO
ROW040   STM   R4,R5,0(R6)         STORE NLA AND FORMAT OF NODE
         AR    R10,R3              INC RECORD COUNTER BY 3 EACH NODE
         CR    R10,R8              RECORDS TREE HOLDS NOW TO REQD NO.
         BNL   ROW050              NO MORE NODES REQUIRED
         AR    R6,R2               INCREMENT TO LOCATION OF NEXT NODE
         LR    R4,R9               SET NEXT LEVEL ADDRESS
         BCT   R7,ROW040           BRANCH IF NODE COUNTER NOT ZERO
         LA    R7,4                RESET NODE OR WAY COUNTER
         AR    R9,R2               INCREMENT NEXT LEVEL ADDRESS
         B     ROW040
*
ROW050   STM   R7,R9,WASAVE        SAVE TREE INFORMATION FOR NETWORK
*
*        INITIALIZE ANY CODE IN SORT NETWORK WHICH MAY HAVE BEEN
*        OVERLAID
*
         MVC   OACASE44(4),KICON2
         MVC   OACAS27(4),KICON3
         MVC   OACAS15(4),KICON4
         MVC   OACASE41(4),KICON5
         MVC   OAC8A(10),KICON6
         MVC   OAGCT+4(4),KICON7
         MVC   OAPICK(12),KICON8
         MVC   OAMODLOC(4),KICON9
         MVC   OAMODNEW(8),KICON10
         MVI   OACSUB8+1,0
         L     R11,PPIDEB+4        EXIT TO DEBLOCK TO RESET ITSELF
         B     12(,R11)
*
*        CONSTANTS
*
KICON1   L     R11,PPIDEB+4        EXIT TO DEBLOCK EOF (PSEUDO)
         B     4(,R11)
KICON2   DC    CL4' '              INSTRUCTION CONSTANTS ARE TAKEN FROM
KICON3   DC    CL4' '              THE SORT NETWORK AND SET IN HERE
KICON4   DC    CL4' '              BY THIS MODULES ASSIGNMENT RTN
KICON5   DC    CL4' '
KICON6   DC    CL10' '
KICON7   DC    CL4' '
KICON8   DC    CL12' '
KICON9   DC    CL4' '
KICON10  DC    CL8' '
*
./ ADD NAME=IERROY   0101-20211-20211-1200-00095-00095-00000-RELEASE 00
ROY      TITLE 'IERROY - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERROY
*
*        MODULE FUNCTION/OPERATION -
*        THIS MODULE INITIALIZES THE REPLACEMENT NETWORK TO
*        ALLOW THE SORT PHASE TO BE REEXECUTED. IT RESETS ALL
*        CODE WHICH IS OVERLAID DURING THE EXECUTION OF A SORT
*        PHASE AND RESETS ADDRESSES IN THE TREE TO ALLOW RSA TO
*        BE FILLED AGAIN. IT FORCES FLUSHING OF THE TREE TO FORM
*        THE MTH SEQUENCE EACH TIME THE SORT PHASE IS EXECUTED.
*        IT ALSO ADJUSTS THE EQUALS ROUTINE FOR THE SORT OR MERGE
*        PHASE BY RESPECTIVELY INCREMENTING OR DECREMENTING THE
*        DISPLACEMENT FIELDS IN THE COMPARE INSTRUCTIONS BY 4
*        BYTES
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - IERAOY
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM ALGORITHM - IERRON
*                       CALLING SEQUENCE -
*                           L    R11,PPIINT+4
*                           BR   R11
*
*                     - ENTRY FROM ALGORITHM - IERRON
*                       CALLING SEQUENCE -
*                           L    R11,PPIINT+4
*                           B    4(,R11)
*
*                     - ENTRY FROM ALGORITHM - IERRON
*                       CALLING SEQUENCE -
*                           L    R11,PPIINT+4
*                           B    8(,R11)
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIDEB   PPIAXERT
*        PPIALG   PPISRTG
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        DISPLACEMENT FIELDS IN EQUALS ROUTINE ARE ADJUSTED FOR
*        PHASE TO BE EXECUTED NEXT
*        CODE IS OVERLAID TO FORCE FLUSHING OF TREE
*        OVERLAID CODE IN SORT NETWORK IS RESET
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS -
*        PPINET - ADDR TO SET DSECT
*
*        EXITS - NORMAL -
*        DEBLOCK   - DSPL = 8  AFTER OVERLAY TO FORCE FLUSHING
*        ALGORITHM - DSPL = 12 NORMAL - AFTER INIT EQUALS FOR MERGE
*        DEBLOCK   - DSPL = 12 RESET SO SORT PH CAN BE REEXECUTED
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS - N/A
*
*        NOTES -
*        THIS MODULE IS USED ONLY WHEN THE OSCILLATING TECHNIQUE
*        IS USED. IT IS USED IN CONJUNCTION WITH SORT NETWORK
*        IERROC -MCF, VARIABLE LENGTH RECORDS
*
IERROY   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERROY SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERROYI
*
*        IERROC
*
IERROC   DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERROC SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERROCI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERROYI  0101-20211-20211-1200-00105-00105-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERROY SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERROYI
*
         USING *,R11
         USING IERRCA,R13
         USING IERROC,R15
*
         B     ROW010              +00 FROM ALG AFTER SORT PORTION,
*                                      INITIALIZE EQUALS RTN FOR MERGE
         B     ROW030              +04 FROM ALG AFTER MERGE PORTION,
*                                      INITIALIZE NTWK, EQUALS, TREE
*                                      FOR SORT
         L     R15,PPINET+4        +08 SET BASE REG FOR NETWORK
         MVC   OCMODNEW(8),KICON1  FROM ALG, FORCE FLUSHING OF TREE
         L     R11,PPIDEB+4        FOR MTH SEQUENCE
         B     8(,R11)             EXIT TO DEBLOCK NORMAL
*
*        INITIALIZE EQUALS ROUTINE FOR MERGE NETWORK
*        DECREMENT THE DISPLACEMENT FIELDS IN THE COMPARE
*        INSTRUCTIONS BY FOUR BYTES
*
ROW010   LA    R1,11               COUNT OF 11
         LA    R2,4                CONSTANT OF 4
         L     R3,PPIAXERT         ADDR OF EQUALS ROUTINE
ROW020   LH    R4,2(,R3)           BASE AND DISP OF FIRST OPERAND
         SR    R4,R2               DECREMENT DISP. OF 1ST OPERAND BY 4
         STH   R4,2(,R3)           RESTORE BASE AND DISPLACEMENT
         LH    R4,4(,R3)           BASE AND DISP OF 2ND OPERAND
         SR    R4,R2               DECREMENT DISP OF 2ND OPERAND BY 4
         STH   R4,4(,R3)           RESTORE BASE AND DISPLACEMENT
         LA    R3,8(,R3)           INCREMENT TO CLC, BCR OF NEXT CF
         BCT   R1,ROW020
         L     R11,PPIALG+4        EXIT TO ALGORITHM (NORMAL)
         B     12(,R11)
*
*        INITIALIZE FOR SORT PHASE
*
ROW030   L     R15,PPINET+4        SET BASE REG FOR NETWORK
*
*        RESET ADDRS IN THE TREE FOR SORT NETWORK
*
         LA    R10,1
         L     R6,WCTREE           ADDR OF TREE
         L     R8,PPISRTG          SET UP OTHER CONSTANTS NEEDED
         LR    R9,R6               NEXT LEVEL ADDR FOR PREVIOUS LEVEL
         LA    R7,2                WAY OR NODE COUNTER
         LA    R4,WCLTNODE         ADDR OF LAST TEST NODE
         SR    R5,R5               SET FORMAT OF THIS NODE TO ZERO
ROW040   STM   R4,R5,0(R6)         STORE NLA AND FORMAT OF NODE
         LA    R10,1(,R10)         INC RECORD COUNTER BY 1 EACH NODE
         CR    R10,R8              RECORDS TREE HOLDS NOW TO REQD NO
         BNL   ROW050              NO MORE NODES REQUIRED
         LA    R6,12(,R6)          INCREMENT TO LOCATION OF NEXT NODE
         LR    R4,R9               SET NEXT LEVEL ADDR
         BCT   R7,ROW040           BRANCH IF NODE COUNTER NOT ZERO
         LA    R7,2                WAY OR NODE COUNTER
         LA    R9,12(,R9)          INCREMENT NEXT LEVEL ADDR
         B     ROW040
*
ROW050   STM   R7,R9,WCSAVE        SAVE TREE INFORMAITON FOR NETWORK
*
*        INITIALIZE EQUALS ROUTINE FOR SORT NETWORK
*        INCREMENT THE DISPLACEMENT FIELDS IN THE COMPARE
*        INSTRUCTIONS BY FOUR BYTES
*
         PPITEST  PPIEQUAL         EQUALS ACTIVE ?
         BZ    ROW070              NO, BRANCH
         LA    R1,11               COUNT OF 11
         LA    R2,4                CONSTANT OF 4
         L     R3,PPIAXERT         ADDR OF EQUALS RTN
ROW060   LH    R4,2(,R3)           BASE AND DISP OF FIRST OPERAND
         AR    R4,R2               INCREMENT DISP OF 1ST OPERAND BY 4
         STH   R4,2(,R3)           RESTORE BASE AND DISPLACEMENT
         LH    R4,4(,R3)           BASE AND DISP OF 2ND OPERAND
         AR    R4,R2               INCREMENT DISP OF 2ND OPERAND BY 4
         STH   R4,4(,R3)           RESTORE BASE AND DISPLACEMENT
         LA    R3,8(,R3)           INCREMENT TO CLC, BCR OF NEXT CF
         BCT   R1,ROW060
*
*        INITIALIZE ANY CODE IN SORT NETWORK WHICH MAY HAVE BEEN
*        OVERLAID
*
ROW070   MVC   OCC7A(8),KICON2
         MVC   OCPICK(4),KICON3
         MVC   OCMODLOC(4),KICON4
         MVC   OCMODNEW(8),KICON5
         MVI   OCC8A+1,0
         L     R11,PPIDEB+4        EXIT TO DEBLOCK TO RESET ITSELF
         B     12(,R11)
*
*        CONSTANTS
*
KICON1   L     R11,PPIDEB+4        EXIT TO DEBLOCK EOF (PSEUDO)
         B     4(,R11)
KICON2   DC    CL8' '              INSTRUCTION CONSTANTS ARE TAKEN FROM
KICON3   DC    CL4' '              THE SORT NETWORK AND SET IN HERE
KICON4   DC    CL4' '              BY THIS MODULES ASSIGNMENT RTN
KICON5   DC    CL8' '
*
./ ADD NAME=IERROZ   0101-20211-20211-1200-00083-00083-00000-RELEASE 00
ROZ      TITLE 'IERROZ - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERROZ
*
*        MODULE FUNCTION/OPERATION -
*        THIS MODULE INITIALIZES THE REPLACEMENT NETWORK TO
*        ALLOW THE SORT PHASE TO BE REEXECUTED. IT RESETS ALL
*        CODE WHICH IS OVERLAID DURING THE EXECUTION OF A SORT
*        PHASE AND RESETS ADDRESSES IN THE TREE TO ALLOW RSA TO
*        BE FILLED AGAIN. IT FORCES FLUSHING OF THE TREE TO FORM
*        THE MTH SEQUENCE EACH TIME THE SORT PHASE IS EXECUTED
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - IERAOZ
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM ALGORITHM - IERRON
*                       CALLING SEQUENCE -
*                           L    R11,PPIINT+4
*                           B    4(,R11)
*
*                     - ENTRY FROM ALGORITHM - IERRON
*                       CALLING SEQUENCE -
*                           L    R11,PPIINT+4
*                           B    8(,R11)
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIDEB   PPIALG   PPISRTG
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        CODE IS OVERLAID TO FORCE FLUSHING OF TREE
*        OVERLAID CODE IN SORT NETWORK IS RESET
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS -
*        PPINET - ADDR TO SET DSECT
*
*        EXITS - NORMAL -
*        DEBLOCK - DSPL = 8 - AFTER OVERLAY TO FORCE FLUSHING
*        DEBLOCK - DSPL =12 - RESET SO SORT PH CAN BE
*                             REEXECUTED
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS - N/A
*
*        NOTES -
*        THIS MODULE IS USED ONLY WHEN THE OSCILLATING TECHNIQUE
*        IS USED. IT IS USED IN CONJUNCTION WITH SORT NETWORK
*        IERROD -SCF, VARIABLE LENGTH RECORDS
*
IERROZ   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERROZ SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERROZI
*
*        IERROD
*
IERROD   DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERROD SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRODI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERROZI  0101-20211-20211-1200-00068-00068-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERROZ SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERROZI
*
         USING *,R11
         USING IERRCA,R13
         USING IERROD,R15
*
         B     *                   +00 DUMMY ENTRY - NOT USED
         B     ROW030              +04 FROM ALG AFTER MERGE PORTION,
*                                      INITIALIZE NTWK, EQUALS, TREE
*                                      FOR SORT
         L     R15,PPINET+4        +08 FROM ALG
         MVC   OCMODNEW(8),KICON1  FORCE FLUSHING OF TREE
         L     R11,PPIDEB+4        FOR MTH SEQUENCE
         B     8(,R11)             EXIT TO DEBLOCK NORMAL
*
*        INITIALIZE FOR SORT PHASE
*
ROW030   L     R15,PPINET+4        SET BASE REG FOR NETWORK
*
*        RESET ADDRESSES IN THE TREE FOR SORT NETWORK
*
         LA    R10,1
         L     R6,WCTREE           ADDR OF TREE
         L     R8,PPISRTG          SET UP OTHER CONSTANTS NEEDED
         LR    R9,R6               NEXT LEVEL ADDR FOR PREVIOUS LEVEL
         LA    R7,2                WAY OR NODE COUNTER
         LA    R4,WCLTNODE         ADDR OF LAST TEST NODE
         SR    R5,R5               SET FORMAT OF THIS NODE TO ZERO
ROW040   STM   R4,R5,0(R6)         STORE NLA AND FORMAT OF NODE
         LA    R10,1(,R10)         INCR RECORD COUNTER BY 1 EACH NODE
         CR    R10,R8              RECORDS TREE HOLDS NOW TO REQD NO ?
         BNL   ROW050              YES, NO MORE NODES REQUIRED
         LA    R6,12(,R6)          INCREMENT TO LOCATION OF NEXT NODE
         LR    R4,R9               SET NEXT LEVEL ADDR
         BCT   R7,ROW040           BRANCH IF NODE COUNTER NOT ZERO
         LA    R7,2                WAY OR NODE COUNTER
         LA    R9,12(,R9)          INCREMENT NEXT LEVEL ADDR
         B     ROW040
*
ROW050   STM   R7,R9,WCSAVE        SAVE TREE INFORMAITON FOR NETWORK
*
*        INITIALIZE ANY CODE IN SORT NETWORK WHICH MAY HAVE BEEN
*        OVERLAID
*
         MVC   OCC7A(8),KICON2
         MVC   OCPICK(4),KICON3
         MVC   OCMODLOC(4),KICON4
         MVC   OCMODNEW(8),KICON5
         MVI   OCC8A+1,0
         L     R11,PPIDEB+4        EXIT TO DEBLOCK TO RESET ITSELF
         B     12(,R11)
*
*        CONSTANTS
*
KICON1   L     R11,PPIDEB+4        EXIT TO DEBLOCK EOF (PSEUDO)
         B     4(,R11)
KICON2   DC    CL8' '              INSTRUCTION CONSTANTS ARE TAKEN FROM
KICON3   DC    CL4' '              THE SORT NETWORK AND SET IN HERE
KICON4   DC    CL4' '              BY THIS MODULES ASSIGNMENT RTN
KICON5   DC    CL8' '
*
./ ADD NAME=IERRO3   0101-20211-20211-1200-00054-00054-00000-RELEASE 00
RO3      TITLE 'IERRO3 - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRO3 - NOT SUPPORTED
*
*        MODULE FUNCTION/OPERATION -
*        DRUM MERGE ALGORITHM - RUNNING PROGRAM
*        THIS MODULE CONTAINS A MERGE TABLE WHICH IS USED TO
*        CONTROL WHERE MERGED SEQUENCES ARE TO BE WRITTEN ON THE
*        DRUM. IT MAINTAINS THE NUMBER OF STRINGS AND THE
*        DIRECTORY OF BEGINNING ADDRESSES. IT ALSO DETERMINES IF
*        A PHASE 2 PASS WILL BE NEEDED AGAIN
*
*        USED AS A DSECT IN - IERAO3
*
*        LIST OF MACROS USED BY MODULE - SMPPI
*
*        ENTRY POINTS -
*
*        INPUT -
*
*        OUTPUT -
*
*        EXTERNAL ROUTINES -
*
*        EXTERNAL PARAMETERS -
*
*        EXITS - NORMAL -
*
*        EXITS - ERROR -
*
*        TABLES/WORK AREAS -
*
*        NOTES -
*        THIS MODULE IS RESTRICTED TO 2311 DISK OPERATIONS ONLY
*
IERRO3   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRO3 SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRO3I
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERRO3I  0101-20211-20211-1200-00228-00228-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERRO3 SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERRO3I - NOT SUPPORTED
*
         USING *,R11               SET BASE REG FOR THIS PROGRAM
         USING IERRCA,R13
*
IERDOT   B     RO3START            +00 ENTRY FROM ASIGNMENT ROUTINE
         DC    A(0)                +04 NO ENTRY PT
         DC    A(0)                +08 NO ENTRY PT
         DC    A(0)                +12 NO ENTRY PT
         B     RO3EOS              +16
*
RO3START LA    R8,WTABLE           SET R8 TO NTH TABLE ADDR
         L     R5,WNODSKA
         LA    R7,1                CONSTANT 1
         SR    R5,R7               REDUCE NO /AREAS BY 1
         ST    R5,WNODSKA          SET UP COUNTER TO DETERMINE END/PASS
         LA    R6,36               GENERATE MULTIPLIER CONST
         MR    R4,R6               DISPLCMT TO NTH POS/TABLE
         LA    R7,0(R5,R8)         GET ADDR OF NTH POS IN TABLE
         LR    R8,R7               HENCEFORTH R8 = ADDR/NTH POS
         SR    R7,R6               SET R7 TO N-1 TABLE ADDR
         LH    R4,34(0,R7)         GET SEQ CT IN
         LTR   R4,R4               SEQ COUNT ZERO ?
         BNZ   RO3GOA              NOT ZERO, BRANCH
         L     R4,0(,R8)           GET 'N' AREA KEY
         SLL   R4,1                MULTIPLY BY 2
         LA    R5,PPISEQCT         GET START POINT OF PPI SEQUENCE CTRS
         AR    R5,R4               GET PPI SEQ CT LOCATION
         MVC   0(2,R5),34(R7)      STORE IN PPI
         B     RO3GOB
*
RO3GOA   LA    R4,4(,R8)           GET NEXT SEQ ADDR FROM NTH POS
         MVC   WCLBKAR(8),0(R4)    BLOCK ONE ADDR
         MVC   PPIDEPHO(8),0(R4)   STOW NEXT SEQ ADDR FOR WRITE IN PPI
RO3GON   CLC   PPIMRGOP(2),34(R7)  OPT MRG ORD = NO/SEQ IN AREA N-1 ?
         BNL   RO3GOC
         MVC   PPIMRGMX(2),PPIMRGOP  STOW OPT MRG ORDER IN MAX MRG ORD
RO3GOE   LH    R4,34(,R7)          GET NO/SEQ IN N-1 POS
         SH    R4,PPIMRGMX         REDUCE SEQ COUNT BY MAX MRG ORDER
         STH   R4,34(,R7)          PUT BACK
         B     RO3GOF
*
RO3GOC   MVC   PPIMRGMX(2),34(R7)  STORE NO/SEQ IN MAX
         B     RO3GOE
*
RO3GOF   ST    R8,WSAVERI          SAVE REG
         LA    R6,PPIWKARE         GET WORK AREA ADDR
         L     R5,28(,R7)          GET ADDR OF NXT POS IN BLK
         MVC   PPIDIRAD,20(R7)     MOVE NEXT READ ADDR INTO PPI
         STM   R5,R7,WSAVERF       SAVE REGS
         L     R11,PPIRD+4         TO READ DIRECTORY
         BASR  R14,R11             GOTO AND RETURN FROM READ DIR RTN
         LM    R5,R7,WSAVERF       RESTORE REGS
         LH    R1,PPIMRGMX         GET MAX MRG ORDER
RO3GOK   MVC   0(8,R6),0(R5)       PUT "FROM" ADDR IN "TO" ADDR IN PPI
         LA    R5,8(,R5)           INCR "FROM" ADDR
         LA    R6,8(,R6)           INCR "TO" ADDR
         B     RO3GOG
*
RO3GOX   BCT   R1,RO3GOK           REDUCE MERGE ORDER .
         ST    R5,28(0,R7)         STOW "FROM" ADDR IN TABLE
         ST    R7,WSAVERH          SAVE REGISTERS
         L     R11,PPIRD+4         TO READ ROUTINE
         B     4(,R11)
*
RO3GOG   LA    R4,PPILAB01+64
         CLR   R5,R4               BLOCK LIMIT REACHED ?
         BL    RO3GOX              NO, GOTO REDUCE MRG ORDER
         LA    R5,PPILAB01         SET "FROM" ADDR TO BEG/BLK
         CLI   27(R7),X'1C'        LAST BLK ON TRACK ?
         BE    RO3NEWTK            YES, GO REDUCE TRACK
         L     R4,24(,R7)          GET RIGHT HALF OF NXT DIR BLK (N-1)
         LA    R4,1(,R4)           INCREMENT TRACK COUNT
         ST    R4,24(,R7)          PUT BACK
RO3GOH   LA    R4,1
         CLR   R1,R4               READ ANOTHER BLOCK ?
         BE    RO3GOX              YES, GOTO REDUCE MRG ORDER
         MVC   PPIDIRAD(8),20(R7)  PUT READ ADDR IN PPI
         STM   R5,R7,WSAVERF       SAVE REGISTERS
         ST    R1,WSAVERB          SAVE MERGE ORDER
         L     R11,PPIRD+4         TO READ DIRECTORY
         BAS   R14,0(,R11)         GOTO READ PRIME ROUTINE
         LM    R5,R7,WSAVERF       RESTORE REGISTERS
         L     R1,WSAVERB          RESTORE MERGE ORDER
         B     RO3GOX
*
RO3NEWTK MVI   27(R7),X'01'        SET RECORD COUNT TO 1
         SR    R4,R4               CLEAR REG
         IC    R4,26(,R7)          GET TRACK NO
         BCTR  R4,0                REDUCE TRACK NUMBER
         STC   R4,26(,R7)          PUT TRACK NO BACK
         B     RO3GOH
*
*        END OF SEQUENCE ROUTINE
*
RO3EOS   LM    R7,R8,WSAVERH       SET REGS TO N-1
         LH    R4,32(,R8)          GET NO NEW SEQ
         LA    R4,1(,R4)           BUMP BY 1
         STH   R4,32(,R8)          PUT BACK
         L     R4,WBLKCT           GET DICTY BLOCK COUNT
         BCT   R4,RO3GOL           BRANCH IF BLOCK NOT FILLED
         B     RO3GOM              GOTO NEXT SEQ RTN
*
RO3GOL   LA    R5,8                GET DISPL IN BLKG AREA VIA BLKCTR
         SR    R5,R4
         ST    R4,WBLKCT           STORE DECR BLOCK COUNT
         SLL   R5,3
         LA    R6,WCLBKAR          GET START PTR
         AR    R6,R5
         MVC   0(8,R6),PPIDEPHO    MOVE INTO BLOCK
         LH    R4,34(0,R7)         GET COUNT FROM N-1 TABLE
         LTR   R4,R4               ALL PASSED ?
         BNE   RO3GON              NOT ALL PASSED, BRANCH
*
*        THIS SERIES OF INSTRUCTIONS IS EXECUTED WHEN WRITING A
*        PARTIALLY FILLED BLOCK OF DIRECTORY
*
         BAS   R14,RO3SETDR        BRANCH TO DIRECTORY SET UP RTN
         L     R11,PPIWRT+4        LOAD ADDR OF WRITE ROUTINE (IERRPE)
         BAS   R14,12(,R11)        CALL WRITE A BLOCK OF DIRECTORY
         LM    R7,R8,WSAVERH       RESTORE REGS
RO3GOR   L     R4,0(,R8)           GET 'N' AREA KEY
         SLL   R4,1                MULTPY BY 2
         LA    R5,PPISEQCT         GET START PTR
         AR    R5,R4
         MVC   0(2,R5),32(R8)
RO3GOB   LA    R4,1                CONSTANT 1
         L     R5,WNODSKA          GET N CT
         CLR   R5,R4               END OF PASS ?
         BNE   RO3START            NO, LOOP TO BEG PT AND CONT PASS
         L     R4,0(,R7)           GET 'N'1 AREA KEY
         SLL   R4,1                MULTPY BY 2
         LA    R5,PPISEQCT         GET START PTR
         AR    R5,R4               DISP
         MVC   0(2,R5),32(R7)
         SR    R5,R5               CLEAR R5
         LH    R4,PPINDSKA         GET NUMBER OF AREAS
         LA    R6,PPISEQCT         GET SEQUENCE COUNT ADDR
RO3LOOPH AH    R5,0(,R6)           SUM IN R5
         LA    R6,2(,R6)           BUMP TO NXT CTR
         BCT   R4,RO3LOOPH         SUMMING COMPLETE ?
*
*        SUM VS ALT
*
         LH    R6,PPIMRGAL
         CLR   R5,R6
         BH    RO3PHAS2
         STH   R5,PPIMRGOP         STORE NO STRINGS FOR MERGE
         STH   R5,PPIMRGMX         UPDATE MRGMX WITH SUM OF SEQ CNTS
         LA    R1,4                SET FOR PHASE 3
         L     R15,PPIADSSC        R15 -> SSC
         BAS   R14,20(,R15)        EXIT TO SSC FOR PHASE 3
*
RO3PHAS2 PPIFLIP  PPIDMCO          FLIP DISK MERGE TABLE COLL ORDER
*
*        SET INDICATER TO PHASE 2
*
         LA    R1,0
         L     R15,PPIADSSC        R15 -> SSC
         BAS   R14,20(,R15)        EXIT TO SSC
*
RO3GOM   MVC   4(8,R8),PPIDEPHO    SAVE NEXT SEQ ADDR
*
*        THIS SERIES OF INSTRUCTIONS IS ENTERED WHEN WRITING A
*        FULL BLOCK OF DIRECTORY
*
         BAS   R14,RO3SETDR        CALL DIRECTORY SET UP RTN
         L     R11,PPIWRT+4        LOAD ADDR OF WRITE ROUTINE (IERRPE)
         BAS   R14,12(,R11)        CALL WRITE A BLOCK OF DIRECTORY
         LM    R7,R8,WSAVERH       RESTORE REGS
         LH    R4,34(,R7)
         LTR   R4,R4               ALL SEQS PASSED ?
         BE    RO3GOR              YES, BRANCH
         CLI   19(R8),82           82 RECORDS BEEN WRITTEN ?
         BNE   RO3GOS              NO, RANCH
         LA    R4,1
         STC   R4,19(,R8)          RESET RECORD COUNT
         IC    R5,18(,R8)          GET TRK NO
         SR    R5,R4               DECR BY 1
         STC   R5,18(,R8)          PUT BACK
         B     RO3GOA
*
RO3GOS   IC    R4,19(,R8)          GET RECORD CT
         LA    R4,1(,R4)           INCREMENT RECORD COUNT
         STC   R4,19(,R8)          STOW NEW RECORD NUMBER
         B     RO3GOA
*
*        THIS SUBROUTINE IS ENTERED EACH TIME A BLOCK OF
*        DIRECTORY IS TO BE WRITTEN. ITS FUNCTION IS TO MOVE THE
*        DIRECTORY TO PPI, STORE THE DISK ADDRESS IN PPI, AND
*        RESET THE DIRECTORY BLOCKING COUNTER
*
RO3SETDR MVC   PPIDIRAD(8),12(R8)    PUT DIRECTORY ADDR IN PPI
         MVC   PPIWKARE(64),WCLBKAR  PUT BLOCK OF DIRECTORY IN PPI
         STM   R7,R8,WSAVERH       SAVE REGS
         LA    R4,8
         ST    R4,WBLKCT           RESET DIRECTORY BLOCKING COUNTER
         BR    R14                 RETURN TO MAIN LINE
*
         DC    0F'0'
WTABLE   DC    X'00000000'         MERGE TABLE    FIRST AREA
         DC    8F'0'
         DC    X'00000001'                        SECOND AREA
         DC    8F'0'
         DC    X'00000002'                        THIRD AREA
         DC    8F'0'
         DC    X'00000003'                        FOURTH AREA
         DC    8F'0'
         DC    X'00000004'                        FIFTH AREA
         DC    8F'0'
         DC    X'00000005'                        SIXTH AREA
         DC    8F'0'
WSAVERB  DC    F'0'
WSAVERF  DC    F'0'                SAVE AREA FOR R5 WHEN LINKING
WSAVERG  DC    F'0'                SAVE AREA FOR R6 WHEN LINKING
WSAVERH  DC    F'0'                SAVE AREA FOR R7 WHEN LINKING
WSAVERI  DC    F'0'                SAVE AREA FOR R8 WHEN LINKING
WCLBKAR  DC    16F'0'              DICT BLOCKING AREA = 64 BYTES
WBLKCT   DC    X'00000008'         DICT BLOCKING COUNTER
WNODSKA  DC    X'00000000'         NO DISK AREAS COUNT -DET END/PASS
*
./ ADD NAME=IERRPA   0101-20211-20211-1200-00124-00124-00000-RELEASE 00
RPA      TITLE 'IERRPA - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRPA
*
*        MODULE FUNCTION/OPERATION -
*        THIS MODULE IS DESIGNED TO BE USED AS A TAPE WRITE
*        MODULE WITH EITHER ONE OR TWO OUTPUT AREAS. IT ACCEPTS A
*        BLOCK OF RECORDS AT A TIME FROM THE BLOCK ROUTINE AND
*        SCHEDULES IT TO BE WRITTEN. AT EOS EOV EOF TIME IT WILL
*        EXIT TO THE ALGORITHM. HOWEVER THE NORMAL EXIT FROM THIS
*        ROUTINE IS TO THE BLOCK ROUTINE WITH AN EMPTY BUFFER.
*        THIS MODULE USES THE EXCP AND WAIT MACROS TO COMMUNICATE
*        WITH IOS
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - IERAPA
*
*        MACROS USED -
*        SMPPI   GETMAIN
*        EXCP    DELETE
*        WAIT    DCBD
*
*        ENTRY POINTS - ENTRY FROM ALGORITHM AFTER EOV
*                       CALLING SEQUENCE -
*                           L   R11,PPIWRT+4
*                           BR  R11
*
*                     - ENTRY FROM BLOCK RTN ON EOS
*                       CALLING SEQUENCE-
*                           L   R11,PPIWRT+4
*                           B   4(,R11)
*
*                       ENTRY FROM BLOCK ROUTINE - NORMAL
*                       CALLING SEQUENCE-
*                           L   R11,PPIWRT+4
*                           B   8(,R11)
*
*                       ENTRY FROM LOAD MODULE AFTER ASSGN
*                       CALLING SEQUENCE -
*                           L   R11,PPIWRT+4
*                           B   16(,R11)
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIDEPHO   PPISTDCB   PPIALG   PPIBLK
*        PPIBLK2    PPIADSSC
*
*        FULL BUFFER IS PASSED TO BE WRITTEN
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        FULL BUFFER IS WRITTEN ON TAPE. EMPTY BUFFER IS
*        RETURNED TO BLOCK ROUTINE
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS -
*
*        FIELDS IN DCBS AND IOBS ARE USED
*        USER EXIT ADDRESS IS CHECKED
*
*        EXITS - NORMAL -
*        BLOCK (PH1) - DSPL = 8 - NORMAL RETURN WITH EMPTY BUFFER ADDR
*        BLOCK (PH2) - DSPL = 8 - NORMAL RETURN WITH EMPTY BUFFER ADDR
*        ALGORITHM   - DSPL = 0 - FINAL EOS
*        ALGORITHM   - DSPL = 4 - EOV
*        ALGORITHM   - DSPL = 8 - EOV AND EOS
*        ALGORITHM   - DSPL =12 - NORMAL EOS
*        NETWORK     - DSPL = 0 - TO FIRST R15 AFTER ASSGN
*
*        EXITS - ERROR - EXIT TO USER ON I/O ERROR
*                        BALR R14,R15
*
*                      - EXIT TO SSC TO TERMINATE JOB ON I/O ERROR
*                        L    R15,PPIADSSC
*                        BAL  R14,16(,R15)
*
*        TABLES/WORK AREAS -
*        WKAREA
*        WSAVE
*        WRSAVE
*
*        NOTES -
*        THIS MODULE IS USED IN THE SORT OR OSCILLATING PHASE
*        WITH TAPE WORK UNITS
*
IERRPA   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRPA SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRPAI
*
         PRINT NOGEN
*
         DCBD  DSORG=PS,DEVD=(TA,DA)
*
         PRINT GEN
*
*        IOB DSECT
*
         IERIOB
*
*        IERCCWEQ
*
         IERCCWEQ
*
OPENLST  DSECT
*
         DC    19F'0'
RDOPT2   DC    X'20000000'
WRTOPT   DC    F'0'
WRTOPT2  DC    F'0'
         DC    9F'0'
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERRPAI  0101-20211-20211-1200-00401-00401-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERRPA SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERRPAI
*
         USING IERDPW1,R11
         USING IERRCA,R13
         USING IHADCB,R12
*
IERDPW1  B     RPAEOV              +00 RETURN FROM ALG AFTER EOV
         B     RPAEOS              +04 EOS ENTRY FROM BLOCK
*                                      R4=0 FINAL EOS, R4=4 NORMAL EOS
         B     RPA005              +08 NORMAL ENTRY FROM BLOCK
         B     *                   +12 DUMMY ENTRY - NOT USED
*
         DELETE EP=IERRC9          +16 AFTER LAST ASSGN RTN IS EXEC
*
         LTR   R15,R15
         BZ    RPA001              NO ERROR
         L     R15,PPIADSSC        ERROR ON DELETE - PRINT MESSAGE
         BAS   R14,28(,R15)        AND TERMINATE
         L     R15,PPIADSSC
         BAS   R14,16(,R15)        EXIT TO SSC
*
*        CHECK IF ADDITIONAL OUTPUT BUFFER SHOULD BE OBTAINED
*
RPA001   TM    PPILAB04,X'80'      DO NOT GETMAIN OUTPUT BUFF SW SET ?
         BO    RPA002              NO, BUFFERS ARE OK
         MVC   KLENGTH,PPILAB07    L'SECOND OUTPUT BUFFER
         MVI   KLENGTH,X'80'       SET LIST TERMINATOR
         LH    R2,PPILAB07+2       L'SECOND OUTPUT BUFFER
*
         GETMAIN EC,LV=(R2),A=KADDRS
*
         LTR   R15,R15
         BNZ   RPA003              NO SPACE AVAIL FOR SECOND BUFFER
*
*        SECOND BUFFER HAS BEEN OBTAINED
*        ADD CORE SPACE TO GETMAIN LISTS
*
         SR    R2,R2
         L     R3,PPIGETSZ
RPA0014  CLI   0(R3),X'80'         SCAN FOR END OF LIST
         BE    RPA0016
         LA    R2,4(,R2)
         LA    R3,4(,R3)
         B     RPA0014
*
RPA0016  MVC   4(4,R3),KLENGTH     ADD SIZE ENTRY IN SIZE LIST
         MVI   0(R3),X'00'         TURN OFF PREVIOUS LIST STOPPER
         L     R3,PPIGETMN
         L     R1,KADDRS
         ST    R1,4(R2,R3)
         ST    R1,PPILAB05
         AH    R1,PPILAB07+2
         ST    R1,RPABPT2
         MVI   PPILAB07,2          TWO BUFFERS
RPA002   L     R11,PPINET+4        EXIT TO NETWORK
         B     0(,R11)
*
*        RESET ALL POINTERS FOR SINGLE BUFFER
*
RPA003   L     R1,RPABPT1
         ST    R1,RPABPT2
         SR    R1,R1
         ST    R1,RPAPT2
         OI    RPAONE+1,X'F0'      SET SWITCH TO BRANCH TO WAIT ROUTINE
         B     RPA002
*
RPA005   L     R6,RPAPTIOB         R6 -> IOB
*                                  NORMAL ENTRY FROM BLOCK
*                                  R2 -> BUFFER TO BE WRITTEN
*                                  R1  = NO BYTES TO BE WRITTEN
         USING IOBSTDRD,R6
         STM   R9,R12,WSAVE
         STH   R1,KLENGTH
*
*        SUBTRACT SECOND BUFFER ADDR FROM CURRENT BUFFER
*        IF RESULT IS EITHER NEGATIVE OR GREATER THAN BUFFER
*        SIZE, THEN CURRENT BUFFER IS LAB04. ELSE IT IS LAB05
*
         LR    R4,R2
         S     R4,PPILAB05
         BM    RPA010              MINUS
         CH    R4,PPILAB07+2
         BH    RPA010
*
*        SECOND BUFFER IS TO BE WRITTEN
*
         L     R4,RPAPT2           R4 -> CURRENT BUFFER CCW
         L     R5,RPAPT1           R5 -> ALTERNATE BUFFER CCW
         MVC   RPABPT(4),RPABPT1   SET PTR TO RETURN TO BLOCK
         B     RPA025
*
*        FIRST BUFFER IS TO BE WRITTEN
*
RPA010   L     R4,RPAPT1           R4 -> CURRENT BUFFER CCW
         L     R5,RPAPT2           R5 -> ALTERNATE BUFFER CCW
         MVC   RPABPT(4),RPABPT2   SET PTR TO RETURN TO BLOCK
*
RPA025   OI    0(R4),X'80'         TURN PENDING SW ON FOR CURRENT BUFF
         L     R12,KDCBSV
         TM    0(R5),X'80'
         BZ    RPA020              BRANCH IF PENDING OFF FOR ALT BUFF
         L     R1,IOBECBPT
*
         IERWAIT 1,ECB=(1)         WAIT ON I/O COMPLETION
*
         NI    0(R5),X'7F'         SET PENDING OFF FOR ALT BUFFER
         TM    KSW,X'01'           EOV DETECTED ON PREVIOUS WRITE ?
         BO    RPAERR12            YES
         TM    DCBIFLGS,DCBIFPEC   I/O ERROR ?
         BO    RPAERR1             YES, BRANCH
RPA030   NI    KSW,X'FB'           SET OFF EOS SW FOR PREVIOUS WRITE
RPA020   LA    R7,8(,R4)           R7 -> CCW FOR THIS BUFFER
         ST    R2,WKAREA
         MVC   1(3,R7),WKAREA+1    MOVE COMMAND ADDR INTO CCW
         MVC   6(2,R7),KLENGTH
*
*        MOVE NOT EOS INDICATION TO BEGINNING OF BUFFER
*
RPA024   MVC   0(4,R2),KEOS2       FOR VARIABLE LENGTH RECORDS, INSTR
*                                  IS MODIFIED TO PLACE EOS
*                                  INDICATION BEYOND BCC
RPAFIRST B     RPAPRIME            INTIALLY ON AND FOR FIRST BLOCK
*                                  OF SEQUENCE, ELSE SET TO NOP
RPA023   TM    KSW,X'02'           LAST BLOCK OF A SEQUENCE ?
         BO    RPA055              YES, MOVE IN SPECIAL EOS INDICATION
RPA044   LA    R7,8(,R4)           R7 -> CCW FOR THIS BUFFER
         ST    R7,IOBSTART
*
         IEREXCP  (R6)
*
         ST    R12,KDCBSV          SAVE DCB ADDR
RPAONE   NOP   RPA060              SET TO BRANCH IF ONLY 1 AREA
RPAEOS2  NOP   RPAERR15
RPA080   L     R2,RPABPT           LOAD POINTER FOR BLOCK ROUTINE
*                                  POINTER FOR BLOCK ROUTINE
         LM    R9,R12,WSAVE
         PPITEST  PPIPH1           SORT OR MERGE PHASE IN CONTROL ?
         BZ    RPA050              MERGE
         L     R11,PPIBLK+4
         B     8(,R11)
*
RPA050   L     R11,PPIBLK2+4
         B     8(,R11)
*
*        ENTRY ON EOS FROM BLOCK
*
RPAEOS   B     RPACPY              SET TO NOP FOR FXD REC - BAL OR OSC
         OI    KSW,X'02'           SET LAST BLOCK OF SEQUENCE SW
RPACPY   OI    RPAEOS2+1,X'F0'     SET EOS SW IN MAIN LINE
         B     RPANEXT(R4)
*
RPANEXT  NI    RPA078+1,X'0F'      SET FINAL EOS SW ON
         B     RPA005
*
RPA055   MVI   2(R2),C'G'          SET EOS INDICATION FOR FINAL
*                                  BLOCK OF SEQUENCE
*                                  OVERLAID FOR VARIABLE LENGTH RECORDS
         NI    KSW,X'FD'           RESET SW
         B     RPA044
*
*        AFTER EXCP IF THERE IS ONLY ONE OUTPUT AREA
*
RPA060   L     R1,IOBECBPT
*
         IERWAIT 1,ECB=(1)         WAIT ON I/O COMPLETION
*
         NI    0(R4),X'7F'         SET PENDING OFF FOR CURRENT BUFFER
         TM    KSW,X'01'           EOV DETECTED ON PREVIOUS WRITE ?
         BO    RPAERR21            YES, BRANCH
         TM    DCBIFLGS,DCBIFPEC   NO, CHECK FOR I/O ERROR
         BO    RPAERR2             I/O ERROR FOUND
RPA061   CLI   RPAEOS2+1,X'F0'
         BNE   RPA080              NO, CONTINUE
         NI    RPAEOS2+1,X'0F'     YES, SET EOS SW TO NOP
         OI    RPAFIRST+1,X'F0'    SET FIRST BLK OF SEQ SW ON
         CLI   RPA078+1,X'00'      FINAL EOS ?
         BE    RPA062              YES
         LM    R9,R12,WSAVE        RESTORE REGISTERS
         L     R11,PPIALG+4
         B     12(,R11)            NORMAL EOS EXIT TO ALG
*
RPA062   OI    RPA078+1,X'F0'      RESET FINAL EOS SWITCH TO
*                                  BRANCH FOR NORMAL RUNNING
         LM    R9,R12,WSAVE        RESTORE REGISTERS
         L     R11,PPIALG+4
         BR    R11                 FINAL EOS EXIT TO ALG
*
RPAEOV   LM    R0,R10,WRSAVE       RETURN FROM ALG
         OI    RPAFIRST+1,X'F0'
RPAEVOA  B     RPA061
*
*        THIS ROUTINE SWITCHES THE POINTER IN THE IOB TO THE NEW
*        DCB AFTER EOV AND AT THE BEGINNING OF EACH NEW SEQUENCE.
*        IT ALSO MOVES THE EOS INDICATION TO THE BEGINNING OF
*        THE BUFFER
*
RPAPRIME NI    RPAFIRST+1,X'0F'    SET FIRST TIME SW TO NOP
RPAUPDAT MVI   1(R2),C'G'          FOR VARIABLE LENGTH RCDS INSTR IS
*                                  MODIFIED TO PLACE EOS INDICATION
*                                  BEYOND BCC
         SR    R9,R9
         IC    R9,PPIDEPHO+3       GET DCB INCREMENT FROM ALG
         L     R10,PPISTDCB        START OF DCB TABLE
         L     R0,0(R9,R10)
         ST    R0,IOBDCBPT
         LR    R12,R0
         B     RPA023
*
*        NORMAL EOS WHEN THERE ARE TWO AREAS
*
RPA070   OI    KSW,X'04'           SET EOS ON PREV WRITE SW
         NI    RPAEOS2+1,X'0F'     SET OFF EOS SW
         OI    RPAFIRST+1,X'F0'    RESET FIRST BLOCK OF SEQ SW
         L     R2,RPABPT           RESET BUFFER POINTERS FOR BLOCK RTN
         PPITEST  PPIPH1           SORT OR MERGE PHASE ?
         BZ    RPA090              MERGE
         L     R5,PPIBLK+4         SORT
RPA077   ST    R2,20(,R5)
         ST    R2,24(,R5)
RPA078   B     RPA084              INSTRUCTION CHANGED TO NOOP
*
         L     R1,IOBECBPT
*
         IERWAIT 1,ECB=(1)         WAIT ON I/O COMPLETION
*
         NI    0(R4),X'7F'         SET PENDING OFF FOR CURRENT BUFF
         OI    RPA078+1,X'F0'      RESET FINAL EOS SW TO BRANCH
         TM    DCBIFLGS,DCBIFPEC
         BO    RPA100
         LM    R9,R12,WSAVE
         L     R11,PPIALG+4
         BR    R11                 EXIT TO ALG ON FINAL EOS
*
RPA084   TM    KSW,X'01'
         BO    RPA080
RPA085   LM    R9,R12,WSAVE
         L     R11,PPIALG+4        NORMAL EOS
         B     12(,R11)            EXIT TO ALG
*
*        EOS IN MERGE PHASE (OSCILLATING ONLY) - WAIT ON EOS
*
RPA090   L     R5,PPIBLK2+4
         ST    R2,20(,R5)          SET BUFFER POINTER IN BLOCK RTN
         ST    R2,24(,R5)
         L     R1,IOBECBPT
*
         IERWAIT 1,ECB=(1)         WAIT ON I/O COMPLETION
*
         NI    0(R4),X'7F'         SET PENDING SW OFF FOR CURRENT BUFF
         NI    KSW,X'FB'           SET OFF EOS SW ON PREV WRITE
         TM    DCBIFLGS,DCBIFPEC   I/O ERROR ?
         BO    RPA100              ERROR
         B     RPA085              NO ERROR, RETURN TO ALG
*
RPA100   TM    IOBUSTAT,UE         ERROR CAUSED BY EOV ?
         BZ    RPAPERM             NO, PERMANENT ERROR
         NI    DCBIFLGS,255-DCBIFPEC  RESET IFLGS
RPA110   STM   R0,R10,WRSAVE
         LM    R9,R12,WSAVE        CONTINUE - ALG - EOV,EOS
         L     R11,PPIALG+4
         B     8(,R11)
*
RPAERR1  TM    IOBUSTAT,UE         EOV ?
         BZ    RPAPERM             NOT EOV, PERMANENT ERROR
         NI    DCBIFLGS,255-DCBIFPEC  ERROR CAUSED BY EOV, RESET IFLGS
         PPITEST  PPIBALN          BALANCED SORT ?
         BO    RPAERR14            YES
         PPITEST  PPIBALN          BALANCED SORT ?
         BZ    RPA110              NO, EXIT TO ALG EOV AND TERMINATE
         TM    KSW,X'04'           YES, PREV BLK AN EOS BLK ?
         BO    RPAERR13            YES, SPECIAL EOV ENTRY TO ALG
RPAERR1A STM   R0,R10,WRSAVE
         LM    R9,R12,WSAVE        NO, NORMAL EOV ENTRY TO ALG TO
         L     R11,PPIALG+4        RETURN TO WRITE
         B     4(,R11)
*
*        ONE BLOCK AFTER EOV HAS BEEN WRITTEN
*
RPAERR12 NI    DCBIFLGS,255-DCBIFPEC  RESET DCB ERROR FLAGS
         MVI   KSW,X'00'
         B     RPA020
*
RPAERR13 STM   R0,R10,WRSAVE       SPECIAL EOV ENTRY TO BALN ALG
         L     R11,PPIALG+4
         B     16(,R11)
*
RPAERR14 TM    KSW,X'04'           PREV BLK AN EOS BLOCK ?
         BO    RPAERR13            NO, SPECIAL EOV TO ALG
         MVC   RPAEVOA+2(2),RPAERR16+2
         OI    KSW,X'03'           WRITE ANOTHER BLOCK BEFORE
         OI    RPAEOS2+1,X'F0'     TERMINATING SEQUENCE
         B     RPA020
*
RPAERR15 TM    KSW,X'01'
         BO    RPAERR1A
RPAERR16 B     RPA070
*
RPAERR2  TM    IOBUSTAT,UE         ERROR CAUSED BY EOV ?
         BZ    RPAPERM             NO, PERMANENT ERROR
         NI    DCBIFLGS,255-DCBIFPEC  RESET DCBIFLGS
         PPITEST  PPIBALN          BALANCED SORT ?
         BZ    RPA110              NO, BRANCH
         B     RPAERR24
*
RPAERR23 NI    RPAEOS2+1,X'0F'     SET EOS TO NOP
         OI    RPAFIRST+1,X'F0'    SET FIRST TIME SW TO BRANCH
         L     R2,RPABPT           RESET BUFFER POINTERS FOR BLOCK RTN
         PPITEST  PPIPH1           SORT OR MERGE PHASE ?
         BZ    RPA120              MERGE
         L     R4,PPIBLK+4
RPAERR25 ST    R2,20(,R4)
         ST    R2,24(,R4)
         STM   R0,R10,WRSAVE       STORE REG
         LM    R9,R12,WSAVE        RESTORE REGISTERS
         L     R11,PPIALG+4        EOV ENTRY TO ALG RETURN TO DEBLOCK
         B     4(,R11)
*
RPA120   L     R4,PPIBLK2+4
         B     RPAERR25
*
RPAERR21 MVI   KSW,X'00'           RESET KSW
         NI    DCBIFLGS,255-DCBIFPEC
RPAERR28 STM   R0,R10,WRSAVE
         B     RPAERR23
*
RPAERR24 CLI   RPAEOS2+1,X'00'     EOS ?
         BNE   RPAERR28
         OI    KSW,X'03'           SET EXTRA BLOCK AND LAST BLK OF SEQ
         OI    RPAEOS2+1,X'F0'     SET EOS SW ON
         B     RPA080
*
RPAPERM  PPITEST  PPIPH2
         BO    RPAPH2
RPAPERM1 ICM   R15,B'1111',KERREXIT
         BZ    RPANOEXT            NO USER EXIT, BRANCH
*
*        SET UP FOR EXIT TO USER
*
         LR    R0,R6               SET R0 = IOB ADDR WITH X'10' IN
         A     R0,KCON             HIGH ORDER BYTE
         LR    R1,R12              SET REG 1 = DCB ADDR
         BASR  R14,R15             CALL USER EXIT
         CLI   KERROPT,X'20'       TEST ERROR OPTION
         BE    RPANOEXT            PERMANENT ERROR - TERMINATE JOB
*
*        MISSING CODE HERE TO TAKE ACTION ON WHAT THE USER SET
*        SET IN KERROPT
*
RPANOEXT PPISETON PPIWRITE         SET WRITE ERROR FLAG IN PPI
         L     R15,PPIADSSC
         BAS   R14,16(,R15)        EXIT TO SSC - TERMINATE JOB
*
         USING OPENLST,R4
RPAPH2   L     R4,PPIOPEN+4
         MVC   KERROPT(1),KERROPT2
         MVC   KERREXIT+1(3),KERREXT2+1   EXIT ADDR GETS PH2 VALUE
         B     RPAPERM1
*
         DROP   R4
*
*        CONSTANTS
*
RPAPT1   DC    A(0)                POINTS TO FIRST BUFFER CCW-8 IN
*                                  GENERATED CORE
RPAPT2   DC    A(0)                POINTS TO SECOND BUFFER CCW-8 IN
*                                  GENERATED CORE
RPAPTIOB DC    A(0)                POINTS TO IOB
RPABPT1  DC    A(0)                FIRST BUFFER FOR BLOCK
RPABPT2  DC    A(0)                SECOND BUFFER POINTER FOR BLOCK
RPABPT   DC    F'0'                BUFFER ADDR TO RETURN TO BLOCK RTN
KEOS2    DC    C'HHHH'             CONSTANT FOR NOT EOS CASE
KDCBSV   DC    F'0'
KLENGTH  DC    A(0)                PARAMETERS USED IN ACCESSING
KADDRS   DC    A(0)                SECOND OUTPUT BUFFER
K0       DC    A(0)
KCON     DC    X'10000000'
KERREXIT DC    A(0)                ADDRS OF USER EXIT
KERREXT2 DC    A(0)
KERROPT2 DC    C' '
KERROPT  DC    C' '                USER ERROR OPTION
KSW      DC    X'00'               FROM RIGHT TO LEFT
*                                  BIT 1 = WRITE ANOTHER BLOCK AFTER
*                                          EOV
*                                  BIT 2 = FINAL BLOCK OF SEQ SW
*                                  BIT 3 = LAST BLOCK WRITTEN WAS AN
*                                          EOS BLOCK
*                                  BIT 4-8 = NOT USED
*
*        WORK AREAS
*
WKAREA   DC    A(0)
WSAVE    DC    4F'0'
WRSAVE   DC    11F'0'
*
./ ADD NAME=IERRPB   0101-20211-20211-1200-00101-00101-00000-RELEASE 00
RPB      TITLE 'IERRPB - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRPB
*
*        MODULE FUNCTION/OPERATION -
*        BALN TECHNIQUE PHASE1 ROUTINE THAT WILL WRITE EITHER DATA OR
*        DIRECTORY ON THE DISK
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - IERAPB
*
*        MACROS USED BY MODULE -
*        SMPPI
*        EXCP
*        WAIT
*        DELETE
*        GETMAIN
*
*        ENTRY POINTS - CALLING SEQUENCE -
*                          L    R11,PPIWRT+4
*                          B    0(,R11)  WRITE DIRECTORY
*
*                          L    R11,PPIWRT+4
*                          B    4(,R11)  END OF SEQUENCE
*
*                          L    R11,PPIWRT+4
*                          B    8(,R11)  WRITE DATA
*
*                          L    R11,PPIWRT+4
*                          B    12(,R11) EOV WRITE
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIADSSC   PPIBPTRK   PPIENDAR
*        PPINDSKA   PPISTDCB   PPISTIOB
*        PPIDIRAD
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPIDEPHO   PPILABO1   PPIWKARE
*        PPICNTL
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS -
*        DSECT IERIOB - MODEL IOB
*        DSECT IHADCB - MODEL DCB
*        DSECT IERRCA - MODEL PPI
*
*        EXITS - NORMAL -
*        TO ALGORITHM (IERROK) ON THE FOLLOWING CONDITIONS -
*        END OF SEQUENCE
*        END OF AREA
*        END OF AREA/SEQUENCE
*        WRITE DIRECTORY
*
*        EXIT TO BLOCK ROUTINE (PPIBLK+4) AFTER WRITING DATA
*
*        EXITS - ERROR -
*        TO SORT SYSTEM CONTROL ON ANY WRITE ERROR
*        TO USER ERROR OPTION ROUTINE ON WRITE ERROR
*
*        TABLES/WORK AREAS -
*        CHANNEL COMMAND WORD LIST TO WRITE DIRECTORY
*
IERRPB   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRPB SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRPBI
*
*        CCW EQUATES
*
         IERCCWEQ
*
*        DSECTS
*
*        MAP IERIOB
*
         PRINT NOGEN
*
         IERIOB
*
         PRINT GEN
*
         PRINT NOGEN
*
         DCBD  DSORG=(PS),DEVD=(DA)
*
         PRINT GEN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERRPBI  0101-20211-20211-1200-00416-00416-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERRPB SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERRPBI
*
         USING *,R11               PROGRAM BASE REG
         USING IERIOB,R12          IOB BASE REG
         USING IHADCB,R10          DCB BASE REG
         USING IERRCA,R13          PPI BASE REG
*
*        BRANCH TABLE
*
IERDPW1  B     RPBENT4             +00 WRITE DIRECTORY (EOV)
         B     RPBENT2             +04 END OF SEQUENCE
         B     RPBENT1B            +08 NORMAL DATA WRITE
         B     RPBENT3             +12 WRITE DIRECTORY
         B     RPBENT5             +16 DELETE RC9
*
RPBENT1B LA    R4,4                SET TO NO EOS
         PPITEST  PPIVAR           VARIABLE RECORDS ?
         BO    RPBVVR              YES, GOTO ERASE EOS
         MVC   0(L'KEOS1,R2),KEOS1   ERASE EOS (FIXED)
         B     RPBENT1             GOTO NORMAL DATA WRITE ROUTINE
*
RPBVVR   MVC   4(L'KEOS1,R2),KEOS1   ERASE EOS (VAR)
RPBENT1  STM   R0,R15,KRPBREG      NORMAL DATA WRITE ROUTINE
         L     R12,PPISTIOB        R12 ->  IOB TABLE
         LA    R9,8                CALC IERIOB PREFIX ADDR
         SR    R12,R9              R12 -> IERIOB
         TM    RPBDBSW,X'02'       DOUBLE BUFFERED ?
         BZ    RPBENT1A            NO, GOTO SINGLE BUFFER
RPBPASS  NOP   RPBPASS1            NOP FIRST TIME THROUGH
         SR    R6,R6
         ICM   R6,B'0111',PPILAB04+1  R6 -> BUFF 1
         SR    R6,R9               SUBTRACT 8 FROM BUFF ADDR
         ST    R6,RPBWRKC          SAVE ADJUSTED BUFF ADDR
         MVI   RPBPASS+1,X'F0'     TURN BY PASS SWITCH ON
RPBPASS1 TM    RPBBF,X'01'         FIRST WRITE ?
         BO    RPBNOWT             YES, BRANCH TO NO WAIT
         LA    R6,RPBENT1A         SET RETURN ADDR
         B     RPBSTAY             GOTO WAIT
*
RPBNOWT  MVI   RPBBF,X'00'         TURN OFF WAIT SWITCH
RPBENT1A SR    R2,R9               SET BUFFER ID ADDR, SUB 8
*
*        LOCATE DCB
*
         SR    R6,R6
         IC    R6,PPIDEPHO         GET INCREMENT FROM M FIELD
         L     R10,PPISTDCB        R10 -> DCB TABLE
         L     R10,0(R6,R10)       R10 -> DCB
         ST    R10,IOBDCBPT        CHAIN DCB AND IOB
*
*        SETUP FOR EXCP
*        CONVERT TTR -> MBBCCHHR
*
         STM   R14,12,12(R13)      SAVE REGS ACROSS RTN
         LR    R3,R13              SAVE R13
         SR    R0,R0
         ICM   R0,B'1110',PPIDEPHO+5  R0 = TTR0
         L     R1,DCBDEBAD         R1 -> DEB
         LA    R2,IOBSEEK          R2 -> MBBCCHHR RESULT
         L     R15,PPIPCNVT        R15 -> CONVERSION RTN
         BASR  R14,R15             CONVERT TTR -> MBBCCHHR
         LR    R13,R3
         LTR   R15,R15          *  SET CC
         LM    R14,R12,12(R13)  |  RESTORE REGS
         BNZ   RPBTERM          V  CONVERSION FAILED, TERMINATE SORT
         MVC   0(5,R2),IOBSEEK+3   SET CCHHR DISK ADDR IN COUNT BUFFER
         MVC   DCBFDAD,IOBSEEK
*
*        ORIENT ON PREVIOUS RECORD FOR SEARCH ID EQ CCW
*
         IC    R9,PPIDEPHO+7       GET RECORD NUMBER
         BCTR  R9,0                DECREMENT RCD NUMBER
         STC   R9,IOBR             PUT IN IOB SEEK ADDR
         LA    R9,2(,R9)           INCR AND SET DEPHO TO NEXT RECORD
         STC   R9,PPIDEPHO+7
         MVI   5(R2),X'00'         ZERO KL IN BUFFER COUNT FIELD
         STH   R1,6(,R2)           SET BUFFER COUNT BYTE COUNT
         MVI   WTRKSW,X'00'        TURN OFF TRACK FULL SWITCH
         CLC   4(1,R2),PPIBPTRK+1  WILL TRACK BE FULL ?
         BL    RPBNORML            NO, BRANCH
         MVI   WTRKSW,X'01'        YES, SET TRACK FULL SWITCH
         LA    R5,PPIENDAR         GET DISK ENDING ADDR
         LH    R6,PPINDSKA         GET NUMBER OF AREAS
*
*        LOOP THROUGH ALL SORTWK AREAS FOR MATCH
*
RPBMTRY  CLC   PPIDEPHO(1),0(R5)   COMPARE M, FOUND CORRECT END ADDR ?
         BE    RPBFLUSH            YES, GO OUT OF LOOP
         LA    R5,8(,R5)           NO, UP PPIENDAR SEARCH ADDR
         BCT   R6,RPBMTRY          GO BACK TO LOOP
RPBFLUSH CLC   PPIDEPHO+5(2),5(R5)  COMPARE TT IN ENDAR, END OF AREA ?
         BE    RPBEOAID            YES, GOTO END OF AREA PROCESSING
         PPITEST  PPIVAR           NO, VARIABLE RECORDS ?
         BO    RPBVARY             YES, BRANCH
*
*        NORMAL PROCESSING
*
RPBNORML LA    R7,IOBSTDRD         SET IOB ADDR
         ST    R7,DCBIOBAD         SET IOB POINTER IN DCB
         MVC   KRPBREGC(4),RPBBUF1 PASS ADDR TO BLOCK ROUTINE
         MVC   IOBSTART,HOLDPR     SET PRIME CCW ADDR IN IOB
         TM    RPBDBSW,X'02'       TEST FOR DOUBLE BUFFER
         BO    RPBDBL              GOTO DBL BUFFER ROUTINE
         BAS   R14,RPBSUBRT        CALL SET UP CCW
*
         IEREXCP  (R7)             WRITE DISK
*
         BAS   R6,RPBSTAY          CALL WAIT RTN
RPBUPRCD LTR   R4,R4               END OF FILE ?
         BZ    RPBENDSQ            YES, BRANCH TO EOF EXIT ROUTINE
         TM    WEOASW,X'01'        END OF AREA ?
         BO    RPBENDDK            YES, BRANCH
         TM    WTRKSW,X'01'        TRACK FULL ?
         BO    RPBFULTK            YES, BRANCH
RPBSEQTT TM    KEOSSW,X'01'        EOS ?
         BO    RPBENDSQ            YES, GOTO EOS RETURN
RPBENT4  LM    R0,R15,KRPBREG      RESTORE REGS
         L     R11,PPIBLK+4        SET RETURN REG
         B     8(,R11)             GOTO BLOCK
*
RPBDBL   C     R2,RPBWRKC          EQUAL COMPARE ?
         BE    RPB1                YES, BRANCH
         MVC   IOBSTART,IERALTCW
         LA    R14,RPBDBLRT        SET RETURN REG
         B     RPBSUBRT            GO SET UP CCW FOR WRITING RECORDS
*
RPB1     MVC   KRPBREGC(4),RPBBUF2  PASS ADDR TO BLOCK ROUTINE
         BAS   R14,RPBSUBRT        CALL SET UP CCW
*
RPBDBLRT IEREXCP  (R7)             WRITE DISK
*
         B     RPBUPRCD            GOTO MAIN LINE
*
*        WAIT AFTER EXCP RTN
*
RPBSTAY  L     R10,IOBDCBPT        SET DCB BASE REG
*
         IERWAIT  1,ECB=(R12)      WAIT ON I/O COMPLETION
*
         TM    DCBIFLGS,DCBIFPEC   IOS ERROR ?
         BO    RPBTERM             YES, GOTO TERMINATE JOB
         LM    R0,R2,KRPBREG       NO, RESTORE PASS INFO
         BR    R6                  GOTO MAIN LINE
*
*        SET UP CCW FOR WRITING RECORDS
*
RPBSUBRT L     R8,IOBSTART         CCW POINTER
         LA    R1,8(,R1)           UP RCD BYTE COUNT
         STH   R1,22(,R8)          STOW IN CCW
         BR    R14                 GOTO MAIN LINE
*
RPBENDSQ MVI   KEOSSW,X'00'        TURN OFF EOS SWITCH
         L     R3,PPIBLK+4         LOAD ADDR OF BLOCK ROUTINE
         MVC   20(4,R3),KRPBREGC   MOVE POINTER INTO BLOCK RTN
         MVC   24(4,R3),KRPBREGC   MOVE POINTER INTO BLOCK RTN
*
RPBSGL   LM    R0,R15,KRPBREG      RESTORE REGS
         B     RPBFSTB(R4)         GOTO EOS BRANCH TABLE
*
RPBFNLES L     R11,PPIALG+4        SET RETURN REG
         BR    R11                 GOTO FINAL EOS
*
RPBFSTB  B     RPBFNLES            GOTO FINAL EOS
         L     R11,PPIALG+4        SET RETURN REG
         B     12(,R11)            GOTO NORMAL EOS
*
*        AN END OF AREA HAS BEEN FOUND
*
RPBEOAID MVI   WEOASW,X'01'        TURN ON EOA SWITCH
         PPITEST  PPIVAR           VARIABLE RECORDS ?
         BO    RPBVEOS             YES, GOTO INDICATE VAR EOS/EOA
         MVC   8(4,R2),KEOS2
         MVI   10(R2),C'G'         INDICATE FIXED EOS
         B     RPBNORML            GOTO MAIN LINE
*
RPBVEOS  MVC   12(4,R2),KEOS2
         MVI   14(R2),C'G'         INDICATE VARIABLE EOS/EOA
         B     RPBNORML            GOTO MAIN LINE
*
*        TRACK FULL RTN
*        INCR TO NEXT TRACK
*
RPBFULTK MVI   PPIDEPHO+7,X'01'    SET R TO FIRST RECORD ON NEW TRACK
         SR    R9,R9
         ICM   R9,B'0011',PPIDEPHO+5  R9 = TT
         LA    R9,1(,R9)              INCR TT
         STCM  R9,B'0011',PPIDEPHO+5  UPDATE TT
         B     RPBSEQTT            GO TO EOS TEST
*
*        AN END OF AREA HAS BEEN REACHED
*        RETURN FROM HERE TO THE ALGORITHM
*
RPBENDDK MVI   WEOASW,X'00'        TURN OFF EOA SWITCH
         CLI   KEOSSW,X'01'        EOS ?
         BE    RPBSWOFF            YES, GOTO TURN OFF EOS INDICATOR
         LM    R0,R15,KRPBREG      RESTORE REGS
         L     R11,PPIALG+4        SET RETURN REG
         B     4(,R11)             BRANCH TO EOA ALGORITHM
*
RPBSWOFF MVI   KEOSSW,X'00'        TURN OFF EOS INDICATE
         LM    R0,R15,KRPBREG      RESTORE REGS
         L     R11,PPIALG+4        SET RETURN REG
         B     8(,R11)             GOTO EOS EOA ROUTINE
*
*        END OF SEQUENCE
*
RPBENT2  MVI   KEOSSW,X'01'        TURN ON EOS SWITCH
         STM   R4,R6,KRPBREGB      SAVE REGS
         SR    R5,R5
         ICM   R5,B'0111',PPILAB07+1  BUFFER SIZE
         LH    R6,PPIRCDL2         SORT REC SIZE
         SR    R4,R4
         SR    R5,R1               BUFF SIZE - SHORT BLOCK SIZE
         DR    R4,R6               FR=RECORDS NOT ACCOUNTED FOR
         L     R6,PPINMAX
         SR    R6,R5               NMAX REC NOT ACCOUNTED FOR
         ST    R6,PPINMAX
         LM    R4,R6,KRPBREGB      RESTORE REGS
         PPITEST  PPIVAR           VARIABLE RECORDS ?
         BO    RPBVAR              YES, GOTO INDICATE EOS
         MVC   0(4,R2),KEOS2       INDICATE EOS (FIXED)
         LTR   R4,R4               FINAL SEQUENCE ?
         BZ    RPBNFIN             YES, BRANCH
         B     RPBENT1             GOTO MAIN LINE
*
RPBNFIN  MVI   2(R2),C'G'          INDICATE FINAL EOS
         B     RPBENT1             GOTO MAIN LINE
*
RPBVAR   MVC   4(4,R2),KEOS2       INDICATE EOS (VARIABLE)
         LTR   R4,R4               FINAL SEQUENCE ?
         BZ    RPBVFIN             YES, BRANCH
         B     RPBENT1             GOTO MAIN LINE
*
RPBVFIN  MVI   6(R2),C'G'          INDICATE FINAL EOS
         B     RPBENT1             GOTO MAIN LINE
*
*        ENTRY TO WRITE DIRECTORY
*
RPBENT3  STM   R0,R15,KRPBREG      SAVE REGISTERS
         L     R12,PPISTIOB        SET IOB BASE REG
         LA    R7,8
         SR    R12,R7              R12 -> IERIOB
         TM    RPBDBSW,X'02'       DOUBLE BUFFERED ?
         BZ    RPBSTORE            NO, BRANCH
         BAS   R6,RPBSTAY          CALL RTN TO WAIT ON I/O COMPLETION
RPBSTORE SR    R7,R7
         IC    R7,PPIDIRAD         GET INCREMENT
         L     R10,PPISTDCB
         L     R10,0(R7,R10)       R10 -> DCB
         ST    R10,IOBDCBPT        SET DCB POINTER IN IOB
*
*        SETUP FOR EXCP
*
         STM   R14,R12,12(R13)
         LR    R3,R13
         SR    R0,R0
         ICM   R0,B'1110',PPIDIRAD+5  R0 = TTR0
         L     R1,DCBDEBAD         R1 -> DEB
         LA    R2,IOBSEEK          R2 -> MBBCCHHR RESULT
         L     R15,PPIPCNVT        R15 -> CONVERSION RTN
         BASR  R14,R15             CONVERT TTR -> MBBCCHHR
         LR    R13,R3
         LTR   R15,R15          *  SET CC
         LM    R14,R12,12(R13)  |  RESTORE REGS
         BNZ   RPBTERM          V  CONVERSION FAILED, TERMINATE SORT
         IC    R9,IOBR             GET RECORD NUMBER
         BCTR  R9,0                DECREMENT RCD NUMBER
         STC   R9,IOBR             PUT IN IOB FOR SEARCH ID EQ
         LA    R9,1(,R9)           RESTORE RECORD COUNT
*
*        SHUFFLE PPIWKARE DOWN 8 BYTES TO ALLOW FOR COUNT FIELD
*
         MVC   PPILAB01(64),PPIWKARE
         MVC   PPIWKARE+8(64),PPILAB01
         MVC   PPIWKARE(5),IOBSEEK+3   BUILD CCHHR COUNT FIELD
         STC   R9,PPIWKARE+4       SET CORRECT R IN COUNT
         MVC   PPIWKARE+5(3),KDKBUF    MOVE INTO COUNT KL, DATA LENGTH
         LA    R7,RPBIDCCW
         ST    R7,IOBSTART         SET CCW PTR IN IOB
         LA    R7,IOBSTDRD
         ST    R7,DCBIOBAD         SET IOB ADDR IN DCB
*
         IEREXCP  (R7)             WRITE DISK
*
         MVI   RPBBF,X'01'         TURN FIRST TIME SWTCH ON
         BAS   R6,RPBSTAY          CALL WAIT RTN
         LM    R0,R15,KRPBREG      RESTORE REGS
         L     R11,PPIALG+4        SET RETURN REG
         BR    R14                 GOTO ALGORITHM
*
*        WRITE ERROR
*        TEST EXIT 18, EXECUTE USER MOD, AND TERMINATE THE JOB
*
RPBTERM  IC    R3,DCBFDAD+7        LOAD DCBFDAD RECORD NO
         BCTR  R3,0                DECREMENT RECORD NO BY 1
         STC   R3,DCBFDAD+7        STORE UPDATED RECORD NO IN DCB
         ICM   R15,B'1111',RPBUSERX  USER MOD ADDR PROVIDED ?
         BZ    RPBOFF              NO, BRANCH TO TERMINATE JOB
         ST    R7,PPIWKARE         STORE IOB ADDR FOR USER EXIT
         MVI   PPIWKARE,X'10'      SET HI-ORDER BYTE
         L     R0,PPIWKARE
         LR    R1,R10              R1 -> DCB FOR USER EXIT
         BASR  R14,R15             CALL USER EXIT 18
RPBOFF   ST    R4,RPBSVEME         SAVE ORIGINAL CONTENTS
         L     R6,PPISTIOB         SAVE IOB ADDR
         PPISETON PPIWRITE         WRITE ERROR FLAG IN PPI
         L     R15,PPIADSSC        R15 -> SSC
         BAS   R14,16(,R15)        EXIT TO SSC, NO RETURN
*
RPBENT5  DELETE EP=IERRC9          FREE CORE
*
         LTR   R15,R15             SUCCESSFUL DELETE ?
         BZ    RPBBUFCK            YES, BRANCH
         L     R15,PPIADSSC        ERROR ON DELETE - PRINT MESSAGE
         BAS   R14,28(,R15)
         L     R15,PPIADSSC
         BAS   R14,16(,R15)        EXIT TO SSC, NO RETURN
*
RPBTONET L     R11,PPINET+4
         B     0(,R11)             GOTO NETWORK
*
RPBBUFCK TM    PPILAB04,X'80'      NEED ANOTHER BUFFER ?
         BO    RPBTONET            BUFFERS OK, BRANCH
         LH    R15,PPILAB07+2
         LA    R15,8(,R15)         CALC L'BUFFER
*
         GETMAIN EC,LV=(R15),A=RPBADDR
*
         LTR   R15,R15             GETMAIN SUCCESSFUL ?
         BNZ   RPBTONET            NO, GOTO NETWORK
RPBBUFOK MVI   PPILAB07,2          YES, CHANGE BUFFER COUNT TO 2
         MVI   RPBDBSW,2           SET DOUBLE SWITCH
         ST    R2,RPBREGSV         SAVE CONTENTS OF R2
         ST    R12,RPBREGSE        SAVE CONTENTS OF R12
         L     R2,RPBADDR
         LA    R2,8(,R2)
         ST    R2,PPILAB05         STORE NEW ADDR OF BUFFER 2
         PPITEST  PPIVAR           VARIABLE RECORDS ?
         BO    RPBVVV              YES, BRANCH
         LA    R2,4(,R2)           CALC FIXED BUF ADDR
         B     RPBFIX
*
RPBVVV   LA    R2,8(,R2)           CALC VARIABLE BUF ADDR
RPBFIX   ST    R2,RPBBUF2
         L     R2,PPIGETSZ         LOAD ADDR OF SIZE TABLE
RPBCOMPR CLI   0(R2),X'80'         FIRST BYTE X'80' ?
         BE    RPBHIT              YES, BRANCH
         LA    R2,4(,R2)           INCREMENT REG BY 4
         B     RPBCOMPR            BRANCH BACK TO COMPARE
*
RPBHIT   LH    R15,PPILAB07+2      CALC L'BUFFER
         LA    R15,8(,R15)
         ST    R15,4(,R2)          MOVE L'BUFF INTO SIZE TABLE
         MVI   4(R2),X'80'         SET NEW END OF TABLE MARKER
         MVI   0(R2),X'00'         CLEAR PREV END OF TABLE INDICATOR
         S     R2,PPIGETSZ         SUBTRACT STARTING ADDR FOR DIFF
         A     R2,PPIGETMN         ADD ADDR OF TABLE TO DIFF
         MVC   4(4,R2),RPBADDR     MOVE ADDR OF BUFF INTO ADDR TABLE
         L     R12,PPISTIOB
         LA    R9,8
         SR    R12,R9              R12 -> IERIOB
         L     R2,IERALTCW
         MVC   17(3,R2),RPBADDR+1  MOVE ADDR INTO ALT CCW
         L     R2,RPBREGSV         RESTORE R2
         L     R12,RPBREGSE        RESTORE R12
         B     RPBTONET            GOTO NETWORK
*
*        VARIABLE RECORD PROCESSING
*
RPBVARY  SR    R7,R7
         IC    R7,0(,R5)           GET DCB INCR (M) FROM PPIENDAR ENTRY
         LA    R7,RPBCOMTB(R7)     R7 -> RPBCOMTB TABLE POINTER
         CLC   PPIDEPHO+5(2),2(R7)  COMPARE TT, END OF EXTENT ?
         BE    RPBEOAID            YES, BRANCH
         B     RPBNORML            GOTO SET IOB ADDR
*
RPBCOMTB DC    7F'0'               TABLE OF ADJUSTED ENDAR VALUES
*                                  FOR VARIABLE LENGTH RECORDS
*
RPBWRKC  DC    F'0'                U  D
RPBSVEME DC    F'0'                 S  U
RPBADDR  DC    F'0'                  E  R
RPBREGSV DC    F'0'                   D  I
RPBREGSE DC    F'0'                EQUAL/EXTRACT ADDR
RPBBUF1  DC    F'0'                    F  N
RPBBUF2  DC    F'0'                     O  G
RPBUSERX DC    F'0'                      R  T
*
KRPBREG  DC    2F'0'            *         W  H
KRPBREGC DC    14F'0'           V          O  E
*
KRPBREGB DC    3F'0'                        R  P
HOLDPR   DC    F'0'                SET BY IERAPB
KEOSSW   DC    X'00'                         K  R
RPBBF    DC    X'01'                           N  G
RPBDBSW  DC    X'00'                            G
KEOS1    DC    CL4'HHHH'           NON EOS INDICATOR (NORMAL STANDARD)
KEOS2    DC    CL4'HGHH'           EOS INDICATOR
WEOASW   DC    X'00'               END OF AREA SWITCH
WTRKSW   DC    X'00'               FULL TRACK SWITCH
KDKBUF   DC    X'00'            *  COUNT DATA, KL AND DATA LENGTH(64)
         DC    AL2(64)          V
*
*        CCW LIST TO WRITE DIRECTORY
*
RPBIDCCW CCW   SEARIDEQ,0,CC+SLI,5
RPBCTCCW CCW   TIC,RPBIDCCW,CC+SLI,0
RPBCCW2  CCW   WRITECKD,0,SLI,72
*
./ ADD NAME=IERRPC   0101-20211-20211-1200-00243-00243-00000-RELEASE 00
RPC      TITLE 'IERRPC - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRPC
*
*        MODULE FUNCTION/OPERATION -
*        END OF SORT PHASE HOUSEKEEPING
*        RECORD COUNTS ARE CHECKED AND OUTPUT FILES ARE CLOSED
*
*        USED AS A DSECT IN - N/A
*
*        MACROS USED -
*        SMPPI
*        CLOSE
*
*        ENTRY POINTS - ENTRY FROM IERRCV
*                       CALLING SEQUENCE -
*                            LOAD EP=IERRPC(,DCB=SORTLIB)
*                            L    R11,R0
*                            B    0(R1,R11)
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIADSSC   PPIBDSVA   PPIFILSZ   PPINDSKA
*        PPISTDCB   PPIWKARE   PPIAXERT   PPICOUNT
*        PPIRCDCT   PPICNTL
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPICNTL
*        PPIWKARE
*
*        EXTERNAL ROUTINES - EXTERN IERRMA - MSG TEXT MODULE
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL - TO SORT SYSTEM CONTROL AT END OF PHASE
*                         CALLING SEQUENCE
*                            L   R15,PPIADSSC
*                            BAL R14,8(,R15)
*
*                       - TO SSC ON INCORRECT RECORD COUNT
*                         CALLING SEQUENCE
*                            L   R15,PPIADSSC
*                            BAL R14,16(,R15)
*
*        EXITS - ERROR -
*
*        TABLES/WORK AREAS - N/A
*
*        NOTES - USE LIMITED TO END OF SORT PHASE
*
IERRPC   CSECT
*
         USING *,R11               PROGRAM BASE
         USING DIERRMA,R12         MESSAGE BASE
         USING IERRCA,R13          PPI BASE
*
*        THE FIRST INSTRUCTION IS EXECUTED IF THE BRANCH TO THIS
*        ROUTINE IS A DISPLACEMENT OF ZERO. IT WILL MODIFY
*        RPCRETRN TO GOTO LOAD PHASE 2. IF THIS ROUTINE IS
*        ENTERED ON A DISPLACEMENT OF 4, RPCRETRN IS INITIALLY
*        SET TO GOTO LOAD PHASE 3
*
         MVI   RPCRETRN+3,X'04'    +00 MODIFY RETURN TO GOTO PH2
         LM    R6,R8,PPICOUNT      +04 LOAD RCD COUNTS FROM PPI
*
*        THE FOLLOWING SECTION OF CODE SAVES THE BLOCK COUNTS IF
*        IT IS A TAPE SORT. THE BLOCK COUNTS WILL BE RESTORED AT
*        THE START OF PHASE TWO
*
         PPITEST  PPITAPE          TAPE SORT ?
         BZ    RPCCHK              NO, DISK SORT
         SR    R1,R1               ZERO REG
         IC    R1,PPIBDSVA         LOAD NUMBER OF WORK UNITS
         LA    R2,PPITPTBL         LOAD STARTING ADDR OF TAPE TABLE
         PPITEST  PPIPOLY          POLYPHASE SORT ?
         BZ    RPC100              NO, BRANCH
         IC    R1,PPIMRGMX+1       INSERT M
RPC100   TM    0(R2),X'40'         OPEN BIT ON FOR THIS UNIT ?
         BZ    RPC300              NO, BRANCH TO INCREMENT TAPE ADDR
         PPITEST  PPIBALN          BALANCED SORT ?
         BZ    RPC200              NO,
         TM    0(R2),X'80'         YES, INPUT BIT ON ?
         BO    RPC300              YES, DON'T SAVE BLOCK COUNT
RPC200   SR    R3,R3               ZERO REG
         IC    R3,1(,R2)           LOAD TAPE INCREMENT
         L     R4,PPISTDCB         LOAD STARTING ADDR OF DCB TABLE
         LA    R5,PPIENDAR         LOAD STARTING ADDR OF SAVE AREA
         AR    R4,R3               GET DCB POINTER
         L     R4,0(,R4)           R4 -> DCB
         USING IHADCB,R4
         AR    R5,R3               GET ADDR TO SAVE BLK CNT OF UNIT
         MVC   0(4,R5),DCBBLKCT    MOVE BLK CNT FROM DCB TO SAVE AREA
         DROP  R4
RPC300   LA    R2,2(,R2)           INCREMENT TAPE TABLE ADDRESS
         BCT   R1,RPC100           ALL UNITS TESTED.... NO LOOP AGAIN
*
*        IF THE EQUALS ROUTINE IS PRESENT, DECREMENT THE
*        DISPLACEMENT FIELDS IN THE COMPARE INSTRUCTIONS BY FOUR
*        BYTES FOR MERGE NETWORK
*
RPCCHK   PPITEST  PPIEQUAL         EQUALS RTN ACTIVE ?
         BZ    RPCEXERT            NO, BRANCH
         LA    R1,11               COUNT OF 11
         LA    R10,4               CONSTANT OF 4
         L     R9,PPIAXERT         R9 -> EQUALS ROUTINE
RPCMORE  LH    R4,2(,R9)           BASE AND DISP OF 1ST OPERAND
         SR    R4,R10              DECREMENT DISP OF 1ST OPERAND BY 4
         STH   R4,2(,R9)           RESTORE BASE AND DISPLACEMENT
         LH    R4,4(,R9)           BASE AND DISP OF 2ND OPERAND
         SR    R4,R10              DECREMENT DISP OF 2ND OPERAND BY 4
         STH   R4,4(,R9)           RESTORE BASE AND DISPLACEMENT
         LA    R9,8(,R9)           INCREMENT TO CLC, BCR OF NEXT CF
         BCT   R1,RPCMORE          GO BASE AND DISP LOOP
RPCEXERT L     R12,PPIRMA+4        SET MSG BASE REG
         L     R10,PPIFILSZ        INPUT FILE SIZE
         PPITEST  PPIFSZE          FILE SIZE ESTIMATED ?
         BO    RPCENT1             YES, BRANCH
         PPITEST  PPIREADE         PH1 READ ERROR SWITCH ON ?
         BO    RPCENT1             YES, TREAT FILE SIZE AS ESTIMATED
         CR    R6,R10              SORT COUNT VS GIVEN
         BNE   RPCENT2             NOT EQUAL, BRANCH TO MSG
RPCENT1  LR    R9,R6               GET SORT COUNT
         AR    R9,R8               ADD INSERTS
         SR    R9,R7               SUBTRACT DELETES
         PPISETOF PPIFSZE          TURN OFF EST SWITCH
         ST    R6,PPIFILSZ         STORE FILE SIZE
         ST    R9,PPIRCDCT         TOTAL RECORDS TO BE SORTED
         SR    R6,R6               SET TO ZERO
         ST    R6,PPICOUNT         CLEAR RECORD COUNTER
         L     R9,PPISTDCB         SET DCB TABLE ADDR
         PPITEST  PPITAPE          TAPE SORT ?
         BZ    RPCDS               NO, BRANCH
         IC    R6,PPIBDSVA         GET NUMBER OF WORK UNITS
         B     RPNXTDCB            GOTO CLOSE UNIT
*
RPCDS    LH    R6,PPINDSKA         GET NUMBER OF DISK AREAS
*
*        THIS LOOP WILL CLOSE ALL FILES AS NEEDED
*
RPNXTDCB LA    R9,4(,R9)           INCR BY 4 TO INITIALLY SKIP INPT DCB
         L     R2,0(,R9)           SET O/P DCB ADDR
         USING IHADCB,R2
         CLI   0(R9),X'80'         UNIT CLOSED ?
         BE    RPCLOOP             YES, BRANCH
         PPITEST  PPITAPE          TAPE SORT ?
         BZ    RPCINDCT            NO, DASD, BRANCH
         OI    DCBOFLGS,DCBOFLWR   SET CLOSE/LEAVE (EOV WILL WRITE TM)
         PPITEST  PPICLOSR         CLOSE WITH REWIND ?
         BO    RPCRREAD            YES, BRANCH
*
         CLOSE ((R2),LEAVE)        CLOSE A TAPE FILE
*
         LTR   R15,R15             CLOSE SUCCESSFULL ?
         BZ    RPCLOOP             GOTO INDICATE A CLOSE FILE
*
         DC    H'0'                CLOSE FAILED, FORCE AN 0C1 ABEND
*                                  FOR DIAGNOSTIC PURPOSES
*
RPCINDCT XC    DCBDSORG,DCBDSORG   CLEAR DSORG
         NI    DCBOFLGS,255-DCBOFLWR   PREVENT EOV WRITING AN EOF
*                                      MARKER AS NEITHER DCBFDAD
*                                      OR DCBTRBAL ARE MAINTAINED
*                                      CLOSE WITH REREAD IRRELEVANT
*                                      FOR DASD
*
RPCRREAD CLOSE ((R2),REREAD)       CLOSE A FILE
*
         LTR   R15,R15             CLOSE SUCCESSSFULL ?
         BZ    RPCLOOP             YES, BRANCH
*
         DC    H'0'                CLOSE FAILED, FORCE AN 0C1 ABEND
*                                  FOR DIAGNOSTIC PURPOSES
RPCLOOP  MVI   0(R9),X'80'         INDICATE A CLOSED FILE
         BCT   R6,RPNXTDCB         FALL THRU IF TABLE END
*
         DROP  R2
*
*        END OF CLOSE LOOP
*
         PPITEST  PPIME17          USER MOD E17 ACTIVE ?
         BNO   RPCENT4             NO, BRANCH
*
*        CALL USER E17 EXIT
*
RPCMODEX L     R15,PPIX17+4        SET TO USER ADDR
         BASR  R14,R15             CALL USER EXIT
RPCENT4  TM    WABSW1,X'01'        TERMINATE ?
         BO    RPCABT              YES, BRANCH
         LM    R0,R1,IER045        IER045I END OF SORT PHASE
         L     R15,PPIADSSC        R15 -> MSG PRINT RTN
         BAS   14,12(,R15)         CALL MSG PRINT RTN
         TM    RPCRETRN+3,X'08'    SKIP PHASE MSG TO BE PRINTED ?
         BO    RPCENT3             YES, GO TO PRINT
RPCOUTLK L     R15,PPIADSSC        R15 -> SSC
RPCRETRN BAS   R14,8(,R15)         EXIT TO SSC TO LOAD NEXT PHASE
*
RPCENT3  LM    R0,R1,IER049        IER049I SKIP MERGE PHASE
         L     R15,PPIADSSC        R15 -> PRINT MSG RTN
         BAS   14,12(,R15)         CALL PRINT MSG RTN
         B     RPCOUTLK            GOTO MAIN LINE
*
RPCABT   L     R15,PPIADSSC        R15 -> SSC
         BAS   R14,16(,R15)        EXIT TO SSC, TERMINATE
*
*        SET UP PRINTING INCORRECT COUNT MESSAGE
*
RPCENT2  MVI   WABSW1,X'01'        TURN ON TERMINATE SWITCH
         CVD   R10,PPIWKARE        CONVERT RECORDS IN TO DECIMAL
         ED    IER047I,PPIWKARE+4  FORMAT DATA
         CVD   R6,PPIWKARE         CONVERT RECORDS OUT TO DECIMAL
         ED    IER047O,PPIWKARE+4  FORMAT DATA
         L     R1,IER047
         MVC   PPIABMNO,3(R1)      MOVE MSG NO INTO ABEND CODE
         LM    R0,R1,IER047        IER047A RECORD COUNT ERROR
         L     R15,PPIADSSC        R15 -> SSC
         BAS   14,12(,R15)         CALL MSG WRITER
         B     RPCENT1             GOTO MAIN LINE
*
WABSW1   DC    X'00'               TERMINATE SWITCH
*
*        ALL OF THE MESSAGES THAT ARE REQUIRED FOR PHASE 1
*        RUNNING PROGRAM
*
DIERRMA  DSECT
*
         COPY RMAMAIN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
*        DCB
*
         PRINT NOGEN
*
         DCBD DEVD=(DA,TA),DSORG=PS
*
         PRINT GEN
*
         SMPPI
*
         END
./ ADD NAME=IERRPD   0101-20211-20211-1200-00117-00117-00000-RELEASE 00
RPD      TITLE 'IERRPD - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRPD
*
*        MODULE FUNCTION/OPERATION -
*        THIS MODULE IS DESIGNED TO BE USED AS A TAPE WRITE
*        MODULE WITH EITHER ONE OR TWO OUTPUT AREAS. IT ACCEPTS A
*        BLOCK OF RECORDS AT A TIME FROM THE BLOCK ROUTINE AND
*        SCHEDULES IT TO BE WRITTEN. AT EOS EOV EOF TIME IT WILL
*        EXIT TO THE ALGORITHM. HOWEVER THE NORMAL EXIT FROM THIS
*        ROUTINE IS TO THE BLOCK ROUTINE WITH AN EMPTY BUFFER.
*        THIS MODULE USES THE EXCP AND WAIT MACROS TO COMMUNICATE
*        WITH IOS
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - IERAPD
*
*        MACROS USED -
*        SMPPI
*        EXCP
*        WAIT
*        DCBD
*        DELETE
*        GETMAIN
*
*        ENTRY POINTS - IERRPD    - ENTRY FROM ALGORITHM AFTER EOV
*                                   CALLING SEQUENCE -
*                                       L   R11,PPIWRT+4
*                                       BR  R11
*
*                     - IERRPD+4  - ENTRY FROM BLOCK RTN ON EOS
*                                   CALLING SEQUENCE -
*                                       L    R11,PPIWRT+4
*                                       B    4(,R11)
*
*                     - IERRPD+8  - ENTRY FROM BLOCK RTN - NORMAL
*                                   CALLING SEQUENCE -
*                                       L    R11,PPIWRT+4
*                                       B    8(,R11)
*
*        ENTRY        - IERRPD+12 - ENTRY FROM LOAD MODULE AFTER ASSGN
*                                   CALLING SEQUENCE -
*                                       L    R11,PPIWRT+4
*                                       B    12(,R11)
*
*        INPUT PPI FIELDS REFERENCED -
*        PPIDEPHO
*        PPISTDCB
*        PPIALG
*        PPIBLK2
*        PPIADSSC
*        FULL BUFFER IS PASSED TO BE WRITTEN
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        FULL BUFFER IS WRITTEN ON TAPE. EMPTY BUFFER IS
*        RETURNED TO BLOCK ROUTINE
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS -
*        FIELDS IN DCBS AND IOBS ARE USED
*        USER EXIT ADDRESS IS CHECKED
*
*        EXITS - NORMAL -
*        BLOCK (PH2) - DSPL=8  - NORMAL RETURN WITH EMPTY BUFFER ADDR
*        ALGORITHM   - DSPL=0  - TO FIRST RUNNING PROGRAM
*        ALGORITHM   - DSPL=4  - EOV
*        ALGORITHM   - DSPL=8  - EOV AND EOS
*        ALGORITHM   - DSPL=12 - NORMAL EOS
*
*        EXITS - ERROR - EXIT TO USER ON I/O ERROR
*                        EXIT TO SSC TO TERMINATE JOB ON I/O ERROR
*                        BALR PO,R15
*                        L R15,PPIADSSC
*                        BAL R14,16(,R15)
*
*        TABLES/WORK AREAS -
*        WKAREA
*        WSAVE
*        WRSAVE
*
*        NOTES -
*        THIS MODULE IS USED IN THE INTERMEDIATE MERGE PHASE
*        WHEN WORK UNITS ARE TAPE
*
IERRPD   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRPD SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRPDI
*
         PRINT NOGEN
*
         DCBD  DSORG=PS,DEVD=(TA)
*
         PRINT GEN
*
*        CCW EQUATES
*
         IERCCWEQ
*
*        IOB
*
         IERIOB
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERRPDI  0101-20211-20211-1200-00328-00328-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERRPD SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERRPDI
*
*
         USING *,R11
         USING IERRCA,R13
         USING IHADCB,R12
*
         B     RPAEOV              +00 RETURN FROM ALG AFTER EOV
         B     RPAEOS              +04 EOS ENTRY FROM BLOCK
*                                      R4=0 FINAL EOS, R3=4 NORMAL EOS
         B     RPA005              +08 NORMAL ENTRY FROM BLOCK
         B     *                   +12 DUMMY ENTRY - NOT USED
*                                  +16
         DELETE EP=IERRC9          ENTRY AFTER LAST ASSGN RTN IS EXEC
*
         LTR   R15,R15
         BZ    RPA001              NO ERROR, BRANCH
         L     R15,PPIADSSC        ERROR ON DELETE - PRINT MESSAGE
         BAS   R14,28(,R15)
         L     R15,PPIADSSC
         BAS   R14,16(,R15)        TERMINATE
*
*        CHECK IF ADDITIONAL OUTPUT BUFFER SHOULD BE OBTAINED
*
RPA001   TM    PPILAB04,X'80'      GETMAIN ADDITIONAL BUFFER ?
         BO    RPA002              NO, BUFFERS ARE OK
         LH    R2,PPILAB07+2       YES, R2 = L'SECOND BUFFER
*
RPA0012  GETMAIN EC,LV=(R2),A=KADDRS
*
         LTR   R15,R15
         BNZ   RPA003              NO SPACE AVAIL FOR SECOND BUFFER
*
*        SECOND BUFFER HAS BEEN OBTAINED
*        ADD CORE SPACE TO GETMAIN LISTS
*
         SR    R2,R2
         L     R3,PPIGETSZ
RPA0014  CLI   0(R3),X'80'         END OF LIST ?
         BE    RPA0016             YES, BRANCH
         LA    R2,4(,R2)
         LA    R3,4(,R3)
         B     RPA0014             CONTINUE
*
RPA0016  LH    R15,PPILAB07+2      L'SECOND BUFFER
         ST    R15,4(,R3)
         MVI   4(R3),X'80'         SET NEW LIST TERMINATOR
         MVI   0(R3),X'00'         CLEAR PREV LIST TERMINATOR
         L     R3,PPIGETMN
         L     R1,KADDRS
         ST    R1,4(R2,R3)
         ST    R1,PPILAB05
RPA0018  AH    R1,PPILAB07+2
         ST    R1,RPABPT2
         MVI   PPILAB07,2          SET NUMBER OF BUFFERS TO 2
RPA002   L     R11,PPIALG+4        EXIT TO ALG
         BR    R11                 EXIT
*
*        RESET ALL POINTERS FOR SINGLE BUFFER
*
RPA003   L     R1,RPABPT1
         ST    R1,RPABPT2
         LA    R1,K0
         ST    R1,RPAPT2
         OI    RPAONE+1,X'F0'
         B     RPA002              EXIT
*
RPA005   L     R6,RPAPTIOB         ADDR OF IOB
*                                  NORMAL ENTRY FROM BLOCK
*                                  R2 = ADDR OF BUFFER TO BE WRITTEN
*                                  R1 = NO BYTES TO BE WRITTEN
         USING IOBSTDRD,R6         IOB ADDRESSABILITY
         STM   R9,R12,WSAVE
*
*        SUBTRACT SECOND BUFFER ADDR FROM CURRENT BUFFER
*        IF RESULT IS EITHER NEGATIVE OR GREATER THAN BUFFER
*        SIZE, THEN CURRENT BUFFER IS LAB04. OTHERWISE IT IS
*        LAB05
*
         LR    R4,R2
         S     R4,PPILAB05
         BM    RPA010              MINUS
         CH    R4,PPILAB07+2
         BH    RPA010              GREATER
*
*        SECOND BUFFER IS TO BE WRITTEN
*
         L     R4,RPAPT2           R4 POINTS TO CURRENT BUFFER CCW
         L     R5,RPAPT1           R5 POINTS TO ALTERNATE BUFFER CCW
         MVC   RPABPT(4),RPABPT1   SET PTR TO RETURN TO BLOCK
         B     RPA020              SET CCW
*
*        FIRST BUFFER IS TO BE WRITTEN
*
RPA010   L     R4,RPAPT1           R4 POINTS TO CURRENT BUFFER CCW
         L     R5,RPAPT2           R5 POINTS TO ALTERNATE BUFFER CCW
         MVC   RPABPT(4),RPABPT2   SET PTR TO RETURN TO BLOCK
RPA020   LA    R7,8(,R4)           GET ADDR OF CCW FOR THIS BUFFER
*                                  IN R7, R4 POINTS TO CURRENT BUFFER
         ST    R2,WKAREA           STORE R2
         MVC   1(3,R7),WKAREA+1    MOVE COMMAND ADDR INTO CCW USE
         STH   R1,6(,R7)           STORE BYTE COUNT IN CCW
*
*        MOVE NOT EOS INDICATION TO BEGINNING OF BUFFER
*
RPA024   MVC   0(4,R2),KEOS2       FOR VARIABLE LENGTH RCDS, INSTR IS
*                                  MODIFIED TO PLACE EOS INDICATION
*                                  BEYOND BCC
RPAFIRST B     RPAPRIME            INITIALLY ON AND FOR FIRST BLOCK
*                                  OF SEQUENCE, OTHERWISE SET TO NOP
RPA023   TM    KSW,X'02'           LAST BLOCK OF SEQUENCE ?
         BO    RPA055              YES
RPA025   OI    0(R4),X'80'         TURN PENDING SW ON FOR CURRENT BUFF
         L     R12,IOBDCBPT        ADDR OF DCB IN R12
         TM    0(R5),X'80'
         BZ    RPA044              BRANCH IF PENDING OFF FOR ALT BUFF
         L     R1,IOBECBPT
*
         IERWAIT 1,ECB=(1)         WAIT ON I/O COMPLETION
*
         NI    0(R5),X'7F'         SET PENDING OFF FOR ALT BUFFER
         BAS   R9,RPAERCHK         CHECK FOR ERROR
RPA044   LA    R7,8(,R4)           GET ADDR OF CCW FOR THIS BUFFER
         ST    R7,IOBSTART
*
         IEREXCP  (R6)
*
         ST    R12,KDCBSV          SAVE DCB ADDR FOR ERROR MSG
RPAONE   NOP   RPA060              SET TO BRANCH IF ONLY 1 AREA
*
RPAEOS2  NOP   RPA070              THIS IS THE EOS SWITCH
RPA080   L     R2,RPABPT           LOAD POINTER FOR BLOCK ROUTINE
         LM    R9,R12,WSAVE
RPA050   L     R11,PPIBLK2+4
         B     8(,R11)
*
*
*        ENTRY ON EOS FROM BLOCK
*
RPAEOS   B     RPANEXT             SET TO NOP FOR FXD RCD BAL OR OSC
*
         OI    KSW,X'02'           SET LAST BLOCK OF SEQUENCE SW
RPANEXT  OI    RPAEOS2+1,X'F0'     SET EOS SW IN MAIN LINE
         B     RPA005              GOTO NORMAL ENTRY PT
*
*        FIRST BLOCK OF EACH SEQUENCE SWITCH
*        TAPE UNITS AND MOVE EOS INDICATION INTO BUFFER
*
RPAPRIME BAS   R7,RPAUPDAT         START NEW SEQUENCE ON NEW TAPE UNIT
         NI    RPAFIRST+1,X'0F'    SET FIRST TIME SW TO NOP
         B     RPA023              LST BLK ?
*
RPA055   MVI   2(R2),C'G'          SET LAST BLOCK OF SEQ INDIC IN BUFF
*                                  OVERLAID FOR VAR RCDS TO PLACE
*                                  EOS BEYOND BCC
         NI    KSW,X'FD'           SET SW OFF
         B     RPA025              START ALT
*
*        AFTER EXCP IF THERE IS ONLY ONE OUTPUT AREA
*
RPA060   L     R1,IOBECBPT
*
         IERWAIT 1,ECB=(1)         WAIT ON I/O COMPLETION
*
         NI    0(R4),X'7F'         SET PENDING OFF FOR CURRENT BUFF
         BAS   R9,RPAERCHK         CHECK FOR ERRORS
RPA063   CLI   RPAEOS2+1,X'00'     TEST EOS SWITCH
         BE    RPA080              BRANCH TO EXIT IF OFF
*
*        ENTER HERE IF ONE AREA AND EOS
*
         B     RPA077              GOTO EOS ROUTINE BUT SKIP THE WAIT
*
*        EOV WAS REACHED ON LAST WRITE
*
RPAEOV1  STM   R0,R10,WRSAVE
         L     R11,PPIALG+4
         B     4(0,R11)            EXIT TO ALG TO SWITCH UNITS
*
RPAEOV   LM    R0,R10,WRSAVE       RETURN FROM ALG
         OI    RPAFIRST+1,X'F0'    SET FIRST TIME SW TO BRANCH
         NI    KSW,X'F7'
         CLI   PPILAB07,1          ONLY ONE BUFFER ?
         BE    RPAEOV3             YES, GOTO EOV3
         PPITEST  PPIPOLY          POLY SORT ?
         BO    RPA024              YES, WRITE BFR IN NEW SEQ
*
*        ONE AREA RETURN TO BLOCK ROUTINE FOR FIRST BLOCK IN NEW
*        SEQUENCE
*
RPAEOV3  NI    RPAEOS2+1,X'0F'     SET EOS SWITCH OFF
         B     RPA080              EXIT
*
*        SWITCH THE POINTER IN THE IOB TO THE NEW DCB AFTER EOV
*        AND AT THE BEGINNING OF EACH NEW SEQUENCE
*        MOVE THE EOS INDICATION TO THE BEGINNING OF THE BUFFER
*
RPAUPDAT MVI   1(R2),C'G'          FOR VARIABLE LENGTH RCDS INSTR IS
*                                  MODIFIED TO PLACE EOS INDICATION
*                                  BEYOND BCC
         SR    R9,R9
         IC    R9,PPIDEPHO+3       GET DCB INCREMENT FROM ALG
         L     R10,PPISTDCB        START OF DCB TABLE
         L     R0,0(R9,R10)
         ST    R0,IOBDCBPT
         B     0(,R7)              RETURN
*
*        EOS
*
RPA070   L     R1,IOBECBPT
*
         IERWAIT 1,ECB=(1)         WAIT ON I/O COMPLETION
*
         NI    0(R4),X'7F'         SET PENDING OFF FOR CURRENT BUFFER
         BAS   R9,RPAERCHK         CHECK FOR ERRORS
RPA077   NI    RPAEOS2+1,X'0F'     SET EOS SW TO NOP
         OI    RPAFIRST+1,X'F0'    SET SWITCH TO BRANCH
         LM    R9,R12,WSAVE
         L     R8,PPIALG+4
         TM    KSW,X'08'           EOV & EOS SETTING
         BZ    RPA081              NOT EOV
         NI    KSW,X'F7'           SET EOV SW OFF
         LR    R11,R8
         B     8(,R11)             EXIT TO ALG EOS AND EOV
*
RPA081   LR    R11,R8
         B     16(,R11)            NORMAL EOS EXIT TO ALG
*
*        CHECK FOR PERMANENT I/O ERROR
*
*        IF NO ERROR EXISTS, RETURN TO MAIN LINE CODE. IF
*        ERROR EXISTS, IT CHECKS TO SEE IF ERROR WAS CAUSED BY
*        EOV. IF EOV IS PRESENT, IT RETURNS TO EOV PART OF MAIN
*        LINE CODE. ELSE IT CONSIDERS THE ERROR A PERMANENET I/O
*        ERROR AND PREPARES TO TERMINATE THE JOB.
*        IF EOV IS DETECTED ON A BALANCED FIXED LENGTH SORT, ONE
*        MORE BLOCK IS WRITTEN TO ALLOW THE LAST BLOCK OF
*        SEQUENCE INDICATION TO BE MOVED INTO THE BUFFER AND THEN
*        THE ALGORITHM IS NOTIFIED OF THE EOV.
*
RPAERCHK TM    KSW,X'01'           EOV OCCURED ON PREVIOUS WRITE ?
         BO    RPAERR2             YES
         TM    DCBIFLGS,DCBIFPEC   BOTH BITS ONE - ERROR
         BNOR  R9                  NOT ON, RETURN TO MAINLINE
RPAERROR TM    IOBUSTAT,UE         EOV ?
         BZ    RPAPERM             NOT EOV, PERMANENT ERROR
         NI    DCBIFLGS,255-DCBIFPEC   ERROR CAUSED BY EOV
         PPITEST  PPIBALN          BALANCED SORT ?
         BZ    RPAEOV1             NO, PROCESS EOV
         CLI   RPAEOS2+1,X'00'     YES, AN EOS BLOCK ?
         BNE   RPAERR1             YES,  BRANCH
         OI    KSW,X'02'           SET LAST BLOCK OF SEQ BIT
         CLI   PPILAB07,1          NUMBER OF BUFFERS = 1 ?
         BE    RPAERR3             YES, GOTO ERR3
         OI    RPAEOS2+1,X'F0'     SET EOS SW ON
         OI    KSW,X'09'           SET EXTRA BLOCK AND EOV SWITCHES
         B     RPA055              LAST BLCK
*
RPAERR1  OI    KSW,X'08'           SET EOV AND EOS SW ON
         BR    R9                  RETURN AS NORMAL
*
RPAERR2  TM    DCBIFLGS,DCBIFPEC   CHECK FOR ERROR
         BZ    RPAERR25            NOT ERROR
         TM    IOBUSTAT,UE         EOV ?
         BZ    RPAPERM             NOT EOV, MUST BE PERM ERROR
RPAERR25 NI    DCBIFLGS,255-DCBIFPEC  IGNORE EOV, RESET IFLGS
         MVI   KSW,X'08'           SET ON EOS AND EOV BIT
         B     RPAEOV1             PROC EOV
*
RPAERR3  OI    KSW,X'01'           SET EXTRA BLOCK AFTER EOV SW
         BR    R9                  RETURN
*
RPAPERM  ICM   R0,B'1111',KERREXIT   USER EXIT ADDR ?
         BZ    RPANOEXT            NO, BRANCH
*
*        SET UP FOR EXIT TO USER
*
         LR    R15,R0
         LR    R0,R6               R0 -> IOB ADDR WITH X'10' IN
         ICM   R0,B'1000',KCON     HIGH ORDER BYTE
         LR    R1,R12              SET REG 1 = DCB ADDR
         BASR  R14,R15             EXIT TO USER
         CLI   KERROPT,X'20'       TEST ERROR OPTION
         BE    RPANOEXT            PERMANENT ERROR - TERMINATE JOB
RPANOEXT PPISETON PPIWRITE         SET WRITE ERROR FLAG IN PPI
         L     R15,PPIADSSC
         BAS   R14,16(,R15)        EXIT TO SSC - TERMINATE JOB
*
*        CONSTANTS
*
RPAPT1   DC    A(0)                POINTS TO FIRST BUFFER CCW 8 IN
*                                  GENERATED CORE
RPAPT2   DC    A(0)                POINTS TO SECOND BUFFER CCW 8 IN
*                                  GENERATED CORE
RPAPTIOB DC    A(0)                ADDR OF IOB
RPABPT1  DC    A(0)                FIRST BUFFER FOR BLOCK
RPABPT2  DC    A(0)                SECOND BUFFER POINTER FOR BLOCK
RPABPT   DC    F'0'                BUFFER ADDR TO RETURN TO BLOCK RTN
KEOS     DC    CL4'HGHH'           EOS INDICATOR
KEOS2    DC    CL4'HHHH'           NOT EOS INDICATOR
KDCBSV   DC    A(0)                DCB ADDR SAVED FOR ERROR MSG
KADDRS   DC    A(0)                SECOND OUTPUT BUFFER
K0       DC    A(0)                ZERO
KERREXIT DC    A(0)                ADDRS OF USER EXIT
KCON     DC    X'10'               FOR USER EXIT
KERROPT  DC    C' '                USER ERROR OPTION
KSW      DC    X'00'               EOV SW
*                                  BIT 1 = EOV HAS BEEN DETECTED BUT
*                                          ONE MORE BLOCK WILL BE
*                                          WRITTEN (BAL-FXD ONLY)
*                                  BIT 2 = LAST BLOCK OF SEQ SW
*                                  BIT 3 = NOT USED
*                                  BIT 4 = EOV SW (ONLY SET WHEN
*                                          SIMULT WITH EOS)
*
*        WORK AREAS
*
WKAREA   DC    A(0)                WORK AREA
WSAVE    DC    4F'0'               SAVE AREA
WRSAVE   DC    11F'0'              SAVE AREA
*
./ ADD NAME=IERRPE   0101-20211-20211-1200-00092-00092-00000-RELEASE 00
RPE      TITLE 'IERRPE - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRPE
*
*        MODULE FUNCTION/OPERATION -
*        PHASE2 ROUTINE THAT WILL WRITE EITHER DATA
*        OR DIRECTORY ON THE DISK
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - IERAPE
*
*        MACROS USED BY MODULE -
*        SMPPI    EXCP    WAIT    GETMAIN
*        DELETE   DCB     DCBD
*
*        ENTRY POINTS - ENTRY IERDPW2 - CALLING SEQUENCE -
*                                       L    R11,PPIWRT+4
*                                       B    0(,R11)  WRITE DIRECTORY
*
*                                       L    R11,PPIWRT+4
*                                       B    4(,R11)  END OF SEQUENCE
*
*                                       L    R11,PPIWRT+4
*                                       B    8(,R11)  WRITE DATA
*
*                                       L    R11,PPIWRT+4
*                                       B    12(,R11) EOV WRITE
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIADSSC   PPIBPTRK   PPIENDAR   PPINDSKA
*        PPISTDCB   PPISTIOB   PPIDIRAD
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPIDEPHO   PPILABO1   PPIWKARE
*        PPICNTL
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - DSECT IERIOB - MODEL IOB
*        DSECT IHADCB - MODEL DCB
*        DSECT IERRCA - MODEL PPI
*
*        EXITS - NORMAL -
*        EXIT TO ALGORITHM ON THE FOLLOWING CONDITIONS -
*        END OF SEQUENCE
*        END OF AREA
*        END OF AREA/SEQUENCE
*        WRITE DIRECTORY
*        EXIT TO BLOCK ROUTINE AFTER WRITING DATA
*
*        EXITS - ERROR -
*        TO SORT SYSTEM CONTROL ON ANY WRITE ERROR
*        TO USER ERROR OPTION ROUTINE ON WRITE ERROR
*
*        TABLES/WORK AREAS - CHANNEL COMMAND WORD LIST TO WRITE
*        DIRECTORY
*
*        NOTES -
*        THIS MODULE IS RESTRICTED TO 2311 DISK OPERATIONS ONLY
*
IERRPE   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRPE SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRPEI
*
*        IERIOB
*
         IERIOB
*
*        IERCCWEQ
*
         IERCCWEQ
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         PRINT NOGEN
*
         DCBD  DSORG=(PS),DEVD=(DA)
*
         PRINT GEN
*
         END
./ ADD NAME=IERRPEI  0101-20211-20211-1200-00390-00390-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERRPE SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERRPEI
*
         USING IHADCB,R10
         USING *,R11
         USING IERIOB,R12
         USING IERRCA,R13
*
*        BRANCH TABLE
*
IERDPW2  B     RPEENT4             +00 WRITE DIRECTORY (EOV)
         B     RPEENT2             +04 END OF SEQUENCE
         B     RPEENT1B            +08 NORMAL DATA WRITE
         B     RPEENT3             +12 WRITE DIRECTORY
         B     RPEENT5             +16 DELETE IERRC9
*
RPEENT1B PPITEST  PPIVAR           VARIABLE LENGTH RECORDS ?
         BO    RPEVVR              YES, BRANCH
         MVC   0(4,R2),KEOS3       ERASE FIXED EOS
         B     RPEENT1             GOTO MAIN LINE
*
RPEVVR   MVC   4(4,R2),KEOS3       ERASE VARIABLE EOS
RPEENT1  STM   R0,R15,WRPEREG      SAVE REGS
         L     R12,PPISTIOB        GET IOB POINTER
         L     R12,0(,R12)         SET IOB BASE REG
         ST    R12,RPEIOBSV        TEMPERARLY SAVE IOB ADDR
         LA    R9,8
         SR    R12,R9              SET IOB BASE REG
         TM    RPEDBSW,X'02'       DOUBLE BUFFERING ?
         BZ    RPEENT1A            NO, GOTO SINGLE BUFFERING
RPEPASS  NOP   RPEPASS1            NOP FIRST TIME THROUGH
         SR    R6,R6
         ICM   R6,B'0111',PPILAB04+1  R6 -> BUFF 1
         SR    R6,R9               SUBTRACT 8 FROM BUFF ADDR
         ST    R6,RPEWRKC          SAVE ADJUSTED BUFF ADDR
         NI    RPEWRKC,X'00'
         MVI   RPEPASS+1,X'F0'     TURN BY PASS SWITCH ON
RPEPASS1 TM    RPEBF,X'01'         FIRST WRITE ?
         BO    RPENOWT             YES, BRANCH TO NO WAIT
         LA    R6,RPEENT1A         SET RETURN ADDR
         B     RPESTAY             CALL WAIT, RETURN TO R6
*
RPENOWT  MVI   RPEBF,X'00'         TURN OFF WAIT SWITCH
RPEENT1A SR    R2,R9               CALC BEGINNING BUFFER ADDR
*
*        LOCATE DCB
*
         SR    R6,R6
         IC    R6,PPIDEPHO         GET INCREMENT FROM M FIELD
         L     R10,PPISTDCB        R10 -> DCB TABLE
         L     R10,0(R6,R10)       R10 -> DCB
         ST    R10,IOBDCBPT        STORE DCB ADDR IN IOB
*
*        SETUP FOR EXCP
*        CONVERT TTR -> MBBCCHHR
*
         STM   R14,12,12(R13)      SAVE REGS ACROSS RTN
         LR    R3,R13              SAVE R13
         SR    R0,R0
         ICM   R0,B'1110',PPIDEPHO+5  R0 = TTR0
         L     R1,DCBDEBAD         R1 -> DEB
         LA    R2,DCBFDAD          R2 -> MBBCCHHR RESULT
         L     R15,PPIPCNVT        R15 -> CONVERSION RTN
         BASR  R14,R15             CONVERT TTR -> MBBCCHHR
         LR    R13,R3
         LTR   R15,R15          *  SET CC
         LM    R14,R12,12(R13)  |  RESTORE REGS
         BNZ   RPETERM          V  CONVERSION FAILED, TERMINATE SORT
         MVC   IOBSEEK,DCBFDAD     MOVE SEARCH ADDR TO IOB
         IC    R9,PPIDEPHO+7       GET RECORD NUMBER
         BCTR  R9,0                DECREMENT RECORD NUMBER
         STC   R9,IOBR             STORE IN IOB FOR SEARCH ID EQ
         MVC   0(5,R2),DCBFDAD+3   SET DISK ADDR IN COUNT BUFFER
         LA    R9,2(,R9)           INCR AND SET DEPHO TO NEXT RECORD
         STC   R9,PPIDEPHO+7
         MVI   5(R2),X'00'         SET KL IN COUNT FIELD
         STH   R1,6(,R2)           SET BYTE COUNT IN COUNT FIELD
         MVI   WSWTRK,X'00'        TURN OFF TRACK FULL SWITCH
         CLC   4(1,R2),PPIBPTRK+1  TRACK BE FULL ?
         BL    RPENORML            NO, BRANCH
         MVI   WSWTRK,X'01'        YES, TURN ON FULL TRACK SWITCH
         LA    R5,PPIENDAR         SET POINTER TO FIRST ENDING ADDR
         LH    R6,PPINDSKA         SET COUNTER FOR NUMBER OF AREAS
*
*        LOOP THROUGH ALL SORTWK AREAS FOR MATCH
*
RPEMTRY  CLC   PPIDEPHO(1),0(R5)   COMPARE M, CORRECT END ADDR ?
         BE    RPEFLUSH            YES, BRANCH OUT OF LOOP
         LA    R5,8(,R5)           NO, UP PPIENDAR SEARCH ADDR
         BCT   R6,RPEMTRY          LOOP
RPEFLUSH CLC   PPIDEPHO+5(2),5(R5)  COMPARE TT IN ENDAR, END OF AREA ?
         BNE   RPENORML            NO, CONTINUE THE SORT
         L     R14,PPIRMB+4        YES, ABNORMAL TERMINATION
         USING DIERRMB,R14
         L     R1,IER046           R1 -> MSG TEXT
         MVC   PPIABMNO,3(R1)      MOVE MSG NO INTO ABEND NO
         LM    R0,R1,IER046        IER046A SORT CAPACITY EXCEEDED
         L     R15,PPIADSSC        R15 -> SSC
         BAS   R14,12(,R15)        CALL MSG WRITER
         DROP  R14
*
*        APROX RCD CNT IS PPICOUNT - B
*        WHERE B IS A MAX VALUE, IF CNT TURNS NEGATIVE, CNT IS
*        SET TO B
*        THIS NEGATIVE CONDITION IS MOST LIKELY IF THE BLOCK
*        BEING WRITTEN OUT IS SHORT AND/OR RECORD FORMAT IS
*        VARIABLE
*
         L     R1,PPICOUNT         NO RCD BLOCKED
         LH    R15,PPISRTBL        B - F = NO RCDS/BLOCK
         PPITEST  PPIFIX               V = BYTES/BLOCK
         BO    RORGOM1             BRANCH, FIXED LENGTH RECORDS
         LH    R0,PPIRCDL4         B / MIN RCD LENGTH = MAX NO
         SR    R14,R14
         DR    R14,R0              RECORDS IN BLOCK
RORGOM1  CR    R1,R15              MAKE SURE CNT ISN'T NEGATIVE
         BH    RORGOM2             NOT NEGATIVE, BRANCH
         LR    R1,R15              NEGATIVE, SET CNT TO B
         B     RORGOM3             BYPASS NSI
*
RORGOM2  SR    R1,R15              APROX RCD CNT = PPICOUNT - B
RORGOM3  CVD   R1,PPIWKARE
         USING DIERRMB,R14
         L     R14,PPIRMB+4        ADDR OF IERRMB
         ED    IER066A,PPIWKARE+4  FORMAT WITH LEFT ZERO SUPPRESS
         LM    R0,R1,IER066        IER066A APPROXIMATE RECORD COUNT
         L     R15,PPIADSSC        R15 -> PRINT MSG RTN
         BAS   R14,12(,R15)        SORT SYSTEM CONTROL FOR RUNNING PGM
         L     R15,PPIADSSC
         BAS   R14,16(,R15)        EXIT TO SORT SYSTEM CONTROL
*
         DROP  R14
*
RPENORML LA    R5,IOBSTDRD         R5 -> IOB
         ST    R5,DCBIOBAD
         MVC   IOBSTART,HOLDPCW    SET PRIME CCW ADDR IN IOB
         MVC   WRPEREGC(4),RPEBUF1 PASS ADDR TO BLOCK ROUTINE
         TM    RPEDBSW,X'02'       DOUBLE BUFFERS ?
         BO    RPEDBL              YES, BRANCH TO DOUBLE ROUTINE
         BAS   R14,RPESUBRT        NO, GO SET UP CCWS
*
         IEREXCP  (R5)             WRITE DISK
*
         BAS   R6,RPESTAY          CALL WAIT ROUTINE
RPEUPRCD TM    WSWTRK,X'01'        TRACK FULL ?
         BO    RPEFULTK            YES, BRANCH
RPESEQTT TM    RPEEOSW,X'01'       EOS ?
         BO    RPEENDSQ            YES, GOTO EOS RETURN
RPEENT4  LM    R0,R15,WRPEREG      RESTORE REGS
         L     R11,PPIBLK2+4       SET RETURN REG
         B     8(,R11)             GOTO BLOCK
*
RPEDBL   C     R2,RPEWRKC          EQUAL COMPARE ?
         BE    RPE1                YES, BRANCH
         MVC   IOBSTART,IERALTCW   SET CCW PTR IN IOB
         LA    R14,RPEDBLRT        SET RETURN REG
         B     RPESUBRT            CALL SET UP CCW WITH RETURN IN R14
*
RPE1     MVC   WRPEREGC(4),RPEBUF2 PASS ADDR TO BLOCK ROUTINE
         BAS   R14,RPESUBRT        GO SET UP CCWS
*
RPEDBLRT IEREXCP  (R5)             WRITE DISK
*
         B     RPEUPRCD            GOTO MAIN LINE
*
RPESTAY  L     R10,IOBDCBPT        SET DCB BASE REG
*
         IERWAIT  1,ECB=(R12)      WAIT ON I/O COMPLETION
*
         TM    DCBIFLGS,DCBIFEC    IOS ERROR ?
         BO    RPETERM             YES, GO TERMINATE JOB
         LM    R0,R2,WRPEREG       RESTORE REGS
         BR    R6                  GOTO MAIN LINE
*
*        SET CCW UP FOR WRITING EITHER SINGLE OR DOUBLE BUFFERS
*
RPESUBRT L     R8,IOBSTART         CCW POINTER
         LA    R1,8(,R1)           UP RECORD BYTE COUNT
         STH   R1,22(R8)           STOW IN CCW
         BR    R14                 GOTO MAIN LINE
*
RPEENDSQ MVI   RPEEOSW,X'00'       TURN OFF EOS SWITCH
         MVI   RPEBF,X'01'         TURN ON FIRST TIME SWITCH
         TM    RPEDBSW,X'02'       TWO BUFFERS ?
         BZ    RPEALGRT            NO, BRANCH
         BAS   R6,RPESTAY          CALL WAIT ROUTINE
RPEALGRT LM    R0,R15,WRPEREG      RESTORE REGS
         L     R11,PPIALG+4        SET RETURN REGS
         B     16(,R11)            GOTO ALGORITHM
*
*        TRACK FULL RTN
*
RPEFULTK MVI   PPIDEPHO+7,X'01'    SET RECORD NO TO FIRST ON TRACK
         MVI   WSWTRK,X'00'        TURN OFF TRACK FULL SWITCH
         SR    R6,R6
         ICM   R6,B'0011',PPIDEPHO+5  R6 = TT
         LA    R6,1(,R6)           INCR TT
         STCM  R6,B'0011',PPIDEPHO+5  STORE UPDATED TT
         B     RPESEQTT            GOTO END OF SEQ TEST
*
*        WRITE ERROR. TEST EXIT 28
*        EXECUTE USER MOD, AND TERMINATE THE JOB
*
RPETERM  IC    R3,DCBFDAD+7        R3 = RECORD NUMBER
         BCTR  R3,0                DECR
         STC   R3,DCBFDAD+7        STORE UPDATED RECORD NUMBER
         ICM   R15,B'1111',RPEUSERX   GET USER MOD ADDR
         BZ    RPEOFF              NO EXIT SPECIFIED, TERMINATE
         ST    R5,PPIWKARE         SET IOB ADDR FOR USER
         MVI   PPIWKARE,X'10'
         L     R0,PPIWKARE
         LR    R1,R10              R1 -> DCB FOR USER EXIT
         BASR  R14,R15             CALL USER EXIT
RPEOFF   ST    R4,RPESVEME         SAVE ORIGINAL CONTENTS
         L     R6,RPEIOBSV         RESTORE IOB ADDR
         PPISETON PPIWRITE         TURN ON WRITE ERROR FLAG
         L     R15,PPIADSSC        R15 -> SSC
         BAS   R14,16(,R15)        EXIT TO SSC
*
*        END OF SEQUENCE
*
RPEENT2  MVI   RPEEOSW,X'01'       TURN ON EOS SWITCH
         PPITEST  PPIVAR           VARIABLE LENGTH RECORDS ?
         BO    RPEVAR              YES, INDICATE EOS (VARIABLE)
         MVC   0(4,R2),KEOS4       INDICATE EOS (FIXED)
         B     RPEENT1             GOTO MAIN LINE
*
RPEVAR   MVC   4(4,R2),KEOS4       INDICATE EOS (VARIABLE)
         B     RPEENT1             GOTO MAIN LINE
*
*        WRITE THE DIRECTORY
*
RPEENT3  STM   R0,R15,WRPEREG      SAVE REGS
         LA    R6,PPIWKARE         SET DIR READIN ADDR
         L     R12,PPISTIOB
         L     R12,0(,R12)
         LA    R9,8                SUB 8 FROM IOB ADDR TO SET IERIOB
         SR    R12,R9              R12 -> IERIOB
*
*        LOCATE DCB
*
         SR    R7,R7
         IC    R7,PPIDIRAD         GET M INCREMENT
         L     R10,PPISTDCB
         L     R10,0(R7,R10)       R10 -> DCB
         ST    R10,IOBDCBPT        STORE DCB PTR IN IOB
*
*        SETUP FOR EXCP
*
         STM   R14,R12,12(R13)
         LR    R3,R13
         SR    R0,R0
         ICM   R0,B'1110',PPIDIRAD+5  R0 = TTR0
         L     R1,DCBDEBAD         R1 -> DEB
         LA    R2,IOBSEEK          R2 -> MBBCCHHR RESULT
         L     R15,PPIPCNVT        R15 -> CONVERSION RTN
         BASR  R14,R15             CONVERT TTR -> MBBCCHHR
         LR    R13,R3
         LTR   R15,R15          *  SET CC
         LM    R14,R12,12(R13)  |  RESTORE REGS
         BNZ   RPETERM          V  CONVERSION FAILED, TERMINATE SORT
         IC    R9,IOBR             GET RECORD NUMBER
         BCTR  R9,0                DECREMENT RCD NUMBER
         STC   R9,IOBR             PUT IN IOB FOR SEARCH ID EQ
         LA    R9,1(,R9)           RESTORE RECORD COUNT
*
*        SHUFFLE PPIWKARE DOWN 8 BYTES TO ALLOW FOR COUNT FIELD
*
         MVC   PPILAB01(64),PPIWKARE
         MVC   PPIWKARE+8(64),PPILAB01  REPOSITION DIRECTORY
         MVC   PPIWKARE(5),IOBSEEK+3    BUILD CCHHR COUNT FIELD
         STC   R9,PPIWKARE+4            SET CORRECT R IN COUNT FIELD
         MVC   PPIWKARE+5(3),KDKBUFF    BUILD BUFFER INFO
         LA    R7,RPESKID
         ST    R7,IOBSTART         SET CCW PTR IN IOB
         LA    R5,IOBSTDRD         R5 -> IOB
         ST    R5,DCBIOBAD         SAVE IN DCB
*
         IEREXCP  (R5)
*
         BAS   R6,RPESTAY          CALL WAIT RTN
         LM    R0,R15,WRPEREG      RESTORE REGS
         L     R11,PPIALG+4        SET RETURN REG
         BR    R14                 RETURN TO ALG
*
RPEENT5  DELETE EP=IERRC9          FREE CORE BY DELETING IERRC9
*
         LTR   R15,R15             SUCCESSFULL ?
         BZ    RPEBUFCK            YES, BRANCH
         L     R15,PPIADSSC        ERROR ON DELETE, PRINT MESSAGE
         BAS   R14,28(,R15)
         L     R15,PPIADSSC
         BAS   R14,16(,R15)        EXIT TO SORT SYSTEM CONTROL
*
RPETOALG L     R11,PPIALG+4
         BR    R11                 RETURN TO ALGORITHM
*
RPEBUFCK TM    PPILAB04,X'80'      GETMAIN ANOTHER BUFFER ?
         BO    RPETOALG            NO, BRANCH
         LH    R15,PPILAB07+2      GET ANOTHER BUFFER
         LA    R15,8(,R15)         CALC L'BUFFER
*
         GETMAIN EC,LV=(R15),A=RPEADDR
*
         LTR   R15,R15             SUCCESSFULL GETMAIN ?
         BNZ   RPETOALG            NO, GOTO ALGORITHM
         MVI   PPILAB07,2          YES, CHANGE NO OF BUFFERS TO TWO
         MVI   RPEDBSW,X'02'       SET DOUBLE SWITCH
         ST    R2,RPEREGSV         SAVE CONTENTS OF R2
         ST    R12,RPEREGSE        SAVE CONTENTS OF R12
         L     R2,RPEADDR
         LA    R2,8(,R2)
         ST    R2,PPILAB05         STORE NEW ADDR OF BUFFER 2
         PPITEST  PPIVAR           VARIABLE LENGTH RECORDS ?
         BO    RPEVVV              YES, BRANCH
         LA    R2,4(,R2)           CALC FIXED BUFFER ADDR
         B     RPEFIX
*
RPEVVV   LA    R2,8(,R2)           CALC VARIABLE BUF ADDR
RPEFIX   ST    R2,RPEBUF2
         L     R2,PPIGETSZ
RPECOMPR CLI   0(R2),X'80'         FIRST BYTE 80 ?
         BE    RPEHIT              YES, BRANCH
         LA    R2,4(,R2)           INCREMENT BY 4
         B     RPECOMPR            BRANCH BACK TO COMPARE
*
RPEHIT   LH    R15,PPILAB07+2
         LA    R15,8(,R15)         CALC L'BUFFER
         ST    R15,4(,R2)          STORE L'BUFFER
         MVI   4(R2),X'80'         SET LIST TERMINATOR
         MVI   0(R2),X'00'         CLEAR PREV TABLE INDICATER
         S     R2,PPIGETSZ         SUBTRACT STARTING ADDR FOR DIFF
         A     R2,PPIGETMN         ADD ADDR OF TABLE TO DIFF
         MVC   4(4,R2),RPEADDR     MOVE ADDR OF BUFF INTO ADDR TABLE
         L     R12,PPISTIOB
         L     R12,0(,R12)
         LA    R9,8
         SR    R12,R9              SET IERIOB ADDR
         L     R2,IERALTCW
         MVC   17(3,R2),RPEADDR+1  MOVE ADDR INTO ALT CCW
         L     R2,RPEREGSV         RESTORE REG
         L     R12,RPEREGSE        RESTORE REG
         B     RPETOALG            GOTO ALGORITHM
*
*        CHANNEL PROGRAM LIST
*
RPEIOBSV DC    A(0)                IOB ADDR
RPESVEME DC    F'0'                EOS INDICATOR TYPE
RPEADDR  DC    A(0)                ADDR OF ADDR LIST
RPEREGSV DC    A(0)                BUFFER ADDR
RPEREGSE DC    A(0)                EQUAL/EXTRACT ADDR
*
*        CHANNEL PROGRAM
*
RPESKID  CCW   SEARIDEQ,0,CC+SLI,5          SEARCH ID
         CCW   TIC,RPESKID,CC+SLI,0         TIC
RPEBUFAD CCW   WRITECKD,0,SLI,72            WRITECKD
*
*        CONSTANTS AND WORK AREAS
*
RPEWRKC  DC    F'0'                ADJUSTED BUFFER ADDR
*
HOLDPCW  DC    F'0'                PRIME CCW ADDR
HOLDCC   DC    F'0'                TEMP STORAGE
WRPEREG  DC    2F'0'            *  REGISTER SAVE AREA
WRPEREGC DC    14F'0'           V  REGISTER SAVE AREA
RPEEOSW  DC    X'00'               END OF SEQUENCE SWITCH
RPEBF    DC    X'01'               WAIT AND FIRST TIME SWITCH
RPEDBSW  DC    X'00'               DOUBLE BUFFER INDICATOR
RPEBUF1  DC    A(0)                BUFFER ADDR
RPEBUF2  DC    A(0)                BUFFER ADDR
RPEUSERX DC    A(0)                USER MOD ADDR, SET BY IERAPE
KEOS3    DC    CL4'HHHH'           NOT EOS INDICATION
KEOS4    DC    CL4'HGHH'           EOS INDICATION
WSWEOA   DC    X'00'               END OF AREA SWITCH
WSWTRK   DC    X'00'               TRACK FULL SWITCH
KDKBUFF  DC    X'0000'             BUFFER CONSTANT
         DC    X'40'               WORD ALIGNMENT
EPATTERN DC    XL8'4020202020202020'  ZERO SUPRESS ED PATTERN
*
DIERRMB  DSECT
*
         COPY  RMBMAIN
*
./ ADD NAME=IERRPF   0101-20211-20211-1200-00223-00223-00000-RELEASE 00
RPF      TITLE 'IERRPF - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRPF
*
*        MODULE FUNCTION/OPERATION -
*        THIS MODULE CHECKS RECORD COUNTS,
*        CLOSE ALL OUTPUT FILES,
*        DO END OF PHASE HOUSE KEEPING FOR THE INTERMEDIATE MERGE
*
*        USED AS A DSECT IN - N/A
*
*        MACROS USED -
*        SMPPI
*        CLOSE
*
*        ENTRY POINTS - ENTRY FROM IERRCV - CALLING SEQUENCE -
*                                           LOAD   EP=IERRPF
*                                                  (,DCB=SORTLIB)
*                                           L      R11,R0
*                                           B      0(R1,R11)
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPICNTL   PPIFILSZ   PPISTDCB   PPINDSKA   PPIRMB
*        PPIWKARE  PPIRCDCT   PPIBDSVA   PPIADSSC   PPICOUNT
*        PPIX27
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPIWKARE
*        PPICNTL
*
*        EXTERNAL ROUTINES - IERRMB - REFERENCE TO MSG MODULE
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL -
*        TO SORT SYSTEM CONTROL - CALLING SEQUENCE -
*                                 L     R15,PPIADSSC
*                                 BAL   R14,8(,R15)
*
*        EXITS - ERROR -
*        TO SSC ON INCORRECT RECORD COUNT - CALLING SEQUENCE -
*                                           L     R15,PPIADSSC
*                                           BAL   R14,16(,R15)
*
*        TABLES/WORK AREAS - N/A
*
*        NOTES -
*        USE RESTRICTED TO PHASE 2 END OF FILE ROUTINE
*
IERRPF   CSECT
*
         USING *,R11               PROGRAM BASE REG
         USING DIERRMB,R12         MESSAGE MODULE BASE REG
         USING IERRCA,R13          PPI BASE REG
*
*        INITIAL SETTING FOR RETURN TO SORT SYS CONTROL IS TO
*        PHASE 3. IF ENTERED ON A DISPLACEMENT OF ZERO THE
*        INSTRUCTION RPFRETRN IS MODIFIED TO RETURN TO PHASE 2
*
         MVI   RPFRETRN+3,X'04'    SET RETURN TO PH2
         ST    R12,KRPFWORK        SAVE R12
         L     R12,PPIRMB+4        SET MSG BASE REG
*
*        THE FOLLOWING SECTION OF CODE SAVES THE BLOCK COUNTS IF
*        IT IS A TAPE SORT. THE BLOCK COUNTS WILL BE RESTORED AT
*        THE START OF PHASE THREE
*
         PPITEST  PPITAPE          TAPE SORT ?
         BNO   RPFBAL              NO, DISK SORT
         SR    R1,R1               ZERO REGISTER
         IC    R1,PPIBDSVA         LOAD NUMBER OF WORK UNITS
         LA    R2,PPITPTBL         LOAD STARTING ADDR OF TAPE TABLE
RPF100   TM    0(R2),X'40'         OPEN BIT ON FOR THIS UNIT ?
         BNO   RPF300              NO - BRANCH TO INCREMENT TAPE ADDR
         PPITEST  PPIBALN          BALANCED SORT ?
         BZ    RPF200              NO, BRANCH
         TM    0(R2),X'80'         YES, INPUT BIT ON ?
         BO    RPF300              YES, DON'T SAVE BLOCK COUNT
RPF200   SR    R3,R3               ZERO REGISTER
         IC    R3,1(,R2)           LOAD TAPE INCREMENT
         L     R4,PPISTDCB         LOAD STARTING ADDR OF DCB TABLE
         LA    R5,PPIENDAR         LOAD STARTING ADDR OF SAVE AREA
         AR    R4,R3               GET DCB POINTER
         L     R4,0(,R4)           GET STARTING ADDR OF DCB
         AR    R5,R3               GET ADDR TO SAVE BLK CNT OF UNIT
         MVC   0(4,R5),12(R4)      MOVE BLK CNT FROM DCB TO SAVE AREA
RPF300   LA    R2,2(,R2)           INCREMENT TAPE TABLE ADDR
         BCT   R1,RPF100           ALL UNITS TESTED ? NO LOOP AGAIN
RPFBAL   PPITEST  PPIBALN          BALANCED SORT ?
         BZ    RPFENT2             NO, BRANCH
         LM    R6,R8,PPICOUNT      GET RECORD COUNTS FROM PPI
         STM   R9,R10,PPIWKARE     SAVE REGS
         L     R10,PPIFILSZ        GET RECORD COUNT
         LR    R9,R6               SORT COUNT
         AR    R9,R7               ADD DELETE COUNT
         SR    R9,R8               SUBTRACT INSERT COUNT
         PPITEST  PPIFSZE          TEST FILE SIZE ESTIMATED SWITCH
         BO    RPFENT2             ON, DO NOT CROSSFOOT
         CR    R9,R10              CROSSFOOT RECORD COUNT
         BNE   RPFENT4             BRANCH TO MESSAGE PRINT
*
*        LOOP TO CLOSE THE OUTPUT FILES
*
         ST    R6,PPIRCDCT         STOW RECORDS TO BE SORTED IN PPI
RPFENT2  L     R5,PPISTDCB         R5 -> DCB TABLE
         PPISETOF PPIFSZE          TURN OFF FILE SIZE ESTIMATED SWITCH
         SR    R6,R6
         ST    R6,PPICOUNT         CLEAR COUNT AREA
         PPITEST  PPITAPE          TAPE SORT ?
         BZ    RPFDS               NO, BRANCH
         IC    R6,PPIBDSVA         TOTAL NO OF WORK UNITS
RPFLOOP  LA    R5,4(,R5)           INCR UP TO NEXT DCB ENTRY
         L     R2,0(,R5)           SET DCB ADDR IN CLOSE REG
         LTR   R2,R2               CHECK FOR NULL ENTRY
         BNP   RPFUPREG            YES, FETCH NEXT ENTRY
         PPITEST  PPITAPE          TAPE SORT ?
         BZ    RPFINDCT            NO, BRANCH
         USING IHADCB,R2
         OI    DCBOFLGS,DCBOFLWR   SET CLOSE/LEAVE BIT IN DCB
         PPITEST  PPICLOSR         CLOSE WITH REWIND ?
         BO    RPFDASD             YES, BRANCH
*
         CLOSE ((R2),LEAVE)        CLOSE A FILE
*
         LTR   R15,R15             CLOSE SUCCESSFULL ?
         BZ    RPFUPR01            YES, BRANCH
*
         DC    H'0'                CLOSE FAILED, FORCE AN 0C1 ABEND
*                                  FOR DIAGNOSTIC PURPOSES
RPFUPR01 MVI   0(R5),X'80'         INDICATE CLOSED FILE
RPFUPREG BCT   R6,RPFLOOP          GOTO CLOSE NEXT FILE
*
*        END OF CLOSE LOOP
*
         PPITEST  PPIME27          USER MOD E27 ?
         BO    RPFMODEX            GOTO USER ROUTINE
RPFENT3  TM    WABSW2,X'01'        SHOULD IT TERMINATE ?
         BO    RPFABT              YES, BRANCH
         TM    RPFRETRN+3,X'08'    END OF PHASE ?
         BO    RPFEOP              YES, BRANCH
RPFEND   LM    R9,R10,PPIWKARE     RESTORE R9-R10
         L     R12,KRPFWORK        RESTORE R12
         L     R15,PPIADSSC        R15 -> SSC
RPFRETRN BAS   R14,8(,R15)         EXIT TO SORT SYS CONTROL
*
*        GENERATE  INCORRECT COUNT MESSAGE IER047
*
RPFENT4  LM    R0,R1,IER047        IER047A RECORD COUNT ERROR
         ST    R6,PPIFILSZ
         PPITEST  PPIREADE         READ ERROR OCCUR ?
         BZ    RPAB001             NO, SET TERMINATE SW
         PPITEST  PPIACCPT
         BO    RPAB002             GOTO CONVERT INPUT COUNT
RPAB001  MVI   WABSW2,X'01'        TURN ON TERMINATE SWITCH
RPAB002  CVD   R10,PPIWKARE        CONVERT INPUT COUNT
         ED    IER047I,PPIWKARE+4  FORMAT VALUE WITH LEFT ZERO SUPP
         CVD   R6,PPIWKARE         CONVERT OUTPUT COUNT
         ED    IER047O,PPIWKARE+4  FORMAT VALUE WITH LEFT ZERO SUPP
         L     R1,IER047           R1 -> MSG TEXT
         MVC   PPIABMNO,3(R1)      MOVE MSG NO INTO ABEND NO
         L     R15,PPIADSSC        R15 -> SSC
         BAS   14,12(,R15)         CALL MSG WRITER
         B     RPFENT2             GOTO CLOSE FILES
*
RPFABT   L     R15,PPIADSSC        SET LINK TO SSC
         BAS   R14,16(,R15)        EXIT TO SSC, TERMINATE
*
RPFEOP   LM    R0,R1,IER050        IER050I END OF MERGE PHASE
         L     R15,PPIADSSC        R15 -> SSC
         BAS   14,12(,R15)         CALL PRINT MESSAGE
         B     RPFEND              GOTO RESTORE R9-R10
*
RPFINDCT XC    DCBDSORG,DCBDSORG   CLEAR DSORG
         NI    DCBOFLGS,255-DCBOFLWR   PREVENT EOV WRITING AN EOF
*                                      MARKER AS NEITHER DCBFDAD
*                                      OR DCBTRBAL ARE MAINTAINED
*                                      CLOSE WITH REREAD IRRELEVANT
*                                      FOR DASD
*
RPFDASD  CLOSE ((R2),REREAD)       CLOSE A FILE
*
         LTR   R15,R15             CLOSE SUCCESSFULL ?
         BZ    RPFDASD1            YES, BRANCH
*
         DC    H'0'                CLOSE FAILED, FORCE AN 0C1 ABEND
*                                  FOR DIAGNOSTIC PURPOSES
RPFDASD1 MVI   0(R5),X'80'         INDICATE CLOSED FILE
         B     RPFUPREG            GOTO CLOSE NEXT FILE
*
RPFDS    LH    R6,PPINDSKA         GET NUMBER OF AREAS
         B     RPFLOOP             GOTO MAIN LINE
*
RPFMODEX L     R15,PPIX27+4        SET TO USER ADDR
         BASR  R14,R15             BRANCH AND LINK TO USER
         B     RPFENT3             GOTO EOP MSG ROUTINE
*
KRPFWORK DC    F'0'                USED TO SAVE R12
WABSW2   DC    X'00'               TERMINATE SWITCH
*
*        MODULE NAME - IERRMB
*
*        THIS MODULE CONTAINS ALL OF THE MESSAGES THAT ARE
*        REQUIRED FOR PHASE 2 RUNNING PROGRAM
*
DIERRMB  DSECT
*
         COPY RMBMAIN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         PRINT NOGEN
*
         DCBD  DSORG=(PS),DEVD=(TA,DA)
*
         PRINT GEN
*
         END
./ ADD NAME=IERRPG   0101-20211-20211-1200-00325-00325-00000-RELEASE 00
RPG      TITLE 'IERRPG - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRPG
*
*        MODULE FUNCTION/OPERATION -
*        END OF JOB ROUTINE FOR FINAL MERGE OR MERGE ONLY. THIS
*        MODULE WILL ISSUE A GETMAIN REQUEST FOR A SECOND OUTPUT
*        BUFFER IF B & G CALCULATED FOR TWO AND STORAGE LAYOUT
*        ROUTINE ONLY ALLOCATED ONE (MODULE WILL CONTINUE
*        NORMALLY IF REQUEST IS DENIED). IF REQUEST IS GRANTED,
*        MODULE WILL UPDATE PPILAB05 AND OUTPUT DCB AND IOB.
*        RECORD COUNTS WILL BE CHECKED, THE EOJ MESSAGE IS
*        WRITTEN, AND THE OUTPUT FILES WILL BE CLOSED BY THIS
*        MODULE. THIS MODULE ALSO DELETES IERRC9 IF ENTERED ON A
*        DISPLACEMENT OF 8
*
*        USED AS A DSECT IN - N/A
*
*        MACROS USED -
*        SMPPI
*        DELETE
*        CLOSE
*        BUILDS
*        GETMAIN
*
*        ENTRY POINTS - ENTRY IERRPG
*                       ENTRY FROM BLOCK OR RECORD AND DEBLK A/P
*                       CALLING SEQUENCE -
*                       L  R11,PPIWRT+4 (E35 INACTIVE)
*                       BR R11
*
*                     - ENTRY IERRPG+4 - DUMMY ENTRY
*
*                     - ENTRY IERRPG+8
*                       ENTRY FROM IERRC9
*                       CALLING SEQUENCE -
*                       L  R11,PPIWRT+4
*                       B  8,(,R11)
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIADSSC   PPICOUNT   PPILAB06   PPISTDCB
*        PPIATP3E   PPIFILSZ   PPILAB07   PPIRCDCT
*        PPICNTL
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED - PPIWKARE
*
*        EXTERNAL ROUTINES -
*        IERRMC - REFERENCE TO MESSAGE PRINT MODULE
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL - TO SSC - L   R15,PPIADSSC
*                                  BAL 14,0(,R15)
*
*                       - TO NETWORD - L   R11,PPINET+4
*                                      BR  R11
*
*                       - TO BLOCK - L   R11,PPIBLK+4
*                                    BR  R11
*
*        EXITS - ERROR - TO IERRCV IF OPEN ERROR, DELETE
*                        ERROR, OR RECORD COUNT OFF
*                        CALLING SEQUENCE -
*                        L   R15,PPIADSSC
*                        B   16(0,R15)
*
*        TABLES/WORK AREAS -
*        RPGLIST - OUTPUT BUFFER ADDR FOR BUILDS
*        WREGSV  - HOLD AREA FOR REGS 14, 15 ON A DELETE
*
*        NOTES -
*        THIS MODULE CONTAINS USER MODIFICATION EXIT E37
*
IERRPG   CSECT
*
         USING *,R11               BASE REG 11
         USING IERRCA,R13          SET BASE PPI
         USING DIERRMC,R12
         B     RPGNORM             +00 ENTRY FOR NORMAL EOJ
         B     *                   +04 DUMMY ENTRY
*
*        ENTRY FROM IERRC9
*
RPGDISP8 STM   R14,R15,WREGSV      +08 SAVE R14 - R15 BEFORE DELETE
*
         DELETE  EP=IERRC9         DELETE RC9
*
         B     RPG001(R15)         BRANCH ON RETURN CODE FROM DELETE
RPG001   B     RPG002              +00 ZERO RETURN CODE
         L     R15,PPIADSSC        +04 DELETE FAILED
         BAS   R14,28(,R15)        ERROR MESSAGE
         B     RPGABT              BRANCH TO TERMINATE EXIT
*
RPG002   LM    R14,R15,WREGSV      RESTORE REGS
         ICM   R2,B'1111',PPIATP3E  SORT ATTACHED ?
         BNZ   RPGRTRN             YES, GO CHECK FOR ZERO FILE
*
*        CONDITIONAL GETMAIN REQUEST FOR OPTIONAL PHASE 3
*        SECOND OUTPUT BUFFER
*
RPGOPEN  TM    PPILAB04,X'80'      OUT BUFFERS ALL GOTTEN BY API ?
         BO    RPGBUILD            YES, BYPASS GETMAIN
*
*        TRY FOR SECOND BUFFER
*
         LH    R4,PPILAB07+2       L'GETMAIN REQUEST
         LA    R0,PPILAB05
*
         GETMAIN EC,LV=(R4),A=(0)
*
         B     RPGCORE(R15)        TEST CONDITIONAL GETMAIN RETURN CODE
RPGCORE  B     RPGCOREG            +00 STORAGE AVAILABLE
         B     RPGBUILD            +04 STORAGE NOT AVAILABLE
*
RPGCOREG MVI   PPILAB07,X'02'      SET BUFFER COUNT TO TWO
         L     R15,PPIGETSZ
RPGCMP   CLI   0(R15),X'80'        TERMINATING ENTRY IN PPIGETSZ ?
         BE    RPGHIT              YES, BRANCH
         LA    R15,4(,R15)         NO, INCR PPIGETSZ PTR
         B     RPGCMP              LOOP TO PROCESS NEXT ENTRY
*
RPGHIT   LH    R0,PPILAB07+2       GET L'OUTPUT BUFFER
         ST    R0,4(,R15)          STORE L'BUFFER IN PPIGETSZ ENTRY
         MVI   4(R15),X'80'        MARK AS TERMINAL ENTRY
         MVI   0(R15),X'00'        REMOVE PREV TERMINATION FLAG
         S     R15,PPIGETSZ        USE DISPLACEMENT TO PLACE
         A     R15,PPIGETMN        BUFFER ADDR IN PPIGETMN
         MVC   4(4,R15),PPILAB05
RPGBUILD L     R5,PPISTDCB         R5 -> DCB TABLE
         L     R2,0(,R5)           R2 -> OUTPUT DCB
         LH    R0,PPILAB07+2       GET L'OUTPUT BUFFER
         ICM   R0,B'0100',PPILAB07     GET NUMBER OF BUFFERS
         MVC   RPGLIST(4),PPILAB06     ADDR OF OUTPUT BUFFER ONE
         MVC   RPGLIST+4(4),PPILAB05   ADDR OF OUTPUT BUFFER TWO
         LA    R1,RPGLIST              PASS POINTER TO BUILDS
*
         BUILDS (1),(0)            BUILD THE OUTPUT BUFFERS
*
         OPEN  ((R2),OUTPUT)       OPEN THE OUTPUT DATA SET
*
         LTR   R15,R15             OPEN ERROR ?
         BNZ   RPOPNERR            ERROR, BRANCH TO RCV LINK RTN
         PPITEST  PPIMERGO         MERGE ONLY ?
         BO    RPGEND              YES, BRANCH TO MERGE NETWORK
*
*        EXIT TO CALLER
*
RPGRTRN  ICM   R2,B'1111',PPIRCDCT   ZERO FILE ?
         BNZ   RPGEND              NO, BRANCH
         L     R11,PPIBLK+4        YES, BLOCK ROUTINE
         BR    R11
*
RPGEND   L     R11,PPINET+4        NO, MERGE NETWORK
         BR    R11
*
*        GENERATE OPEN ERROR MSG IER063
*
RPOPNERR L     R12,PPIRMC+4        SET MESSAGE BASE REGISTER
         USING IHADCB,R2
         MVC   IER063A,DCBDDNAM    MOVE DDNAME INTO ERROR MSG
         DROP  R2
         LM    R0,R1,IER063        IER063A OPEN ERROR
         L     R15,PPIADSSC        R15 -> SSC
         BAS   R14,12(,R15)        CALL MSG WRITER
         LR    R1,R0
         MVC   PPIABMNO,3(R1)      MOVE MSG NUMBER INTO ABEND CODE
         B     RPGABT              BRANCH TO TERMINATE EXIT
*
*        NORMAL EOJ ENTRY
*
RPGNORM  L     R10,PPIFILSZ        GET RECORD COUNT
         ST    R12,SAVER12         SAVE R12
         L     R12,PPIRMC+4        SET MSG BASE REGISTER
         LM    R6,R8,PPICOUNT      LOAD RECORD COUNTS
         LR    R9,R6               CALC TOTAL ROUTINE
         AR    R9,R7               COUNT + DELETE-
         SR    R9,R8               INSERT = TOTAL
         PPITEST  PPIMERGO         MERGE ONLY ?
         BO    RPGMERGE            YES, GOTO MERGE ONLY RTN
RPGCOMP  CR    R9,R10              COUNT CORRECT ?
         BNE   RPGENT2             NO, BRANCH
*
*        GENERATE SORT STATISTICS MESSAGES
*
*        IER054 WILL BE WRITTEN AFTER THE DATA SETS ARE CLOSED
*
RPGENT3  CVD   R10,PPIWKARE        CONVERT FILE SIZE TO DECIMAL
         MVC   IER054I,EPATTERN    MOVE IN EDIT PATTERN
         ED    IER054I,PPIWKARE+4  FORMAT DATA
         CVD   R6,PPIWKARE         CONVERT RCDS OUT TO DECIMAL
         MVC   IER054O,EPATTERN    MOVE IN EDIT PATTERN
         ED    IER054O,PPIWKARE+4  FORMAT DATA
         LTR   R8,R8               INSERTS ?
         BZ    RPGDELT             NO, BRANCH
         CVD   R8,PPIWKARE
         MVC   IER055I,EPATTERN    MOVE IN EDIT PATTERN
         ED    IER055I,PPIWKARE+4  FORMAT NO OF INSERTS
         B     RPGTDEL             GOTO CONVERT DELETES
*
RPGDELT  LTR   R7,R7               DELETES ?
         BZ    RPGENT1             NO, BRANCH
RPGTDEL  CVD   R7,PPIWKARE         CONVERT DELETES
         MVC   IER055D,EPATTERN    MOVE IN EDIT PATTERN
         ED    IER055D,PPIWKARE+4  FORMAT NO OF DELETES
         LM    R0,R1,IER055        IER055I RECORDS INSERTED
         L     R15,PPIADSSC
         BAS   14,12(,R15)         CALL PRINT MSG RTN
*
*        CLOSE OPEN DCBS
*
RPGENT1  LH    R5,PPINDSKA         NUMBER TO DISK WORK AREAS
         LA    R5,1(,R5)           INCR TO INCLUDE SORTOUT DCB
         L     R2,PPISTDCB         R2 -> DCB TABLE
         ICM   R1,B'1111',PPIATP3E  SORT ATTACHED ?
         BNZ   RPNXTDCB            YES, BRANCH TO BYPASS SORTOUT CLOSE
RPGENT1A TM    0(R2),X'80'         DCB OPEN ?
         BO    RPNXTDCB            NO, TRY NEXT ONE IN TABLE
         L     R15,0(,R2)          R15 -> DCB ADDR
         USING IHADCB,R15
         TM    DCBMACR,DCBMRECP    SORTWK EXCP DATA SET ?
         BZ    RPGENT1C            NO, MUST BE QSAM
         NI    DCBOFLGS,255-DCBOFLWR  BYPASS WRITING FILE MARK AS
*                                     DCBFDAD AND DCBTRBAL NOT MAINTED
*
RPGENT1C CLOSE ((R15))             CLOSE SORTOUT AND SORTWK01, ETC
*
         DROP  R15
*
         LTR   R15,R15             CLOSE SUCCESSFULL?
         BZ    RPGENT1B            YES, BRANCH
*
         DC    H'0'                CLOSE FAILED, FORCE AN 0C1 ABEND
*                                  FOR DIAGNOSTIC PURPOSES
RPGENT1B MVI   0(R2),X'80'         INDICATE DCB CLOSED
         PPITEST  PPITAPE          TAPE SORT ?
         BO    RPGRTNRG            YES, BRANCH AROUND DISK DCB CLOSE
*
RPNXTDCB LA    R2,4(,R2)           INCR DCB TABLE PTR TO NEXT DCB ADDR
         BCT   R5,RPGENT1A         LOOP UNTIL ALL DCBS CLOSED
*
*        INVOKE E37 IF REQUESTED
*
RPGRTNRG PPITEST  PPIME37          EXIT 37 ACTIVE ?
         BZ    RPGENT5             NO, BRANCH
         L     R15,PPIX37+4        YES, R15 -> USER EXIT 37 ROUTINE
         BASR  R14,R15             CALL USER ROUTINE E37
*
*        GENERATE STATISTICS MESSAGE IER054
*
RPGENT5  LM    R0,R1,IER054        IER054I RECORDS IN
         L     R15,PPIADSSC
         BAS   R14,12(,R15)        CALL PRINT ROUTINE
         TM    WABSW3,X'01'        SHOULD JOB TERMINATE ?
         BO    RPGABT              YES, BRANCH
         LM    R0,R1,IER052        IER052I END OF SORT
         L     R15,PPIADSSC
         BAS   R14,12(,R15)        CALL PRINT ROUTINE
         L     R12,SAVER12         RESTORE R12
         L     R15,PPIADSSC        R15 -> SSC
         BASR  R14,R15             END OF TASK, EXIT TO SORT SYS CNTL
*
*        MERGE PROCESSING
*
RPGMERGE LTR   R9,R9               NULL FILE ?
         BO    RPGENT1             YES, GOTO CLOSE
*
*        ### LTR DOES NOT SET CC1 SO THIS BRANCH NEVER TAKEN ###
*
         PPITEST  PPIFSZE          FILE ESTIMATED ?
         BO    RPGSETT             YES, BRANCH
         ICM   R4,B'1111',PPIFILSZ   USER PROVIDE FILE SIZE ?
         BNZ   RPGCOMP             YES, FILE SIZE PROVIDED, BRANCH
RPGSETT  SR    R10,R10             CLEAR PRINT REG
         B     RPGENT3             GOTO MAIN LINE
*
*        TERMINATE SORT EXIT
*
RPGABT   L     R15,PPIADSSC        R15 -> SSC
         BAS   R14,16(,R15)        EXIT TO TERMINATE, NO RETURN
*
*        GENERATE IER047 RECORD COUNT ERROR MSG
*
RPGENT2  L     R1,IER047           R1 -> MSG TEXT
         MVC   PPIABMNO,3(R1)      MOVE MSG NO INTO ABEND NO
         LM    R0,R1,IER047        IER047A RECORD COUNT ERROR
         PPITEST  PPIREADE         READ ERROR OCCUR ?
         BZ    RPGAB001            NO, SET TERMINATE SW
         PPITEST  PPIACCPT         ACCEPT BAD RECORD ?
         BO    RPGAB002            YES, DO NOT SET TERMINATE SW
RPGAB001 MVI   WABSW3,X'01'        TURN ON TERMINATE SWITCH
RPGAB002 L     R15,PPIADSSC
         BAS   14,12(,R15)         CALL PRINT MSG ROUTINE
         B     RPGENT3             RETURN TO MAIN LINE
*
WABSW3   DC    X'00'               TERMINATE SWITCH
WBRTBSW  DC    X'00'               BRANCH TABLE SWITCH
SAVER12  DC    F'0'                R12 SAVE AREA
WREGSV   DC    2F'0'
RPGLIST  DC    2A(0)               OUTPUT BUFFER ADDR FOR BUILDS
EPATTERN DC    XL8'4020202020202020'   ZERO SUPPRESS EDIT PATTERN
*
*        IERRMC
*
*        THIS DSECT CONTAINS ALL OF THE MESSAGES THAT ARE
*        REQUIRED FOR PHASE 2 RUNNING PROGRAM
*
DIERRMC  DSECT
*
         COPY  RMCMAIN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         PRINT NOGEN
*
         DCBD  DSORG=PS,DEVD=(DA,TA)
*
         PRINT GEN
*
         END
./ ADD NAME=IERRPM   0101-20211-20211-1200-00212-00212-00000-RELEASE 00
RPM      TITLE 'IERRPM - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRPM
*
*        MODULE FUNCTION/OPERATION -
*        CHECK RECORD COUNTS, CLOSE ALL OUTPUT FILES, AND DO END
*        OF PHASE HOUSE KEEPING FOR THE OSCILLATING MERGE PHASE
*
*        USED AS A DSECT IN - N/A
*
*        MACROS USED -
*        SMPPI
*        CLOSE
*
*        ENTRY POINTS - ENTRY FROM IERRCV
*                       CALLING SEQUENCE -
*                           LOAD   EP=IERRPM,DCB=SORTLIB
*                           L      R11,R0
*                           B      0(R1,R11)
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPICNTL   PPIFILSZ   PPISTDCB   PPIRMB
*        PPIWKARE  PPIRCDCT   PPIBDSVA   PPIADSSC
*        PPICOUNT  PPIX27     PPIX17
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPIWKARE
*        PPICNTL
*
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - IERRMB - REFERENCE TO MSG MODULE
*
*        EXITS - NORMAL - SORT SYSTEM CONTROL
*                         L    R15,PPIADSSC
*                         B    8(0,R15)
*
*        EXITS - ERROR - SORT SYSTEM CONTROL
*                        L    R15,PPIADSSC
*                        B    16(0,R15)
*
*        TABLES/WORK AREAS - N/A
*
*        NOTES -
*        USE RESTRICTED TO OSCILLATING SORT/MERGE
*        USER EXITS E17 AND E27 ARE ASSOCIATED WITH THIS MODULE
*
IERRPM   CSECT
*
         USING *,R11               PROGRAM BASE REG
         USING DIERRMB,R12         MESSAGE MODULE BASE REG
         USING IERRCA,R13          PPI BASE REG
*
*        CALL FOR PHASE TWO CANNOT VALIDLY OCCUR IN AN
*        OSCILLATING TECHNIQUE SO IT'S ENTRY (LEFT FOR
*        COMPATIBILITY) IS A NOP
*
         NOP   *+4                 PHASE 2 CALL CANNOT OCCUR VALIDLY
         ST    R12,KRPMWORK        SAVE R12
         L     R12,PPIRMB+4        SET MSG BASE REG
*
*        SAVE THE BLOCK COUNTS IF IT IS A TAPE SORT
*        THE BLOCK COUNTS WILL BE RESTORED AT THE START OF PHASE
*        THREE
*
         PPITEST  PPITAPE          TAPE SORT ?
         BZ    RPMCKP              NO, DASD, BRANCH
         SR    R1,R1               ZERO REGISTER
         IC    R1,PPIBDSVA         LOAD NUMBER OF WORK UNITS
         LA    R2,PPITPTBL         LOAD STARTING ADDR OF TAPE TABLE
RPM100   TM    0(R2),X'40'         OPEN BIT ON FOR THIS UNIT ?
         BZ    RPM300              NO, BRANCH TO INCREMENT TAPE ADDR
         SR    R3,R3
         IC    R3,1(,R2)           LOAD TAPE INCREMENT
         L     R4,PPISTDCB         LOAD STARTING ADDR OF DCB TABLE
         LA    R5,PPIENDAR         LOAD STARTING ADDR OF SAVE AREA
         AR    R4,R3               GET DCB POINTER
         L     R4,0(,R4)           GET STARTING ADDR OF DCB
         USING IHADCB,R4           ESTABLISH DCB ADRESSABILITY
         AR    R5,R3               GET ADDR TO SAVE BLK CNT OF UNIT
         MVC   0(4,R5),DCBBLKCT    MOVE BLK CNT FROM DCB TO SAVE AREA
         DROP  R4
RPM300   LA    R2,2(,R2)           INCREMENT TAPE TABLE ADDR
         BCT   R1,RPM100           ALL UNITS TESTED ? NO LOOP AGAIN
RPMCKP   LM    R6,R8,PPICOUNT      GET RCD COUNTS FROM PPI
         STM   R9,R10,PPIWKARE     SAVE REGS
         L     R10,PPIFILSZ        GET RECORD COUNT
         PPITEST  PPIFSZE          TEST ESTIMATED FILE SIZE SWITCH
         BO    RPMCHNG1            DON'T COMPARE RCDS WITH FILSZ IF ON
         CR    R6,R10              COMPARE RCDS IN WITH FILSZ
         BNE   RPMENT4             NOT EQUAL GOTO PRINT MESSAGE
RPMENT2  LR    R9,R6               SORT COUNT
         AR    R9,R8               ADD INSERT COUNT
         SR    R9,R7               SUBTRACT DELETE COUNT
         ST    R9,PPIRCDCT         RCDS TO BE SORTED
         L     R5,PPISTDCB         GET DCB TABLE ADDR
         PPISETOF PPIFSZE          TURN OFF EST SWITCH
         SR    R6,R6
         ST    R6,PPICOUNT         CLEAR COUNT AREA
         IC    R6,PPIBDSVA         TOTAL NO OF WORK UNITS
         LA    R9,PPITPTBL         INTITIALIZE TAPE TABLE POINTER
RPMLOOP  LA    R5,4(,R5)           UP TO NEXT DCB ENTRY
         LA    R9,4(,R9)           INCREMENT TO NEXT UNIT
         L     R2,0(,R5)           SET DCB ADDR IN CLOSE REG
         USING IHADCB,R2
         OI    DCBOFLGS,DCBOFLWR   SET LEAVE BIT
         TM    0(R5),X'80'         TEST FOR NO CLOSE
         BO    RPMUPRG             GOTO UP REG
         PPITEST  PPICLOSR         CLOSE WITH REWIND ?
         BO    RPMDASD             YES, BRANCH
*
RPMSHUT  CLOSE ((R2),LEAVE)        CLOSE AN O/P FILE
*
         DROP  R2
*
RPMUPREG MVI   0(R5),X'80'         INDICATE CLOSED FILE
RPMUPRG  BCT   R6,RPMLOOP          GOTO CLOSE NEXT FILE
*
*        END OF CLOSE LOOP
*
         PPITEST  PPIME17          USER EXIT 17 ACTIVE ?
         BO    RPMOD17             YES, LINK TO USER
RPMBK17  PPITEST  PPIME27          USER EXIT 27 ACTIVE ?
         BO    RPMOD27             YES, LINK TO USER
RPMENT3  TM    WABSW2,X'01'        TERMINATE ?
         BO    RPMABT              YES, BRANCH
RPMEOP   LM    R0,R1,IER050        IER050I END OF MERGE PHASE
         L     R15,PPIADSSC
         BAS   14,12(,R15)         CALL PRINT MESSAGE
RPMEND   LM    R9,R10,PPIWKARE     RESTORE R9-R10
         L     R12,KRPMWORK        RESTORE R12
         L     R15,PPIADSSC        SET LINK TO SSC
RPMRETRN BAS   R14,8(,R15)         GOTO SORT SYS CONTROL
*
*        GENERATE INCORRECT COUNT MESSAGE
*
RPMENT4  LM    R0,R1,IER047        IER047A RECORD COUNT ERROR
         ST    R6,PPIFILSZ         SAVE FILSZ IF NO TERMINATE
         PPITEST  PPIREADE         READ ERROR OCCUR ?
         BZ    RPAB01              NO, SET TERMINATE SW
         PPITEST  PPIACCPT         ACCEPT BAD RECORD ?
         BO    RPAB02              YES, DO NOT SET TERMINATE SW
RPAB01   MVI   WABSW2,X'01'        TURN ON TERMINATE SWITCH
RPAB02   CVD   R10,PPIWKARE        CONVERT RECORDS IN TO DECIMAL
         MVC   IER047I,EPATTERN    MOVE IN ZERO SUPPRESS PATTERN
         ED    IER047I,PPIWKARE+4  EDIT INTO MESSAGE FIELD
         CVD   R6,PPIWKARE         CONVERT RCDS OUT TO DECIMAL
         MVC   IER047O,EPATTERN    MOVE IN ZERO SUPPRESS PATTERN
         ED    IER047O,PPIWKARE+4  EDIT INTO MESSAGE FIELD
         L     R15,PPIADSSC        R15 ->SSC
         BAS   14,12(,R15)         CALL SSC
         B     RPMENT2             GOTO CLOSE FILES
*
RPMABT   L     R1,IER047           R1 -> MSG TEXT
         MVC   PPIABMNO,3(R1)      MOVE MSG NO INTO ABEND NO
         L     R15,PPIADSSC        SET LINK TO SSC
         BAS   R14,16(,R15)        GOTO TERMINATE
*
RPMDASD  TM    0(R9),X'80'         TEST ASSOCIATED TAPE TABLE INPUT BIT
         BZ    RPMSHUT             IF NOT INPUT CLOSE AS LEAVE
         PPITEST  PPITAPE          TAPE SORT ?
         BO    RPMDASDA            YES
         USING IHADCB,R2
         NI    DCBOFLGS,255-DCBOFLWR  NO NEED TO WRITE FILE MARK
*
RPMDASDA CLOSE ((R2),REREAD)       CLOSE DCB
*
         DROP  R2
*
         B     RPMUPREG            GOTO CLOSE NEXT FILE
*
RPMOD17  L     R15,PPIX17+4        SET TO USER EXIT 17
         BASR  R14,R15             BRANCH AND LINK TO USER
         B     RPMBK17             GO BACK AFTER E17 EXIT
*
RPMOD27  L     R15,PPIX27+4        SET TO USER EXIT 27
         BASR  R14,R15             BRANCH AND LINK TO USER
         B     RPMENT3             GOTO EOP MSG ROUTINE
*
RPMCHNG1 ST    R6,PPIFILSZ         STORE COUNT INTO FILE SIZE
         B     RPMENT2
*
KRPMWORK DC    F'0'
KZERO    DC    4X'00'
WABSW2   DC    X'00'               TERMINATE SWITCH
EPATTERN DC    XL8'4020202020202020'  ZERO SUPPRESS EDIT PATTERN
*
*        MODULE NAME - IERRMB
*
*        THIS MODULE CONTAINS ALL OF THE MESSAGES THAT ARE
*        REQUIRED FOR PHASE 2 RUNNING PROGRAM
*
DIERRMB  DSECT
*
         COPY  RMBMAIN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         PRINT NOGEN
*
         DCBD  DSORG=(PS),DEVD=(TA,DA)
*
         PRINT GEN
*
         END
./ ADD NAME=IERRPN   0101-20211-20211-1200-00098-00098-00000-RELEASE 00
RPN      TITLE 'IERRPN - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRPN - NOT SUPPORTED - 2301
*
*        MODULE FUNCTION/OPERATION -
*        THIS IS THE PHASE1 ROUTINE THAT WILL WRITE EITHER DATA
*        OR DIRECTORY ON THE DRUM
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - IERAPN
*
*        MACROS USED BY MODULE -
*        SMPPI
*        EXCP
*        WAIT
*        DELETE
*        GETMAIN
*
*        ENTRY POINTS - CALLING SEQUENCE -
*                           L    R11,PPIWRT+4
*                           B    0(,R11)  WRITE DIRECTORY
*
*                           L    R11,PPIWRT+4
*                           B    4(,R11)  END OF SEQUENCE
*
*                           L    R11,PPIWRT+4
*                           B    8(,R11)  WRITE DATA
*
*                           L    R11,PPIWRT+4
*                           B    12(,R11) EOV WRITE
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIADSSC   PPIBPTRK   PPIENDAR
*        PPINDSKA   PPISTDCB   PPISTIOB
*        PPIDIRAD
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPIDEPHO   PPILABO1   PPIWKARE
*        PPICNTL
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS -
*        DSECT IERIOB - MODEL IOB
*        DSECT IHADCB - MODEL DCB
*        DSECT IERRCA - MODEL PPI
*
*        EXITS - NORMAL -
*        EXIT TO ALGORITHM (IERROO) ON THE FOLLOWING CONDITIONS -
*        END OF SEQUENCE
*        END OF AREA
*        END OF AREA/SEQUENCE
*        WRITE DIRECTORY
*
*        EXIT TO BLOCK ROUTINE (PPIBLK+4) AFTER WRITING DATA
*
*        EXITS - ERROR -
*        EXIT TO SORT SYSTEM CONTROL ON ANY WRITE ERROR
*        EXIT TO USER ERROR OPTION ROUTINE ON WRITE ERROR
*
*        TABLES/WORK AREAS -
*        CHANNEL COMMAND WORD LIST TO WRITE DIRECTORY
*
*        NOTES -
*        THIS MODULE IS RESTRICTED TO 2301 DRUM OPERATIONS ONLY
*
IERRPN   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRPN SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRPNI
*
*        CCW EQUATES
*
         IERCCWEQ
*
*        IOB
*
         IERIOB
*
         PRINT NOGEN
*
         DCBD  DSORG=(PS),DEVD=(DA)
*
         PRINT GEN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IERRPNI  0101-20211-20211-1200-00345-00345-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERRPN SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERRPNI - NOT SUPPORTED 2301
*
         USING *,R11               PROGRAM BASE REG
         USING IERIOB,R12          IOB BASE REG
         USING IHADCB,R10          DCB BASE REG
         USING IERRCA,R13          PPI BASE REG
*
*        BRANCH TABLE
*
IERDPW1  B     RPNENT4             +00 WRITE DIRECTORY (EOV)
         B     RPNENT2             +04 END OF SEQUENCE
         B     RPNENT1B            +08 NORMAL DATA WRITE
         B     RPNENT3             +12 WRITE DIRECTORY
         B     RPNENT5             +16 DELETE RC9
*
RPNENT1B LA    R4,4                SET TO NO EOS
         PPITEST  PPIVAR           VARIABLE RECORDS ?
         BO    RPNVVR              YES, BRANCH
         MVC   0(4,R2),KEOS1       ERASE EOS (FIXED)
         B     RPNENT1
*
RPNVVR   MVC   4(4,R2),KEOS1       ERASE EOS (VAR)
RPNENT1  STM   R0,R15,KRPNREG      NORMAL DATA WRITE ROUTINE
         L     R12,PPISTIOB        GET IOB ADDR
         LA    R9,8                CALC ECB ADDR
         SR    R12,R9              SET ECB PTR IN BASE REG
         TM    RPNDBSW,X'02'       DOUBLE BUFFERED ?
         BZ    RPNENT1A            NO, GOTO SINGLE BUFFER
RPNPASS  NOP   RPNPASS1            NOP FIRST TIME THROUGH
         L     R6,PPILAB04         LOAD ADDR OF BUFF 1 INTO R6
         SR    R6,R9               ADJUST BUFF ADDR BY 8
         ST    R6,RPNWRKC          SAVE BUFF ADDR
         NI    RPNWRKC,X'00'
         MVI   RPNPASS+1,X'F0'     TURN BY PASS SWITCH ON
RPNPASS1 TM    RPNBF,X'01'         FIRST WRITE ?
         BO    RPNNOWT             YES, BRANCH TO NO WAIT
         LA    R6,RPNENT1A         SET RETURN ADDR
         B     RPNSTAY             GOTO WAIT
*
RPNNOWT  MVI   RPNBF,X'00'         TURN OFF WAIT SWITCH
RPNENT1A SR    R2,R9               SET BUFFER ID ADDR
         IC    R9,PPIDEPHO+7       GET RECORD NUMBER
         BCTR  R9,0                DECREMENT RCD NUMBER
         STC   R9,IOBR             PUT IN IOB
         MVC   IOBCC(4),PPIDEPHO+3  SET SEARCH ADDR IN IOB
         MVC   0(5,R2),PPIDEPHO+3  SET DISK ADDR IN BUFFER
         SR    R6,R6
         IC    R6,PPIDEPHO         GET INCREMENT
         L     R10,PPISTDCB
         L     R10,0(R6,R10)       GET DCB ADDR
         MVC   DCBFDAD+1(7),PPIDEPHO+1  SET DISK ADDR IN DCB
         ST    R10,IOBDCBPT        PUT DCB ADDR IN IOB
         LA    R9,2(,R9)           INCREMENT TO NEXT RCD
         STC   R9,PPIDEPHO+7       SET DEPHO TO NEXT RCD
         STH   R1,6(,R2)           SET BFR BYTE COUNT
         MVI   5(R2),X'00'         SET KL IN BUFFER
         MVI   WTRKSW,X'00'        TURN OFF FULL TRACK SWITCH
         CLC   4(1,R2),PPIBPTRK+1  WILL TRACK BE FULL?
         BL    RPNNORML            NO, BRANCH
         MVI   WTRKSW,X'01'        SET FULL TRACK SWITCH
         LA    R5,PPIENDAR         GET DISK ENDING ADDR
         LH    R6,PPINDSKA         GET NUMBER OF AREAS
RPNMTRY  CLC   PPIDEPHO(1),0(R5)   CORRECT END ADDR ?
         BE    RPNFLUSH            YES, GO OUT OF LOOP IF FOUND
         LA    R5,8(,R5)           UP SEARCH ADDR
         BCT   R6,RPNMTRY          GO BACK TO LOOP
RPNFLUSH CLC   PPIDEPHO+3(4),3(R5)   END OF AREA ?
         BE    RPNEOAID            YES, GO TO END OF ARE
RPNNORML LA    R7,IOBSTDRD         SET IOB ADDR
         ST    R7,DCBIOBAD         SET IOB POINTER IN DCB
         MVC   KRPNREGC(4),RPNBUF1 PASS ADDR TO BLOCK ROUTINE
         MVC   IOBSTART,HOLDPR     MOVE PRIME CCW ADDR IN IOB
         TM    RPNDBSW,X'02'       DOUBLE BUFFER ?
         BO    RPNDBL              YES, GOTO DBL BUFFER ROUTINE
         BAS   R14,RPNSUBRT        CALL SET UP CCW
*
         IEREXCP  (R7)             WRITE A BLOCK
*
         BAS   R6,RPNSTAY          GOTO WAIT RTN
RPNUPRCD LTR   R4,R4               END OF FILE ?
         BZ    RPNENDSQ            YES, BRANCH TO EOF EXIT ROUTINE
         TM    WEOASW,X'01'        END OF AREA ?
         BO    RPNENDDK            YES, BRANCH
         TM    WTRKSW,X'01'        TRACK FULL ?
         BO    RPNFULTK            YES, BRANCH
RPNSEQTT TM    KEOSSW,X'01'        EOS ?
         BO    RPNENDSQ            YES, GOTO EOS RETURN
RPNENT4  LM    R0,R15,KRPNREG      RESTORE REGS
         L     R11,PPIBLK+4        SET RETURN TO BLOCK ROUTINE
         B     8(,R11)             GOTO BLOCK
*
RPNDBL   C     R2,RPNWRKC          EQUAL COMPARE ?
         BE    RPN1                YES, BRANCH
         MVC   IOBSTART,IERALTCW   MOVE ALT INTO IOBSTART
         LA    R14,RPNDBLRT        SET RETURN REG
         B     RPNSUBRT
*
RPN1     MVC   KRPNREGC(4),RPNBUF2  PASS ADDR TO BLOCK ROUTINE
         BAS   R14,RPNSUBRT        CALL SET UP CCW
*
RPNDBLRT IEREXCP  (R7)             WRITE A BLOCK
*
         B     RPNUPRCD            GOTO MAIN LINE
*
RPNSTAY  L     R10,IOBDCBPT        SET DCB BASE REG
*
         IERWAIT  1,ECB=(R12)      WAIT ON I/O COMPLETION
*
         TM    DCBIFLGS,DCBIFPEC   ERROR ?
         BO    RPNTERM             YES, GOTO TERMINATE JOB
         LM    R0,R2,KRPNREG       RESTORE PASS INFO
         BR    R6                  GOTO MAIN LINE
*
*        SET UP CCW FOR WRITING RECORDS
*
RPNSUBRT L     R8,IOBSTART         CCW POINTER
         LA    R1,8(,R1)           UP RCD BYTE COUNT
         STH   R1,22(R8)           STOW IN CCW
         BR    R14                 GOTO MAIN LINE
*
RPNENDSQ MVI   KEOSSW,X'00'        TURN OFF EOS SWITCH
         L     R3,PPIBLK+4         LOAD ADDR OF BLOCK ROUTINE
         MVC   20(4,R3),KRPNREGC   MOVE POINTER INTO BLOCK RTN
         MVC   24(4,R3),KRPNREGC   MOVE POINTER INTO BLOCK RTN
RPNSGL   LM    R0,R15,KRPNREG      RESTORE REGS
         B     RPNFSTB(R4)         GOTO EOS BRANCH TABLE
*
RPNFNLES L     R11,PPIALG+4        SET RETURN REG
         BR    R11                 GOTO FINAL EOS
*
RPNFSTB  B     RPNFNLES            GOTO FINAL EOS
         L     R11,PPIALG+4        SET RETURN REG
         B     12(,R11)            GOTO NORMAL EOS
*
RPNEOAID MVI   WEOASW,X'01'        TURN ON EOA SWITCH
         PPITEST  PPIVAR           VARIABLE RECORDS ?
         BO    RPNVEOS             YES, BRANCH
         MVC   8(4,R2),KEOS2
         MVI   10(R2),C'G'         INDICATE FIXED EOS
         B     RPNNORML            GOTO MAIN LINE
*
RPNVEOS  MVC   12(4,R2),KEOS2
         MVI   14(R2),C'G'         INDICATE VARIABLE EOS/EOA
         B     RPNNORML
*
RPNFULTK MVI   PPIDEPHO+7,X'01'    SET ADDR TO NEXT RCD
         IC    R9,PPIDEPHO+6
         LA    R9,1(,R9)           INCREMENT TRACK COUNT
         STC   R9,PPIDEPHO+6       PUT IN PPI
         B     RPNSEQTT            GOTO EOS TEST
*
*        AN END OF AREA HAS BEEN REACHED
*
*        RETURN FROM HERE TO THE ALGORITHM
*
RPNENDDK MVI   WEOASW,X'00'        TURN OFF EOS SWITCH
         CLI   KEOSSW,X'01'        IOS ?
         BE    RPNSWOFF
         LM    R0,R15,KRPNREG      RESTORE REGS
         L     R11,PPIALG+4        SET RETURN REG
         B     4(,R11)             BRANCH TO EOA ALGORITHM
*
RPNSWOFF MVI   KEOSSW,X'00'        TURN OFF EOS INDICATE
         LM    R0,R15,KRPNREG      RESTORE REGS
         L     R11,PPIALG+4        SET RETURN REG
         B     8(0,R11)            GOTO EOS-EOA ROUTINE
*
*        THIS ROUTINE IS ENTERED ON END OF SEQUENCE
*
RPNENT2  MVI   KEOSSW,X'01'        TURN ON EOS SWITCH
         STM   R4,R6,KRPBREGB      SAVE REGS
         L     R5,PPILAB07         BUFFER SIZE
         LA    R5,0(,R5)           ZERO BUFFER COUNT IN FIRST BYTE
         LH    R6,PPIRCDL2         SORT REC SIZE
         SR    R4,R4
         SR    R5,R1               BUFF SIZE - SHORT BLOCK SIZE
         DR    R4,R6               FR = RECORDS NOT ACCOUNTED FOR
         L     R6,PPINMAX
         SR    R6,R5               NMAX - REC NOT ACCOUNTED FOR
         ST    R6,PPINMAX
         LM    R4,R6,KRPBREGB      RESTORE REGS
         PPITEST  PPIVAR           VAR FORMAT ?
         BO    RPNVAR
         MVC   0(4,R2),KEOS2       INDICATE EOS (FIXED)
         LTR   R4,R4               FINAL SEQUENCE ?
         BZ    RPNNFIN             YES, BRANCH
         B     RPNENT1             GOTO MAIN LINE
*
RPNNFIN  MVI   2(R2),C'G'          INDICATE FINAL EOS
         B     RPNENT1             GOTO MAIN LINE
*
RPNVAR   MVC   4(4,R2),KEOS2       INDICATE EOS (VARIABLE)
         LTR   R4,R4               FINAL SEQUENCE ?
         BZ    RPNVFIN             YES, BRANCH
         B     RPNENT1             GOTO MAIN LINE
*
RPNVFIN  MVI   6(R2),C'G'          INDICATE FINAL EOS
         B     RPNENT1             GOTO MAIN LINE
*
*        ENTRY TO WRITE DIRECTORY
*
RPNENT3  STM   R0,R15,KRPNREG      SAVE REGISTERS
         L     R12,PPISTIOB        SET IOB BASE REG
         LA    R7,8
         SR    R12,R7              POINT BASE TO ECB
         TM    RPNDBSW,X'02'       DOUBLE BUFFERED ?
         BZ    RPNSTORE            NO, BRANCH
         BAS   R6,RPNSTAY          CALL SUBRTN
RPNSTORE LA    R6,PPIWKARE         GET DIRECTORY ADDR
         IC    R9,PPIDIRAD+7       GET DIRECT RECORD
         BCTR  R9,0                CALC SEARCH ADDR
         STC   R9,IOBR             PUT IN IOB
         MVC   IOBCC(4),PPIDIRAD+3  SET SEARCH ADDR IN IOB
         MVC   PPILAB01(64),PPIWKARE
         MVC   PPIWKARE+8(64),PPILAB01  REPOSITION DIRECTORY
         MVC   PPIWKARE+5(3),KDKBUF     BUILD BUFFER INFO
         MVC   PPIWKARE(5),PPIDIRAD+3   SET CYL ADDR IN BUFFER
         SR    R7,R7
         IC    R7,PPIDIRAD         GET INCREMENT
         L     R10,PPISTDCB
         L     R10,0(R7,R10)       SET DCB BASE REG
         ST    R10,IOBDCBPT        SET DCB POINTER IN IOB
         LA    R7,RPNIDCCW
         ST    R7,IOBSTART         SET CCW PTR IN IOB
         LA    R7,IOBSTDRD
         ST    R7,DCBIOBAD         SET IOB ADDR IN DCB
*
         IEREXCP  (R7)             WRITE DISK
*
         MVI   RPNBF,X'01'         TURN FIRST TIME SWTCH ON
         BAS   R6,RPNSTAY          GOTO WAIT RTN
         LM    R0,R15,KRPNREG      RESTORE REGS
         L     R11,PPIALG+4        SET RETURN REG
         BR    R14                 GOTO ALGORITHM
*
*        WRITE ERROR. TEST FOR USER EXIT 18
*        EXECUTE USER MOD TERMINATE THE JOB
*
RPNTERM  L     R3,DCBFDAD+3        LOAD DCB+3 INTO REG R3
         BCTR  R3,0                DECR RCD # BY 1
         ST    R3,DCBFDAD+3        STORE UPDATED DCB
         ICM   R15,B'1111',RPNUSERX  USER MOD ADDR PROVIDED ?
         BZ    RPNOFF              NO, BRANCH TO TERMINATE JOB
         ST    R7,PPIWKARE         SET IOB ADDR FOR USER
         MVI   PPIWKARE,X'10'
         L     R0,PPIWKARE
         LR    R1,R10              SET DCB ADDR FOR USER
         BASR  R14,R15             CALL USER EXIT E18
RPNOFF   ST    R4,RPNSVEME
         PPISETON PPIWRITE         WRITE ERROR FLAG IN PPI
         L     R15,PPIADSSC        R15 -> SSC
         BAS   R14,16(,R15)        EXIT TO SSC
*
RPNENT5  DELETE EP=IERRC9          FREE CORE
*
         LTR   R15,R15             SUCCESSFUL ?
         BZ    RPNBUFCK            YES, BRANCH
         L     R15,PPIADSSC        NO, ERROR ON DELETE - PRINT MESSAGE
         BAS   R14,28(,R15)
         L     R15,PPIADSSC        R15 -> SSC
         BAS   R14,16(R15)         EXIT TO SSC
*
RPNTONET L     R11,PPINET+4
         B     0(,R11)
*
RPNBUFCK TM    PPILAB04,X'80'      NEED ANOTHER BUFFER ?
         BO    RPNTONET            BUFFERS OK, BRANCH
         LH    R15,PPILAB07+2
         LA    R15,8(,R15)
         STH   R15,DISPLCE+6
*
DISPLCE  GETMAIN EC,LV=100,A=RPNADDR
*
         LTR   R15,R15             SUCCESSFUL ?
         BNZ   RPNTONET            NO, BRANCH
RPNBUFOK MVI   PPILAB07,2          CHANGE NO OF BUFFERS TO TWO
         MVI   RPNDBSW,X'02'       SET DOUBLE SWITCH
         ST    R2,RPNREGSV         SAVE CONTENTS OF R2
         ST    R12,RPNREGSE        SAVE CONTENTS OF R12
         L     R2,RPNADDR
         LA    R2,8(,R2)
         ST    R2,PPILAB05         STORE NEW ADDR OF BUFFER 2
         PPITEST  PPIVAR           VARIABLE RECORDS ?
         BO    RPNVVV              YES, BRANCH
         LA    R2,4(,R2)           CALC FIXED BUF ADDR
         B     RPNFIX
*
RPNVVV   LA    R2,8(,R2)           CALC VARIABLE BUF ADDR
RPNFIX   ST    R2,RPNBUF2
         L     R2,PPIGETSZ         LOAD ADDR OF SIZE TABLE
RPNCOMPR CLI   0(R2),X'80'         FIRST BYTE X'80' ?
         BE    RPNHIT              YES, BRANCH
         LA    R2,4(,R2)           INCREMENT REG BY 4
         B     RPNCOMPR            BRANCH BACK TO COMPARE
*
RPNHIT   MVI   4(R2),X'80'         SET NEW END OF TABLE MARKER
         MVC   5(3,R2),DISPLCE+5   MOVE LENGTH OF BUFF INTO SIZE TABLE
         MVI   0(R2),X'00'         CLEAR END OF TABLE INDICATOR
         S     R2,PPIGETSZ         SUBTRACT STARTING ADDR FOR DIFF
         A     R2,PPIGETMN         ADD ADDR OF TABLE TO DIFF
         MVC   4(4,R2),RPNADDR     MOVE ADDR OF BUFF INTO ADDR TABLE
         L     R12,PPISTIOB
         LA    R9,8
         SR    R12,R9              SET IOB BASE REG
         L     R2,IERALTCW
         MVC   17(3,R2),RPNADDR+1  MOVE ADDR INTO ALT CCW
         L     R2,RPNREGSV         RELOAD TRUE VALUE
         L     R12,RPNREGSE        RESTORE REG
         B     RPNTONET
*
RPNWRKC  DC    F'0'
RPNSVEME DC    F'0'
RPNADDR  DC    F'0'
RPNREGSV DC    F'0'
RPNREGSE DC    F'0'                EQUAL/EXTRACT ADDR
RPNBUF1  DC    F'0'
RPNBUF2  DC    F'0'
RPNUSERX DC    F'0'
KRPNREG  DC    2F'0'
KRPNREGC DC    14F'0'
KRPBREGB DC    3F'0'
KEOSSW   DC    X'00'
HOLDPR   DC    F'0'
RPNBF    DC    X'01'
RPNDBSW  DC    X'00'
KEOS1    DC    CL4'HHHH'           NOT EOS INDICATION
KEOS2    DC    CL4'HGHH'           EOS INDICATION
WEOASW   DC    X'00'               END OF AREA SWITCH
WTRKSW   DC    X'00'               FULL TRACK SWITCH
KDKBUF   DC    X'0000'             BUFFER CONSTANT
         DC    X'40'
*
*        CCW LIST TO WRITE DIRECTORY
*
RPNIDCCW CCW   SEARIDEQ,RPNIDCCW,CC+SLI,5   SEARCH ID CCW
RPNCTCCW CCW   TIC,RPNIDCCW,CC+SLI,0
RPNCCW2  CCW   WRITECKD,RPNCCW2+1,SLI,72    WRITE DIRECTORY RECORD
*
./ ADD NAME=IERRPO   0101-20211-20211-1200-00096-00096-00000-RELEASE 00
RPO      TITLE 'IERRPO - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IERRPO - NOT SUPPORTED - 2301
*
*        MODULE FUNCTION/OPERATION -
*        THIS IS THE PHASE2 ROUTINE THAT WILL WRITE EITHER DATA
*        OR DIRECTORY ON THE DRUM
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - IERAPO
*
*        MACROS USED -
*        SMPPI    EXCP      WAIT
*        DELETE   GETMAIN
*
*        ENTRY POINTS - ENTRY IERDPW2 - ENTRY FROM
*                                       CALLING SEQUENCE -
*                                       L    R11,PPIWRT+4
*                                       B    0(,R11) EOV WRITE
*
*                                       L    R11,PPIWRT+4
*                                       B    4(,R11)  END OF SEQUENCE
*
*                                       L    R11,PPIWRT+4
*                                       B    8(,R11)  WRITE DATA
*
*                                       L    R11,PPIWRT+4
*                                       B    12(,R11) WRITE DIRECTRY
*
*                                       L    R11,PPIWRT+4
*                                       B    16(,R11) DELETE RC9
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIADSSC   PPIBPTRK   PPIENDAR
*        PPINDSKA   PPISTDCB   PPISTIOB
*        PPIDIRAD
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPIDEPHO   PPILABO1   PPIWKARE
*        PPICNTL
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS -
*        DSECT RPOECB - MODEL IOB
*        DSECT IHADCB - MODEL DCB
*        DSECT IERRCA - MODEL PPI
*
*        EXITS - NORMAL -
*        EXIT TO ALGORITHM (IERRO3) ON THE FOLLOWING CONDITIONS -
*                END OF SEQUENCE
*                END OF AREA
*                END OF AREA/SEQUENCE
*                WRITE DIRECTORY
*        EXIT TO BLOCK ROUTINE (PPIBLK+4) AFTER WRITING DATA
*
*        EXITS - ERROR -
*        EXIT TO SORT SYSTEM CONTROL ON ANY WRITE ERROR
*        EXIT TO USER ERROR OPTION ROUTINE ON WRITE ERROR
*
*        TABLES/WORK AREAS -
*        CHANNEL COMMAND WORD LIST TO WRITE DIRECTORY
*
*        NOTES -
*        THIS MODULE IS RESTRICTED TO 2301 DRUM OPERATIONS ONLY
*
IERRPO   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERRPO SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IERRPOI
*
         IERIOB
*
*        CCW EQUATES
*
         IERCCWEQ
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         PRINT NOGEN
*
         DCBD  DSORG=(PS),DEVD=(DA)
*
         PRINT GEN
*
         END
./ ADD NAME=IERRPOI  0101-20211-20211-1200-00292-00292-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IERRPO SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IERRPOI - NOT SUPPORTED - 2301
*
         USING *,R11
         USING IHADCB,R10
         USING IERIOB,R12
         USING IERRCA,R13
*
*        BRANCH TABLE
*
IERDPW2  B     RPOENT4             +00 ENTRY ON WRITE DIRECTORY (EOV)
         B     RPOENT2             +04 ENTRY ON END OF SEQUENCE
         B     RPOENT1B            +08 ENTRY ON NORMAL DATA WRITE
         B     RPOENT3             +12 ENTRY ON WRITE DIRECTORY
         B     RPOENT5             +16 ENTRY TO DELETE RC9
*
RPOENT1B PPITEST  PPIVAR           VARIABLE LENGTH RECORDS ?
         BO    RPOVVR              YES, BRANCH
         MVC   0(4,R2),KEOS3       ERASE FIXED EOS
         B     RPOENT1             GOTO MAIN LINE
*
RPOVVR   MVC   4(4,R2),KEOS3       ERASE VARIABLE EOS
RPOENT1  STM   R0,R15,WRPOREG      SAVE REGS
         L     R12,PPISTIOB        GET IOB POINTER
         L     R12,0(,R12)         SET IOB BASE REG
         ST    R12,RPOIOBSV        TEMPERARLY SAVE IOB ADDR
         LA    R9,8
         SR    R12,R9              SET IOB BASE REG TO PREFIXED AREA
         TM    RPODBSW,X'02'       DOUBLE BUFFERED ?
         BZ    RPOENT1A            NO, GOTO SINGLE BUFFER
RPOPASS  NOP   RPOPASS1            NOP FIRST TIME THROUGH
         L     R6,PPILAB04         LOAD ADDR OF BUFF 1 INTO REG R6
         SR    R6,R9               SUBTRACT 8 FROM BUFF ADDR
         ST    R6,RPOWRKC          SAVE ADJUSTED BUFF ADDR
         NI    RPOWRKC,X'00'
         MVI   RPOPASS+1,X'F0'     TURN BY PASS SWITCH ON
RPOPASS1 TM    RPOBF,X'01'         FIRST WRITE ?
         BO    RPONOWT             YES, BRANCH TO NO WAIT
         LA    R6,RPOENT1A         SET RETURN ADDR
         B     RPOSTAY             GOTO WAIT
*
RPONOWT  MVI   RPOBF,X'00'         TURN OFF WAIT SWITCH
RPOENT1A SR    R2,R9               CALC BEGINNING BUFFER ADDR
         IC    R9,PPIDEPHO+7       GET RECORD NUMBER
         BCTR  R9,0                DECREMENT RCD NUMBER
         STC   R9,IOBR             PUT IN IOB
         MVC   IOBCC(4),PPIDEPHO+3  SET SEARCH ADDR IN IOB
         MVC   0(5,R2),PPIDEPHO+3  SET DISK ADDR IN BUFFER
         SR    R6,R6
         IC    R6,PPIDEPHO         GET DCB ADDR INCREMENT
         L     R10,PPISTDCB        GET TABLE POINTER
         L     R10,0(R6,R10)       GET DCB ADDR
         ST    R10,IOBDCBPT        SET DCB POINTER IN IOB
         MVC   DCBFDAD+1(7),PPIDEPHO+1  SET CYL ADDR IN DCB
         LA    R9,2(,R9)           INCREMENT TO NEXT RCD
         STC   R9,PPIDEPHO+7       SET DEPHO TO NEXT RCD
         STH   R1,6(,R2)           SET BFR BYTE COUNT
         MVI   5(R2),X'00'         SET KL IN BUFFER
         MVI   WSWTRK,X'00'        TURN OFF FULL TRACK SWITCH
         CLC   4(1,R2),PPIBPTRK+1  WILL TRACK BE FULL?
         BL    RPONORML            LOW, BRANCH
         MVI   WSWTRK,X'01'        TURN ON FULL TRACK SWITCH
RPONORML LA    R5,IOBSTDRD         R5 - > IOB
         ST    R5,DCBIOBAD
         MVC   IOBSTRTB,HOLDPCW+1  SET PRIME CCW ADDR IN IOB
         MVC   WRPOREGC(4),RPOBUF1  ASS ADDR TO BLOCK ROUTINE
         TM    RPODBSW,X'02'       DOUBLE BUFFERS ?
         BO    RPODBL              YES, BRANCH TO DBL ROUTINE
         BAS   R14,RPOSUBRT
*
         IEREXCP  (R5)             WRITE DISK
*
         BAS   R6,RPOSTAY          CALL WAIT SUBROUTINE
RPOUPRCD TM    WSWTRK,X'01'        TRACK FULL ?
         BO    RPOFULTK            YES, BRANCH
RPOSEQTT TM    RPOEOSW,X'01'       EOS ?
         BO    RPOENDSQ            YES, GOTO EOS RETURN
RPOENT4  LM    R0,R15,WRPOREG      RESTORE REGS
         L     R11,PPIBLK2+4       SET RETURN REGISTER
         B     8(,R11)             GOTO BLOCK
*
RPODBL   C     R2,RPOWRKC          EQUAL COMPARE ?
         BE    RPO1                YES, BRANCH
         MVC   IOBSTRTB,IERALTCW+1  SET CCW PTR IN IOB
         LA    R14,RPODBLRT        SET RETURN REG
         B     RPOSUBRT            GO SET UP CCW
*
RPO1     MVC   WRPOREGC(4),RPOBUF2 PASS ADDR TO BLOCK ROUTINE
         BAS   R14,RPOSUBRT
*
RPODBLRT IEREXCP  (R5)             WRITE DISK
*
         B     RPOUPRCD            GOTO MAIN LINE
*
RPOSTAY  L     R10,IOBDCBPT        SET DCB BASE REG
*
         IERWAIT  1,ECB=(R12)      WAIT ON I/O COMPLETION
*
         TM    DCBIFLGS,DCBIFPEC   I/O ERROR ?
         BO    RPOTERM             YES, GO TERMINATE JOB
         LM    R0,R2,WRPOREG       RESTORE REGS
         BR    R6                  GOTO MAIN LINE
*
*        SET CCW UP FOR WRITING EITHER SINGLE OR DOUBLE BUFFERS
*
RPOSUBRT L     R8,IOBSTRTB-1       CCW POINTER
         LA    R1,8(,R1)           UP RECORD BYTE COUNT
         STH   R1,22(,R8)          STOW IN CCW
         BR    R14                 GOTO MAIN LINE
*
RPOENDSQ MVI   RPOEOSW,X'00'       TURN OFF EOS SWITCH
         MVI   RPOBF,X'01'         TURN ON FIRST TIME SWITCH
         TM    RPODBSW,X'02'       TWO BUFFERS ?
         BZ    RPOALGRT            NO, BRANCH
         BAS   R6,RPOSTAY
RPOALGRT LM    R0,R15,WRPOREG      RESTORE REGISTERS
         L     R11,PPIALG+4        SET RETURN REGISTER
         B     16(,R11)            GOTO ALGORITHM
*
RPOFULTK MVI   PPIDEPHO+7,X'01'    SET ADDR TO NEXT RCD
         MVI   WSWTRK,X'00'        TURN OFF FULL TRK SWITCH
         IC    R6,PPIDEPHO+6
         LA    R6,1(,R6)           INCREMENT TRACK COUNT
         STC   R6,PPIDEPHO+6       PUT IN PPI
         B     RPOSEQTT            GOTO EOS TEST
*
*        WRITE ERROR - TEST EXIT 28
*        EXECUTE USER MOD, AND TERMINATE THE JOB
*
RPOTERM  L     R3,DCBFDAD+3        LOAD DCB+3 INTO R3
         BCTR  R3,0                DECREMENT RCD NO BY 1
         ST    R3,DCBFDAD+3        STORE UPDATED DCB
         ICM   R15,B'1111',RPOUSERX  GET USER MOD ADDR
         BZ    RPOOFF              ZERO, NO ADDR TERMINATE
         ST    R5,PPIWKARE         SET IOB ADDR FOR USER
         MVI   PPIWKARE,X'10'
         L     R0,PPIWKARE
         LR    R1,R10              SET DCB ADDR FOR USER
         BASR  R14,R15             CALL USER ROUTINE
RPOOFF   ST    R4,RPOSVEME         SAVE ORIGINAL CONTENTS
         PPISETON PPIWRITE         WRITE ERROR FLAG
         L     R15,PPIADSSC        R15 -> SSC
         BAS   R14,16(,R15)        EXIT TO SSC
*
*        THIS ROUTINE IS ENTERED ON END OF SEQUENCE
*
RPOENT2  MVI   RPOEOSW,X'01'       TURN ON EOS SWITCH
         PPITEST  PPIVAR           VARIABLE LENGTH RECORDS ?
         BO    RPOVAR              YES, BRANCH
         MVC   0(4,R2),KEOS4       INDICATE EOS (FIXED)
         B     RPOENT1             GOTO MAIN LINE
*
RPOVAR   MVC   4(4,R2),KEOS4       INDICATE EOS (VARIABLE)
         B     RPOENT1             GOTO MAIN LINE
*
RPOENT5  DELETE EP=IERRC9          FREE CORE
*
         LTR   R15,R15             SUCCESSFULL ?
         BZ    RPOBUFCK            YES, BRANCH
         L     R15,PPIADSSC        NO, ERROR ON DELETE PRINT MESSAGE
         BAS   R14,28(,R15)
         L     R15,PPIADSSC        R15 -> SSC
         BAS   R14,16(,R15)        EXIT TO SSC
*
RPOTOALG L     R11,PPIALG+4
         B     0(,R11)             GOTO ALGORITHM
*
RPOBUFCK TM    PPILAB04,X'80'      NEED ANOTHER BUFFER ?
         BO    RPOTOALG            BUFFERS OK, BRANCH
         LH    R15,PPILAB07+2
         LA    R15,8(,R15)
         STH   R15,RPODISP+6
*
RPODISP  GETMAIN EC,LV=100,A=RPOADDR
*
         LTR   R15,R15             SUCESSFULL ?
         BNZ   RPOTOALG            NO, BRANCH
RPOBUFOK MVI   PPILAB07,2          CHANGE NO OF BUFFERS TO TWO
         MVI   RPODBSW,X'02'       SET DOUBLE SWITCH
         ST    R2,RPOREGSV         SAVE CONTENTS OF R2
         ST    R12,RPOREGSE        SAVE CONTENTS OF R12
         L     R2,RPOADDR
         LA    R2,8(,R2)
         ST    R2,PPILAB05         STORE NEW ADDR OF BUFFER 2
         PPITEST  PPIVAR           VARIABLE LENGTH RECORDS ?
         BO    RPOVVV              YES, BRANCH
         LA    R2,4(,R2)           CALC FIXED BUF ADDR
         B     RPOFIX
*
RPOVVV   LA    R2,8(,R2)           CALC VARIABLE BUF ADDR
RPOFIX   ST    R2,RPOBUF2
         L     R2,PPIGETSZ         LOAD ADDR OF SIZE TABLE
RPOCOMPR CLI   0(R2),X'80'         FIRST BYTE X'80' ?
         BE    RPOHIT              YES, BRANCH
         LA    R2,4(,R2)           INCREMENT REG BY 4
         B     RPOCOMPR            BRANCH BACK TO COMPARE
*
RPOHIT   MVI   4(R2),X'80'         SET NEW END OF TABLE MARKER
         MVC   5(3,R2),RPODISP+5   MOVE LENGTH OF BUFF INTO SIZE TABLE
         MVI   0(R2),X'00'         CLEAR END OF TABLE INDICATER
         S     R2,PPIGETSZ         SUBTRACT STARTING ADDR FOR DIFF
         A     R2,PPIGETMN         ADD ADDR OF TABLE TO DIFF
         MVC   4(4,R2),RPOADDR     MOVE ADDR OF BUFF INTO ADDR TABLE
         L     R12,PPISTIOB
         L     R12,0(,R12)
         LA    R9,8
         SR    R12,R9              SET IOB BASE REG TO PREFIXED AREA
         L     R2,IERALTCW
         MVC   17(3,R2),RPOADDR+1  MOVE ADDR INTO ALT CCW
         L     R2,RPOREGSV         RELOAD TRUE VALUE
         L     R12,RPOREGSE        RESTORE REG
         B     RPOTOALG
*
*        THIS ROUTINE WILL WRITE THE DIRECTORY
*
RPOENT3  STM   R0,R15,WRPOREG      SAVE REGS
         LA    R6,PPIWKARE         SET DIR ADDR
         L     R12,PPISTIOB
         L     R12,0(,R12)
         LA    R9,8
         SR    R12,R9              SET IOB BASE REG
         TM    RPODBSW,X'02'       TWO BUFFERS ?
         BZ    RPOGCHAR            NO, GOTO MAINLINE
         BAS   R6,RPOSTAY          CALL WAIT SUBROUTINE
RPOGCHAR IC    R9,PPIDIRAD+7       GET DIRECT RECORD NO
         BCTR  R9,0                DECREMENT R9 BY 1
         STC   R9,IOBR             STORE RECORD NUMBER INTO CCW
         MVC   IOBCC(4),PPIDIRAD+3       SET SEARCH ADDR IN IOB
         MVC   PPILAB01(64),PPIWKARE
         MVC   PPIWKARE+8(64),PPILAB01   REPOSITION DIRECTORY
         MVC   PPIWKARE+5(3),KDKBUFF     BUILD BUFFER INFO
         MVC   PPIWKARE(5),PPIDIRAD+3    SET CYL ADDR IN BUFFER
         LA    R7,RPOSKID
         STCM  R7,B'0111',IOBSTRTB  SET CCW PTR IN IOB
         SR    R7,R7
         IC    R7,PPIDIRAD
         L     R10,PPISTDCB
         L     R10,0(R7,R10)       SET DCB BASE REG
         ST    R10,IOBDCBPT        SET DCB PTR IN IOB
         LA    R5,IOBSTDRD         R5 -> IOB
         ST    R5,DCBIOBAD         CHAIN BACK TO DCB
*
         IEREXCP  (R5)
*
         BAS   R6,RPOSTAY          CALL WAIT
         LM    R0,R15,WRPOREG      RESTORE REGS
         L     R11,PPIALG+4        SET RETURN REGISTER
         BR    R14                 RETURN TO ALG
*
*        CHANNEL PROGRAM
*
RPOSKID  CCW   SEARIDEQ,RPOBUFAD,CC+SLI,5   SEARCH ID
         CCW   TIC,RPOSKID,CC+SLI,0         TIC
RPOBUFAD CCW   WRITECKD,RPOBUFAD,SLI,0      WRITECKD
         ORG   RPOBUFAD+7
RPOBYTES DC    AL1(72)                      RECORD LENGTH COUNT
         ORG
*
*        END THE CHANNEL PROGRAM
*
*        CONSTANTS AND WORK AREAS
*
RPOWRKC  DC    F'0'
RPOIOBSV DC    F'0'
RPOSVEME DC    F'0'
RPOADDR  DC    F'0'
RPOREGSV DC    F'0'
RPOREGSE DC    F'0'                EQUAL/EXTRACT ADDR
HOLDPCW  DC    F'0'
HOLDCC   DC    F'0'
WRPOREG  DC    2F'0'
WRPOREGC DC    14F'0'
RPOEOSW  DC    X'00'               END OF SEQUENCE SWITCH
RPOBF    DC    X'01'
RPODBSW  DC    X'00'
RPOBUF1  DC    F'0'
RPOBUF2  DC    F'0'
RPOIOBAD DC    F'0'
RPOUSERX DC    F'0'
KEOS3    DC    CL4'HHHH'           NOT EOS INDICATION
KEOS4    DC    CL4'HGHH'           EOS INDICATION
WSWEOA   DC    X'00'               END OF AREA SWITCH
WSWTRK   DC    X'00'               FULL TRACK SWITCH
KDKBUFF  DC    X'0000'             BUFFER CONSTANT
         DC    X'40'
*
./ ADD NAME=IER8BN   0101-20211-20211-1200-00086-00086-00000-RELEASE 00
BN8      TITLE 'IER8BN - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IER8BN
*
*        MODULE FUNCTION/OPERATION-
*        PHASE 3 RUNNING MODULE - VBS - NO EXITS
*        THE FUNCTION OF THIS MODULE IS TO BLOCK VARIABLE
*        SPANNED RECORDS THIS IS ACCOMPLISHED USING AN INLINE MOVE
*        ROUTINE AND THE PUT MACRO IN MOVE MODE. THE MOVE
*        ROUTINE MOVES THE RECORD FROM THE INPUT BUFFER TO THE
*        WORKAREA
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - IER9BN
*
*        MACROS USED -
*        SMPPI
*        PUT
*
*        ENTRY POINTS - ENTRY FROM MERGE NETWORK
*                       CALLING SEQUENCE -
*                           L    R11,PPIBLK+4
*                           B    0(R11)     LAST RECORD
*                           B    4(R11)     NORMAL
*
*                     - ENTRY FROM PUT
*                       CALLING SEQUENCE -
*                           BR   R14
*
*        INPUT PPI FIELDS REFERENCED - PPIDOOBA
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPICOUNT
*        ADDR OF WINNER IN OUTPUT BUFFER FOR MERGE SEQUENCE CHECK
*        RECORD COUNTER
*
*        EXTERNAL ROUTINES - NONE
*
*        EXTERNAL PARAMETERS - SEE REGISTERS
*
*        EXITS - NORMAL - EXIT TO DEBLOCK
*                         CALLING SEQUENCE -
*                             L    R11,PPIDEB+4
*                             B    4(,R11)
*
*                       - EXIT TO END OF JOB
*                             L    R11,PPIWRT+4
*                             BR   R11
*
*                       - EXIT TO PUT
*                             PUT  (R7)   R7 -> DCB
*
*        EXITS - ERROR - NONE
*
*        TABLE/WORK AREAS -
*        WDCB     - ADDR OF OUTPUT DCB
*        WINRCDAD - ADDR OF WINNER RCD IN INPUT BUFFER
*
*        NOTES -
*        THIS MODULE WILL EXECUTE FOR ANY VARIABLE LENGTH SORT
*        WITHOUT USER EXITS
*
IER8BN   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IER8BN SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IER8BNI
*
         PRINT NOGEN
*
         DCBD  DSORG=PS,DEVD=(DA,TA)
*
         PRINT NOGEN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IER8BNI  0101-20211-20211-1200-00090-00090-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IER8BN SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IER8BNI
*
         USING *,R11               MODULE BASE REG LOADED EXTERNALLY
         USING IERRCA,R13          ADDR OF PPI
         USING IHADCB,R1           DSECT FOR OUTPUT DCB
*
*        ENTRY TABLE
*
IERDB34  B     RBEOJ               +00 FROM MERGE, LAST RECORD
*
*        NORMAL ENTRY FROM MERGE
*        R3 -> INPUT RECORD
*
         ST    R3,WINRCDAD         +04 SAVE INPUT ADDR OF NEXT
*                                      OUTPUT RECORD
         L     R1,WDCB             R1 -> DCB
         MVC   DCBLRECL,0(R3)      MOVE L'RECORD IN DCB FOR PUT MACRO
         LH    R8,DCBLRECL         R8 = L'INPUT RECORD FOR MOVE RTN
RBNNOP   B     RBNFIRST            OVERLAID TO NOP BY FIRST RECORD
*
         L     R0,PPIDOOBA         R0 -> WORKAREA
*
         PUT   (1),(0)
*
RBNMOVE  LR    R4,R3               R4 -> INPUT RECORD
         L     R5,PPIDOOBA         R5 -> WORKAREA FOR OUTPUT RECORD
*
*        GENERALIZED MOVE RTN USED TO MOVE ANY SIZED DATA RECORD
*        FROM ONE DATA AREA TO ANOTHER
*        REGISTERS ON INPUT -
*        R4 -> DATA SOURCE
*        R5 -> DATA TARGET
*        R8 = L'DATA
*
*        IN ADDITION, THE ROUTINE USES REGISTERS R6 AND R7
*
*        THE ROUTINE DOES ALL INTERMEDIARY UPDATING OF
*        REGISTERS. UPON COMPLETION OF THE MOVE THE REGISTERS
*        CONTAIN-
*        R4 FROM ADDR UPDATED
*        R5 TO ADDR UPDATED
*        R8 REMAINING RECORD LENGTH SET TO ZERO
*
         LR    R6,R5               R6 -> DATA TARGET
         LR    R5,R8               R5 = L'DATA
         LR    R7,R8               R7 = L'DATA
         MVCL  R6,R4               MOVE DATA, NO PAD
         LR    R5,R6               R5 -> TARGET+1
         SR    R8,R8               R8 = REMAINING COUNT = 0
*
*        END OF GENERALIZED MOVE ROUTINE
*
         L     R6,PPICOUNT         LOAD RECORD COUNTER
         LA    R6,1(,R6)           INCR RECORD COUNTER BY 1
         ST    R6,PPICOUNT         SAVE RECORD COUNTER
*
*        INTERFACE TO DEBLOCK MODULE
*        R3 HAS INPUT RECORD ADDR OF WINNER, AND FILE NO IN
*        HI ORDER BYTE
*
         L     R11,PPIDEB+4        ADDR OF DEBLOCK MODULE
         B     4(,R11)             BR TO DEBLOCK MODULE
*
*        LAST RECORD WAS PUT
*        INTERFACE TO END OF JOB MODULE
*
RBEOJ    L     R1,WDCB             R1 -> DCB
         L     R0,PPIDOOBA
*
         PUT   (1),(0)
*
         L     R11,PPIWRT+4        ADDR OF END OF JOB MODULE
         BR    R11                 BRANCH TO END OF JOB MODULE
*
RBNFIRST NI    RBNNOP+1,X'00'      OVERLAY BRANCH TO NOP
         B     RBNMOVE             GOTO MOVE
*
*        WORKAREAS
*
WDCB     DC    F'0'                -> DCB FOR OUTPUT FILE LOADED
*                                     LOADED BY IER9BN
WINRCDAD DC    F'0'                INPUT ADDR OF NEXT OUTPUT RECORD
*
./ ADD NAME=IER8BO   0101-20211-20211-1200-00147-00147-00000-RELEASE 00
BO8      TITLE 'IER8BO - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IER8BO
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 3 RUNNING MODULE VBS WITH E35 EXIT
*        THE FUNCTION OF THIS MODULE IS TO BLOCK VARIABLE LENGTH
*        SPANNED RECORDS. TO ACCOMPLISH THIS IT USES A MOVE
*        ROUTINE AND QSAM PUT IN MOVE MODE
*        THE USER ROUTINE IS EXECUTED ONCE FOR EVERY RECORD
*        LEAVING THE MERGE. THE EXIT OCCURS AFTER THE RECORD TO
*        BE PUT LEAVES THE MERGE. THE USER MAY THEN DO THE
*        FOLLOWING
*        1. INSERT A RECORD
*        2. DELETE OR SUMMARIZE A RECORD, OR
*        3. DO NOTHING, ALTER, LENGTHEN, OR SHORTEN A RECORD.
*        THE USER RETURNS TO THE APPROPRIATE ROUTINE IN THIS
*        MODULE. THE MODULE LINKS TO THE PROPER DEBLOCK OR EOJ
*        MODULE WHEN NEEDED
*
*        LINKAGE FROM MODULE TO USER IS VIA THE CALL MACRO
*        LINKAGE FROM USER TO MODULE IS VIA RETURN REGISTER PLUS
*        PROPER DISPLACEMENT DEPENDING ON WHAT ROUTINE THE USER
*        WISHES TO RETURN TO
*
*        TWO PARAMETERS ARE PASSED TO THE USER. THE ADDR OF THE
*        RECORD LEAVING THE MERGE, AND THE STARTING ADDRESS OF
*        THE AREA IN THE WORKAREA INTO WHICH THE PREVIOUS RECORD
*        HAD BEEN PLACED
*
*        THE USER CAN PASS TWO PARAMETERS TO THE MODULE, THE
*        ADDRESS OF THE RECORD TO INSERT, DO NOTHING, ALTER,
*        LENGTHEN, SHORTEN IN R1, AND A 4 IF THE INTEGRITY OF THE
*        CONTROL FIELD OF THE RCD COMING FROM THE MERGE HAS BEEN
*        CHANGED OR A ZERO IF NO CHANGE, IN THE THIRD PARAMETER
*        OF THE PARAMETER LIST
*
*        THE MODULE PASSES THESE PARAMETERS TO THE MERGE FOR
*        SEQUENCE CHECKING AGAINST THE NEXT RECORD THE MERGE
*        PASSES TO THE MODULE
*
*        AT EOJ, MODULE ZEROS OUT PARAM 1 OF THE PARAM LIST TO
*        USER
*
*        MODULES IN WHICH THIS MODULE APPEARS AS A DSECT -
*        IER9BO
*
*        MACROS USED BY THE MODULE -
*        SMPPI
*        PUT
*
*        ENTRY POINTS - ENTRY FROM MERGE NETWORK
*                       CALLING SEQUENCE
*                           L    R11,PPIBLK+4
*                           B    0(R11)     LAST RECORD
*                           B    4(R11)     NORMAL
*
*                     - ENTRY FROM PUT
*                       CALLING SEQUENCE -
*                           BR   R14
*
*                     - ENTRY FROM IERRPG
*                       CALLING SEQUENCE -
*                           L    R11,PPIBLK+4
*                           B    0(R11)     ZERO INPUT FILE
*
*                     - ENTRY FROM EXIT E35
*                       CALLING SEQUENCE -
*                           RETURN  RE=(15) R14 = RETURN REG
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPICOUNT   PPIX35    PPIDOOBA
*        PPIDEB     PPIGETMN
*        VARIOUS ADDRESSES AND COUNTERS
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED - PPICOUNT
*        PPIDOOBA
*        UPDATE COUNTERS AND OUTPUT BUFFER ADDRESSES
*
*        EXTERNAL ROUTINES - NONE
*
*        EXTERNAL PARAMETERS - SEE REGISTERS
*
*        EXITS - NORMAL - EXIT TO DEBLOCK
*                         CALLING SEQUENCE -
*                              L    R11,PPIDEB+4
*                              B    4(,R11)
*
*                         EXIT TO OS PUT MOVE MODE
*                         CALLING SEQUENCE
*                              L    R5,WDCB       DCB ADDRESS
*                              L    R0,WOPBUFAD   WORKAREA ADDR
*                              PUT  (R5),(R0)
*
*                         EXIT TO IERRPG
*                         CALLING SEQUENCE-
*                              L    R11,PPIWRT+4
*                              BR   R11
*
*                         EXIT TO EXIT E35
*                         CALLING SEQUENCE -
*                              L    R15,PPIX35+4
*                              BALR R14,R15
*
*        EXITS - ERROR - NONE
*
*        TABLES/WORK AREAS -
*        WRCDLGTH - L'RECORD TO MOVE TO OUTPUT BUFFER
*        WMRGRCD  - ADDR OF WINNER RECORD IN INPUT BUFFER
*        WOPBUFAD - ADDR OF WINNER RECORD IN WORKAREA FOR QSAM PUT
*        WINTEGSW - SEQUENCE CHECK SWITCH SET BY USER
*        WDCB     - OUTPUT DCB ADDR
*        WINSRTSW - INSERT SWITCH IS TURNED ON FOR INSERTING RECORDS
*        WSYSEOF  - SYSTEM END OF FILE SW TURNED ON WHEN INPUT
*                   EOF IS REACHED
*        WUSREOF  - USER END OF FILE SWITCH IS TURNED ON AFTER
*                   USER REACHES EOF
*
*        NOTES -
*        THE MODULE IS EXECUTED FOR ANY VAR SPANNED OUTPUT SORT
*        WITH USER EXIT E35
*
IER8BO   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IER8BO SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IER8BOI
*
         PRINT NOGEN
*
         DCBD  DSORG=PS,DEVD=(TA,DA)
*
         PRINT GEN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IER8BOI  0101-20211-20211-1200-00159-00159-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IER8BO SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IER8BOI
*
         USING *,R11               MODULE BASE REG LOADED EXTERNALLY
         USING IERRCA,R13
         USING IHADCB,R5
*
*        ENTER BRANCH TABLE FROM MERGE OR READ PRIME RTN
*
IERDB34  B     RBSETREG            +00 FROM MERGE, LAST RECORD, OR
*                                      FROM READ PRIME ZERO INPUT FILE
         LM    R6,R8,PPICOUNT      +04 RESTORE COUNTERS
RBSETPAR ST    R3,WMRGRCD          SET PARAMETER 1 OF 2 FOR CALL MACRO
*                                  ADDR OF NEXT RCD FROM MERGE TO PUT
*
*        CALL USER EXIT E35
*
RBUSREXT LA    R1,WMRGRCD          PARAM LIST ADDR WILL BE OVLAYED BY
*                                  B RBLOADRE ON USER EOF
         L     R15,PPIX35+4        IF ATTACHED, PPIX35 WILL HAVE ADDR
*                                  OF ATTACHED EXIT FROM PPI
         MVC   UEXIT,PPIUEXIT      SETUP PARAMETER LIST
         BASR  R14,R15             CALL USER EXIT
         MVC   PPIUEXIT,UEXIT      SAVE USER EXIT WORD FOR NEXT CALL
*
*        USER RETURNS TO MODULE VIA RETURN REG AND PROPER
*        DISPLACEMENTS
*
         B     *+4(15)             +00 ENTRY POINT
         B     RBALSHNO            +04 ALTER,LENGTHEN,SHORTEN,NOTHG RTN
         B     RBDELSUM            +08 DELETE - SUMMARIZE RTN
         B     RBUSREOF            +12 USER END OF FILE ROUTINE
*
*        INSERT A RECORD
*
RBINSRT1 OI    WINSRTSW,X'01'      TURN INSERT SWITCH ON
         LA    R8,1(,R8)           INCR INSERT CTR BY ONE
         LA    R6,1(,R6)           INCR RCD COUNTER BY ONE
RBOVLAY  B     RBLOADRE            BR TO LOAD ADDR OF RCD FOR MOVE RTN
*
*        ALTER, LENGTHEN, SHORTEN, DO NOTHING TO THE INPUT
*        RECORD FROM THE MERGE
*
RBALSHNO NOP   0
*
RBLOADRE MVC   WRCDLGTH+2(2),0(R1)  MOVE RECORD LEN TO A BOUNDARY. R1
*                                   WILL BE OVLAYD BY R3 ON USER EOF
RBOVLAY1 LR    R4,R1               STORE ADDR OF RCD FROM THE MERGE IN
*                                  MOVE RTN REG. THIS INSTR WILL BE
*                                  OVLAYD BY LR R4,R3 ON USER EOF
RBONOP   B     RBOFIRST  ÝMAYBE NOP¨ CHANGED TO NOP BY FIRST RECORD
*
         L     R0,WOPBUFAD         R0 -> WORKAREA
         L     R5,WDCB             R5 -> DCB
         MVC   DCBLRECL,WRCDLGTH+2  L'RECORD
*
         PUT   (5),(0)
*
RBOMOVE  L     R5,WOPBUFAD
         STM   R6,R8,PPICOUNT      SAVE COUNTERS
         L     R8,WRCDLGTH         L'RCD FOR MOVE RTN
*
*        GENERALIZED MOVE RTN USED TO MOVE ANY SIZE DATA RECORD
*        FROM ONE DATA AREA TO ANOTHER
*
*        REGISTERS USED -
*        R4 -> SOURCE DATA
*        R5 -> TARGET
*        R8 =  L'SOURCE DATA
*
*        IN ADDITION THE ROUTINE USES R6 AND R7
*
         LR    R6,R5               R6 -> TARGET
         LR    R5,R8               R5 = L'DATA
         LR    R7,R8               R7 = L'DATA
         MVCL  R6,R4               MOVE DATA, NO PAD
         LR    R5,R6               R5 -> TARGET+1
         SR    R8,R8               R8 = REMAINING COUNT = 0
*
*        END OF GENERALIZED MOVE ROUTINE
*
         LM    R6,R8,PPICOUNT      RESTORE REGISTERS
         CLI   WINSRTSW,X'00'      TEST INSERT SWITGH
         BZ    RBDOOBA             OFF, BRANCH TO STORE ADDR OF OUTPUT
*                                  RECORD IN PPI
         NI    WINSRTSW,X'00'      TURN INSERT SWITCH OFF
         B     RBUSREXT            BRANCH TO USER EXIT
*
RBDOOBA  LA    R6,1(,R6)           INCREMENT RECORD CTR BY ONE
RBDEBLK  STM   R6,R8,PPICOUNT      SAVE COUNTERS
*
*        INTERFACE TO DEBLOCK MODULE
*        R3 HAS FILE NO OF WINNER IN 1ST BYTE
*
         L     R11,PPIDEB+4        DEBLOCK ADDR
         B     4(,R11)             BRANCH TO DEBLOCK MODULE
*
*        LAST RECORD AND ZERO INPUT FILE ROUTINE
*
RBSETREG LM    R6,R8,PPICOUNT      RESTORE COUNTERS
         SR    R3,R3               ZERO WINNER REG (PARAM 1 TO USER)
         OI    WSYSEOF,X'01'       SET SYSTEM END OF FILE SWITCH
         CLI   WUSREOF,X'00'       USER END OF FILE SWITCH ON ?
         BNE   RBEOJ               ON, BRANCH TO END OF JOB MODULE
         B     RBSETPAR            OFF, BRANCH TO USER ROUTINE
*
*        USER END OF FILE ROUTINE
*
RBUSREOF OI    WUSREOF,X'01'       SET USER END OF FILE SWITCH
         MVC   RBUSREXT,RBOVLAY    OVERLAY USER EXIT (BYPASS EXIT E35)
         MVI   RBLOADRE+4,X'30'    OVERLAY INSTR (CHANGES R1 TO R3)
         MVI   RBOVLAY1+1,X'43'    OVERLAY INSTR (CHANGES R1 TO R3)
         CLI   WSYSEOF,X'00'       SYSTEM END OF FILE SWITCH ON ?
         BNE   RBEOJ               ON, BRANCH TO END OF JOB MODULE
         PPITEST  PPIATT           ATTACHED SORT ?
         BO    RBEOJ               YES, BRANCH TO EOJ
         B     RBLOADRE            BRANCH TO LOAD ADDR OF RCD IN R3
*
*        LINKAGE TO END OF JOB MODULE
*
RBEOJ    L     R5,WDCB             R5 -> DCB
         L     R0,WOPBUFAD         R0 -> WORKAREA
*
         PUT   (5),(0)
*
         L     R11,PPIWRT+4        END OF JOB ADDR
         BR    R11                 EOJ EXIT TO MODULE NAMED IERRPG
*
*        DELETE OR SUMMARIZE A RECORD
*
RBDELSUM LA    R7,1(,R7)           INCR DELETE SUMMARIZE CTR BY ONE
         ICM   R11,B'1111',PPICOUNT  ANY RECORDS GONE THRU ?
         B     RBDEBLK             BRANCH TO DEBLOCK MODULE LINKAGE
*
RBOFIRST NI    RBONOP+1,X'00'
         B     RBOMOVE
*
*        WORK AREAS
*
WRCDLGTH DC    F'0'                RECORD LENGTH
*
*        E35 PARAMETER LIST
*
WMRGRCD  DC    A(0)                PARAM 1, -> NEXT RECORD TO BE PUT
WOPBUFAD DC    A(0)                PARAM 2, -> WORKAREA FOR PUT
UEXIT    DC    F'0'                PARAM 3, USER EXIT WORD
*
WDCB     DC    A(0)                -> DCB FOR OUTPUT FILE
*                                  SET BY IER9BO
WINSRTSW DC    X'00'               INSERT SWITCH
WSYSEOF  DC    X'00'               SYSTEM END OF FILE SWITCH
WUSREOF  DC    X'00'               USER END OF FILE SWITCH
*
./ ADD NAME=IER8DJ   0101-20211-20211-1200-00060-00060-00000-RELEASE 00
DJ8      TITLE 'IER8DJ - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IER8DJ
*
*        MODULE FUNCTION/OPERATION -
*        THE MODULE HANDLES VARIABLE SPANNED RECORDS BY WAY OF
*        THE DATA MANAGEMENT GET MACRO IN MOVE MODE. IT THEN
*        PASSES THE INPUT RECORD ADDRESS IN THE WORKAREA TO THE
*        MERGE PHASE
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - IER9BJ
*
*        MACROS USED BY MODULE - GET
*
*        ENTRY POINTS - ENTRY FROM BLOCK
*                       CALLING SEQUENCE -
*                       L     R11,PPIDEB+4
*                       B     4(R11)
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIGETMN+M+3 - START OF TABLE WITH WORKAREA ADDR
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED - NONE
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL - MERGE NETWORK
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS -
*        WORKAREA AT WORKGET CONTAINS ADDR OF THE WORKAREA TABLE
*        FOR GET
*
*        NOTES -
*        THIS MODULE IS USED FOR VARIABLE SPANNED RECORDS ON
*        MERGE ONLY
*
IER8DJ   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IER8DJ SOURCE
*
*----------------------------------------------------------------------
*
         COPY IER8DJI
*
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IER8DJI  0101-20211-20211-1200-00037-00037-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IER8DJ SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IER8DJI
*
*
         USING *,R11
         USING IERRCA,R13          PPI BASE REGISTER
*
IERDD34  B     *                   +00 DUMMY ENTRY, NOT USED
*
*        REAL ENTRY POINT
*
         L     R6,PPISTDCB         +04 R6 -> DCB TABLE
         SRL   R3,24               ACCESS INCREMENT
         L     R5,0(R3,R6)         R5 -> APPROPRIATE DCB
         L     R6,WORKGET          R0 -> APPROPRIATE WORKAREA
         L     R0,0(R3,R6)               FOR QSAM GET RTN
*
         GET   (R5),(0)
*
*        ADDR OF NEW RECORD IN R1
*
         SLL   R3,24               SET WINNER ADDR IN R3 AND PLACE
         AR    R3,R1               INCREMENT IN HIGH ORDER BYTE
         L     R11,PPINET+4        EXIT TO MERGE
         B     8(,R11)             MERGE RTN
*
*        CONSTANTS
*
WORKGET  DC    A(0)                ADDR OF WORKAREA TABLE FOR QSAM GET
*                                  SET BY IER9DJ
*
./ ADD NAME=IER8GB   0101-20211-20211-1200-00208-00208-00000-RELEASE 00
GB8      TITLE 'IER8GB - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IER8GB
*
*        MODULE FUNCTION/OPERATION -
*        INTERMEDIATE MERGE PHASE READ ROUTINE USED FOR THE
*        THE CRCX ALGORITHM
*
*        BEGINS EACH MERGE PASS OR SUBPASS BY PRIMING EACH OF
*        M AREAS WITH THE FIRST BLOCK OF M SEQUENCES FROM M DISK
*        AREAS. IT MAKES AVAILABLE TO THE MERGE NETWORK THE
*        FIRST LOGICAL RECORD FROM EACH SEQUENCE. THEREAFTER IT
*        SUPPLIES THE DEBLOCK ROUTINE WITH FULL BUFFERS EACH TIME
*        A BUFFER IS EMPTIED. IT USES THE EXCP MACRO TO READ AND
*        THE WAIT MACRO TO CHECK FOR CORRECT COMPLETION OF A
*        READ.
*
*        IT INFORMS THE NETWORK WHENEVER EOS IS REACHED ON A
*        FILE. IT DETECTS EOS BY EXAMINING THE 4 BYTE EOS
*        INDICATION AT THE BEGINNING OF EACH BUFFER. AN EOS
*        INDICATION OF HHHH INDICATES A NORMAL BLOCK. AN
*        INDICATION OF HGHH INDICATES AN EOS BLOCK.
*
*        THE ADDRESS OF THE DISK AREA FROM WHICH THE READ
*        ROUTINE WILL READ IS FOUND IN ONE OF TWO WAYS -
*        1.  AT PRIMING TIME OR AFTER AN EOS, THE ALGORITHM
*            PLACES THE AREA ADDRESS(ES) IN PPIWKARE.
*        2.  UNDER NORMAL CONDITIONS, THE DISK CHAIN ADDRESS IN
*            THE BUFFER CONTAINS THE ADDRESS OF THE NEXT AREA TO
*            BE READ FOR THAT FILE
*
*        THIS MODULE IS ALSO DIRECTLY CONCERNED WITH BUFFERING
*        AND OVERLAP. IF THERE ARE 2M BUFFERS, IT IS ALWAYS
*        WORKING WITH FULL OVERLAP. IF THE NUMBER OF BUFFERS IS
*        FROM M TO 2M-1, THE ROUTINE TRIES TO GAIN AS MUCH
*        OVERLAP AS POSSIBLE BY IMPLEMENTING THE FOLLOWING IDEA.
*        WHENEVER A READ IS COMPLETED ON A FILE THAT HAS 2
*        BUFFERS ASSOCIATED WITH IT, THIS ROUTINE TRIES TO ATTACH
*        THE ALTERNATE BUFFER FROM THAT FILE TO THE FILE WITH
*        THE LOWEST BLOCK COUNT, (I.E. THE FILE THAT WILL
*        PROBABLY HAVE THE NEXT EMPTY BUFFER AND THUS REQUIRE THE
*        NEXT READ). IN THIS WAY, OVERLAP MAY BE INCREASED BY NOT
*        HAVING TO WAIT FOR THE NEXT READ TO COMPLETE.
*
*        IF IOS DETECTS AN UNCORRECTABLE ERROR WHILE READING,
*        THE SORT IS TERMINATED UNLESS THE USER HAS SUPPLIED AN
*        ERROR OPTION BY ACTIVATING E28. IF A SYNCHRONOUS ERROR
*        EXIT ROUTINE ALSO IS PRESENT, THE READ ROUTINE WILL GIVE
*        CONTROL TO IT. WHEN CONTROL IS RETURNED, THE READ
*        PROCEEDS IN ACCORDANCE WITH THE ERROR OPTION SPECIFIED
*        BY E28. THE POSSIBLE OPTIONS ARE -
*        1. TERMINATE THE JOB
*        2. ACCEPT THE BLOCK IN ERROR AND CONTINUE
*        3. SKIP THE BLOCK IN ERROR AND CONTINUE WITH THE NEXT BLOCK
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - IER9GB
*
*        MACROS USED -
*        SMPPI
*        EXCP
*        WAIT
*        DCBD
*
*        ENTRY POINTS - ENTRY FROM ALGORITHM AFTER READ EOS
*                         CALLING SEQUENCE
*                         L     R11, PPIRD+4
*                         BR    R11
*
*                     - ENTRY FROM ALGORITHM FOR PRIMING
*                         CALLING SEQUENCE
*                         L     R11,PPIRD+4
*                         B     4(R11)
*
*                     - ENTRY FROM DEBLOCK TO FILL AN EMPTY BUFFER
*                         CALLING SEQUENCE
*                         L     R11,PPIRD+4
*                         B     8(R11)
*
*                     - ENTRY FROM ALGORITHM AFTER RELEASING A TRACK
*                         CALLING SEQUENCE
*                         L     R11,PPIRD+4
*                         BR    R14
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPISTDCB   PPIWKARE   PPISBLCT
*        PPIPSVA    PPISTIOB   PPILAB02
*        PPISRTBL   PPIDEPHO   PPIMRGMX
*        PPILAB07   PPIRCDL2   PPICNTL
*        PPIBLK2    PPIALG     PPINETM
*        PPIDEB2
*
*        PHYSICAL RECORDS ON DISK AREAS ARE READ INTO STORAGE.
*        THE FORMAT OF THE BLOCKS ARE AS FOLLOWS -
*
*         ___________________
*        |                   |
*        | BLOCK CHAR COUNT  |  +00 4 BYTES - PRESENT ONLY FOR
*        |___________________|                VARIABLE LENGTH RECORDS
*        |                   |
*        |  DISK TTR CHAIN   |  +04 8 BYTES   MB000TTR
*        |     ADDRESS       |
*        |___________________|
*        |   EOS INDICATION  |  +12 4 BYTES   HHHH | HGHH
*        |___________________|
*        |                   |  +16 DATA
*        |                   |
*        |    LOGICAL        |
*        |    RECORDS        |
*        |                   |
*        |                   |
*        |                   |
*        |___________________|
*
*
*        ALL DISK ADDRESSES ARE ARE OF THE FORM MB000TTR WHERE -
*        M  = DCB INCR FOR PHYSICAL AREA BEING READ FROM
*        B  = LOGICAL DCB INCREMENT SPECIFYING THE ORIGINAL OF M
*             AREAS WITH WHICH THE SEQUENCE WAS ASSOCIATED
*        TT = RELATIVE TRACK ADDR
*        R  = RECORD NUMBER
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED - N/A
*
*        FULL BUFFER IS ACCESSED FOR THE DEBLOCK ROUTINE
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL - TO DEBLOCK ROUTINE WITH FULL BUFFER
*                           L     R11,PPIBLK2+4
*                           B     4(0,R11)
*
*                       - TO BUFFER TABLE PRIME ROUTINE AFTER PRIMING
*                           L     R11,PPIDEB2+4
*                           BR    R11
*
*                       - TO MERGE NETWORK ON EOS
*                           L     R11,PPINETM+4
*                           B     4(0,R11)
*
*                       - TO ALGORITHM ON EOS TO DETERMINE IF FILE
*                         CAN BE PRIMED FOR NEXT PASS
*                           L     R11,PPIALG+4
*                           B     20(0,R11)
*
*                       - TO ALGORITHM TO RELEASE A TRACK
*                           L     R11,PPIALG+4
*                           BAL   R14,16(0,R11)
*
*        EXITS - ERROR -
*        TO USER'S SYNCHRONOUS ERROR ROUTINE (E28) ON PERMANENT
*        I/O ERROR TO SSC TO TERMINATE THE JOB
*
*        TABLES/WORK AREAS -
*        FILE COUNT TABLE - CONTAINS DCB INCREMENT AND BLOCK
*        COUNT FOR EACH FILE. USED IN PARTIAL OVERLAP TO
*        DETERMINE WHICH FILE SHOULD HAVE AN ALTERNATE BUFFER
*
*        NOTES - N/A
*
IER8GB   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IER8GB SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IER8GBI
*
*        CCW EQUATES
*
         IERCCWEQ
*
*        DSECTS
*
         IERIOB
*
         PRINT NOGEN
*
*        MAP DEB
*
         IEZDEB LIST=NO
*
*        MAP UCB
*
UCB      DSECT
*
         IEFUCBOB PREFIX=NO,LIST=NO
*
*        MAP ECB
*
         IHAECB
*
         DCBD  DEVD=(DA)
*
         PRINT GEN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IER8GBI  0101-20211-20211-1200-00577-00577-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IER8GB SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IER8GBI
*
         USING *,R11               PROGRAM BASE REG
         USING IOBSTDRD,R5         IOB BASE
         USING IHADCB,R7           DCB BASE REG
         USING IERRCA,R13          PPI BASE REG
*
         B     RGC080              +00 FROM ALG ON PREVIOUS READ EOS
         B     RGC250              +04 FROM ALG AT PRIMING TIME
         STM   R2,R10,KSAVE+4      +08 NORMAL ENTRY FROM DEBLOCK RTN
*                                      TO READ THE NEXT BLOCK
*        ON ENTRY -
*        R2 -> EMPTY BUFFER FROM PREVIOUS READ
*        R3  = LOGICAL FILE INCREMENT (M)
*
         ST    R2,KEMPTY           SAVE EMPTY BUFFER ADDR FOR LATER
*
*        USE M PASSED IN R3 TO LOCATE THE DCB AND IOB
*
         L     R7,PPISTDCB         R7 -> DCB TABLE
         L     R7,0(R3,R7)         INCR PLUS R7 -> DCB
         L     R5,DCBIOBAD         R5 -> IOB FROM DCB
*
*        TEST FOR EODS INDICATOR SET (HGHH) IN BUFFER
*
RGC010   CLI   9(R2),C'G'          EMPTY BUFFER LAST ONE IN SEQ ?
*                                  DSPL=13 FOR VAR RCDS
         BE    RGC060              YES, BRANCH
         L     R1,IOBECBPT         NO
         TM    4(R1),X'02'         DOUBLE BUFFERING ?
         BO    RGC050              YES, BRANCH
*
*        SINGLE BUFFERING
*
*        ISSUE ANOTHER READ TO OBTAIN FULL BLOCK FOR DEBLOCK
*        ROUTINE
*
         BAS   R8,EXCP010          CALL READ
         BAS   R6,WAITRTN          CALL WAITRTN
         B     RGC040              GOTO EXIT
*
RGC050   BAS   R6,WAITRTN          DOUBLE BUFFERS - WAIT ON LAST EXCP
*
*        IF LAST EXCP COMPLETED SUCCESSFULLY -
*        WAITRTN WILL SET THE FOLLOWING PARAMETERS AND RETURN HERE
*
*        R1       = COUNT OF AMOUNT OF DATA IN BUFFER
*        R2      -> BUFFER READ INTO
*        KSAVE+4 -> FIRST RECORD IN THE BUFFER
*        IOBSEEK  = M0000TTR OF NEXT RECORD TO READ
*
RGC020   CLI   9(R2),C'G'          AN EOS BUFFER ? (HGHH)
*                                  DSPL=13 FOR VAR RCDS
         BE    RGC040              YES, BRANCH
RGC030   B     RGC110  ÝMAYBE NOP¨ SET BY IER9GB TO NOP IF FULL
*                                  OVERLAP - B FOR PARTIAL OVERLAP
RGC035   BAS   R8,EXCPRTN          ISSUE NEXT READ ON FILE
*                                  WAIT RTN WILL HAVE PRIMED IOBSEEK
*                                  WITH THE SEEK ADDR OF NEXT RECORD
*
*        RETURN TO DEBLOCK ROUTINE SETTING FOLLOWING PARAMETERS -
*                                                          KSAVE
*        R1  = BLOCK COUNT FOR FULL BUFFER                 +00
*              FIXED RECORDS    - NO OF RECORDS IN BUFFER
*              VARIABLE RECORDS - NO OF BYTES IN BUFFER
*        R2 -> FIRST DATA RECORD WITHIN FULL BUFFER        +04
*        R3  = LOGICAL INCR FOR FILE                       +08
*        R4 -> FULL BUFFER                                 +12
*
RGC040   LM    R1,R10,KSAVE        SET UP PARAMETERS
         L     R11,PPIBLK2+4       EXIT TO DEBLOCK
         B     4(,R11)             TO DEBLOCK
*
*        EMPTY BUFFER RETURNED BY DEBLOCK WAS EOS BUFFER
*
*        IF IT IS THE LAST RECORD ON THE TRACK IT WILL HAVE BEEN
*        PREVIOUSLY RELEASED BY WAIT ROUTINE
*
RGC060   STM   R2,R7,KSAVE2        SAVE IOB AND DCB ADDR
         CLC   IOBR,PPIBPTRK+1     LAST RECORD ON TRACK ?
         BE    RGC070              YES, BYPASS RELEASE OF TRACK
*                                  AS RELEASED PREVIOUSLY
*        SETUP TO RELEASE TRACK
*
         L     R7,IOBDCBPT         R7 -> DCB
         MVC   PPIWKARE(8),IOBSEEK   MOVE M0000TTR INTO PPIWKARE
         MVC   PPIWKARE(1),DCBOPTCD  M FROM DCBOPTCD
         L     R11,PPIALG+4        R11 -> ALG
         BAS   R14,16(,R11)        RELEASE A TRACK AFTER READ
*
*        ALGORITHM RETURNS HERE AFTER RELEASING TRACK
*
RGC070   L     R1,KSAVE+8     ÝR3¨ TO ALG TO DETERMINE IF THIS BUFFER
*                                  CAN BE PRIMED FOR THE NEXT PASS
         L     R11,PPIALG+4        PASS LOGICAL INCR TO ALG
         B     20(,R11)            EXIT TO ALG, READ AT EOS
*
*        ENTRY - FROM ALGORITHM - AFTER READ EOS
*
*        DETERMINE WHETHER ANOTHER READ SHOULD BE ISSUED ON THIS
*        FILE
*        R1 = 0 - NO MORE READS
*        R1 = 4 - ISSUE ANOTHER READ
*        PPIWKARE CONTAINS MB000TTR ADDR OF NEXT RECORD TO BE
*        READ IF A READ IS TO BE PERFORMED
*
RGC080   LM    R2,R7,KSAVE2
         LTR   R1,R1               ISSUE ANOTHER READ ?
         BZ    RGC100              NO, BRANCH
         MVC   IOBSEEK,PPIWKARE    MOVE MB000TTR DASD ADDR FROM ALG TO
*                                  IOBSEEK FOR CONVERSION IN EXCPRTN
         BAS   R8,EXCP010          READ
         L     R1,IOBECBPT
         OI    4(R1),X'80'         SET SW TO BYPASS THIS FILE IN PRIME
RGC100   LM    R1,R10,KSAVE
         L     R11,PPINETM+4       TO MERGE NETWORK CUTBACK RTN
         B     4(,R11)             EXIT TO NETWORK
*
*        PARTIAL OVERLAP PROCESSING
*
*        FULL OVERLAP DOES NOT EXIST ON ALL FILES
*        TOTAL NUMBER OF BUFFERS IS BETWEEN M AND 2M. DETERMINE
*        WHICH FILE THE EMPTY BUFFER SHOULD BE ATTACHED TO FOR NEXT
*        READ
*
RGC110   LA    R2,TFCNT            SCAN FILE COUNT TABLE
         L     R1,PPISBLCT         R1 -> BLOCK COUNT TABLE
         LH    R6,KMRGMX
         LA    R4,PPIPSVA          R4 -> MERGE NETWORK PRIME SAVE AREA
         SR    R14,R14
         ST    R14,0(R3,R1)        SET RELEASED FILE'S BUFFER COUNT = 0
RGC120   IC    R14,0(,R2)          UPDATE FILE COUNT TABLE BY ADDING
         L     R15,0(R14,R1)       APPROPRIATE DEBLOCK COUNTS TO
         A     R15,0(,R2)          CORRESPONDING ENTRY
         ST    R15,0(,R4)
         LA    R2,4(,R2)
         LA    R4,4(,R4)
         BCT   R6,RGC120           DO NEXT ENTRY
         LA    R2,PPIPSVA          SET UP CONSTANTS AND POINTERS
         LH    R1,KMRGMX           FOR SCAN
         STC   R3,RGC140+1
         LR    R4,R2
         B     RGC140              START SEARCH
*
*        SCAN TABLE FOR LOWEST FILE COUNT
*        NOT INCLUDING THE RELEASED FILE COUNT
*
RGC130   LA    R4,4(,R4)
         CLC   1(3,R2),1(R4)       LOWER ?
         BH    RGC180              NO, BRANCH
RGC140   CLI   0(R4),X'00'         YES, THE RELEASED FILE ?
         BE    RGC190              YES, BRANCH
RGC150   BCT   R1,RGC130           NO, FALL THRU AT END OF SCAN
*                                  OTHERWISE SEARCH NEXT ELEMENT
         LA    R0,PPIPSVA          OBTAIN FILE COUNT ADDR VIA
         SR    R2,R0               DISPLACEMENTS OF LOWEST AND
         SR    R15,R0              RELEASED FROM PPIPSVA
         LA    R0,TFCNT
         AR    R15,R0
         AR    R2,R0
         L     R4,IOBECBPT
         MVI   4(R4),X'01'         RELEASED FILE'S NO OF BUFFERS
         LR    R14,R5
         IC    R1,0(,R2)           R1 = INCR (M)
         L     R7,PPISTDCB
         L     R7,0(R1,R7)         R7 -> DCB
         L     R5,DCBIOBAD         R5 -> IOB
         L     R4,IOBSTART         R4 -> CCW STRING
         L     R4,16(,R4)          R4 -> BUFFER
RGC160   CLI   9(R4),C'G'          EOS ON BUFFER ALREADY ATTACHED
         BNE   RGC166              TO FILE ? - NOT EOS
*                                  DSPL=13 FOR VAR RCDS
RGC164   LR    R5,R14              YES, GO BACK AND ATTACH ALT BUFFER
         B     RGC035              TO FILE IT WAS ON BEFORE
*
RGC166   L     R4,IOBECBPT         SET BASE FOR ECB
         TM    4(R4),X'80'         ALREADY PRIMED FOR NEXT MRG ?
         BO    RGC164              YES, BRANCH
RGC170   L     R4,0(,R2)           UPDATE NEW FILE COUNT AND RELEASED
         AH    R4,PPISRTBL         FILE COUNT
         ST    R4,0(,R2)
         L     R4,0(,R15)
         SH    R4,PPISRTBL
         ST    R4,0(,R15)
         B     RGC035              GO DO READ
*
RGC180   LR    R2,R4               ADDR OF LOWEST FILE COUNT IN PPI
         B     RGC140              SAVE AREA
*
RGC190   LR    R15,R4              ADDR OF RELEASED FILE COUNT IN PPI
         B     RGC150              SAVE AREA
*
*        ENTRY - FROM ALGORITHM - PRIMING ROUTINE
*
*        BEGIN NEW PASS OR SUBPASS
*        PPIWKARE CONTAINS M DISK ADDRS TO START READING FROM
*
RGC250   NOP   RGC260   ÝMAYBE B¨  SET TO BR AFTER FIRST TIME THROUGH
         OI    RGC250+1,X'F0'
         B     RGC270              GOTO PRIME
*
*        SWITCH IOB AND DCB ADDRS TO REFLECT NEW PASS
*
RGC260   SR    R2,R2
         SR    R3,R3
         IC    R2,KSV1             INCR FOR OLD OUTPUT DCB
         IC    R3,PPIDEPHO+1       INCR FOR NEW OUTPUT DCB
         L     R15,PPISTDCB        R15 -> DCB TABLE
         L     R7,0(R2,R15)
         L     R6,DCBIOBAD         R6 -> OUT IOB
         LR    R8,R7               R8 -> OLD OUT DCB
         L     R7,0(R3,R15)
         L     R10,DCBIOBAD        R10 -> INPUT IOB
         LR    R9,R7               R9 -> NEW OUT DCB
*
*        SWITCH POINTERS WITHIN THE CONTROL BLOCKS TO REFLECT THE
*        FOLLOWING OUTPUT IOB AND NEW OUTPUT DCB MUST REFERENCE
*        EACH OTHER INPUT IOB AND OLD OUTPUT DCB (NOW AN INPUT
*        DCB) MUST REFERENCE EACH OTHER
*
         LR    R7,R8
         LR    R5,R6
         ST    R10,DCBIOBAD
         ST    R9,IOBDCBPT
         LR    R7,R9
         LR    R5,R10
         ST    R6,DCBIOBAD
         ST    R8,IOBDCBPT
RGC270   LA    R4,PPIWKARE         R4 -> PPIWKARE. CONTAINS LIST OF
*                                  MB000TTR DISK ADDRS FOR PRIMING
         LA    R10,KPT             R10 -> PRIMING TABLE
RGC280   MVC   KSV1,PPIDEPHO+1     SAVE CURRENT OUTPUT INCR
         LH    R2,PPIMRGMX         R2 = COUNT OF NO AREAS TO BE PRIMED
         STH   R2,KMRGMX
*
*        BEGIN PRIMING LOOP
*
RGC290   L     R15,PPISTDCB
         SR    R3,R3
         IC    R3,1(R4)            R3 = LOGICAL INCR (M)
         STC   R3,KSAVE+11
         L     R7,0(R3,R15)        R7 -> LOGICAL DCB
         L     R5,DCBIOBAD         R5 -> ASSOCIATED IOB
         L     R9,IOBECBPT
         TM    4(R9),X'80'         FILE HAS ALREADY BEEN PRIMED ?
         BZ    RGC340              NO, GO PRIME
*
*        AREA HAS ALREADY BEEN PRIMED - SKIP READ
*
         NI    4(R9),X'7F'         RESET SW
         B     RGC300              SET FOR PRIME
*
RGC340   MVC   IOBSEEK,0(R4)       MOVE MB000TTR DASD ADDR FROM
*                                  PPIWKARE ENTRY TO IOBSEEK FOR
*                                  CONVERSION IN EXCP RTN TO MBBCCHHR
         ST    R7,IOBDCBPT         CHAIN IOB TO DCB
         BAS   R8,EXCP010          CALL EXCP READ RTN
*
RGC300   ST    R5,0(,R10)          STORE IOB ADDR INTO PRIMING TABLE
         MVC   0(1,R10),1(R4)      MOVE IN INCR (M) INTO PRIMING TABLE
         LA    R4,8(,R4)           INCR PPIWKARE TO NEXT ENTRY
         LA    R10,4(,R10)         INCR PRIMING TABLE TO NEXT ENTRY
         BCT   R2,RGC290           CONTINUE PRIMING LOOP
*
*        A READ HAS BEEN ISSUED ON EACH OF M AREAS
*        WAIT FOR COMPLETION OF EACH READ AND ISSUE A SECOND
*        READ IF FILE HAS AN ALTERNATE BUFFER
*
         LH    R0,PPIMRGMX         R0 = NUMBER OF AREAS
         LA    R10,KPT             R10 -> PRIMING TABLE
         LA    R9,TFCNT            R9 -> FILE COUNT TABLE
         LA    R4,PPIWKARE
*
*        BEGIN WAIT LOOP
*
*        PROCESS EACH ENTRY IN THE PRIMING TABLE
*
RGC310   L     R5,0(,R10)          R5 -> IOB
         L     R7,IOBDCBPT         R7 -> DCB
         BAS   R6,WAITRTN          CALL WAITRTN
*
*        IF THE LAST EXCP COMPLETED SUCCESSFULLY, WAITRTN WILL
*        SET THE FOLLOWING PARAMETERS -
*        R1  = L'DATA IN BUFFER
*        R2 -> BUFFER READ INTO
*        R1 AND R2 ARE ALSO STORED INTO KSAVE AND KSAVE+12
*        RESPECTIVELY
*
         L     R15,PPISBLCT        R15 -> BLOCK COUNT TABLE
         SR    R3,R3
         IC    R3,0(,R10)          GET INCR (M) FROM PRIMING TABLE
         ST    R1,0(R3,R15)        STORE L'DATA INTO BLOCK COUNT TABLE
         LH    R1,PPISRTBL         GET MAXIMUM BLOCK SIZE
         L     R14,IOBECBPT
         TM    4(R14),X'01'        ALT BUFFER ON THIS FILE ?
         BO    RGC320              NO ALT BUFFER
RGC315   CLI   9(R2),C'G'          ALT BUFFER, LAST BLOCK AN EOS ?
*                                  DSPL=13 FOR VAR RECORDS
         BNE   RGC350              NO, BRANCH TO ISSUE ANOTHER READ
RGC320   ST    R1,0(,R9)           YES, SET UP FILE COUNT TABLE
         STC   R3,0(,R9)           STORE INCR (M) IN TFCNT
RGC330   L     R6,KSAVE+4
         ST    R6,0(,R4)           SET PPIWKARE WITH INCR AND FIRST
         STC   R3,0(,R4)           RECORD ADDR FOR EACH OF M FILES
         LA    R4,4(,R4)           CHECK NEXT FILE
         LA    R10,4(,R10)         INCR PRIMING TABLE TO NEXT ENTRY
         LA    R9,4(,R9)           INCR FILE COUNT TABLE TO NEXT ENTRY
         BCT   R0,RGC310           LOOP TO PROCESS ALL THE WAITS
*
         LM    R1,R10,KSAVE
         L     R11,PPIDEB2+4       TO DEBLOCK PRIME ROUTINE TO SET UP
         BR    R11                 BUFFER TABLE
*
*        SET UP FILE COUNT TABLE AND ISSUE A READ ON THE
*        ALTERNATE BUFFER
*
RGC350   SLL   R1,1                2 * SORT BLOCKING
         ST    R1,0(,R9)
         STC   R3,0(,R9)
         STC   R3,KSAVE+11
         L     R14,4(,R14)         R14 -> ALTERNATE CCW LIST
         MVC   KEMPTY,16(R14)      KEMPTY = BUFFER ADDR
         BAS   R8,EXCPRTN          CALL EXCP READ
         B     RGC330              GO SET INCR AND ADDR
*
*        WAITRTN
*
*        THE FOLLOWING PARAMETERS ARE REQUIRED -
*        R5  -> IOB
*        R6   = RETURN ADDR
*
*        THE FOLLOWING PARAMETERS ARE SET BY THE WAIT SUBROUTINE
*        IF NO ERROR IS DETECTED -
*        R1  = COUNT OF AMOUNT OF DATA IN BUFFER
*        R2 -> BUFFER READ INTO
*        R1 AND R2 ARE ALSO STORED IN KSAVE AND KSAVE+12
*        RESPECTIVELY ADDR OF THE FIRST RECORD IN THE BUFFER
*        IS STORED IN KSAVE+4
*
WAITRTN  STM   R14,R0,KSAVE5
WAITRTNA L     R1,IOBECBPT         RETRY EXCP ENTRY, BYPASS REG SAVE
*
         IERWAIT  1,ECB=(1)        WAIT ON I/O COMPLETION
*
         L     R1,IOBECBPT         R1 -> ECB
         CLI   0(R1),ECBNORM       ECB POSTED NORMALLY ?
         BNE   WAIT065             NO, ERROR EXISTS
*
*        PROCESS RETURNED BUFFER
*
WAIT010  L     R2,IOBSTART         R2 -> CCW STRING
         ICM   R2,B'0111',17(R2)   R2 -> BUFFER FROM CCW
         LA    R2,0(,R2)           ZERO HI-ORDER BYTE
         ST    R2,KSAVE+12         KSAVE+12 = BUFFER ADDR
WAIT020  LA    R1,12               OVERLAID FOR VAR RCDS TO SET R1=16
         AR    R1,R2               R1 -> DATA IN BUFFER
         ST    R1,KSAVE+4          KSAVE+4 = DATA ADDR
         LH    R1,PPILAB07+2       DETERMINE NO OF BYTES READ
         SH    R1,IOBCSW+5         SUBTRACT CSW RESIDUAL COUNT
         SH    R1,K4               SUBTR 4 FOR EOS FIELD
         CLC   IOBR,PPIBPTRK+1     LAST RECORD ON THE TRACK ?
         BNE   WAIT030             NO
*
*        RELEASE THE TRACK
*
         STM   R1,R10,KSAVE2
         L     R7,IOBDCBPT         R7 -> DCB
         MVC   KSAVE7(8),PPIWKARE  SAVE PPIWKARE (NEEDED FOR IERRDL)
*
*        CONVERT MBBCCHHR -> TTR
*
         STM   R14,12,12(R13)      SAVE REGS ACROSS RTN
         LR    R3,R13              SAVE R13
         L     R1,DCBDEBAD         R1 -> DEB
         LA    R2,IOBSEEK          R2 -> MBBCCHHR
         L     R15,PPIPRLTV        R15 -> CONVERSION RTN
         BASR  R14,R15             CONVERT MBBCCHHR -> TTR
         LR    R13,R3              RESTORE R13
         LTR   R15,R15          *  SET CC
         LM    R14,R15,12(R13)  |  RESTORE REGS, DO NOT RESTORE R0
         LM    R1,R12,24(R13)   |
         BNZ   WAIT080A         V  CONVERSION FAILED, TERMINATE SORT
         XC    PPIWKARE(8),PPIWKARE
         MVC   PPIWKARE(1),DCBOPTCD   USE DCBOPTCD TO PROVIDE M
         STCM  R0,B'1110',PPIWKARE+5  STORE TTR TO PASS M0000TTR TO ALG
         L     R11,PPIALG+4        R11 -> IER8ON
         BAS   R14,16(,R11)        CALL ALG TO RELEASE THE TRACK
*                                  RETURN ON R14
         MVC   PPIWKARE(8),KSAVE7  RESTORE PPIWKARE
         LM    R1,R10,KSAVE2       RESTORE REGS ACROSS RELEASE TRACK
WAIT030  NOP   WAIT050   ÝMAYBE B¨ SET TO BRANCH FOR VAR RECORDS
*
*        CALCULATE NUMBER OF RECORDS IN BUFFER FOR FIXED LENGTH
*        RECORDS
*
         SR    R0,R0
         SH    R1,K8               SUB 8 FOR CHAIN ADDR
         LH    R14,PPIRCDL2
         DR    R0,R14              R1 = NUMBER OF RECORDS IN BUFFER
WAIT050  ST    R1,KSAVE            SAVE NO OF RECORDS INTO KSAVE
WAIT060  MVC   IOBSEEK,0(R2)       MOVE MB000TTR DASD CHAIN ADDR FROM
*                                  RECORD JUST READ INTO
*                                  IOBSEEK FOR NEXT READ
*                                  ON FILE DISPL=4 FOR VAR RECORDS
         LM    R14,R0,KSAVE5
         BR    R6                  RETURN TO CALLER
*
WAIT065  CLI   0(R1),ECBREPRG      ADDR OF IOB AN AVAILABLE ?
*                                  PURGED REQUEST ELEMENT IN THE DEB
*                                  CHECKING ECB FOR X48 TO FIND OUT
         BNE   WAIT070             NO, BRANCH TO PERMANENT R3 ERR RTN
         L     R1,IOBDCBPT         YES, GET ADDR OF IOB ASSOC WITH
         DROP  R7                  TEMPORARILY DROP R7 DCB ADDR
         USING IHADCB,R1
         L     R1,DCBDEBAD         DEB ADDR
         DROP  R1
         USING DEBBASIC,R1         DEB ADDRESSABILITY
         LA    R1,DEBUSRPG         POINT TO FIRST PURGED IOB CHAIN
*
         IERESTOR (R1)             PASS ADDR OF IOB CHAIN
*
         DROP  R1
         USING IHADCB,R7           RESTORE R7 DCB ADDR
*
         MVI   IOBFLAG1,IOBCMDCH     SET ON COMMAND CHAINING
         NI    IOBUSTAT,255-UC-UE    RESET CSW FLGS IN IOB ASSOC WITH
         NI    IOBCSTAT,255-IL-CDC   THE ECB FOR WHICH WAIT ISSUED
         NI    DCBIFLGS,255-DCBIFEC  CLEAR ERROR FLAGS IN DCB
         B     WAITRTNA              TO TRY AGAIN
*
*        PERMANENT READ ERROR
*
WAIT070  PPISETON PPIREADE         SET READ ERROR INDICATION
         LR    R1,R7               SET UP PARAMETERS FOR SYNCH ERROR
         ST    R5,KSAVE2           EXIT ROUTINE
         MVI   KSAVE2,X'10'        R1 -> IOB, R0 -> DCB
         L     R0,KSAVE2
*
*        CALL E28
*
WAIT075  L     R15,AE28
         BASR  R14,R15             EXIT TO USER ERROR RTN
*
*        RETURN HERE FROM USER ERROR ROUTINE
*
*        AT ASSGN TIME THE FOLLOWING BRANCH INSTRUCTION IS SET
*        TO ONE OF THE FOLLOWING IN ACCORDANCE WITH THE USER
*        OPTION SPECIFIED -
*        B     WAIT080 TERMINATE SORT
*        B     WAIT090 ACCEPT BAD RECORD
*        B     WAIT100 SKIP BAD RECORD AND CONTINUE
*
WAIT077  B     WAIT080             TERMINATE SORT
*
WAIT080  MVC   PPIABMNO,IERZ800    SET ABEND CODE 800 - USER EXIT REQ
WAIT080A L     R15,PPIADSSC
         BAS   R14,16(,R15)        EXIT TO SSC, TERINATE SORT
*
IERZ800  DC    C'800'              ABEND CODE FOR TERMINATE REQUEST
*                                  FROM USER EXIT
*
WAIT090  NI    IOBUSTAT,255-UC-UE     ACCEPT BAD RECORD
         NI    IOBCSTAT,255-IL-CDC    RESET FLAGS AND CONTINUE
         NI    DCBIFLGS,255-DCBIFEC   CLEAR ERROR FLAGS IN DCB
         OI    IOBFLAG1,IOBCMDCH      SET ON COMMAND CHAINING
         B     WAIT010                CONTINUE AS NORMAL
*
WAIT100  NI    IOBUSTAT,255-UC-UE     ACCEPT BAD RECORD
         NI    IOBCSTAT,255-IL-CDC    RESET FLAGS AND CONTINUE
         NI    DCBIFLGS,255-DCBIFEC   CLEAR ERROR FLAGS IN DCB
         OI    IOBFLAG1,IOBCMDCH   SET ON COMMAND CHAINING
         L     R2,IOBSTART         BAD RECORD AN EOS BLOCK ?
         LA    R2,16(,R2)          R2 -> BUFFER
WAIT110  CLI   9(R2),C'G'          DSPL=13 FOR VAR RECORDS
         BE    RGC060              YES, DON'T ISSUE ANOTHER READ YET
WAIT120  MVC   IOBSEEK,0(R2)       IOBSEEK HAS DISK ADDR FOR NEXT REC
*                                  DSPL=4 FOR VAR RECORDS
         BAS   R8,EXCP010          GOTO READ
         B     WAITRTNA            GOTO WAIT
*
*        EXCP SUBROUTINE
*
*        THE FOLLOWING PARAMETERS ARE REQUIRED -
*        R5 -> IOB
*        R8 = RETURN ADDR
*
*        IOBSEEK CONTAINS THE M0000TTR DASD ADDR OF THE RECORD TO
*        BE READ. THIS WAS PROVIDED EITHER FROM PPIWKARE OR FROM
*        THE DISK CHAIN IN THE PREVIOUSLY READ RECORD. IOBSEEK
*        MUST BE CONVERTED TO MBBCCHHR FORMAT PRIOR TO ISSUEING
*        AN EXCP REQUEST
*
EXCP010  STM   R15,R4,KSAVE6
         B     EXCP005             GOTO READ
*
EXCPRTN  STM   R15,R4,KSAVE6
         L     R4,IOBSTART
         L     R15,IOBECBPT        SWITCH CCW'S IF THERE ARE TWO
         MVC   IOBSTRTB,5(R15)     UPDATE CCW CHAIN ADDR
         ST    R4,4(,R15)
         L     R4,IOBSTART
         MVC   17(3,R4),KEMPTY+1   SET BUFFER ADDR IN CCW
         OI    4(R15),X'02'        SET NO BUFFERS = 2
EXCP005  SR    R3,R3               SET DCB ADDR IN IOB
         IC    R3,IOBM             R3 = M INCREMENT
         L     R15,PPISTDCB        R15 -> DCB TABLE
         L     R7,0(R3,R15)        R7 -> DCB
         ST    R7,IOBDCBPT         CHAIN IOB TO DCB
*
*        CONVERT TTR IN IOBSEEK -> MBBCCHHR
*
         STM   R14,12,12(R13)      SAVE REGS ACROSS RTN
         LR    R3,R13              SAVE R13
         SR    R0,R0
         ICM   R0,B'1110',IOBHH    R0 = TTR0 FROM IOB
         L     R1,DCBDEBAD         R1 -> DEB
         LA    R2,DCBFDAD          R2 -> MBBCCHHR RESULT
         L     R15,PPIPCNVT        R15 -> CONVERSION RTN
         BASR  R14,R15             CONVERT TTR -> MBBCCHHR
         LR    R13,R3
         LTR   R15,R15          *  SET CC
         LM    R14,R12,12(R13)  |  RESTORE REGS
         BNZ   WAIT080A         V  CONVERSION FAILED, TERMINATE SORT
         MVC   IOBSEEK,DCBFDAD     MOVE SEARCH ADDR TO IOB
         NI    DCBIFLGS,255-DCBIFEC   CLEAR ERROR FLAGS IN DCB
*
         IEREXCP  (R5)
*
         LM    R15,R4,KSAVE6
         BR    R8                  RETURN
*
*        CONSTANTS AND VARIABLES
*
AE28     DC    A(0)                ADDR OF USERS SYNCHRONOUS ERROR
*                                  EXIT - SET BY ASSGN ROUTINE
KEMPTY   DC    A(0)                CONTAINS ADDR OF EMPTY BUFFER
*                                  FOR NEXT READ
K4       DC    H'4'                FOUR
K8       DC    H'8'                EIGHT
KMRGMX   DC    H'0'                CURRENT MERGE ORDER
KSV1     DC    X'00'               SAVE AREA FOR OUTPUT INCR
KSAVE    DC    10F'0'              REGISTER SAVE AREA FOR R1 TO R10
*                                  FIRST 4 WORDS ARE USED TO STORE
*                                  PARAMETERS WHICH ARE PASSED TO
*                                  THE DEBLOCK RTN
KSAVE2   DC    10F'0'              WORK AREA OR SAVE AREA USED WHEN
*                                  EXITING TO ALGORITHM
KSAVE5   DC    3F'0'               SAVE AREA FOR WAIT SUBROUTINE
KSAVE6   DC    6F'0'               SAVE AREA FOR EXCP SUBROUTINE
KSAVE7   DC    2F'0'               SAVE AREA FOR PPIWKARE
*
*        TABLES
*
*        WORK AREA USED IN PRIMING
*        M ENTRIES FOR M AREAS
*
KPT      DC    16F'0'              BYTE 1   - CONTAINS THE DCB INCR (M)
*                                       2-4 -> IOB USED TO PRIME THE M
*                                              AREAS ACCESSED AFTER
*                                              M READS TO ISSUE M WAITS
*
TFCNT    DC    16F'0'              FILE COUNT TABLE
*                                  USED WHEN PARTIAL OVERLAP EXISTS
*                                  TO DETERMINE WHICH FILE SHOULD
*                                  GET AN ALTERNATE BUFFER
*                                  F - NO BLOCKS ATTACHED TO FILE
*                                  V - NO BYTES ATTACHED TO FILE
*                                  BYTE 1   - CONTAINS THE DCB INCR (M)
*                                       2-4 - FILE COUNT
*
./ ADD NAME=IER8GC   0101-20211-20211-1200-00178-00178-00000-RELEASE 00
GC8      TITLE 'IER8GC - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IER8GC
*
*        MODULE FUNCTION/OPERATION -
*        THE FINAL MERGE PHASE READ ROUTINE FOR USE
*        WITH THE CRCX ALGORITHM
*
*        SUPPLIES THE DEBLOCK ROUTINE WITH A FULL BUFFER EACH
*        TIME A BUFFER IS EMPTIED. IT USES THE EXCP MACRO TO
*        READ AND THE WAIT MACRO TO CHECK FOR CORRECT COMPLETION
*        OF A READ. THE DISK AREA ADDRESS FROM WHICH THE READ
*        ROUTINE MUST READ IS CONTAINED IN THE LAST BUFFER READ
*        FROM THAT FILE THIS MODULE INFORMS THE NETWORK WHENEVER
*        EOS IS REACHED ON A FILE. IT DETECTS EOS BY EXAMINING
*        THE 4 BYTE EOS INDICATION AT THE BEGINNING OF EACH
*        BUFFER. AN EOS INDICATION OF HHHH INDICATES A NORMAL
*        BLOCK. AN INDICATION OF HGHH INDICATES AN EOS BLOCK
*
*        THIS MODULE IS ALSO DIRECTLY CONCERNED WITH BUFFERING
*        AND OVERLAP. IF THERE ARE 2M BUFFERS, IT IS ALWAYS
*        WORKING WITH FULL OVERLAP. IF THE NUMBER OF BUFFERS IS
*        FROM M TO 2M-1, THE ROUTINE TRIES TO GAIN AS MUCH
*        OVERLAP AS POSSIBLE BY IMPLEMENTING THE FOLLOWING IDEA.
*        WHENEVER A READ IS COMPLETED ON A FILE THAT HAS 2
*        BUFFERS ASSOCIATED WITH IT, THIS ROUTINE TRIES TO ATTACH
*        THE ALTERNATE BUFFER FROM THAT FILE TO THE FILE WITH THE
*        LOWEST BLOCK COUNT, (IE THE FILE THAT WILL PROBABLY
*        HAVE THE NEXT EMPTY BUFFER AND THUS REQUIRE THE NEXT
*        READ). THE SAME IDEA IS APPLIED WHEN A BUFFER IS FREED
*        BECAUSE EOS IS REACHED ON A FILE. IN THIS WAY, OVERLAP
*        MAY BE INCREASED BY NOT HAVING TO WAIT FOR THE NEXT READ
*        TO COMPLETE
*
*        IF IOS DETECTS AN UNCORRECTABLE ERROR WHILE READING,
*        THE SORT IS TERMINATED UNLESS THE USER HAS SUPPLIED AN
*        ERROR OPTION BY ACTIVATING E38. IF A SYNCHRONOUS ERROR
*        ROUTINE ALSO IS PRESENT, THE READ ROUTINE WILL GIVE
*        CONTROL TO IT. WHEN CONTROL IS RETURNED, THE READ
*        PROCEEDS IN ACCORDANCE WITH THE ERROR OPTION SPECIFIED
*        BY E38. THE POSSIBLE OPTIONS ARE - TERMINATE THE JOB, ACCEPT
*        THE BLOCK IN ERROR AND CONTINUE, OR SKIP THE BLOCK IN
*        ERROR AND CONTINUE WITH THE NEXT BLOCK.
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - IER9GC
*
*        MACROS USED -
*        SMPPI
*        EXCP
*        WAIT
*        DCBD
*
*        ENTRY POINTS - ENTRY FROM DEBLOCK TO FILL AN EMPTY BUFFER
*                       CALLING SEQUENCE -
*                         L     R11,PPIRD+4
*                         B     4(R11)
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPISTIOB   PPISBLCT   PPIALG
*        PPIDEB     PPILAB07   PPIBPTRK
*        PPILAB02   PPISTDCB   PPIRCDL2
*        PPISRTBL   PPINET     PPIADSSC
*
*        PHYSICAL RECORDS ON DISK AREAS ARE READ INTO STORAGE.
*        THE FORMAT OF THE BLOCKS ARE AS FOLLOWS -
*
*         ___________________
*        |                   |
*        | BLOCK CHAR COUNT  |  +00 4 BYTES - PRESENT ONLY FOR
*        |___________________|                VARIABLE LENGTH RECORDS
*        |                   |
*        |  DISK TTR CHAIN   |  +04 8 BYTES   M0000TTR
*        |     ADDRESS       |
*        |___________________|
*        |   EOS INDICATION  |  +12 4 BYTES
*        |___________________|
*        |                   |  +16 DATA
*        |                   |
*        |    LOGICAL        |
*        |    RECORDS        |
*        |                   |
*        |                   |
*        |                   |
*        |___________________|
*
*
*        ALL DISK ADDRESSES ARE ARE OF THE FORM MB000TTR WHERE -
*        M = DCB INCR FOR PHYSICAL AREA BEING READ FROM
*        B = LOGICAL DCB INCREMENT SPECIFYING THE ORIGINAL OF M
*            AREAS WITH WHICH THE SEQUENCE WAS ASSOCIATED
*        B = 0
*        C = 0
*        C = 0
*        T = RELATIVE TRACK NO
*        T = ..
*        R = RECORD NUMBER
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPICNTL PPIREADE SET ON READ ERROR
*        PPIPSVA USED AS WORK AREA
*        FULL BUFFER IS ACCESSED FOR THE DEBLOCK ROUTINE
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL - TO DEBLOCK ROUTINE WITH FULL BUFFER
*                           L     R11,PPIDEB+4
*                           BR    R11
*
*                       - TO MERGE NETWORK ON EOS
*                           L     R11,PPINET+4
*                           B     4(,R11)
*
*        EXITS - ERROR  - TO SORT SYSTEM CONTROL ON PERMANENT ERROR
*                           L     R11,PPIADSSC
*                           B     16(,R11)
*
*                       - TO USERS SYNCH ERROR ROUTINE ON READ ERROR
*                           L     R15,=V(ERRRTN)
*                           BALR  R14,R15
*
*        TABLES/WORK AREAS -
*        FILE COUNT TABLE - CONTAINS DCB INCREMENT AND BLOCK
*        COUNT FOR EACH FILE. USED IN PARTIAL OVERLAP TO
*        DETERMINE WHICH FILE SHOULD HAVE AN ALTERNATE BUFFER
*
*        NOTES - N/A
*
IER8GC   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IER8GC SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IER8GCI
*
*        IERIOB
*
         IERIOB
*
*        IERCCWEQ
*
         IERCCWEQ
*
         PRINT NOGEN
*
*        MAP DEB
*
         IEZDEB LIST=NO
*
*        MAP UCB
*
UCB      DSECT
*
         IEFUCBOB PREFIX=NO,LIST=NO
*
*        DCB DSECT
*
         DCBD  DSORG=(PS),DEVD=(DA)
*
*        IHAECB
*
         IHAECB DSECT=NO
*
         PRINT GEN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IER8GCI  0101-20211-20211-1200-00410-00410-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IER8GC SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IER8GCI
*
         USING *,R11               MODULE BASE REG
         USING IOBSTDRD,R5         IOB BASE REG
         USING IHADCB,R7           DCB BASE REG
         USING IERRCA,R13          PPI BASE REG
*
         B     *                   +00 DUMMY ENTRY - NOT USED
         STM   R2,R8,KSAVE+4       +04 NORMAL ENTRY FROM DEBLOCK WITH
*                                      EMPTY BUFFER
*                                      R2 -> EMPTY BUFFER
*                                      R3  = INCREMENT
         ST    R2,KEMPTY           SAVE EMPTY BUFFER ADDR
         L     R5,PPISTIOB
         L     R5,0(R3,R5)         R5 -> IOB ADDR
         L     R7,IOBDCBPT         R7 -> DCB ADDR
RGE010   CLI   9(R2),C'G'          EMPTY BUFFER AN EOS BUFFER ?
*                                  DSPL=13 FOR VAR RCDS
         BE    RGE200              YES
         L     R1,IOBECBPT         NO
         TM    4(R1),X'02'         ONE OR TWO BUFFERS ON THIS FILE ?
         BNO   RGE040              ONE
         BAS   R6,WAITRTN          TWO, EXCP ALREADY ISSUED, WAIT ON IT
*
*        IF LAST EXCP COMPLETED SUCCESSFULLY, WAITRTN WILL SET THE
*        FOLLOWING PARAMETERS AND RETURN HERE
*        R1 =  L'DATA IN BUFFER
*        R2 -> BUFFER READ INTO
*        KSAVE+4 -> FIRST RECORD WITHIN THE BUFFER
*
RGE020   CLI   KTOTAL,X'00'        TOTAL NO BUFFERS = 2*MERGE ORDER ?
         BL    RGE110              LESS, PARTIAL OVERLAP
*
*        FULL OVERLAP
*
RGE030   CLI   9(R2),C'G'          THIS BUFFER EOS ? (HGHH)
*                                  DSPL=13 FOR VAR RCDS
         BE    RGE050              YES
RGE035   BAS   R8,EXCP             NOT EOS, ISSUE ANOTHER READ
         B     RGE050              RETURN TO DEBLOCK
*
*        SINGLE BUFFERING
*        FILL EMPTY BUFFER TO RETURN TO DEBLOCK
*
RGE040   BAS   R8,EXCP010          CALL READ
         BAS   R6,WAITRTN          CALL WAITRTN
         LH    R4,KCOUNT           AN AVAILABLE ALTERNATE BUFFER ?
         BCT   R4,RGE060           YES, BRANCH
RGE050   LM    R1,R8,KSAVE         NO, RETURN TO DEBLOCK WITH FULL
         L     R11,PPIDEB+4        BUFFER
         BR    R11                 RETURN
*
*        ANOTHER BUFFER IS AVAILABLE TO BE ATTACHED TO THIS FILE
*
RGE060   CLI   9(R2),C'G'          THIS AN EOS BUFFER ? (HGHH)
         BO    RGE050              YES, DON'T BOTHER TO ATTACH
*                                  ALTERNATE BUFFER TO THIS FILE
         STH   R4,KCOUNT
         L     R2,PPILAB02
         MVC   KEMPTY,0(R2)        SAVE AVAILABLE BUFFER ADDR
         BAS   R8,EXCP             DO READ
         LA    R2,4(,R2)           UPDATE POINTER TO AVAIL BUFFER LIST
         ST    R2,PPILAB02
         IC    R2,KTOTAL           INCREMENT BY 1 TOTAL NO BUFFERS
         LA    R2,1(,R2)           BEING USED
         STC   R2,KTOTAL
         STC   R3,RGE080+1
         LH    R0,PPISRTBL
RGE070   LA    R2,TFCNT
RGE080   CLI   0(R2),X'00'         LOCATE APPROPRIATE FILE COUNT FOR
         BE    RGE090              FILE WHICH JUST GAINED BUFFER
         LA    R2,4(,R2)
         B     RGE080              CONTINUE
*
RGE090   A     R0,0(,R2)           INCREMENT FILE COUNT BY SORT BLKNG
         ST    R0,0(,R2)           TO REFLECT ALTERNATE BUFFER
         B     RGE050              RETURN TO DEBLOCK
*
*        PARTIAL OVERLAP
*        SCAN FILE COUNTERS TO DETERMINE WHICH FILE TO ATTACH
*        ALTERNATE BUFFER TO FOR NEXT READ
*        ATTACH TO FILE WITH LEAST NUMBER OF RECORDS LEFT IN ITS
*        BUFFER
*
RGE110   LA    R2,TFCNT
         L     R1,PPISBLCT         ADDR OF BLOCK COUNT TABLE
         LH    R6,PPIMRGMX
         LA    R4,PPIPSVA
         SR    R14,R14             SET BLOCK COUNT FOR RELEASED FILE=0
         ST    R14,0(R3,R1)
RGE120   IC    R14,0(,R2)          ACCESS M INCR
         L     R15,0(R14,R1)       ACCESS CORRESPONDING FILE COUNT
         A     R15,0(,R2)          ADD BLOCK COUNT AND SAVE IN PSVA
         ST    R15,0(,R4)
         LA    R2,4(,R2)           UPDATE POINTERS
         LA    R4,4(,R4)
         BCT   R6,RGE120           M FILES
*
*        SCAN THROUGH SAVED COUNTS AND FIND THE LOWEST
*
         LA    R2,PPIPSVA
         LH    R1,PPIMRGMX
         STC   R3,RGE140+1
         LR    R4,R2
         B     RGE140              CHECK FOR RELEASED
*
RGE130   LA    R4,4(,R4)
         CLC   1(3,R2),1(R4)       COMPARE NEXT WITH LOWEST
         BH    RGE180              SET NEW LOW
RGE140   CLI   0(R4),X'00'         THE RELEASED FILE ?
         BE    RGE190              YES
RGE150   BCT   R1,RGE130           ACCESS NEXT ITEM
*
*        ENTIRE AREA HAS BEEN SCANNED
*        R2 CONTAINS POINTER TO LOWEST ITEM IN AREA
*        R4 CONTAINS POINTER TO RELEASED FILES ITEM IN AREA
*
         LA    R0,PPIPSVA
         SR    R2,R0               ACCESS DISPLACEMENT OF EACH FROM
         SR    R15,R0              BEGINNING OF AREA
         LA    R0,TFCNT
         AR    R15,R0              USE DSPL TO ACCESS LOWEST AND
         AR    R2,R0               RELEASED ENTRIES IN TFCNT
         L     R4,IOBECBPT         SET NO BUFFERS=1 FOR RELEASED FILE
         NI    4(R4),X'FC'
         OI    4(R4),X'01'
         LR    R14,R5
         IC    R1,0(,R2)           INCR FOR NEW FILE
         L     R5,PPISTIOB
         L     R5,0(R1,R5)         R5 -> IOB FOR THIS FILE
         L     R7,IOBDCBPT         R7 -> DCB FROM IOB
         L     R4,IOBSTART         R4 -> CCW CHAIN
         L     R4,16(,R4)          R4 -> BUFFER
RGE160   CLI   9(R4),C'G'          EOS ? DSPL=13 FOR VAR RCDS (HGHH)
         BNE   RGE170              NOT EOS
         LR    R5,R14              EOS
         B     RGE050              GOTO DEBLOCK
*
*        ATTACH ALTERNATE BUFFER TO NEW FILE
*
RGE170   L     R4,0(,R2)           UPDATE FILE COUNT TABLE FOR NEW FILE
         AH    R4,PPISRTBL
         ST    R4,0(,R2)
         L     R4,0(,R15)          AND OLD FILE
         SH    R4,PPISRTBL
         ST    R4,0(,R15)
         B     RGE035              GOTO READ
*
RGE180   LR    R2,R4
         B     RGE140              SET NEW LOW
*
RGE190   LR    R15,R4
         B     RGE150              RELEASED FILE
*
*        EMPTY BUFFER RETURNED BY DEBLOCK WAS EOS BUFFER
*        THIS FILES BUFFER(S) ARE NO LONGER NEEDED BY THIS FILE
*        THEY CAN BE PUT ON THE AVAILABLE LIST FOR USE BY OTHER
*        FILES
*
RGE200   L     R4,IOBSTART         R4 -> CCW CHAIN
         L     R2,PPILAB02
         LH    R14,KCOUNT
RGE210   SH    R2,K4
         MVC   1(3,R2),17(R4)      ADD BUFFER ADDR TO AVAILABLE LIST
         LA    R14,1(,R14)         INCR COUNT OF NO AVAILABLE BUFFERS
         L     R15,IOBECBPT
         TM    4(R15),X'02'        A SECOND BUFFER ?
         BZ    RGE220              NO
         MVI   4(R15),X'01'        YES
         L     R4,4(,R15)          ADD SECOND BUFFER TO AVAILABLE
         B     RGE210              LIST ALSO
*
RGE220   STH   R14,KCOUNT
         ST    R2,PPILAB02
         LH    R0,KH32767
         STC   R3,RGE230+1
         LA    R2,TFCNT            UPDATE APPROPRIATE ENTRIES IN
RGE230   CLI   0(R2),X'00'         FILE COUNT TABLE
         BE    RGE240              EXIT TO NETWORK
         LA    R2,4(,R2)
         B     RGE230              CONTINUE UPDATE
*
RGE240   A     R0,0(,R2)
         ST    R0,0(,R2)
         SR    R0,R0
         IC    R0,RGE020+1         GET 2*M
         SH    R0,K2               REDUCE MERGE ORDER
         STC   R0,RGE020+1
         LM    R1,R10,KSAVE        TO MERGE NETWORK CUTBACK RTN
         L     R11,PPINET+4
         B     4(,R11)             EXIT TO NETWORK
*
*        WAITRTN
*
*        THE FOLLOWING PARAMETERS ARE REQUIRED
*        R5 -> IOB
*        R7 -> DCB
*        R6 = RETURN ADDR
*
*        THE FOLLOWING PARAMETERS ARE SET BY THE WAITRTN SUBROUTINE
*        IF NO ERROR IS DETECTED
*
*        R1  = COUNT OF AMOUNT OF DATA IN BUFFER
*        R2 -> BUFFER READ INTO
*        R1 AND R2 ARE ALSO STORED IN KSAVE AND KSAVE+12
*        RESPECTIVELY. ADDR OF THE FIRST RECORD IN THE BUFFER
*        IS STORED IN KSAVE+4
*
WAITRTN  STM   R14,R0,KSAVE3
WAITRTNA L     R1,IOBECBPT         ENTRY POINT FOR I/O ERROR RETRY
*
         IERWAIT  1,ECB=(1)        WAIT ON I/O COMPLETION
*
         L     R1,IOBECBPT
         CLI   0(R1),ECBNORM       ECB POSTED NORMALLY ?
         BNE   WAIT065             NO, ERROR EXISTS
WAIT010  L     R2,IOBSTART         I/O COMPLETED SUCCESSFULLY
         L     R2,16(,R2)          R2 -> BUFFER
         LA    R2,0(,R2)
         ST    R2,KSAVE+12
WAIT020  LA    R1,12               OVERLAID FOR VAR RCDS TO SET R1=16
         AR    R1,R2
         ST    R1,KSAVE+4
         LH    R1,PPILAB03+2
         SH    R1,IOBCSW+5         SUBSTRACT RESIDUAL COUNT IN CSW
         SH    R1,K4               SUBTRACT 4 FOR EOS FIELD
WAIT030  NOP   WAIT050             SET TO BRANCH FOR VAR RECORDS
         SR    R14,R14
         SH    R1,K8               SUBTR 8 FOR CHAIN ADDR
WAIT040  SH    R1,PPIRCDL2         CONVERT NO BYTES READ TO NO RECORDS
         LA    R14,1(,R14)         READ IN
         CH    R1,PPIRCDL2
         BNL   WAIT040             CONTINUE
         LR    R1,R14
WAIT050  ST    R1,KSAVE
WAIT060  MVC   IOBSEEK,0(R2)       SET DISK ADDR IN IOB FOR NEXT
*                                  READ ON FILE, DSPL=4 FOR VAR RECORDS
         LM    R14,R0,KSAVE3
         BR    R6                  RETURN TO CALLER
*
WAIT065  CLI   0(R1),ECBREPRG      PURGED REQUEST ELEMENT IN THE DEB ?
         BNE   WAIT070             NO, BRANCH TO PERMANENT ERR RTN
         L     R1,IOBDCBPT         YES, GET ADDR OF IOB ASSOC WITH
         DROP  R7                  TEMPORARILY DROP R7 DCB ADDR
         USING IHADCB,R1
         L     R1,DCBDEBAD         DEB ADDR
         DROP  R1
         USING DEBBASIC,R1         DEB ADDRESSABILITY
         LA    R1,DEBUSRPG         POINT TO FIRST PURGED IOB CHAIN
*
         IERESTOR (R1)             PASS ADDR OF IOB CHAIN
*
         DROP  R1
         USING IHADCB,R7           RESTORE R7 DCB ADDR
*
         MVI   IOBFLAG1,IOBCMDCH     SET IOB COMMAND CHAIN BIT
         NI    IOBUSTAT,255-UC-UE    RESET CSW FLGS IN IOB ASSOC WITH
         NI    IOBCSTAT,255-IL-CDC   THE ECB FOR WHICH WAIT ISSUED
         NI    DCBIFLGS,255-DCBIBEC  AND DCB BITS
         B     WAITRTNA              TO TRY AGAIN
*
*        PERMANENT READ ERROR
*
WAIT070  PPISETON PPIREADE         SET READ ERROR INDICATION
         LR    R1,R7               SET UP PARAMETERS FOR SYNCH ERROR
         ST    R5,KSAVE2           EXIT ROUTINE
         MVI   KSAVE2,X'10'        R1 = IOB ADDR, R0 = DCB ADDR
         L     R0,KSAVE2
*
*        CALL E38
*
WAIT075  L     R15,AE38            GET USER ERROR ROUTINE ADDR
         BASR  R14,R15             EXIT TO USER ERROR RTN
*
*        RETURN HERE FROM USER ERROR ROUTINE
*
*        AT ASSIGNMENT TIME, THE FOLLOWING BRANCH INSTRUCTION IS
*        SET TO ONE OF THE FOLLOWING IN ACCORDANCE WITH THE USER
*        OPTION SPECIFIED -
*        B WAIT080 TERMINATE
*        B WAIT090 ACCEPT BAD RECORD
*        B WAIT100 SKIP BAD RECORD AND CONTINUE
*
WAIT077  B     WAIT080             TERMINATE
*
WAIT080  MVC   PPIABMNO,IERZ800    USER ABEND 800 - EXIT REQ
WAIT080A L     R15,PPIADSSC
         BAS   R14,16(,R15)        EXIT TO SSC, TERMINATE SORT
*
IERZ800  DC    C'800'
*
WAIT090  NI    IOBUSTAT,255-UC-UE   ACCEPT BAD RECORD
         NI    IOBCSTAT,255-IL-CDC  RESET FLAGS AND CONTINUE
         NI    DCBIFLGS,255-DCBIFPEC
         OI    IOBFLAG1,IOBCMDCH
         B     WAIT010             RETURN TO MAINLINE
*
WAIT100  NI    IOBUSTAT,255-UC-UE  ACCEPT BAD RECORD AND CONTINUE
         NI    IOBCSTAT,255-IL-CDC
         NI    DCBIFLGS,255-DCBIFPEC
         OI    IOBFLAG1,IOBCMDCH
         L     R2,IOBSTART         BAD RECORD AN EOS BLOCK ?
         L     R2,16(,R2)          R2 = BUFFER ADDR
WAIT110  CLI   9(R2),C'G'          DSPL=13 FOR VAR RCDS (HGHH)
         BE    RGE200              YES, DON'T ISSUE ANOTHER READ YET
WAIT120  MVC   IOBSEEK,0(R2)       SET IOB WITH DISK ADDR FOR NEXT REC
*                                  DSPL=4 FOR VAR RCDS
         BAS   R8,EXCP010          GOTO READ
         B     WAITRTNA            GOTO WAITRTNA
*
*        EXCP SUBROUTINE
*        THIS ROUTINE IS ALSO CALLED FROM IER9GC TO PRIME
*        THE BUFFERS
*        THE FOLLOWING PARAMETERS ARE REQUIRED
*        R5 -> IOB ADDR
*        R7 -> DCB ADDR (NOT USED), DCB ADDR LOCATED FROM M INCREMENT
*        R8  = RETURN ADDR
*        KEMPTY = ADDR OF EMPTY BUFFER TO BE READ INTO
*        THE SAME PARAMETERS ARE RETURNED
*
*        NOTE -
*        THE FORMAT OF IOBSEEK ON ENTRY IS -
*        M  - INCREMENT
*        00   (BB)
*        00   (CC)
*        TT   RELATIVE TRACK
*        R
*        THIS IS CONVERTED TO MBBCCHHR PRIOR TO EXCP
*
*
EXCP     STM   R14,R4,KSAVE7
         L     R4,IOBSTART         SWITCH CCWS IF THERE IS AN ALTERNATE
         L     R15,IOBECBPT
         MVC   IOBSTRTB,5(R15)
         ST    R4,4(,R15)
         L     R4,IOBSTART
         MVC   17(3,R4),KEMPTY+1   MOVE BUFFER ADDR INTO READ CCW
         OI    4(R15),X'02'        SET NO BUFFERS TO 2
         B     EXCP015             GO TO READ
*
EXCP010  STM   R14,R4,KSAVE7
EXCP015  SR    R3,R3               MAKE IOB POINT TO PROPER DCB
         IC    R3,IOBSEEK          R3 = M
         L     R15,PPISTDCB
         L     R7,0(R3,R15)        R7 -> DCB
         ST    R7,IOBDCBPT         CAHAIN DCB TO IOB
         L     R2,KSAVE+4          MOVE CHAIN DISK ADDR INTO IOB
*
*        CONVERT M0000TTR FROM IOBSEEK -> MBBCCHHR
*
         STM   R14,12,12(R13)      SAVE REGS ACROSS RTN
         LR    R3,R13              SAVE R13
         SR    R0,R0
         ICM   R0,B'1110',IOBSEEK+5  R0 = TTR0 FROM DISK CHAIN ADDR
         L     R1,DCBDEBAD         R1 -> DEB
         LA    R2,DCBFDAD          R2 -> MBBCCHHR RESULT
         L     R15,PPIPCNVT        R15 -> CONVERSION RTN
         BASR  R14,R15             CONVERT TTR -> MBBCCHHR
         LR    R13,R3
         LTR   R15,R15          *  SET CC
         LM    R14,R12,12(R13)  |  RESTORE REGS
         BNZ   WAIT080A         V  CONVERSION FAILED, TERMINATE SORT
         MVC   IOBSEEK,DCBFDAD     MOVE SEARCH ADDR TO IOB
         NI    DCBIFLGS,255-DCBIFPEC
*
         IEREXCP  (R5)
*
         LM    R14,R4,KSAVE7
         BR    R8                  RETURN
*
*        CONSTANTS AND VARIABLES
*
K2       DC    H'2'
K4       DC    H'4'
K8       DC    H'8'
KH32767  DC    H'32767'            MAX HWORD VALUE
KCOUNT   DC    H'1'                COUNT OF NO OF BUFS IN AVAIL LIST
KTOTAL   DC    H'0'                TOTAL NO BUFFERS IN USE
KMRGMX   DC    H'0'                MERGE ORDER FOR PH 3
AE38     DC    A(0)                -> USERS SYNCHRONOUS ERROR
*                                  EXIT - SET BY ASSGN ROUTINE
KEMPTY   DC    F'0'                -> EMPTY BUFFER
KSAVE    DC    10F'0'              REGISTER SAVE AREA FOR R1 TO R10
*                                  FIRST 4 WORDS ARE USED TO STORE
*                                  PARAMETERS WHICH ARE RETURNED
*                                  TO THE DEBLOCK ROUTINE
KSAVE2   DC    10F'0'              REGISTER SAVE AREA USED WHEN
*                                  COMMUNICATING WITH ALGORITHM
KSAVE3   DC    3F'0'               REGISTER SAVE AREA FOR WAIT
*                                  SUBROUTINE
KSAVE7   DC    7F'0'               REGISTER SAVE AREA FOR EXCP SUBRTN
*
*        TABLES
*
TFCNT    DC    16F'0'              FILE COUNT TABLE
*                                  USED WHEN PARTIAL OVERLAP
*                                  EXISTS TO DETERMINE WHICH FILE
*                                  SHOULD GET AN ALTERNATE BUFFER
*                                  EACH ENTRY CONTAINS DCB INCR
*                                  AND FILE COUNT
*                                  F - NO BLOCKS ATTACHED TO FILE
*                                  V - NO BYTES ATTACHED TO FILE
*
./ ADD NAME=IER8ON   0101-20211-20211-1200-00126-00126-00000-RELEASE 00
ON8      TITLE 'IER8ON - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IER8ON
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 1 - CRCX PHASE 2 DISK ALGORITHM
*        ITS FUNCTIONS ARE -
*        1.  DETERMINE WHEN TO SORT AND WHEN TO MERGE
*        2.  KEEP STARTING ADDRESSES OF ALL SEQUENCES
*        3.  PASS CHAIN ADDRESS TO WRITE ROUTINE FOR LAST RECORD
*            OF EACH TRACK, EXCEPT AT EOS
*        4.  INFORM NETWORK INITIALIZATION ROUTINE WHEN STARTING
*            THE MTH SEQUENCE DURING SORT PHASE
*        5.  INFORM NETWORK INITIALIZATION ROUTINE WHEN SWITCHING
*            FROM SORT TO MERGE PHASE AND WHAT IS THE MERGE ORDER
*        6.  INFORM NETWORK INITIALIZATION ROUTINE WHEN SWITCHING
*            FROM MERGE TO SORT PHASE
*        7.  KEEP RECORD OF FREE TRACK AREAS ON ALL WORK AREAS
*        8.  SET UP DISK ADDRESSES FOR READ PRIME
*        9.  DETERMINE WHETHER OR NOT ANOTHER READ CAN BE STARTED
*            AFTER AN EOS INDICATION FROM READ ROUTINE DURING A
*            MERGE PASS
*        10. AFTER EOF CONTROLS THE MERGES UNTIL FINAL MERGE PHASE
*        11. PASS THE STARTING ADDRESSES FOR ALL SEQUENCES
*            FOR THE START OF FINAL MERGE PHASE
*
*        MODULE APPEARS AS A DSECT IN IER9ON SO THAT VARIOUS FIELDS
*        MAY BE INITIALIZED BY IER9ON FOR IER8ON
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY IER8ON - ENTRY FROM IER8PA
*                                      CALLING SEQUENCE -
*                                      L     R11,PPIALG+4
*                                      BR    R11   REAL OR DUMMY EOF
*
*                                      L     R11,PPIALG+4
*                                      BAL   R14,4(,R11) GET CHAIN ADDR
*
*                                      L     R11,PPIALG+4
*                                      B     8(,R11)      (AT EOS)
*
*                                      ENTRY FROM SORT NETWORK INITIAL
*                                      CALLING SEQUENCE -
*                                      L     R11,PPIALG+4
*                                      B     12(,R11)
*
*                                      ENTRY FROM IER8GB
*                                      CALLING SEQUENCE -
*                                      L     R11,PPIALG+4
*                                      BAL   R14,16(,R11) (REL A TRK)
*
*                                      L     R11,PPIALG+4
*                                      B     20(,R11)     (AT EOS)
*
*        INPUT PPI FIELDS REFERENCED -
*        PPICNTL   PPIRD     PPIINT
*        PPIDEB    PPIADSSC  PPIWKARE
*        PPICOUNT  PPIDELCT  PPIINSCT
*        PPIUNTCT  PPIMRGMX
*
*        OUTPUT - PPI FIELDS ALTERED -
*        PPICNTL  PPIWKARE  PPIDEPHO
*        PPIMRGMX PPIENDAR
*
*        EXTERNAL ROUTINES - IERRMA - MESSAGE MODULE
*
*        EXTERNAL PARAMETERS -
*        PPIWKARE -
*        CONTAINS M DISK ADDRESSES AT READ PRIME TIME FOR THE
*        READ ROUTINE AND IT CONTAINS THE CHAIN ADDRESS UPON
*        RETURN TO THE WRITE ROUTINE
*        PPIDEPHO -
*        CONTAINS THE DISK ADDRESS FOR THE START OF THE NEXT
*        SEQUENCE TO BE WRITTEN
*
*        EXITS - NORMAL -
*
*        IER8PA -  RETURN WITH CHAIN ADDRESS
*        IER8GB -  BRANCH TO IT AT READ PRIME TIME AND AFTER EOS (READ)
*                  RETURN TO IT AFTER RELEASING TRACK
*        DEBLOCK - BRANCH TO IT AFTER SORT PHASE EOS EXCEPT
*                  AFTER M-1 OR MTH SEQUENCE
*        NETWORK INITIALIZATION - BRANCH TO IT AFTER M-1
*                  SEQUENCES. ALSO, AFTER M SEQUENCES IF EQUALS
*                  ROUTINE IS BEING USED AND WHEN SWITCHING FROM
*                  MERGE TO SORT PHASE
*
*        EXITS - ERROR -
*        IERRCV - BRANCH AND LINK TO PRINT ERROR MESSAGE. BRANCH
*        TO IT TO TERMINATE JOB
*
*        TABLES/WORK AREAS -
*        WSEQCTR -  HALF WORD FOR THE NUMBER OF SEQUENCES IN THIS
*                   SORT PHASE
*        WSEQTOTL - HALF WORD FOR TOTAL NUMBER OF SEQUENCES OUT
*                   OF ALL SORT PHASES SO FAR
*        THE TABLE POINTED TO BY KTABLEX IS THE MAIN ALGORITHM
*        TABLE UPON WHICH THE ALGORITHM BASES NEARLY ALL OF ITS
*        DECISIONS
*        THE AREA POINTED TO BY KPOOL IS FOR THE USE OF ANY FREE
*        TRACK LIST NEEDING ROOM FOR MORE ENTRIES
*
IER8ON   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IER8ON SOURCE
*
*----------------------------------------------------------------------
*
         COPY IER8ONI
*
DIERRMA  DSECT
*
         COPY  RMAMAIN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IER8ONI  0101-20211-20211-1200-01185-01185-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IER8ON SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IER8ONI
*
         USING *,R11               MODULE BASE REG
         USING IERRCA,R13          PPI BASE REG
         USING DIERRMA,R12         BASE REG FOR MESSAGE MODULE
*
*        MODULE ENTRY TABLE
*
         B     ONEOF               +00 WRITE AT EOF (SIM OR REAL)
         B     ONCHNADR            +04 REQUEST NEW CHAIN ADDR FOR WRITE
         B     ONWRTEOS            +08 WRITE AT EOS (PH1 OR PH2)
         B     ONEXRD              +12 NETWORK INITIALIZATION
         B     ONRDTREL            +16 RELEASE A TRACK AFTER READ
         B     ONRDEOS             +20 READ AT EOS
*
*        ENTRY - WRITE AT EOS
*
ONWRTEOS STM   R2,R3,WSAVE1        SAVE R2, R3
         LM    R2,R8,WSAVE         RESTORE REGS SAVED FROM PREV ENTRY
         PPITEST  PPIPH2           MERGING ?
         BO    ONRCDCHK            YES, BRANCH
         BAS   R10,ONREORD         GO REORDER THIS LIST
         LM    R9,R10,WSEQTOTL     AND ALSO WSEQCTR
         LA    R9,1(,R9)           ADD 1 TO TOTAL SEQUENCES
         LA    R10,1(,R10)         ADD 1 TO SEQUENCE CTR (THIS PHASE)
         STM   R9,R10,WSEQTOTL     SAVE TOTALS AND WSEQCTR
         CL    R9,KMSQURD          M SQUARED +1 SEQUENCES YET ?
         BH    ONMSQPLS            YES, BRANCH
         LA    R3,1(,R3)           SET I=I+1
         CL    R3,KMERGORD         I > MERGE ORDER ?
         BNH   ONGETADR            NO, BRANCH
         SR    R3,R3               YES, SET I=0
ONGETADR LR    R1,R3               PUT I INCREMENT IN R1
         BAS   R10,ONGETTRK        CALL TO GET A TRACK  ADDR
         BAS   R10,ONCOMPAC        GO PUT DISK ADDR IN 4 BYTE FORMAT
         MVC   PPIDEPHO,PPIWKARE   MOVE DISK ADDR TO DEPHO
         LR    R10,R3              LOAD I INTO R10
         SLL   R10,2               R10 = I X 4
         LA    R14,4(,R10)         GET LOGICAL INCREMENT
         STC   R14,PPIDEPHO+1      STORE IT
         ST    R9,0(R5,R10)        PUT IN FIRST ROW OF TABLE UNDER I
ONEXIT1E L     R10,WSEQCTR
ONEXIT1  STM   R2,R4,WSAVE         SAVE J, I AND L
         LM    R2,R3,WSAVE1
         CL    R10,KMOMONE         SEQ CTR = M-1 ?
         BE    ONMTHSEQ            YES, BRANCH
         L     R12,PPIAXERT        RELOAD BASE REG FOR EQ OR EXT RTN
         L     R11,PPIDEB+4
         B     8(,R11)             BRANCH TO DEBLOCK
*
ONMTHSEQ L     R11,PPIINT+4
         L     R12,PPIAXERT        RELOAD BASE REG FOR EQ OR EXT RTN
         B     8(,R11)             BRANCH TO NET INIT MTH SEQ
*
ONMSQPLS SH    R2,KONE             SET J = J-1
         BNM   ONGETDA             BRANCH UNLESS MINUS
         L     R2,KMERGORD         SET J = MERGE ORDER
ONGETDA  LR    R1,R2               SET R1 = J
         BAS   R10,ONGETTRK        REQUEST A DISK ADDR INTO PPIWKARE
         MVC   PPIDEPHO,PPIWKARE   MOVE DISK ADDR TO PPIDEPHO
         LR    R12,R2              LOAD J INTO R12
         SLL   R12,2               R12 = J X 4
         LA    R10,4(,R12)         GET LOGICAL INCREMENT
         STC   R10,PPIDEPHO+1      STORE IT
         BAS   R10,ONCOMPAC        CONVERT DISK ADDR TO 4 BYTE FORMAT
         ST    R9,0(R5,R12)        PUT IN FIRST ROW OF TABLE UNDER J
         B     ONEXIT1E            BRANCH TO EXIT
*
*        CONVERT THE 8 BYTE DISK ADDR FROM PPIWKARE AND COMPACT
*        IT INTO 4 BYTES (MTT0) FOR THE ALGORITHM TABLE
*
ONCOMPAC SR    R9,R9
         ICM   R9,B'1000',PPIWKARE     REAL INCREMENT (M)
         ICM   R9,B'0110',PPIWKARE+5   INSERT TT
         BR    R10                 RETURN
*
*        THIS CODE IS ENTERED AFTER EVERY END OF SEQUENCE WHILE
*        MERGING
*
ONRCDCHK BAS   R10,ONRCDCNT        MAKE A CHECK ON RECORD COUNT
         MVI   WSWITCHD,0          CLEAR ANOTHER MERGE PASS INDICATOR
         PPITEST  PPIPEOF          REACHED REAL EOF ?
         BZ    ONNOEOF             NO, BRANCH
         PPITEST  PPIUEOF          YES, REACHED E15 EOF ?
*                                  (WILL BE SET IF E15 NOT ACTIVE)
         BZ    ONNOEOF             NO, BRANCH
         LTR   R4,R4               L = 0 ?
         BZ    ONEQZERO            YES, BRANCH
         LR    R12,R4              PUT L IN R12
         BCT   R12,ONNOEOF         L = 1 ? NO, BRANCH
         LH    R12,KBPRLS4         BYTES PER ROW OF TABLE-4
         L     R12,0(R12,R7)       GET INFO FROM L=1 ROW
         CL    R12,KONEONE         INFO = 1010 ?
         BNE   ONNOEOF             NO, BRANCH
ONEQZERO L     R5,KTABLEX0         SET POINTER TO L=0 ROW
ONEQZER4 SR    R2,R2               ZERO FOR MERGE ORDER
         SR    R1,R1               DON'T NEED TO SAVE REGS NOW
         MVC   PPIDSKED(17*8),PPIENDAR  MOVE FOR END OF PHASE ROUTINE
         LM    R6,R7,PPIDSKED+48   SAVE 8 BYTES BECAUSE PPIWKARE
*                                  +128 (PPIDSKED+48) IS USED BY THE
*                                  SUBROUTINE AT ONEXPAND
         LA    R4,PPIENDAR         R4 -> PPIENDAR
ONLOOP1  SR    R9,R9
         A     R9,0(R1,R5)         GET ENTRY FROM TABLE
         BZ    ONNEXTRY            ZERO, BRANCH
         BAS   R10,ONEXPAND        GO EXPAND ADDR TO 8 BYTES
         MVC   0(8,R4),PPIWKARE+128  MOVE ADDR INTO PPIENDAR
         LA    R4,8(,R4)           INCR PPIENDAR ADDR
         LA    R2,1(,R2)           INCR MERGE ORDER BY 1
ONNEXTRY LA    R1,4(,R1)           INCR POINTER TO NEXT ENTRY
         CH    R1,KBPRLS4          THROUGH ?
         BL    ONLOOP1             NO, BRANCH
         STH   R2,PPIMRGMX         YES, STORE MERGE ORDER FOR PHASE 3
         STM   R6,R7,PPIDSKED+48   RESTORE 8 BYTES
         CLC   WSEQTOTL,KMERGORD   M SEQ OR MORE ?
         BH    ONDONE              YES, GO EXIT TO RCV
         PPITEST  PPIEQUAL         EQUALS ?
         BZ    ONDONE              NO, GO EXIT TO RCV
         MVC   ONEXRD(4),KOVERLA2  OVERLAY TO EXIT TO RCV UPON RETURN
         B     ONOFFA              GO EXIT TO NET INIT
*
ONDONE   LA    R1,4                INDICATE CALL PHASE 3
         L     R12,PPIAXERT        RELOAD BASE REG FOR EQ OR EXT RTN
         L     R15,PPIADSSC        R15 -> SSC
         BAS   R14,20(,R15)        EXIT TO END OF PHASE ENTRY OF SSC
*
*
*        EXPAND A 4 BYTE DISK ADDR (MTT0) RECEIVED IN R9 INTO AN
*        8 BYTE M0000TTR ADDR AT PPIWKARE+128
*        IT WILL CONTAIN THE REAL AREA INCREMENT AND RECORD
*        NUMBER 1 BUT WILL NOT CONTAIN THE LOGICAL AREA INCREMENT
*
ONEXPAND XC    PPIWKARE+128(8),PPIWKARE+128  ZERO M0000TTR
         STCM  R9,B'1000',PPIWKARE+128  STORE (M) REAL INCREMENT
         STCM  R9,B'0110',PPIWKARE+133  STORE TT
         MVI   PPIWKARE+135,X'01'  SET RECORD NO TO 1
         BR    R10                 RETURN
*
*        ENTERED AFTER EVERY MERGE PASS EXCEPT THE LAST ONE IN
*        PHASE 2
*        THE FIRST PORTION WILL BE OVERLAID AT EOF
*
ONNOEOF  PPISETOF PPICRCX          TURN OFF MORE MERGE
         BAS   R10,ONREORD         GO REORDER ALL FTL
         CLC   WSEQTOTL,KMSQURD    M SQUARED SEQUENCES YET ?
         BH    ONMTMSQ             MORE THAN M SQUARED, BRANCH
         LR    R1,R3               PUT I IN R1
         BAS   R10,ONGETTRK        CALL ONGETTRK TO GET A TRACK ADDR
         MVC   PPIDEPHO,PPIWKARE   MOVE IT TO DEPHO
         BAS   R10,ONCOMPAC        COMPACT THE ADDR TO STORE IN TABLE
         LR    R12,R3              PUT I IN R12
         SLL   R12,2               R12 = I X 4
         ST    R9,0(R5,R12)        PUT IN FIRST ROW OF TABLE UNDER I
         LA    R12,4(,R12)         GET LOGICAL INCREMENT
         STC   R12,PPIDEPHO+1      STORE IT
ONSETSRT PPISETOF PPIPH2           SET SORT PHASE 2 OFF
         B     ONEXTNET+4          GO EXIT TO NETWORK INITIALIZATION
*
ONMTMSQ  LH    R10,KBPRLS3         POINTER TO HI NO
         AR    R10,R7              PLUS L ROW
         CLC   0(1,R10),KMOMONE+3  HI NO = MERGE ORDER-1 ?
         BE    ONCHKFUR            YES, BRANCH
         LR    R1,R2               SET R1 = J
ONOLYEOF NOP   ONAFTEOF            WILL BE UNCOND BRANCH AFTER EOF
         BAS   R10,ONGETTRK        REQUEST A TRACK ADDR
         MVC   PPIDEPHO,PPIWKARE   MOVE IT TO DEPHO
         BAS   R10,ONCOMPAC        COMPACT THE DISK ADDR FOR STORAGE
         LR    R12,R2              SET R12 = J
         SLL   R12,2               R12 = J X 4
         ST    R9,0(R5,R12)        PUT IN FIRST ROW OF TABLE UNDER J
         LA    R12,4(,R12)         GET LOGICAL INCREMENT
         STC   R12,PPIDEPHO+1      STORE IT
         B     ONSETSRT
*
ONCHKFUR LH    R10,KBPRLS4         POINTER TO HI
         AR    R10,R7              PLUS L ROW
         LH    R12,KBPRLS2         POINTER TO LO
         AR    R12,R8              PLUS L-1 ROW
         CLC   0(1,R12),0(R10)     EQUAL ?
         BE    ONSETMRG            YES, BRANCH
         PPISETOF PPIPH2           SET SORT PHASE 2 OFF
         B     ONUPHI
*
ONSETMRG SR    R9,R9               CLEAR FOR MERGE ORDER
         LR    R10,R7              ADDR OF L ROW
         L     R12,KMERGORD        R12 = MERGE ORDER
         LA    R12,1(,R12)         PLUS 1
ONCHKMT  CLI   0(R10),0            ANYTHING IN THIS ENTRY ?
         BNE   ONUPMRG             YES, BRANCH
ONNEXENT LA    R10,4(,R10)         INCR POINTER TO NEXT ENTRY
         BCT   R12,ONCHKMT         DECR R12, MORE ENTRIES ? BRANCH
         B     ONCHKUNI            FINISHED WITH THIS ROW
*
ONUPMRG  LA    R9,1(,R9)           UP MERGE ORDER BY 1
         B     ONNEXENT            GO CONTINUE LOOP
*
ONCHKUNI LR    R10,R3              R10 = I
         SLL   R10,2               R10 = I X 4
         AR    R10,R8              R10 = ADDR OF L-1 ROW + I X 4
         CLI   0(R10),0            ANYTHING AT THIS ENTRY ?
         BE    ONSTORMX            NO, BRANCH
         LA    R9,1(,R9)           UP MERGE ORDER BY 1
ONSTORMX STH   R9,PPIMRGMX         STORE MERGE ORDER
         CLI   WSWITCHC,0          SWITCH C SET ?
         BE    ONSWCNO             NO, BRANCH
         MVI   WSWITCHC,0          CLEAR SWITCH C
         LTR   R9,R9               MERGE ORDER = 0 ?
         BZ    ONCLRTBL            YES, BRANCH
         LR    R1,R3               R1 = I
         LA    R1,1(,R1)           PLUS 1
         CL    R1,KMERGORD         BEYOND TABLE ?
         BNH   ONGOGET             NO, BRANCH
         SR    R1,R1               SET TO 0
ONGOGET  BAS   R10,ONGETTRK        REQUEST A TRACK ADDR
         MVC   PPIDEPHO,PPIWKARE   MOVE ADDR TO DEPHO
         BAS   R10,ONCOMPAC        COMPACT DISK ADDR FOR STORAGE
         LR    R10,R3              R10 = I
         LA    R10,1(,R10)         R10 = I+1
         CL    R10,KMERGORD        BEYOND LAST ENTRY ?
         BNH   ONNOTGMO            NO, BRANCH
         SR    R10,R10             SET R10 = 0
ONNOTGMO SLL   R10,2               TIMES 4
         ST    R9,0(R8,R10)        STORE ADDR AT (L-1,I+1)
         B     ONLDWKAR            GO LOAD PPIWKARE WITH NEXT MRG ADDR
*
ONSWCNO  MVI   WSWITCHC,X'FF'      SET SWITCH C
         LTR   R9,R9               MERGE ORDER = 0 ?
         BZ    ONCLRTBL            YES, BRANCH
         LR    R1,R3               NO, R1 = I
         SH    R1,KONE             MINUS 1
         BNM   ONNOTMIN            ¬ MINUS, BRANCH
         L     R1,KMERGORD         SET TO LAST ENTRY
ONNOTMIN BAS   R10,ONGETTRK        REQUEST A TRACK ADDR
         MVC   PPIDEPHO,PPIWKARE   MOVE ADDR TO DEPHO
         BAS   R10,ONCOMPAC        COMPACT DISK ADDR FOR STORAGE
         LR    R10,R3              R10 = I
         SH    R10,KONE            MINUS 1
         BNM   ONNIXMIN            ¬ MINUS, BRANCH
         L     R10,KMERGORD        SET TO LAST ENTRY
ONNIXMIN SLL   R10,2               I X 4
         ST    R9,0(R8,R10)        STORE ADDR AT (L-1,I-1)
ONLDWKAR LA    R10,4(,R10)         GET LOGICAL AREA INCREMENT
         STC   R10,PPIDEPHO+1      STORE IT
         LA    R12,PPIWKARE        R12 -> WORK AREA
         XC    PPIWKARE+128(8),PPIWKARE+128  CLEAR OUT 8 BYTE AREA
         SR    R14,R14             R14 = 0
ONLOOP2  SR    R9,R9
         A     R9,0(R14,R7)        LOAD R9 WITH ENTRY
         BNZ   ONGOTONE            ¬ ZERO, BRANCH
ONLOOP3  LA    R14,4(,R14)         ZERO, INCR POINTER BY 4
         CH    R14,KBPRLS4         THROUGH WITH THIS LINE ?
         BE    ONONELF             YES, BRANCH
         B     ONLOOP2             LOOP
*
ONGOTONE BAS   R10,ONEXPAND        EXPAND THE DISK ADDR
         MVC   0(8,R12),PPIWKARE+128  MOVE TO LIST FOR READ ROUTINE
         LA    R15,4(,R14)         GET LOGICAL AREA INCREMENT
         STC   R15,1(,R12)         STORE IT IN SECOND BYTE OF ADDR
         LA    R12,8(,R12)         UP LIST POINTER BY 8
         B     ONLOOP3             LOOP
*
ONONELF  LR    R15,R3              R15 = I
         SLL   R15,2               TIMES 4
         SR    R9,R9
         A     R9,0(R8,R15)        GET ENTRY AT L-1 UNDER I
         BZ    ONCLRTBL            SKIP IF NULL ENTRY
         BAS   R10,ONEXPAND        EXPAND DISK ADDR
         MVC   0(8,R12),PPIWKARE+128  MOVE IT TO LIST FOR READ ROUTINE
         LA    R15,4(,R15)         I TIMES 4 PLUS 4
         STC   R15,1(,R12)         INSERT LOGICAL AREA INCREMENT
ONCLRTBL MVI   0(R7),0             ZERO ONE BYTE
         LR    R15,R7              ADDR
         LH    R9,KBPRLS6          GET LENGTH FIELD
         EX    R9,ONMOVE           PROPAGATE ZERO THROUGH ROW-4 BYTES
         LA    R9,2(,R9)           UP IT BY 2
         L     R10,KONEONE
         ST    R10,0(R9,R7)        INSERT 1010 IN LAST 4 BYTES
         LR    R10,R3              R10 = I
         SLL   R10,2               TIMES 4
         SR    R9,R9
         ST    R9,0(R10,R8)        ZERO OUT ENTRY AT L-1 UNDER I
         LH    R9,KBPRLS4          POINTER TO HI
         SR    R10,R10
         IC    R10,1(R9,R8)        GET HI NO AT L-1 ROW
         LA    R10,1(,R10)         UP IT BY 1
         STC   R10,1(R9,R8)        STORE IT BACK
         IC    R12,3(R9,R8)        GET LO NO AT L-1
         SH    R12,KONE            DECREMENT BY 1
         STC   R12,3(R9,R8)        STORE IT BACK
         CL    R10,KMERGORD        HI NO NOW = MERGE ORDER ?
         BL    ONDECL              NO, BRANCH
         LH    R10,0(R9,R8)        GET HI AND HI NO AT L-1
         STH   R10,2(R9,R8)        STORE THEM AT LO AND LO NO AT L-1
         SRL   R10,8               ZERO OUT HI NO
         LA    R10,1(,R10)         ADD ONE TO HI
         SLL   R10,8
         STH   R10,0(R9,R8)        STORE IN HI AND HI NO AT L-1
ONDECL   S     R7,KBYPEROW         DECREMENT L ROW POINTER
         S     R8,KBYPEROW         DECREMENT L-1 ROW POINTER
         BCT   R4,ONNOTZRO         BRANCH ¬= 0
ONUPL    LA    R4,1(,R4)           L = L+1
         A     R7,KBYPEROW         INCREMENT L ROW POINTER
         A     R8,KBYPEROW         INCREMENT L-1 ROW POINTER
         LA    R12,10
         CR    R12,R4              L = 10 ?
         BE    ONMSG46A            YES, BRANCH TO PRINT MESSAGE
         LA    R3,1(,R3)           I = I+1
         CL    R3,KMERGORD         I = M+1 ?
         BNH   ONJTOI              NO, BRANCH
         SR    R3,R3               SET I = 0
ONJTOI   LR    R2,R3               SET J = I
         PPITEST  PPIPH2           SORT OR MERGE ?
         BO    ONMGMX              MERGE, BRANCH
ONEXTNET STM   R2,R8,WSAVE         SAVE REGISTERS OVERLAID AT EOF
         LM    R2,R3,WSAVE1        RESTORE R2 AND R3
         L     R12,PPIAXERT        RELOAD BASE REG FOR EQ OR EXT RTN
         L     R11,PPIINT+4
         B     4(,R11)             EXIT TO SORT ENTRY OF INITIAL
*
ONMGMX   CLI   PPIMRGMX+1,0        MERGE ORDER = 0 ?
         BE    ONMTMSQ             YES, BRANCH
ONRESTO  STM   R2,R8,WSAVE         SAVE REGISTERS
         LM    R2,R3,WSAVE1        RESTORE R2 AND R3
         PPITEST  PPIEQUAL         EQUALS ?
         BZ    ONEXRD              NO, BRANCH
         CLI   WSWITCHA,X'FF'      SWITCH A ON ?
         BE    ONOFFA              YES, BRANCH
*
*        ENTRY - NETWORK INITIALIZATION
*
ONEXRD   L     R11,PPIRD+4
         L     R12,PPIAXERT        RELOAD BASE REG FOR EQ OR EXT RTN
         B     4(,R11)             EXIT TO READ (PRIME)
*
ONOFFA   MVI   WSWITCHA,0          TURN OFF SWITCH A
         L     R11,PPIINT+4
         L     R12,PPIAXERT        RELOAD BASE REG FOR EQ OR EXT RTN
         BR    R11                 EXIT TO INITIAL (MERGE ENTRY)
*
ONNOTZRO SR    R12,R12
         IC    R12,1(R9,R7)        GET HI NO AT L
         CL    R12,KMOMONE         = MERGE ORDER - 1 ?
         BNE   ONUPL               NO, BRANCH
         IC    R12,2(R9,R8)        GET LO AT L-1
         SR    R14,R14
         IC    R14,0(R9,R7)        GET HI AT L
         CR    R12,R14             EQUAL ?
         BNE   ONUPHI              NO, BRANCH
         MVI   WSWITCHD,X'FF'      ANOTHER MERGE PASS TO FOLLOW IMMED
         PPISETON PPICRCX          SET PPICRCX ON (ANOTHER MERGE PASS)
         B     ONMGMX              BRANCH BACK
*
ONUPHI   LH    R9,KBPRLS4          POINTER TO HI
         LH    R10,0(R9,R7)        GET HI AND HI NO AT L
         STH   R10,2(R9,R7)        STORE IN LO AND LO NO AT L
         SRL   R10,8               ZERO OUT HI NO
         LA    R10,1(,R10)         ADD ONE TO HI
         SLL   R10,8
         STH   R10,0(R9,R7)        STORE IN HI AND HI NO AT L
         B     ONUPL               GOTO INCR L
*
ONMSG46A L     R12,PPIRMA+4        SET MSG MOD BASE REG
         LM    R0,R1,IER046        IER046A SORT CAPACITY EXCEEDED
         L     R15,PPIADSSC        R15 -> SSC
         BAS   R14,12(,R15)        CALL PRINT ROUTINE
*
*        APROX RECORD COUNT IS SUM OF UNIT COUNTS - B
*        WHERE B IS A MAX VALUE
*        IF COUNT TURNS NEGATIVE, COUNT IS SET TO B
*        THIS NEGATIVE CONDITION IS MOST LIKELY IF THE BLOCK
*        BEING WRITTEN OUT IS SHORT AND/OR THE RECORD FORMAT IS
*        VARIABLE
*
         L     R1,PPIUNTCT         R1 -> UNIT COUNTERS - TABLE
*                                  CONTAINS NO OF RECORDS PER DEVICE
         SR    R2,R2
         SR    R3,R3
         IC    R3,PPIBDSVA         R3 = TOTAL NO WORK UNITS
RON155   LA    R1,4(,R1)
         A     R2,0(,R1)           SUM UNIT COUNTERS
         BCT   R3,RON155
         LH    R15,PPISRTBL        B  - F = RCDS/BLOCK
         PPITEST  PPIFIX                V = BYTES/BLOCK
         BO    RON157
         SR    R14,R14             B / MIN RCD LENGTH = MAX NO
         LH    R0,PPIRCDL4
         DR    R14,R0              RECORDS IN BLOCK
RON157   CR    R2,R15              CHECK TO MAKE SURE COUNT ISN'T
         BH    RON158              NEGATIVE
         LR    R2,R15              SET RECORD COUNT TO B
         B     RON159
*
RON158   SR    R2,R15              APROX RCD CNT = SUM UNIT CNTS - B
RON159   CVD   R2,WSAVE4           SET UP TO PRINT
         ED    IER066A,WSAVE4+4    FORMAT WITH ZERO SUPPRESS
         L     R1,IER046           REASON FOR ERROR
         MVC   PPIABMNO,3(R1)      MOVE MSG NO INTO ABEND CODE
         LM    R0,R1,IER066        IER066A - APROX RECORD COUNT
         B     ONOUTMSG            BRANCH TO PRINT MESSAGE, TERMINATE
*
*        ROUTINE IS ENTERED AT INPUT EOF AS WELL AS THE
*        SIMULATED EOF WHICH OCCURS AFTER EACH M SEQUENCES HAVE
*        BEEN SORTED
*
ONEOF    STM   R2,R3,WSAVE1        SAVE R2 AND R3 FOR CALLING MOD
         LM    R2,R8,WSAVE         RESTORE REGISTERS FOR OWN USE
         L     R9,WSEQTOTL         INCR SEQUENCE TOTAL
         LA    R9,1(,R9)
         ST    R9,WSEQTOTL
         BAS   R10,ONREORD         REORDER THE FTL (INCR IN R1)
*
ONSETSWM PPISETON PPIPH2           SET MERGE SWITCH (PHASE 2)
         OI    WSWITCHA,X'FF'      SET SWITCH A (SWITCHING TO MERGE PH)
         PPITEST  PPIPEOF          A REAL EOF ?
         BZ    ONNOTYET            NO, BRANCH
         PPITEST  PPIUEOF          REACHED E15 END OF FILE ?
         BO    ONRELEOF            YES, BRANCH
ONNOTYET MVI   WSEQCTR+3,0         SET SEQ CTR = 0
ONONETIM CLC   WSEQTOTL,KMSQURD    M SQUARED + 1 SEQUENCES YET ?
         BNH   ONUPI               NO, BRANCH
         SH    R2,KONE             J=J-1
         BNM   ONJNOTM             J NEGATIVE, BRANCH
         L     R2,KMERGORD         SET J = M
ONJNOTM  LR    R1,R2               R1 = INCREMENT (FROM J)
         BAS   R10,ONGETTRK        REQUEST A DISK ADDR
         MVC   PPIDEPHO,PPIWKARE   MOVE IT TO DEPHO
         BAS   R10,ONCOMPAC        COMPACT DISK ADDR
         LR    R12,R2              R12=J
         SLL   R12,2               TIMES 4
         ST    R9,0(R12,R7)        STORE DISK ADDR IN TABLE AT (LJ)
         LA    R9,4(,R12)          GET LOGICAL AREA INCREMENT
         STC   R9,PPIDEPHO+1       STORE IT
         LH    R9,KBPRLS4          R9 -> HI
         SR    R10,R10             CLEAR R10
         IC    R10,1(R9,R7)        GET HI NO
         LA    R10,1(,R10)         INCR BY 1
         STC   R10,1(R9,R7)        STORE IT BACK
         CL    R10,KMOMONE         HI NO = MERGE ORDER-1 ?
         BE    ONISHILO            YES, BRANCH
*
*        THE FIRST 2 INSTRUCTIONS (10 BYTES) OF THE FOLLOWING
*        CODE WILL BE OVERLAID BY NOPS AFTER A REAL INPUT END OF
*        FILE
*
ONONEPAS PPISETOF PPICRCX          CLEAR PPICRCX (ONLY 1 MRG PASS)
ONSETMO  MVC   PPIMRGMX,KMERGORD+2  SET PPIMRGMX = FULL MERGE
         SR    R1,R1
         L     R14,KTABLEX         R14 -> FIRST ROW OF TABLE
         LA    R12,PPIWKARE        R12 -> FOR STORING ADDRS IN PPIWKARE
ONLOOP4  SR    R9,R9
         A     R9,0(R1,R14)        GET NEXT ENTRY
         BNZ   ONACTADR            NOT ZERO ? BRANCH
ONLOOP5  LA    R1,4(,R1)           ZERO, UP POINTER TO NEXT ENTRY
         CH    R1,KBPRLS4          THROUGH LOOP ?
         BL    ONLOOP4             NO, BRANCH
         B     ONCLFSTR            LOOP FINISHED, BRANCH
*
ONACTADR BAS   R10,ONEXPAND        EXPAND DISK ADDR IN R9
         MVC   0(8,R12),PPIWKARE+128  MOVE ADDR TO PPIWKARE ENTRY
         LR    R15,R1              R15 = INCREMENT
         LA    R15,4(,R15)         INCREMENT + 4 (START AT 4 NOT 0)
         STC   R15,1(,R12)         INSERT LOGICAL INCREMENT
         LA    R12,8(,R12)         INCR POINTER TO PPIWKARE
         B     ONLOOP5             CONTINUE LOOP
*
ONCLFSTR L     R15,KTABLEX         R15 -> FIRST ROW OF TABLE
         MVI   0(R15),0            ZERO FIRST BYTE
         LH    R9,KBPRLS6          NO OF BYTES TO ZERO
         EX    R9,ONMOVE           PROPAGATE ZEROS THROUGH FIRST ROW-4
         B     ONRESTO             GO RESTORE REGS AND EXIT
*
ONUPI    LA    R3,1(,R3)           I = I+1
         CL    R3,KMERGORD         I = MERGE ORDER+1 ?
         BNH   ONSKIP1             NO, BRANCH
         SR    R3,R3               I=0
ONSKIP1  LR    R1,R3               R1 = I
         BAS   R10,ONGETTRK        REQUEST A DISK ADDR
         MVC   PPIDEPHO,PPIWKARE   MOVE IT TO DEPHO
         BAS   R10,ONCOMPAC        COMPACT ADDR
         LR    R12,R3              R12 = I
         SLL   R12,2               TIMES 4
         ST    R9,0(R12,R7)        STORE DISK ADDR AT (LI)
         LA    R9,4(,R12)          GET LOGICAL AREA INCREMENT
         STC   R9,PPIDEPHO+1       STORE IT
         LH    R9,KBPRLS1          POINTER TO LO NO
         SR    R12,R12             CLEAR R12
         L     R10,KTABLEX0        POINTER TO L = 0 ROW OF TABLE
         IC    R12,0(R10,R9)       GET LO NO
         LA    R12,1(,R12)         UP BY 1
         STC   R12,0(R10,R9)       STORE IT BACK
         CL    R12,KMERGORD
         BNE   ONONEPAS            BRANCH IF LO NO NOT EQ MERGE ORDER
         LA    R4,1(,R4)           SET L=L+1
         A     R7,KBYPEROW         UP POINTER TO NEW L ROW
         A     R8,KBYPEROW         UP POINTER TO NEW L-1 ROW
         B     ONONEPAS            BRANCH TO ONLY 1 MERGE PASS RTN
*
ONISHILO SR    R14,R14
         SR    R15,R15
         IC    R14,0(R9,R7)        GET HI AT L
         IC    R15,2(R9,R8)        GET LO AT L-1
         CR    R14,R15             EQUAL ?
         BE    ONMTOPAS            YES, GOTO MORE THAN 1 PASS ROUTINE
         LH    R12,0(R9,R7)        GET HI AND HI NO AT L
         STH   R12,2(R9,R7)        STORE IN LO AND LO NO AT L
         SRL   R12,8               HI NO = 0
         LA    R12,1(,R12)         HI = HI+1
         SLL   R12,8               POSITION
         STH   R12,0(R9,R7)        STORE AT HI AND HI NO OF L
         LA    R4,1(,R4)           L = L+1
         A     R7,KBYPEROW         UP L ROW POINTER
         A     R8,KBYPEROW         UP L-1 ROW POINTER
         LA    R12,10
         CR    R4,R12              L = 10 ?
         BE    ONMSG46A            GO PRINT MESSAGE AND TERMINATE
         LA    R3,1(,R3)           I = I+1
         CL    R3,KMERGORD         I PAST LAST ENTRY ?
         BNH   ONSKIP2             NO, BRANCH
         SR    R3,R3               I = 0
ONSKIP2  LR    R2,R3               SET J = I
         B     ONONEPAS
*
ONMTOPAS PPISETON PPICRCX          SET MORE THAN 1 PASS
         MVI   WSWITCHC,0          CLEARED FOR ODD NUMBERED CONSECUTIVE
*                                  MERGE PASSES
         MVI   WSWITCHD,X'FF'      ANOTHER MERGE PASS TO FOLLOW IMMED
         B     ONSETMO             GO SET UP TO MERGE
*
*        ENTRY - WRITE ROUTINE REQUESTED A CHAIN ADDR
*        R1 CONTAINS THE ACTUAL AREA INCREMENT FOR THE BLOCK
*        BEING WRITTEN
*
ONCHNADR L     R6,KFRTRKLT         R6 -> FTL ROW OF TABLE (-4)
         LR    R0,R14              SAVE RETURN REG
         BAS   R10,ONNOTMT         GET A NEW CHAIN ADDR
         LR    R14,R0              RESTORE RETURN REG
         L     R12,PPIAXERT        RELOAD BASE REG FOR EQ OR EXT RTN
         L     R11,PPIWRT+4        RESTORE BASE REG FOR WRITE MODULE
         BR    R14                 RETURN TO WRITE ROUTINE
*
*        ENTRY - READ ROUTINE AT EOS
*
*        R1 CONTAINS THE LOGICAL AREA INCREMENT
*        DETERMINE IF ANOTHER MERGE PASS IS TO FOLLOW AND IF SO
*        WHETHER OR NOT ANOTHER READ CAN BE INITIATED ON THIS
*        AREA NOW. IF IT CAN RETURN WITH R1 = 4 AND THE ADDR TO
*        BE READ IN PPIWKARE. ELSE R1 WILL BE ZERO
*
ONRDEOS  CLI   WSWITCHD,0          ANOTHER MERGE PASS FOLLOW ?
         LM    R2,R8,WSAVE         LOAD MODULE REGISTERS
         BE    ONNOMO              NO, BRANCH
         CLI   WSWITCHC,0          SWITCH C OFF ?
         BE    ONSWCOFF            YES, BRANCH
         LR    R12,R3              R12 = I
         SLL   R12,2               TIMES 4
         LA    R12,8(,R12)         PLUS 8
         CL    R12,KBYPEROW        R12 BEYOND LAST ENTRY ?
         BNE   ONSKIP3             NO, BRANCH
         LA    R12,4               SET TO FIRST ENTRY
ONSKIP3  CR    R1,R12              R1 = AREA I+1 ?
         BE    ONNOMO              YES, BRANCH (THIS IS THE AREA
*                                  BEING WRITTEN)
ONDORBEI LR    R12,R3              R12 = I
         SLL   R12,2               TIMES 4
         LR    R14,R1              R14=LOGICAL INCREMENT
         SH    R14,KFOUR           MINUS 4 (TABLE STARTS AT 0 NOT 4)
         CR    R12,R14             INCREMENT FOR I AREA
         BE    ONRBEI              YES, BRANCH
         SR    R9,R9
         A     R9,0(R14,R7)        GET THIS ENTRY
         BZ    ONNOMO              ZERO ? BRANCH
ONEXPEXT BAS   R10,ONEXPAND        EXPAND TO 8 BYTE ADDR
         MVC   PPIWKARE(8),PPIWKARE+128    MOVE TO WORK AREA
         STC   R1,PPIWKARE+1       INSERT LOGICAL AREA INCREMENT
         LA    R1,4                INDICATE READ POSSIBLE
ONEXITRD L     R11,PPIRD+4
         L     R12,PPIAXERT        RELOAD BASE REG FOR EQ OR EXT RTN
         BR    R11                 EXIT TO READ ROUTINE
*
ONSWCOFF LR    R12,R3              R12 = I
         SLL   R12,2               TIMES 4
         LTR   R12,R12             ZERO ?
         BNZ   ONSKIP4             NOT, ZERO, BRANCH
         LH    R12,KBPRLS4         SET TO LAST ENTRY IN ROW
ONSKIP4  CR    R12,R1              INCREMENT FOR I-1 AREA ?
         BE    ONNOMO              YES, BRANCH (THIS IS THE AREA
*                                  BEING WRITTEN)
         B     ONDORBEI            GO SEE IF THIS IS AREA UNDER I
*
ONRBEI   SR    R9,R9
         A     R9,0(R14,R8)        ADDR AT L-1 OF THIS INCR REAL ?
         BZ    ONNOMO              NO, BRANCH
         B     ONEXPEXT            GO EXPAND ADDR AND EXIT
*
ONNOMO   SR    R1,R1               INDICATE NO READ
         B     ONEXITRD            GO EXIT TO READ
*
*        ROUTINE WILL BE ENTERED ONLY ONCE AFTER THE REAL END OF
*        FILE HAS BEEN REACHED
*        SOME CODE IS OVERLAID SO THAT THERE IS NO RETURN TO THE
*        SORT PHASE
*
ONRELEOF PPISETON PPICRCX          SET PPICRCX (ONLY MERGE PASSES)
         MVC   ONNOEOF(4),KNOP     OVERLAY CLEAR MERGE BIT INSTRUCT
         MVC   ONONEPAS(4),KNOP    OVERLAY CLEAR MERGE BIT INSTRUCT
         MVC   ONSETMO(6),KNOP     OVERLAY SET MERGE ORDER
         SR    R14,R14
         L     R15,WSEQTOTL
         D     R14,KMERGORD        DIVIDE TOTAL SEQS BY MERGE ORDER
         LTR   R14,R14             REMAINDER = 0 ?
         BNZ   ONSKIP5             NO, BRANCH
         L     R14,KMERGORD        YES, THIS IS A FULL MERGE
ONSKIP5  STH   R14,PPIMRGMX        SET MERGE ORDER FOR NEXT MERGE
         CLC   WSEQTOTL,KMERGORD   MORE THAN M SEQUENCES ?
         BH    ONSETX              YES, BRANCH
         L     R5,KTABLEX          R5 -> FIRST ROW
         B     ONEQZER4            GO SET UP PPIENDAR AND EXIT
*
ONSETX   L     R12,KMERGORD
         SH    R12,PPIMRGMX        R12 = NORMAL MERGE ORDER - THIS MO
         CLC   WSEQTOTL,KMSQURD    M SQUARED SEQUENCES YET ?
         BH    ONSKIP6             YES, BRANCH
         AR    R3,R12              I = I+X
         CL    R3,KMERGORD         BEYOND END OF TABLE ?
         BNH   ONSKIP7             NO, BRANCH
         S     R3,KMERGORD         SUBTRACT MERGE ORDER
         BCTR  R3,0                SUBTRACT ONE MORE
         B     ONSKIP7             GO FINISH OVERLAY
*
ONSKIP6  SR    R2,R12              J = J-X
         BNM   ONSKIP7             J ¬ -VE, BRANCH
         A     R2,KMERGORD         ADD MERGE ORDER
         AH    R2,KONE             PLUS 1
ONSKIP7  OI    ONOLYEOF+1,X'F0'    CHANGE INSTRUCTION TO BRANCH
         MVC   ONEXTNET(4),ONSETSWM     OVERLAY CODE
         MVC   ONEXTNET+4(4),KOVERLAY
         B     ONONETIM            SORTING IS DONE FINISH MERGES
*
*        ROUTINE IS ENTERED ONLY AFTER THE REAL INPUT END OF
*        FILE WHEN A SIMULATED MERGE PASS IS TO BE DONE
*        (THE TABLE IS UPDATED BUT NO MERGING IS DONE)
*
ONAFTEOF LA    R2,1(,R2)           J = J+1
         CL    R2,KMERGORD         J BEYOND END OF TABLE ?
         BNH   ONSKIP8             NO, BRANCH
         SR    R2,R2               SET J = 0
ONSKIP8  LH    R10,KBPRLS4
         LH    R12,0(R10,R7)       GET HI NO AT L
         LA    R12,1(,R12)         ADD 1
         STH   R12,0(R10,R7)       STORE IT BACK
         MVI   WSWITCHC,0          TURN OFF SWITCH C
         B     ONMTMSQ             MERGE PASS SIMULATED GO BACK AND
*                                  SEE IF THERE ARE M-1 SEQUENCES AT
*                                  THIS LEVEL OF THE TABLE NOW
*
*        OBTAIN A TRACK FROM THE FREE TRACK LIST INDICATED BY R1
*
*        ON RETURN THE ADDR IS IN THE FIRST 8 BYTES OF PPIWKARE
*        IF THE INCREMENT IN R1 IS IN THE FORM 0,1,2 ETC THE
*        SUBROUTINE IS ENTERED FROM THE TOP. IF IT IS IN THE FORM
*        4,8,12 ETC THE SUBROUTINE IS ENTERED AT +8 (ONNOTMT)
*        IF NO TRACKS ARE AVAILABLE FOR THE INDICATED AREA A
*        SEARCH IS MADE FOR THE LARGEST REMAINING SEGMENT AND A
*        TRACK IS TAKEN FROM THAT AREA LIST
*        ON ENTRY -
*        R1  = M (MAYBE 0,1,2 OR 4,8 ETC DEPENDING ON ENTRY POINT)
*        R6 -> KFRTRKLT FTL ROW OF TABLE
*
*
ONGETTRK SLL   R1,2                CHANGE INCR FROM 0,1,2 ETC TO 4,8
         LA    R1,4(,R1)
ONNOTMT  XC    PPIWKARE(8),PPIWKARE  ZERO OUT PPIWKARE (FIRST 8 BYTES)
         SR    R9,R9
         IC    R9,0(R1,R6)         GET NUMBER OF ENTRIES THIS AREA
         L     R12,0(R1,R6)        R12 -> FIRST ENTRY
         LTR   R9,R9               ANY ENTRIES ?
         BZ    ONFNDBIG            NO, BRANCH
         SR    R14,R14             YES, RETURN WITH THIS ENTRY
         ICM   R14,B'0011',0(R12)  R14 = TT
         STCM  R14,B'0011',PPIWKARE+5  STORE TT
         MVI   PPIWKARE+7,X'01'    SET RECORD NUMBER TO FIRST ON TRACK
         STC   R1,PPIWKARE         STORE REAL INCREMENT
         LA    R14,1(,R14)         INCR TT
         STCM  R14,B'0011',0(R12)  STORE NEW TT
         MVI   IER930Q,C'Q'        REQUEST TRACK TRACE ENTRY
         BAS   R15,TRACKT          TRACE TRACK ALLOCATION
*
*        CHECK IF THIS ENTRY NOW EMPTY
*
         SR    R15,R15
         ICM   R15,B'0011',2(R12)  R15 = END TT
         CR    R14,R15             NEW STARTING TT > ENDING TT ?
         BNHR  R10                 NO, RETURN TO CALLER
         BCT   R9,ONMVFTL          YES, DECR COUNT, BRANCH IF NOT 0
ONRETURN STC   R9,0(R1,R6)         STORE COUNT
         BR    R10                 RETURN
*
*        MULTIPLE ENTRIES FOR THIS AREA
*
ONMVFTL  LR    R14,R9              R14 = COUNT OF ENTRIES IN THIS AREA
ONLOOP6  LA    R15,4(,R12)         R15 -> NEXT ENTRY IN TABLE
         CLI   0(R15),X'FF'        CHAIN ADDR ?
         BE    ONTHISCH            YES, BRANCH
ONLOOP7  MVC   0(4,R12),0(R15)     NO, MOVE ENTRY UP 1 PLACE
         BCT   R14,ONSKIP10        BRANCH IF NOT DONE
         B     ONRETURN            GO RETURN
*
*        CHAINED ADDR PROCESSING
*
ONTHSCHN STM   R2,R4,WSAVE6        SAVE REGISTERS
         SR    R2,R2               SUBTRACT REGISTERS
         SR    R3,R3               FOR DIVIDEND
         LR    R3,R9               R3 = NO ENTRIES FOR THIS AREA
         LA    R4,9                NINE FOR DIVIDEND
         DR    R2,R4               CHECK IF SEGMENT
         CH    R2,KONE             IN POOL CAN BE RELEASED ?
         BNE   ONSKIP21            NO, BRANCH BACK
         CH    R14,KONE            SEGMENT CAN BE RELEASED ?
         BNE   ONSKIP21            NO, BRANCH BACK
         LA    R15,4(,R15)         R15 POINTER TO NEXT LIST ENTRY
         LR    R2,R12              KEEP ADDR
         L     R4,KFPPTR           LOAD ADDR TO FREPOOL LIST
         AH    R4,KFOUR            UPDATE POINTER
         ST    R4,KFPPTR           RESTORE UPDATED ADDR
         L     R2,0(,R2)           LOAD ADDR TO NEXT ENTRY
         ST    R2,0(,R4)           MOVE ENTRY UP 1 PLACE
         IC    R4,KFPPTR           INCR NO OF ENTRIES
         LA    R4,1(,R4)           BY ONE
         STC   R4,KFPPTR           AND STORE IT BACK
         LM    R2,R4,WSAVE6        RESTORE WORK REGISTERS
         B     ONLOOP7             BRANCH BACK
*
ONSKIP21 LM    R2,R4,WSAVE6        RESTORE WORK REG
         L     R12,0(,R12)         GET ADDR FROM CHAIN ADDR
         B     ONLOOP6             GO UPDATE OTHER POINTER
*
ONTHISCH L     R15,0(,R15)         GET ADDR FROM CHAIN ADDR
         B     ONLOOP7             GO MOVE ENTRY UP 1 PLACE
*
ONSKIP10 LA    R12,4(,R12)         UPDATE POINTER TO NEXT ENTRY
         CLI   0(R12),X'FF'        CHAIN ADDR ?
         BE    ONTHSCHN            YES, BRANCH
         B     ONLOOP6             GO UPDATE OTHER POINTER
*
ONFNDBIG LA    R1,4                SET R1 TO GET FIRST LIST ADDR
         SR    R15,R15             CLEAR FOR LARGEST AREA
ONLOOP8  L     R14,0(R1,R6)        R14 = ADDR OF LIST
         SR    R12,R12
         SR    R9,R9
         ICM   R12,B'0011',2(R14)  R12 = ENDING TT ADDR
         ICM   R9,B'0011',0(R14)   R9  = STARTING TT ADDR
         SR    R12,R9              END ADDR MINUS START ADDR
         BM    ONSKIP11            EMPTY, BRANCH
         OI    WSWITCHB,X'FF'      INDICATE A TRACK AVAILABLE
         CR    R12,R15             NEWEST AREA THE LARGEST SO FAR ?
         BL    ONSKIP11            NO, BRANCH
         LR    R15,R12             SAVE ITS SIZE
         STH   R1,WSAVE2           SAVE INCREMENT TO IT
ONSKIP11 LA    R1,4(,R1)           UP POINTER TO NEXT LIST ADDR
         CL    R1,KBYPEROW         DONE CHECKING ?
         BNE   ONLOOP8             NO, BRANCH
         CLI   WSWITCHB,0          ANY TRACKS AVAILABLE ?
         BE    ONMSG46A            NO, BRANCH TO PRINT AND TERMINATE
         MVI   WSWITCHB,0          TURN SWITCH OFF FOR NEXT TIME
         LH    R1,WSAVE2           GET INCREMENT TO LARGEST AREA
         B     ONNOTMT             GO GET AN ADDR FROM THIS AREA
*
*        ROUTINE IS ENTERED ONLY WHEN THE READ ROUTINE HAS
*        FINISHED READING A TRACK
*
*        THE TRACK ADDR IS IN PPIWKARE. THIS ROUTINE WILL
*        RESTORE THAT ADDR TO THE FREE TRACK LIST AND RETURN TO
*        THE READ ROUTINE
*
ONRDTREL L     R6,KFRTRKLT         R6 -> LAST ROW-4 IN FREE TRACK TABLE
         MVI   IER930Q,C'L'        TRACE RELEASE TRACE ENTRY
         BAS   R15,TRACKT          CALL TRACE TRACE DEBUGGING
         SR    R1,R1
         SR    R9,R9
         IC    R1,PPIWKARE         GET M INCREMENT
         IC    R9,0(R1,R6)         GET NUMBER OF ENTRIES
         L     R12,0(R1,R6)        R12 -> FIRST ENTRY
         MVC   WSAVE2,PPIWKARE+5   MOVE TT TO WSAVE2
         LTR   R9,R9               ANY ENTRIES ?
         BZ    ONNOENTS            NO, BRANCH
ONLOOP10 SR    R15,R15
         ICM   R15,B'0011',2(R12)  R15 = END ADDR FOR THIS ENTRY
         SR    R10,R10
         ICM   R10,B'0011',WSAVE2  R10 = TT FROM PPIWKARE
         SR    R10,R15             SUBTRACT END ADDR FOR THIS ENTRY
         BCT   R10,ONDECRJ         BRANCH UNLESS DIFFERENCE IS 1
         SR    R10,R10
*                                  RELOAD RELEASE ADDR
         ICM   R10,B'0011',WSAVE2  R10 = PPIWKARE TT
         STCM  R10,B'0011',2(R12)  STORE AS NEW END ADDR
ONOUTRD  L     R11,PPIRD+4         RELOAD BASE REG FOR CALLING MODULE
         L     R12,PPIAXERT        RELOAD BASE REG FOR EQ OR EXT RTN
         BR    R14                 RETURN TO READ ROUTINE
*
ONDECRJ  LA    R12,4(,R12)         INCR TABLE ADDR TO NEXT ENTRY
         BCT   R9,ONSKIP12         DECR R9, BRANCH IF NOT 0
         B     ONNEWENT            BRANCH TO NEW ENTRY ROUTINE
*
ONSKIP12 CLI   0(R12),X'FF'        CHAIN ADDR ?
         BNE   ONLOOP10            NO, BRANCH
         L     R12,0(,R12)         YES, USING CHAIN ADDR GET ADDR
*                                  OF NEXT ENTRY
         B     ONLOOP10            GO CONTINUE SEARCH
*
ONNOENTS MVC   0(2,R12),PPIWKARE+5  MAKE THIS THE STARTING ADDR
         MVC   2(2,R12),PPIWKARE+5  AND THE ENDING ADDR
         IC    R9,0(R1,R6)         GET NUMBER OF ENTRIES
         LA    R9,1(,R9)           INCR BY 1
         STC   R9,0(R1,R6)         STORE IT BACK
         B     ONOUTRD             GO EXIT TO READ
*
ONNEWENT SR    R4,R4
         SR    R5,R5               CLEAR REGS FOR DIVIDEND
         IC    R5,0(R1,R6)         INSERT NUMBER OF ENTRIES
         CH    R5,KONE             ONLY ONE ENTRY ?
         BE    ONNOENTS            YES, BRANCH
         LA    R7,9
         DR    R4,R7               DIVIDE BY 9
         CH    R4,KONE             REMAINDER = 1 ?
         BNE   ONNOENTS            NO, BRANCH
*
*        CODE IS ENTERED IF A SEGMENT (40 BYTES) OF FREE TRACK
*        LIST IS FILLED AND MORE IS NEEDED
*        IT IS GOTTEN FROM A POOL AND THE SEGMENTS ARE CHAINED
*        TOGETHER
*
         SR    R4,R4
         AH    R4,KPOOLSZ          ANYTHING LEFT IN POOL ?
         BZ    ONSKIP16            NO, BRANCH
         L     R5,KPOOL            R5 -> POOL
         LA    R7,40(,R5)          UP IT BY 40
         ST    R7,KPOOL            STORE NEW ADDR BACK
         SH    R4,KFORTY           SUBTRACT 40 FROM AMOUNT REMAINING
         STH   R4,KPOOLSZ          STORE IT BACK
ONSKIP17 SH    R12,KFOUR           MOVE POINTER BACK TO LIST ENTRY
         MVC   0(4,R5),0(R12)      MOVE LAST ENTRY TO NEW SEGMENT
         ST    R5,0(,R12)          INSERT CHAIN ADDR
         MVI   0(R12),X'FF'        FLAG IT AS A CHAIN ADDR
         LA    R12,4(,R5)          SET ENTRY POINTER TO NEW SEG+4
         B     ONNOENTS            GO INSERT NEW ENTRY
*
ONSKIP16 SR    R4,R4
         ICM   R4,B'0001',KFPPTR   ANY ENTRIES IN FREE POOL ?
         BZ    ONMSG46A            NO, SORT CAPACITY EXCEEDED
         BCTR  R4,0                YES, DECR ENTRY BY ONE
         L     R5,KFPPTR           R5 -> FREE POOL LIST
         LR    R7,R5               R7 -> FREE POOL LIST
         SH    R7,KFOUR            DECREMENT ADDR BY FOUR
         ST    R7,KFPPTR           RESTORE UPDATED ADDR
         STC   R4,KFPPTR           RESTORE UPDATED ENTRY
         L     R5,0(,R5)           POINT TO POOL
         B     ONSKIP17            BRANCH BACK
*
*        SUBROUTINE IS ENTERED EACH TIME THAT A WRITE EOS
*        CONDITION OCCURS.
*        IT COMBINES ADJACENT SEGMENTS ON A FREE TRACK LIST. IF
*        SORTING ONLY THE LIST FOR THE AREA BEING WRITTEN ON IS
*        CONSIDERED. IF MERGING ALL LISTS ARE CONSIDERED. EACH
*        TIME A LIST IS FINISHED BRANCH TO ANOTHER SUBROUTINE
*        WHICH REORDERS THE LIST BY SIZE OF SEGMENT WITH THE
*        LARGEST SEGMENT BEING PUT AT THE TOP OF THE LIST
*
ONREORD  STM   R2,R5,WSAVE4        SAVE REGISTERS
         PPITEST  PPIPH2           MERGING ?
         BZ    ONSOTING            NO, SORTING
         ST    R10,WSAVE3          SAVE RETURN REGISTER
         LA    R1,4                SET R1 TO FIRST AREA
ONLOOP11 BAS   R10,ONSOTING        CALL ONSOTING TO DO THIS LIST
         CH    R1,KBPRLS4          FINISHED ALL LISTS ?
         BE    ONRESTLK            YES, BRANCH
         LA    R1,4(,R1)           INCR POINTER TO NEXT LIST
         B     ONLOOP11            LOOP FOR NEXT LIST
*
ONRESTLK L     R10,WSAVE3          RESTORE RETURN ADDR
ONGOBACK LM    R2,R5,WSAVE4        RESTORE REGISTERS
         BR    R10                 RETURN
*
ONSOTING SR    R2,R2
         IC    R2,0(R1,R6)         R2 = NO OF ENTRIES
         L     R9,0(R1,R6)         R9 -> FIRST ENTRY
         LA    R12,4(,R9)          R12 -> SECOND ENTRY
         LR    R3,R2
         BCTR  R3,0                Y = X-1
         CH    R2,KONE             X = 0 OR 1
         BNH   ONGOBACK            YES, GO RETURN
ONLOOP12 SR    R14,R14
         SR    R15,R15
         ICM   R14,B'0011',2(R12)  GET END TT ADDR OF SECOND ENTRY
         ICM   R15,B'0011',0(R9)   GET START ADDR AT FIRST ENTRY
         SR    R15,R14             SUB END TT ADDR FROM START TT ADDR
         BCT   R15,ONNOTADJ        NOT ADJACENT, BRANCH
         MVC   0(2,R9),0(R12)      MOVE START ADDR FROM PTR 2 TO 1
         B     ONCOMBED            BRANCH, THESE HAVE BEEN COMBINED
*
ONNOTADJ ICM   R14,B'0011',2(R9)   GET END TT AT FROM ENTRY 1
         SR    R15,R15
         ICM   R15,B'0011',0(R12)  GET START TT AT ENTRY 2
         SR    R15,R14             SUB END TT ADDR FROM START TT ADDR
         BCT   R15,ONNOAGIN        NOT ADJACENT, BRANCH
         MVC   2(2,R9),2(R12)      MOVE END TT ADDR FROM PTR 2 TO PTR 1
         B     ONCOMBED            THESE HAVE NOW BEEN COMBINED
*
ONNOAGIN LA    R12,4(,R12)         UPDATE POINTER 2
         SH    R3,KONE             DECREMENT Y
         BZ    ONISXLES            Y = 0, BRANCH
ONLOOP14 CLI   0(R12),X'FF'        CHAIN ADDR AT POINTER 2 ?
         BNE   ONLOOP12            NO, BRANCH
         L     R12,0(,R12)         YES, GET ADDR OF NEXT ENTRY
         B     ONLOOP12            GO CHECK ANOTHER PAIR OF ENTRIES
*
ONCOMBED SR    R5,R5
         IC    R5,0(R1,R6)         GET NUMBER OF ENTRIES
         BCTR  R5,0                DECREMENT BY 1
         STC   R5,0(R1,R6)         STORE IT BACK
         BCTR  R2,0                DECREMENT X
         LR    R4,R3               SET Z = Y
ONLOOP13 SH    R4,KONE             MINUS 1
         BZ    ONSKIP18            GO REORDER FTL & POOL
         LA    R5,4(,R12)          SET POINTER 3 = POINTER 2+4
         CLI   0(R5),X'FF'         CHAIN ADDR AT POINTER 3 ?
         BNE   ONSKIP15            NO, BRANCH
         L     R5,0(,R5)           YES, GET ADDR OF NEXT ENTRY
ONSKIP15 MVC   0(4,R12),0(R5)      MOVE ENTRY FROM PTR 3 TO PTR 2
         LR    R12,R5              SET POINTER 2 = POINTER 3
         B     ONLOOP13            GO CONTINUE MOVING
*
ONISXLES SH    R2,KTWO             X = X-2
         BNP   ONCHKENT            X = 0 OR -VE, BRANCH
         AH    R2,KONE             X = X+1
         LA    R9,4(,R9)           UPDATE POINTER 1
         CLI   0(R9),X'FF'         CHAIN ADDR AT POINTER 1 ?
         BNE   ONMOVOVR            NO, BRANCH
         L     R9,0(,R9)           YES, GET ADDR OF NEXT ENTRY
ONMOVOVR LR    R12,R9              SET POINTER 2 = POINTER 1
         LR    R3,R2               SET Y = X
         B     ONNOAGIN            GO CONTINUE SEARCH
*
ONSKIP18 STM   R2,R4,WSAVE6        KEEP MAINLINE REGS
         SR    R2,R2               CLEAR REG
         SR    R3,R3               FOR DIVIDEND
         IC    R3,0(R1,R6)         GET NO ENTRIES
         CH    R3,KONE             ONLY ONE ENTRY ?
         BE    ONSKIP19            YES, BRANCH
         LA    R4,9                BY DIVIDING NO ENTRIES BY
         DR    R2,R4               NINE NO OF FREE TRACK SEGMENTS
         CH    R2,KONE             CAN BE DETERMINED
         BNE   ONSKIP19            MORE THAN ONE SEGMENT, BRANCH
         L     R5,0(R1,R6)         LOAD STARTING ADDR
         SR    R2,R2               ZERO REG
         IC    R2,0(R1,R6)         INSERT NO ENTRIES
ONLOOPZZ BCT   R2,ONSKIPXX         SCAN FTL
         B     ONSKIP19            BRANCH OUT ENTIRE ENTRY DONE
*
ONSKIPXX LA    R5,4(,R5)           INCT TO NEXT ENTRY
         CLI   0(R5),X'FF'         CHAIN ADDR ?
         BNE   ONLOOPZZ            NO, LOOP BACK
         CH    R2,KONE             LAST ENTRY ?
         BNE   ONLOOPZZ            NO, CONTINUE SEARCH
         LR    R3,R5               KEEP POINTER REG
         L     R5,0(,R5)           GET NEW LIST ADDR
         ST    R5,KCHAIN           KEEP CHAIN ADDR
         L     R4,KFPPTR           LOAD POINTER TO FREE POOL
         AH    R4,KFOUR            UP IT BY FOUR
         ST    R4,KFPPTR           RESTORE UPDATED ADDR
         MVC   0(4,R4),KCHAIN      MOVE POOL ADDR IN LIST
         IC    R4,KFPPTR           UPDATE TOTAL NO OF
         AH    R4,KONE             ENTRIES IN LIST
         STC   R4,KFPPTR
         MVC   0(4,R3),0(R5)       MOVE ENTRY
         B     ONLOOPZZ            BRANCH BACK
*
ONSKIP19 LM    R2,R4,WSAVE6        RESTORE MAINLINE REGISTERS
         B     ONMOVOVR            BRANCH OUT
*
ONCHKENT SR    R15,R15
         IC    R15,0(R1,R6)        GET NUMBER OF ENTRIES
         BCT   R15,ONORDLST        > 0, BRANCH
         B     ONGOBACK            GOTO RETURN
*
ONORDLST L     R15,0(R1,R6)        POINTER TO INITIAL ENTRY (PTR 1)
         LA    R14,4(,R15)         POINTER TO NEXT ENTRY (PTR 2)
         SR    R12,R12
         IC    R12,0(R1,R6)        NO OF ENTRIES IN THIS LIST
         LR    R9,R12
         BCTR  R9,0                ESTABLISH COUNTER (ENTRIES - 1)
ONDTRARA SR    R5,R5
         ICM   R5,B'0011',0(R15)   R5 = START TT ADDR AT PTR1
         SR    R4,R4
         ICM   R4,B'0011',2(R15)   R4 = END TT ADDR AT PTR1
         SR    R4,R5               CALC SIZE OF AREA AT PTR1
         ICM   R5,B'0011',0(R14)   R5 = START TT ADDR AT PTR2
         SR    R2,R2
         ICM   R2,B'0011',2(R14)   R2 = END TT ADDR AT PTR2
         SR    R2,R5               CALC SIZE OF AREA AT PTR2
         CR    R4,R2               PTR1 AREA => PTR2 AREA ?
         BNL   ONSUB3              YES, TRY NEXT ENTRY IN LIST
         L     R3,0(,R15)          NO, SWAP PTR1 AND PTR2 ENTRIES
         MVC   0(4,R15),0(R14)
         ST    R3,0(,R14)
ONSUB3   LA    R14,4(,R14)         INCR PTR2 FOR NEXT ENTRY
         BCT   R9,ONSUB4           THIS PASS THRU LIST DONE ?
         B     ONSUB5              YES, GO SEE IF ENTIRE LIST DONE
*
ONSUB4   TM    0(R14),X'FF'        CHAIN ADDR AT PTR2 ?
         BNO   ONDTRARA            NO, DETERMINE AREA OF NEXT ENTRY
         L     R14,0(,R14)         YES, UPDTE PTR2 FOR CHAIN LIST
         B     ONDTRARA            COMPUTE AREA OF CHAIN LIST ENTRY
*
ONSUB5   CLM   R12,B'0001',=X'03'  ALL ENTRIES ORDERED ?
         BL    ONRETRN             YES, GO SET UP FOR MAIN PROG RETURN
         BCTR  R12,0               NO, DECR LIST ENTRIES BY ONE
         LR    R9,R12
         BCTR  R9,0                DECR PASS THRU LIST CTR BY 1
         LA    R15,4(,R15)         UPDATE PTR1 TO NEXT ENTRY
         TM    0(R15),X'FF'        PTR1 ENTRY A CHAIN ADDR ?
         BNO   ONSUB6              NO
         L     R15,0(,R15)         YES, UPDT PTR1 TO CHAIN LIST ENTRY
ONSUB6   LA    R14,4(,R15)         SET PTR2 EQUAL TO PTR1+4
         B     ONSUB4              GO SEE IF PTR2 IS A CHAIN ADDR
*
ONRETRN  LM    R2,R5,WSAVE4        RESTORE REGISTERS
         BR    R10                 RETURN TO CALLER
*
*        RECORD COUNT SUBROUTINE
*
ONRCDCNT L     R9,PPICOUNT         DETERMINE NO OF INPUT RECORDS
         A     R9,PPIINSCT         ADD RECORDS INSERTED
         S     R9,PPIDELCT         SUBTRACT RECORDS DELETED
         L     R15,PPIUNTCT        GET PTR TO RECORD/UNIT COUNT TABLE
         LA    R15,4(,R15)
         LH    R12,PPINDSKA        GET NUMBER OF DISK AREAS
         SR    R14,R14
ONRCDTOT A     R14,0(,R15)         SUM RECORDS FROM WORK AREAS
         LA    R15,4(,R15)         INCR FOR NEXT WORK AREA RECORD COUNT
         BCT   R12,ONRCDTOT        LOOP TO TOTAL ALL AREAS
         PPITEST  PPIPEOF          QSAM REACHED END OF FILE ?
         BZ    ONFLSHRC            NO, BRANCH
         PPITEST  PPIUEOF          YES, USER REACHED EOF ?
         BO    ONRCDCMP            YES, GO CHECK RECORD COUNTS
         B     ONSERT              NO, QSAM HAS BUT USER HASN'T
*
ONFLSHRC BCTR  R9,0                SUBTRACT 1 FOR RECORD HELD BACK
*                                  TO FORCE FLUSHING
         PPITEST  PPIUIIP          USER INSERT IN PROGRESS ?
         BZ    ONRCDCMP            NO, GO COMPARE RECORD COUNTS
ONSERT   BCTR  R9,0                YES, SUBTRACT 1 FOR RCD HELD
*                                  BACK TO ALLOW USER INSERT
ONRCDCMP CR    R9,R14              RECORDS IN = RECORDS OUT ?
         BNE   ONCNTABT            NO, GOTO TERMINATE RTN
         BR    R10                 RCD CNT EQUAL, RETURN TO MAINLINE
*
*        RECORD COUNT ERROR
*        PRINT COMPUTED TOTALS AND TERMINATE THE JOB
*        R14 = RECORDS OUT, R9 = RECORDS IN
*
ONCNTABT L     R12,PPIRMA+4        SET MESSAGE MODULE ADDR
         CVD   R14,WSAVE4          CONVERT RECORDS OUT TO DECIMAL
         MVC   IER047O,EPATTERN    MOVE IN ZERO SUPPRESS ED PATTERN
         ED    IER047O,WSAVE4+4    FORMAT RECORD OUT COUNT
         CVD   R9,WSAVE4           CONVERT RCDS IN TO DECIMAL
         MVC   IER047I,EPATTERN    MOVE IN ZERO SUPPRESS ED PATTERN
         ED    IER047I,WSAVE4+4    FORMAT RECORD IN COUNT
         L     R1,IER047
         MVC   PPIABMNO,3(R1)      MOVE MSG NO INTO ABEND CODE
         LM    R0,R1,IER047        IER047A RECORD COUNT ERROR
ONOUTMSG L     R12,PPIAXERT        RELOAD BASE REG FOR EQ OR EXT RTN
         L     R15,PPIADSSC        CALL SSC TO PRINT MESSAGE
         BAS   R14,12(,R15)
         L     R15,PPIADSSC        EXIT TO SSC TO TERMINATE THE JOB
         BAS   R14,16(,R15)
*
*        TRACE TRACK REQUEST AND RELEASE DIAGNOSTIC RTN
*
TRACKT   PPITEST  PPIDIAG+PPIDSIM  GENERATE DIAGNOSTIC MESSAGES ?
*                                  ZAP TO BZR TO ACTIVATE TRACE
         BR    R15   <-----------  NO, BYPASS MSG GENERATION
*
         STM   R14,R12,TRACKTSA    SAVE REGS ACROSS RTN
         SR    R1,R1
         SR    R2,R2
         SR    R3,R3
         MVC   WORK8,PPIWKARE
TRACKP   UNPK  IER930A(9),WORK8(5)      UNPACK FIRST 4 BYTES
         UNPK  IER930A+8(9),WORK8+4(5)  UNPACK LAST 4 BYTES
         MVI   IER930A+16,C' '
         TR    IER930A(16),HEXTRAN-240  TRANSLATE TO PRINTABLES
         CLC   IER930A(15),TRAPDATA  REL/REQ MATCH TRAP ADDR ?
*                                    ONLY 15 TO IGNORE RECORD NUMBER
         BNE   TRACKTB               NO, BRANCH
         NOP   0                   THIS MAY BE USED AS DDT BREAKPOINT
TRACKTB  LM    R0,R1,IER930
         L     R15,PPIADSSC
         BAS   R14,12(,R15)        CALL MSG WRITER
         LM    R14,R12,TRACKTSA    RESTORE REGS
         BR    R15                 RETURN TO CALLER
*
ONMOVE   MVC   1(1,R15),0(R15)     USED ONLY BY EXECUTE INSTRUCTIONS
KNOP     NOP   KNOP
         NOPR  0                   USED TO OVERLAY AT INPUT EOF
*
KOVERLAY B     ONMTMSQ             USED TO OVERLAY AT INPUT EOF
KOVERLA2 B     ONDONE              USED TO OVERLAY IF NOT MORE THAN M
*                                  SEQ AND EQUALS RTN BEING USED
WSWITCHA DC    X'00'               SET WHEN SWITCHING FROM SORT TO MRG
WSWITCHB DC    X'00'               SET TO INDICATE TRACKS ARE AVAILABLE
WSWITCHC DC    X'00'               SET DURING EACH EVEN NUMBERED
*                                  CONSECUTIVE MERGE PASS
WSWITCHD DC    X'00'               USED AT ENTRY FROM READ AT EOS TO
*                                  SEE IF ANOTHER MERGE PASS FOLLOWS
WSAVE2   DC    H'0'                WORK AREA FOR SUBROUTINES
*
WSEQTOTL DC    F'0'          *     COUNTER FOR TOTAL SEQUENCES
WSEQCTR  DC    F'0'          V     COUNTER FOR SEQUENCES THIS SORT PH
*
WSAVE1   DC    2F'0'               SAVE R2 AND R3 HERE
WSAVE3   DC    F'0'                SAVE AREA
         DC    0D'0'
WSAVE4   DC    4F'0'               SAVE AREA
WSAVE    DC    F'1'     R2   *     SAVE AREA FOR R2 (J)
         DC    2F'0'    R3,R4|     SAVE AREA FOR R3 AND R4 (I AND L)
KTABLEX  DC    A(0)     R5   |     LOADED WITH TABLE ADDR BY IER9ON
KFRTRKLT DC    A(0)     R6   |     LOADED WITH ADDR OF TABLE WHERE
*                            |     FREE TRACK LIST ADDRS ARE -4
*                            |     (LOADED BY IER9ON ROUTINE)
KTABLEL  DC    F'0'     R7   |     POINTER TO L ROW  (SET ORG BY 9ON)
KTBLMZON DC    F'0'     R8   V     POINTER TO L-1 ROW (SET ORG BY 9ON)
KTABLEX0 DC    F'0'                ADDR OF L=0 ROW OF TABLE (IER9ON)
*
KBYPEROW DC    F'0'                BYTES PER ROW OF TABLE   (IER9ON)
KBPRLS1  DC    H'0'                BYTES PER ROW - 1 (SET BY IER9ON)
KBPRLS2  DC    H'0'                BYTES PER ROW - 2 (SET BY IER9ON)
KBPRLS3  DC    H'0'                BYTES PER ROW - 3 (SET BY IER9ON)
KBPRLS4  DC    H'0'                BYTES PER ROW - 4 (SET BY IER9ON)
KBPRLS6  DC    H'0'                BYTES PER ROW - 6 (SET BY IER9ON)
*
KPOOLSZ  DC    H'0'                SET TO SIZE OF POOL BY IER9ON
KZERO    DC    H'0'
KONE     DC    H'1'
KTWO     DC    H'2'
KFOUR    DC    H'4'
KFORTY   DC    H'40'
KMERGORD DC    F'0'                MERGE ORDER (SET BY ASSIGNMENT)
KMOMONE  DC    F'0'                MERGE ORDER-1 (SET BY ASSIGNMENT)
KMSQURD  DC    F'0'                SET TO M SQUARED BY IER9ON
KPOOL    DC    F'0'                LOADED TO POOL ADDR BY IER9ON
KFPPTR   DC    F'0'                POINTER TO FREE POOL LIST
*                                  NOTE - HIGH ORDER BYTE IS USED AS
*                                  A COUNTER OF THE NO OF ENTRIES
KCHAIN   DC    A(0)                ADDR TO POOL SEGMENT
WSAVE6   DC    3F'0'               SAVE AREA FOR R2-R3-R4
K00FF    DC    XL4'0000FFFF'
KONEONE  DC    X'01000100'         MUST BE ON A FULL WORD BOUNDARY
EPATTERN DC    XL8'4020202020202020'   ZERO SUPPRESS EDIT PATTERN
*
*        DEBUGGING MESSAGE
*
IER930   DC    A(IER930T)
         DC    A(IER930X-IER930T)
IER930T  DC    C'IER930I RE'
IER930Q  DC    C'Q'
         DC    C' TRK '
IER930A  DC    CL17' '
IER930X  EQU   *
*
*        DEBUGGING WORKAREA AND CONSTANTS
*
TRACKTSA DC    18F'0'
WORK8    DC    XL8'00'
HEXTRAN  DC    C'0123456789ABCDEF'
TRAPDATA DC    CL16'0400000000000000'     RECORD NUMBER IGNORED
*
         LTORG
*
./ ADD NAME=IER8PA   0101-20211-20211-1200-00163-00163-00000-RELEASE 00
PA8      TITLE 'IER8PA - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IER8PA
*
*        MODULE FUNCTION/OPERATION -
*        CRCX WRITE ROUTINE
*        HANDLES DASD SORTWK OUTPUT IN THE SORT BY USE
*        OF THE EXCP MACRO. IT ACCEPTS PHYSICAL RECORDS FROM
*        THE BLOCK ROUTINE AND SCHEDULES THEM TO BE WRITTEN. THE
*        ROUTINE INTERFACES WITH IOS, THE ALGORITHM, BLOCK, AND
*        THE SORT NETWORK. IF EXIT E19 OR E29 HAS ACTIVATED
*        SYNAD, THE WRITE ROUTINE (ON A WRITE ERROR) ALLOWS THE
*        USER TO TRY AND CORRECT THE ERROR AFTER IOS HAS TRIED TO
*        DO SO. CONTROL IS THEN PASSED TO SORT SYSTEM CONTROL
*        (IERRCV) TO TERMINATE THE JOB. THE MODULE USES THE GETMAIN,
*        EXCP, WAIT, DCBD, DELETE, AND SMPPI MACROS
*
*        IF THE RECORD FORMAT IS VARIABLE, IER9PA HAS MADE
*        SEVERAL OVERLAYS IN THIS MODULE'S INSTRUCTIONS TO BYPASS
*        THE RDW. FOR EXAMPLE, THE INSTRUCTION AT PAEOSEOF HAS
*        ITS FIRST OPERAND'S DISPLACEMENT ADJUSTED TO 12 -
*        MVC 12(4,RC),KEOS
*
*        NORMAL INTERFACING OCCURS BETWEEN THE BLOCK AND WRITE
*        ROUTINES. WHEN DOUBLE BUFFERED, THE WRITE ROUTINE HAS
*        BEEN DESIGNED TO DELAY WAITING ON A WRITE UNTIL THE NEXT
*        TIME BLOCK ENTERS THE ROUTINE. FOR SINGLE BUFFERING, A
*        WAIT ALWAYS OCCURS IMMEDIATELY AFTER QUEUING THE WRITE.
*        ON EOS OR EOF, THE WRITE DOES NOT RETURN TO THE BLOCK
*        ROUTINE. IT INTERFACES WITH THE ALGORITHM THEN, BUT IT
*        IS STILL RESPONSIBLE FOR PASSING AN EMPTY BUFFER ADDRESS
*        TO THE BLOCK ROUTINE. IT DOES THIS BY PLACING THE
*        BUFFER ADDRESS IN THE BLOCK ROUTINE'S ENTRY TABLE VIA
*        PPIBLK OR PPIBLK2 AT DISPLACEMENT 20 AND 24
*
*        THERE ARE TWO CONDITIONS WHEN THE WRITE CANNOT DELAY
*        ITS WAIT. IF THE CRCX ALGORITHM (IER80N) ENCOUNTERS A
*        TWO MERGE PASSES IN A ROW CONDITION, IT SETS BIT 61 OF
*        PPISW1 (PPICRCX) TO TELL THE WRITE ROUTINE TO WAIT ON THE
*        FORTHCOMING EOS BLOCK. THIS SEQUENCE IS NEEDED BY READ
*        BEFORE THE WRITE IS AGAIN EXECUTED. SO WRITE CHECKS
*        PPISW1, BIT 61 ON EACH EOS BLOCK AND DOES THE WAIT
*        (DOUBLE BUFFERED COND.) ONLY IF THE ALGORITHM SPECIFIES
*        SUCH. THE SECOND CONDITION IS EOF. AT THIS POINT ALL
*        FILES MUST BE READY FOR READ TO PRIME, SO THE WRITE
*        ISSUES A WAIT ON THE LAST BLOCK TO BE WRITTEN BEFORE
*        PRIMING BEGINS
*
*        THIS MODULE ALSO PERFORMS THE FOLLOWING MISCELLANEOUS
*        FUNCTIONS -
*        1. DELETES LOAD MODULE (RC9) AFTER ALL ASSIGNMENT
*           ROUTINES HAVE BEEN EXECUTED
*        2. DETERMINES IF ANOTHER OUTPUT BUFFER IS NEEDED AND
*           ISSUES A GETMAIN TO OBTAIN IT
*
*        MODULES THIS MODULE APPEARS AS A DSECT IN - IER9PA
*
*        MACROS USED -
*
*        GETMAIN - FIXED, CONDITIONAL
*        DELETE  - IERRC9
*        EXCP    - TO WRITE
*        WAIT    - TO HAVE I/O POSTED
*        DCBD    - DCB DSECT
*        SMPPI   - PHASE - PHASE INFO DSECT
*        SVC 17  - PURGE MACRO EXPANSION
*
*        ENTRY POINTS - IER8PA  BRANCH TABLE
*                       DISP = 0,12    DUMMY ENTRIES
*                            = 4       EOS OR EOS/EOF FROM BLK
*                            = 8       NORMAL FROM BLOCK
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIALG+4   - ALGORITHM BASE
*        PPIBLK+4   - BLOCK BASE
*        PPIBLK2+4  - BLOCK BASE
*        PPILAB04   - SWITCH FOR OBTAINING EXTRA OUTPUT BUFFER
*        PPILAB07+2 - OUTPUT BUFFER SIZE
*        PPINET+4   - SORT NETWORK BASE
*        PPIADSSC   - SSC BASE
*        PPISTDCB   - ADDR OF DCB TABLE
*        PPICNTL    - BITS 20 AND 61
*        PPIWKARE   - CHAIN DISK ADDRESS
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPIDEPHO - OUTPUT DISK ADDR
*        PPIGETMN - GETMAIN ADDR
*        PPIGETSZ - AND SIZE TABLES
*        PPILAB05 - SECOND OUTPUT BUFFER ADDR
*        PPILAB07 - NO OF OUTPUT BUFFERS
*        PPICNTL  - BIT 42
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS -
*        CCW'S   - CHANNEL COMMAND WORDS
*        DCB'S   - DATA CONTROL BLOCKS
*        ECB'S   - EVENT CONTROL BLOCKS
*        IOB'S   - INPUT/OUTPUT BLOCKS
*        BUFFERS
*
*        EXITS   - NORMAL -
*                  BLOCK RTNS   AT DISP = 8 FOR NORMAL RETURN WITH
*                                           EMPTY BUFFER ADDR
*                  ALGORITHM    AT DISP = 0 FOR EOF
*                                       = 4 FOR OBTAINING CHAIN ADDR
*                                       = 8 FOR EOS
*                  NETWORK      AT DISP = 0 FOR STARTING SORT
*
*        EXITS - ERROR -IERRCV
*                       AT DISP = 16 FOR TERMINATING THE JOB
*
*        TABLES/WORK AREAS - N/A
*
*        NOTES -
*        USED FOR DASD WORK UNITS WITH THE CRCX ALGORITHM
*
*
IER8PA   CSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IER8PA SOURCE
*
*----------------------------------------------------------------------
*
         COPY IER8PAI
*
*        DSECTS
*
*        MAP IOB
*
         IERIOB
*
         PRINT NOGEN
*
*        MAP DEB
*
         IEZDEB LIST=NO
*
*        MAP UCB
*
UCB      DSECT
*
         IEFUCBOB PREFIX=NO,LIST=NO
*
*        MAP ECB
*
         IHAECB
*
         DCBD  DSORG=PS,DEVD=(DA)
*
         PRINT GEN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IER8PAI  0101-20211-20211-1200-00360-00360-00000-RELEASE 00
*
*----------------------------------------------------------------------
*
*        IER8PA SOURCE
*
*----------------------------------------------------------------------
*
*        MEMBER - IER8PAI
*
         USING *,R11               PROGRAM BASE
         USING IERRCA,R13          PPI BASE
         USING IHADCB,R6           DCB BASE
         USING IOBSTDRD,R5         IOB BASE
*
PABRTAB  DC    A(0)                +00 DUMMY ENTRY - USED AS CONSTANT
         B     PAEOSEOF            +04 EOS/EOF ENTRY R4=0 FOR EOF/EOS
*                                                      =4 FOR EOS ONLY
         B     PANORM              +08 NORMAL ENTRY FROM BLOCK
         DC    A(0)                +12 DUMMY ENTRY - USED AS CONSTANT
*
*        DELETE IERRC9
*        TRY FOR EXTRA BUFFER IF NECESSARY
*        BRANCH TO SORT NETWORK TO START PROCESSING RECORDS
*
         DELETE  EP=IERRC9         +16 ALL ASSIGNMENT MODULES EXECUTED
*                                      DELETE RC9
         LTR   R15,R15             CHECK FOR ERROR
         BZ    PA001               NO ERROR, CONTINUE SORT
         L     R15,PPIADSSC        R15 -> SSC
         BAS   R14,28(,R15)        ERROR OCCURRED, PRINT MESSAGE
         L     R15,PPIADSSC        R15 -> SSC
         BAS   R14,16(,R15)        EXIT TO SSC, TERMINATE
*
*        DETERMINE IF AN ADDITIONAL OUTPUT BUFFER SHOULD BE ATTEMPTED
*
PA001    TM    PPILAB04,X'80'      ON ? DON'T GETMAIN AN ADDITIONAL
         BO    PA010               OUTPUT BUFFER
*
*        ISSUE CONDITIONAL GETMAIN FOR AN OUTPUT BUFFER
*
         LH    R2,PPILAB07+2       SET LV
         LA    R2,8(,R2)           PARAMETER
*
         GETMAIN  EC,LV=(R2),A=PABRTAB
*
         LTR   R15,R15             STORAGE AVAILABLE ?
         BNZ   PA010               NO, STORAGE NOT AVAILABLE
*
*        STORAGE OBTAINED FOR SECOND OUTPUT BUFFER
*
         MVI   PPILAB07,2          SET NO OF BUFFERS TO 2
         L     R1,PPIGETSZ
PA002    CLI   0(R1),X'80'         END OF GETMAIN TABLES ?
         BE    PA003               YES, BRANCH
         LA    R1,4(,R1)           UPDATE TABLE AND
         LA    R15,4(,R15)         DISPLACEMENT COUNT
         B     PA002               TEST NEXT ENTRY
*
PA003    MVI   0(R1),0             PLACE SIZE OF GETMAIN
         ST    R2,4(,R1)
         MVI   4(R1),X'80'         IN TABLE - PPIGETSZ
         L     R1,PPIGETMN
         L     R3,PABRTAB          PLACE ADDR OF BUFFER
         ST    R3,4(R15,R1)        IN TABLE - PPIGETMN
         LA    R3,8(,R3)           ADJUST ADDR BY 8 BYTES - DASD
         ST    R3,PPILAB05         WRITE REQUIRES THIS FOR COUNT FIELD
         ST    R3,KBUFF            SAVE ACTUAL BUFFER ADDR FOR
*                                  DATA PROCESSING
PA010    L     R11,PPINET+4        EXIT TO NETWORK TO
         BR    R11                 START PROCESSING RECORDS
*
*        EOS/EOF ENTRY
*        R4 = 0 FOR EOF
*           = 4 FOR EOS
*
PAEOSEOF MVC   8(4,R2),KEOS        PLACE EOS (HGHH) INDICATOR IN BUFFER
         MVI   PAEOS+1,X'F0'       SET BRANCH TO GOTO ALGORITHM
         MVI   PAEOS1+1,X'00'      SET BRANCH TO PLACE ADDR IN BLK
         MVI   PA059+1,X'F0'       SET BRANCH TO NOT OBTAIN NEW CHAIN
*                                  ADDR FROM ALGORITHM
         B     PA011(R4)           BRANCH ON FINAL/NONFINAL VALUE
*                                  PROVIDED IN R4 FROM PPINET
*
PA011    MVI   PAEOF+1,X'F0'       EOF, SET BRANCH TO WAIT ON FILE
         B     PA020               EOS, NORMAL ENTRY TO QUEUE WRITES
*
*        NORMAL ENTRY FROM BLOCK
*
*        R1 =  L'BUFFER
*        R2 -> BUFFER TO BE WRITTEN
*        R3 -> WINNER RECORD
*
PANORM   MVC   8(L'KNEOS,R2),KNEOS  SET NORMAL RECORD, NOT EOS (HHHH)
         MVI   PAEOS+1,X'00'       TURN OFF EOS AND EOF SWITCHES
         MVI   PAEOS1+1,X'F0'
         MVI   PAEOF+1,X'00'       RETURN TO BLOCK NOW
         MVI   PA059+1,X'00'       AND OBTAIN CHAIN FROM ALG
PA020    STM   R1,R4,KSAVE         SAVE REGISTERS
         L     R5,IOBADDR          R5 -> IOB
         CLI   PPILAB07,X'02'      DOUBLE BUFFERED ?
         BE    PAALT030            YES, ISSUE WAIT/QUEUE NEXT WRITE
*
*        NO OF OUTPUT BUFFERS IS ONE
*        ISSUE WRITE, WAIT, AND ERROR CHECK
*
         BAS   R7,PAEXCP           UPDATE IOB, ETC AND QUEUE WRITE
PA021    BAS   R7,PAWAIT           WAIT - ERROR CHECK
*
PAEOS    NOP   PARTALG   ÝMAYBE B¨ EOS SWITCH IF BRANCH, GOTO ALG
         LM    R2,R3,KSAVE+4       SET PARAMETER REGISTERS
PARTNV   LA    R2,12(,R2)          UPDATE BUFFER TO POINT TO DATA AREA
         PPITEST  PPIPH2           SORT OR MERGE PHASE IN CONTROL
         BO    PA025               YES, BRANCH
         L     R11,PPIBLK+4        SORT BLOCK BASE
         B     8(,R11)
*
PA025    L     R11,PPIBLK2+4       MERGE BLOCK BASE
         B     8(,R11)
*
PARTALG  L     R6,KDCB             R6 -> DCB
         SR    R1,R1
         IC    R1,DCBOPTCD         R1 = M INCREMENT STORED IN DCBOPTCD
         CLI   KSAVE+15,X'04' ÝR4¨ SET COND CODE FOR ENTRY TO ALG
         L     R11,PPIALG+4        SET ALGORITHM'S BASE FOR
         BE    8(,R11)             EOS - WRITE AT EOS (PH1 OR PH2)
         BR    R11                 EOF - WRITE AT EOF (SIM OR REAL)
*
*        NO OF OUTPUT BUFFERS IS TWO
*        ISSUE WAIT, ERROR CHECK, AND QUEUE WRITE
*
PAALT030 NOP   PA035               FIRST TIME THROUGH PASS, BYPASS WAIT
         MVI   PAALT030+1,X'F0'    SET NOP TO BRANCH, SO ISSUE WAIT
         MVC   KSAVE+4(4),KBUFF    SET UP TO GIVE ALTERNATE BUFFER
*                                  TO BLOCK ON RETURN
         B     PA040               QUEUE WRITE
*
PA035    BAS   R7,PAWAIT           WAIT, CHECK FOR I/O COMPLETION
         L     R4,IOBSTART         SWITCH CCW POINTERS
         L     R15,IOBECBPT        AT IOB AND ECB+4
         MVC   IOBSTRTB,5(R15)     MOVE ADDR OF CCWS INTO IOB
         ST    R4,4(,R15)
PA040    BAS   R7,PAEXCP           UPDATE IOB AND QUEUE WRITE
         NOP   0
*
PAEOS1   B     PAEOS+4   ÝMAYBE B¨ NOP WHEN EOS
*
*        ON EOS, WRITE DOES NOT RETURN TO BLOCK
*        PASS THE EMPTY BUFFER ADDR TO BLOCK ROUTINES BY STORING
*        THE ADDR IN BLOCK ROUTINES BRANCH TABLE AT
*        DISPLACEMENT 20 AND 24
*
         L     R14,PPIBLK+4        R14 -> PPIBLK
         L     R15,PPIBLK2+4       R15 -> PPIBLK2
         L     R2,KBUFF            R2 -> BUFFER
PAEOSV   LA    R2,12(,R2)          INCR ADDR FOR CHAIN(8) PLUS EOS(4)
*                                  PLUS RDW(4) IF VARIABLE
         ST    R2,20(,R15)         UPDATE PPIBLK
         ST    R2,20(,R14)         UPDATE PPIBLK2
         ST    R2,24(,R15)
         ST    R2,24(,R14)
PAEOF    NOP   PA050     ÝMAYBE B¨ IF EOF OR 2ND MERGE PASS TO
         PPITEST  PPICRCX          FOLLOW, ISSUE WAIT ON WRITE
         BZ    PARTALG             QUEUED
*
*        ON EOF, RESET FIRST TIME THROUGH SWITCH TO BYPASS WAIT
*        FOR DOUBLE BUFFER
*
PA050    MVI   PAALT030+1,X'00'    RESET FIRST TIME THROUGH AND EOF
         MVI   PAEOF+1,X'00'       SWITCHES
         B     PA021               WAIT ON FILE
*
*        SET UP THE IOB, CCWS, AND BUFFER TO ISSUE AN EXCP
*
*        THE IOB DISK ADDR POINTS TO PREVIOUS RECORD WRITTEN.
*        AT BUFFER-8, THE COUNT FIELD IS FOR RECORD TO BE
*        WRITTEN. THE CHAIN DISK ADDR IN THE BUFFER IS FOR THE
*        NEXT RECORD TO BE WRITTEN. THE CCW LIST USED TO QUEUE A
*        WRITE COMMAND IS -
*        SEARCH ID
*        TIC
*        WRITE
*
*        THE ALGORITHM (IER8ON) HAS CONTROL OVER WHERE DATA IS
*        WRITTEN. IT COMMUNICATES THIS INFORMATION VIA PPI.
*        PPIDEPHO CONTAINS THE DISK ADDR WHERE PRESENT RECORD
*        IS TO BE WRITTEN, AND PPIWKARE IS FOR THE CHAIN DISK
*        ADDR
*
*        UPON ENTERING THIS SUBROUTINE, REGISTERS ARE SET AS
*        FOLLOWS -
*
*        R1  - BUFFER BYTE COUNT
*        R2 -> BUFFER
*        R6 -> DCB
*        R5 -> IOB
*        R7  - RETURN ADDR
*
PAEXCP   L     R4,IOBSTART         R4 -> CCW
         SH    R2,KH8              R2 -> DASD COUNT FIELD
         ST    R2,PABRTAB+12       SAVE ADDR OF DASD COUNT FIELD
         STCM  R2,B'0111',17(R4)   STORE BUFFER ADDR IN WRITE CKD CCW
         SR    R15,R15
         IC    R15,PPIDEPHO        FILE'S M INCREMENT FROM PPIDEPHO
         L     R6,PPISTDCB         R6 -> DCB TABLE
         L     R6,0(R15,R6)        R6 -> DCB
         ST    R6,KDCB             SAVE DCB ADDR FOR LATER
*
*        SETUP FOR EXCP
*
*        DASD TTR ADDR IN PPIDEPHO
*        CONVERT TTR -> MBBCCHHR
*
         STM   R14,R12,12(R13)     SAVE REGS ACROSS RTN
         LR    R3,R13              SAVE R13
         SR    R0,R0
         ICM   R0,B'1110',PPIDEPHO+5  R0 = TTR0
         L     R1,DCBDEBAD         R1 -> DEB
         LA    R2,DCBFDAD          R2 -> MBBCCHHR RESULT
         L     R15,PPIPCNVT        R15 -> CONVERSION RTN
         BASR  R14,R15             CONVERT TTR -> MBBCCHHR
         LR    R13,R3
         LTR   R15,R15          *  SET CC
         LM    R14,R12,12(R13)  |  RESTORE REGS
         BNZ   PANOEXIT         V  CONVERSION FAILED, TERMINATE SORT
         MVC   IOBSEEK,DCBFDAD     MOVE SEARCH ADDR TO IOB
         MVC   0(5,R2),DCBFDAD+3   MOVE CCHHR INTO DASD COUNT FIELD
         MVI   5(R2),X'00'         ZERO KEY (K) IN DASD COUNT FIELD
         STH   R1,6(,R2)           STORE L'RECORD IN DASD COUNT FIELD
         LA    R1,8(,R1)           SET CCW WRITE LENGTH TO L'RECORD
         STH   R1,22(,R4)          PLUS L'DASD COUNT FIELD IN CCW
         IC    R15,PPIDEPHO+7      R15 = RECORD NUMBER
         BCTR  R15,0               DECR RECORD NUMBER
         STC   R15,IOBR            STORE IN IOB FOR SEARCH ID EQ
*                                  ORIENTATION ON PREVIOUS RECORD
         STCM  R6,B'0111',IOBDCBPB  CHAIN IOB TO DCB
         SR    R1,R1
         IC    R1,PPIDEPHO         FILE'S M INCREMENT FOR LATER USE
PA059    B     PA070V  ÝMAYBE NOP¨ IF EOS, DO NOT REQUEST CHAIN ADDR
*                                  FROM ALGORITHM BUT INSTEAD HAVE
*                                  CHAIN POINT TO ITS SELF FOR
*                                  READ TO RELEASE TRACK LATER
         CLC   PPIDEPHO+7(1),PPIBPTRK+1  THIS WRITE WILL FILL TRACK ?
         BNE   PA080               NO, BYPASS REQUEST NEW CHAIN ADDR
*                                  AS MORE RECORDS CAN FIT ON TRACK
*        THIS WRITE WILL FILL THIS TRACK
*
*        OBTAIN NEW CHAIN ADDR FROM THE ALGORITHM TO PLACE IN BLOCK
*        TO BE WRITEN TO FOR READIN CHAIN
*        R1 = FILE'S INCREMENT (M)
*
         STM   R1,R7,PPIWKARE+8    SAVE REGS ACROSS ALG CALL
         L     R11,PPIALG+4        SET ALGORITHM'S BASE
         BAS   R14,4(,R11)         REQUEST NEW CHAIN ADDR FOR WRITE
*                                  WHICH WILL BE RETURNED IN PPIWKARE
         LM    R1,R7,PPIWKARE+8    RESTORE REGS ON RETURN
         MVC   PPIDEPHO(1),PPIWKARE  SET DEPHO FOR NEXT WRITE WITHOUT
         MVC   PPIDEPHO+2(6),PPIWKARE+2  DESTROYING LOGICAL INCR CHAIN
         B     PA070V
*
*        ANOTHER RECORD WILL FIT ON THIS TRACK
*
PA080    IC    R15,PPIDEPHO+7      INCR RECORD FOR NEW CHAIN ADDR
         LA    R15,1(,R15)
         STC   R15,PPIDEPHO+7
*
*        ISSUE EXCP
*
PA070V   MVC   8(8,R2),PPIDEPHO    MOVE TT DISK ADDR INTO CHAIN ADDR
         NI    DCBIFLGS,255-DCBIFEC   CLEAR ERROR FLAGS IN DCB
*
         IEREXCP  (R5)             WRITE
*
         BR    R7                  RETURN TO CALLER
*
*        ISSUE WAIT MACRO
*        CHECK FOR ERRORS
*        SET UP THE PARAMETERS FOR BLOCK
*        R5 -> IOB
*
PAWAIT   MVC   IOBDCBPB,KDCB+1     SET DCB ADDR IN IOB
         L     R1,IOBECBPT
*
         IERWAIT  1,ECB=(1)        WAIT ON I/O COMPLETION
*
         L     R1,IOBECBPT
         CLI   0(R1),ECBNORM       ERROR POSTED IN THE ECB ?
         BNE   PAERROR             YES, BRANCH
*
*        NO ERROR
*        SET UP PARAMETERS FOR BLOCK
*
         L     R1,KSAVE            RESTORE BLOCK COUNT
         L     R4,IOBSTART         OBTAIN BUFFER ADDR FROM WRITECKD CCW
         L     R4,16(,R4)          R4 -> BUFFER ADDR
         LA    R4,8(,R4)           INCR PAST DASD COUNT FIELD
         ST    R4,KSAVE+4          SAVE BUFFER ADDR IN REGISTER SAVE
         ST    R4,KBUFF            AREA AND OWN CONSTANT
PA090    BR    R7     ÝMAYBE NOP¨  IF NOT FULL TRACK BLOCKING
*                                  THIS RETURN IS NOP'ED
         L     R6,KDCB             SET DCB BASE
         SH    R4,KH8              R4 -> DASD COUNT
         BR    R7                  RETURN TO MAIN LINE
*
*        A WRITE ERROR HAS OCCURRED - CHECK SYNAD, LINK TO IT IF
*        ACTIVATED, AND THEN TERMINATE THE JOB
*
PAERROR  CLI   0(R1),ECBEHALT      REQUEST WAS PURGED DUE TO AN ERROR
         BE    PARESTR             ON A READ COMMAND ON UNIT ?
         PPISETON PPIWRITE         NO, SET PERM WRITE ERROR BIT
         PPITEST  PPIPH2           PHASE 2 OR MERGE ?
         BO    PAERROR2            YES, USE E29
         L     R15,AE19            SORT SYNAD
PAERROR1 LTR   R15,R15             SYNAD ACTIVATED ?
         BZ    PANOEXIT            NO, TERMINATE JOB
         L     R1,IOBDCBPT         SET UP R1 - DCB ADDR
         MVI   IOBADDR,X'10'              R0 - IOB ADDR WITH CCW
         L     R0,IOBADDR                      DISPL IN FIRST BYTE
*
*        CALL USER'S E19/E29 SYNAD ROUTINE
*
         BASR  R14,R15
*
PANOEXIT L     R1,IOBDCBPT         OBTAIN SPECIFIC UNIT NUMBER
         L     R15,PPIADSSC        PRINT ERROR MSG AND TERMINATE
         BAS   R14,16(,R15)        TERMINATE THE JOB
*
PAERROR2 L     R15,AE29            MERGE SYNAD
         B     PAERROR1
*
*        WRITE REQUEST HAS BEEN PURGED DUE TO AN I/O ERROR ON A
*        PREVIOUS REQUEST FOR THE UNIT
*
PARESTR  L     R6,KDCB             RESTORE I/O QUEUE LIST
         NI    DCBIFLGS,255-DCBIFEC    RESET ERROR BITS SET BY IOS
         OI    IOBFLAG1,IOBCMDCH   SET ON COMMAND CHAINING
         L     R1,DCBDEBAD         DEB ADDR
         USING DEBBASIC,R1         DEB ADDRESSABILITY
         L     R1,DEBUSRPG         POINT TO FIRST
         LA    R1,0(,R1)           PURGED IOB
*
         IERESTOR (R1)             RESTORE SVC
*
         DROP  R1
         B     PAWAIT
*
*        ADCONS
*
AE19     DC    A(0)
AE29     DC    A(0)
*
*        CONSTANTS
*
KBUFF    DC    A(0)                EMPTY BUFFER ADDR
KEOS     DC    C'HGHH'             EOS INDICATOR
KNEOS    DC    C'HHHH'             NOT EOS INDICATOR
KSAVE    DC    4F'0'               REGISTER SAVE AREA
IOBADDR  DC    A(0)                -> OUTPUT IOB, SET BY IER9PA
KDCB     DC    A(0)                DCB ADDR
KH8      DC    H'8'
*
./ ADD NAME=IER8PM   0101-20211-20211-1200-00188-00188-00000-RELEASE 00
PM8      TITLE 'IER8PM - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IER8PM
*
*        MODULE FUNCTION/OPERATION -
*        CRCX END OF PHASE ROUTINE
*        CHECK RECORD COUNTS, CLOSES ALL WORK DATA SETS
*        GIVES THE USER CONTROL IF EXIT E17 AND/OR E27
*        IS ACTIVATED
*
*        USED AS A DSECT IN - N/A
*
*        LIST OF MACROS USED BY MODULE -
*        SMPPI CLOSE
*
*        ENTRY POINTS - ENTRY FROM IERRCV
*                       CALLING SEQUENCE -
*                       LOAD EP=IER8PM,DCB=SORTLIB
*                       LR R11,R0
*                       B  4(,R11) INITIAL ENTRY
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPICOUNT   PPIINSCT   PPIDELCT   PPICNTL
*        PPIENDAR   PPIFILSZ   PPISTDCB   PPINDSKA
*        PPIADSSC   PPIRMB     PPIWKARE   PPIX17
*        PPIX27
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPIFILSZ - LOADED WITH CONTENTS OF PPICOUNT IF PPIFSZE ON
*        PPIWKARE - USED AS A WORK AREA FOR DATA CONVERSION IF
*                   MESSAGE IER047A MUST BE ISSUED
*        PPIRCDCT - LOADED WITH (PPICOUNT + PPIINSCT - PPIDELCT)
*        PPICNTL  - PPIFSZE IS TURNED OFF
*        PPICOUNT - LOADED WITH ZEROES
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS -
*        IERRMB - REFERENCE TO MESSAGE MODULE VIA DSECT
*
*        EXITS - NORMAL - IERRCV TO CALL PHASE 3
*                         CALLING SEQUENCE -
*                             L    R15,PPIADSSC
*                             BAL  R14,8(,R15)
*
*                       - TO IERRCV TO PRINT MESSAGE
*                         CALLING SEQUENCE -
*                             L    R15,PPIADSSC
*                             BAL  R14,12(,R15)
*
*        EXITS - ERROR - TO IERRCV TO TERMINATE JOB
*                        CALLING SEQUENCE -
*                        L    R15,PPIADSSC
*                        BAL  R14,16(,R15)
*
*        TABLES/WORK AREAS -
*        WABSW2 - AN TERMINATE SWITCH WHICH IS TURNED ON IF
*                 THE FILE SIZE WAS SPECIFIED AND THE RECORD
*                 COUNT DOES NOT MATCH THE FILE SIZE
*
IER8PM   CSECT
*
         USING *,R11               MODULE BASE REGISTER
         USING DIERRMB,R12         MESSAGE MODULE BASE REG
         USING IERRCA,R13          PPI BASE REGISTER
*
*        CALL FOR PHASE TWO CANNOT VALIDLY OCCUR WITH CRCX TECHNIQUE
*        ENTRY (LEFT FOR COMPATIBILITY) IS A NOP
*
         NOP   *+4                 +00PHASE 2 CALL CANNOT OCCUR VALIDLY
         ST    R12,KRPMWORK        +04 SAVE R12
         L     R12,PPIRMB+4        SET MSG BASE REG
         LM    R6,R8,PPICOUNT      GET RECORD COUNTS FROM PPI
         L     R10,PPIFILSZ        LOAD FILE SIZE
         PPITEST  PPIFSZE          ESTIMATED FILE SIZE ON ?
         BO    RPMCHNG1            ON, DON'T COMPARE RECORDS WITH FILSZ
         CR    R6,R10              COMPARE RECORDS IN WITH FILSZ
         BNE   RPMENT4             NOT EQUAL, GOTO PRINT MESSAGE
RPMENT2  LR    R9,R6               SORT COUNT
         AR    R9,R8               ADD INSERT COUNT
         SR    R9,R7               SUBTRACT DELETE COUNT
         ST    R9,PPIRCDCT         RECORDS TO BE SORTED
         PPISETOF PPIFSZE          TURN OFF FILE SIZE EST SWITCH
         XC    PPICOUNT,PPICOUNT   CLEAR COUNT AREA
*
*        INITALIZATION PRIOR TO ENTRY OF THE CLOSE DCBS LOOP
*
         LA    R4,PPIDSKED         R4 -> MBBCCHHR LIST
         LTR   R9,R9               CHECK FOR ZERO FILE, FOR THE
         BNE   RPMCL               ALG MAY NOT HAVE BEEN EXEC TO
         LA    R4,PPIENDAR         R4 -> PPIENDAR
RPMCL    L     R5,PPISTDCB         R5 -> DCB TABLE
         LH    R6,PPINDSKA         R6 = NUMBER OF DISK AREAS
*
*        START OF THE CLOSE DCB LOOP
*
RPMLOOP  SR    R3,R3
         IC    R3,0(,R4)           R3 = M INCREMENT
         LA    R3,0(R3,R5)         R3 -> DCB TABLE ENTRY
         TM    0(R3),X'80'         CLOSED ?
         BO    RPMUPDAT            YES, ALREADY CLOSED - GO UPDATE PTR
         L     R2,0(,R3)           R2 -> DCB
         USING IHADCB,R2
         NI    DCBOFLGS,255-DCBOFLWR  NO NEED TO WRITE A FILE MARK
*
         CLOSE ((R2),REREAD)       CLOSE DASD FILE
*
         LTR   R15,R15             CLOSE SUCCESSFULL ?
         BZ    RPMUPDAT            YES, BRANCH
*
         DC    H'0'                CLOSE FAILED, FORCE 0C1 ABEND
*                                  FOR DIAGNOSTIC PURPOSES
RPMUPDAT MVI   0(R3),X'80'         INDICATE CLOSED FILE
         LA    R4,8(,R4)           UP M POINTER TO NEXT ELEMENT
         BCT   R6,RPMLOOP          LOOP TO CLOSE NEXT DCB
*
*        END OF CLOSE LOOP
*
*        TEST FOR CLOSE EXITS
*
         PPITEST  PPIME17          USER EXIT 17 ACTIVE ?
         BZ    RPMBK17             NOT ACTIVATED, BYPASS
         L     R15,PPIX17+4        R15 -> USER EXIT 17
         BASR  R14,R15             BRANCH AND LINK TO USER EXIT
RPMBK17  PPITEST  PPIME27          USER EXIT 27 ACTIVE ?
         BZ    RPMENT3             NOT ACTIVATED, BYPASS
         L     R15,PPIX27+4        R15 -> USER EXIT 27
         BASR  R14,R15             BRANCH AND LINK TO USER EXIT
RPMENT3  TM    WABSW2,X'01'        SHOULD IT TERMINATE ?
         BO    RPMABT              YES, BRANCH
         LM    R0,R1,IER050        IER050I END OF MERGE PHASE
         L     R15,PPIADSSC        R15 -> PPIADSSC
         BAS   14,12(,R15)         CALL PRINT MESSAGE
         L     R12,KRPMWORK        RESTORE R12
         L     R15,PPIADSSC        R15 -> PPIADSSC
         BAS   R14,8(,R15)         EXIT TO SSC
*
*        SETUP FOR PRINTING INCORRECT COUNT MESSAGE
*
RPMENT4  MVI   WABSW2,X'01'        TURN ON TERMINATE SWITCH
         L     R1,IER047           R1 -> MSG TEXT
         MVC   PPIABMNO,3(R1)      MOVE MSG NO INTO ABEND NO
         LM    R0,R1,IER047        IER047A RECORD COUNT ERROR
         CVD   R10,PPIWKARE        CONVERT RECORDS IN TO DECIMAL
         ED    IER047I,PPIWKARE+4  FORMAT DATA
         CVD   R6,PPIWKARE         CONVERT RECORDS OUT TO DECIMAL
         ED    IER047O,PPIWKARE+4  FORMAT DATA
         L     R15,PPIADSSC        R15 -> SSC
         BAS   R14,12(,R15)        CALL MSG WRITER
         B     RPMENT2             GOTO CLOSE FILES
*
RPMABT   L     R15,PPIADSSC        R15 -> SSC
         BAS   R14,16(,R15)        EXIT TO SSC, TERMINATE
*
RPMCHNG1 ST    R6,PPIFILSZ         STORE COUNT INTO FILE SIZE
         B     RPMENT2
*
*        CONSTANTS, TABLES, WORK AND/OR SAVE AREAS, SWITCHES
*
KRPMWORK DC    F'0'                SAVE AREA FOR R12
WABSW2   DC    X'00'               TERMINATE SWITCH
*
*        MODULE NAME - IERRMB
*
*        THIS MODULE CONTAINS ALL OF THE MESSAGES THAT ARE
*        REQUIRED FOR PHASE 2 RUNNING PROGRAM
*
DIERRMB  DSECT
*
         COPY  RMBMAIN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
*        DCB
*
         PRINT NOGEN
*
         DCBD  DSORG=PS,DEVD=(DA)
*
         PRINT GEN
*
         SMPPI
*
         END
./ ADD NAME=IER9BN   0101-20211-20211-1200-00121-00121-00000-RELEASE 00
BN9      TITLE 'IER9BN - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IER9BN
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 3 BLOCK ASSIGNMENT MODULE - VBS RECORDS
*        THE FUNCTION OF THIS MODULE IS TO INSERT THE ADDRESS OF
*        THE OUTPUT DCB IN IER8BN, SO THAT IER8BN MAY HAVE THIS
*        ADDRESS DIRECTLY. IT CALCULATES THE ADDRESS OF THE
*        WORKAREA FOR QSAM PUT IN MOVE MODE AND STORES THE
*        ADDRESS IN PPIDOOBA
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                       CALLING SEQUENCE -
*                           LOAD   EP=IER9BN,DCB=SORTLIB
*                           LR      R15,R0
*                           BALR    R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPISTDCB
*        PPIGETMN
*        STARTING ADDR OF THE DCBS
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED - PPIDOOBA
*
*        EXTERNAL ROUTINES - NONE
*
*        EXTERNAL PARAMETERS - SEE REGISTERS
*
*        EXITS - NORMAL - EXIT TO IERRC9
*                         CALLING SEQUENCE -
*                             BR   R14
*
*        EXITS - ERROR - NONE
*
*        TABLES/WORK AREAS - NONE
*
*        NOTES -
*        THE MODULE IS EXECUTED FOR ANY SPANNED OUTPUT SORT
*        WITHOUT USER EXIT E35
*
IER9BN   CSECT
*
         USING *,R11
         USING IER8BN,R10          ADDR OF RP DSECT
         USING IERRCA,R13          ADDR OF PPI
         USING DIERAMC,R9          MESSAGE MODULE BASE REG
*
IERMB34  LR    R11,R15             LOAD MODULE BASE REG
         L     R10,PPIBLK+4        ADDR OF IER8BN (RP) FOR DSECT BASE
*
*        CALCULATE ADDR OF OUTPUT DCB AND STORE IN RP
*
         L     R4,PPISTDCB         POINTER TO LIST OF DCB ADDRS
         MVC   WDCB,0(R4)          STORE OUTPUT DCB ADDR IN RP
*
*        CALCULATE ADDR OF WORKAREA FOR PUT IN MOVE MODE
*
ABNVREI  L     R5,PPIBDSVA+12
         ST    R5,PPIDOOBA         STORE ADDR OF WORKAREA IN PPI
*
*        ISSUE DIAGNOSTIC MESSAGE IF OPTIONED
*
         L     R9,PPIAMC+4         SET MESSAGE BASE REG
         PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTICS ?
         BZ    ABNNOMES            NO, BYPASS MESSAGE
         ST    R14,ABNSAVO         SAVE R14
         SR    R0,R0
         ICM   R0,B'0111',PPILAB04+1  R0 = OB1 FOR CONVERSION
         L     R15,PPICONV+4       LOAD ADDR OF CONVERSION ROUTINE
         BAS   R14,4(,R15)         CONVERT
         MVC   IER942A,2(R1)       MOVE FORMATTED ADDR IN MESSAGE
         L     R0,PPILAB05         LOAD ADDR OF OB2 FOR CONVERSION
         L     R15,PPICONV+4       LOAD ADDR OF CONVERSION ROUTINE
         BAS   R14,4(R15)          CONVERT
         MVC   IER942B,2(R1)       MOVE FORMATTED ADDR IN MESSAGE
         LM    R0,R1,IER942        IER942I OUTPUT BUFFER ADDR
         L     R15,PPIADSSC        R15 -> SSC
         BAS   R14,12(,R15)        CALL MSG WRITER
         L     R14,ABNSAVO         RESTORE R14
ABNNOMES BR    R14                 RETURN TO IERRC9
*
ABNSAVO  DC    F'0'
*
DIERAMC  DSECT
*
         COPY  AMCMAIN
*
*        MODULE NAME - IER8BN
*
IER8BN   DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IER8BN SOURCE
*
*----------------------------------------------------------------------
*
         COPY IER8BNI
*
*        DCB
*
         PRINT NOGEN
*
         DCBD  DSORG=PS,DEVD=(DA,TA)
*
         PRINT GEN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IER9BO   0101-20211-20211-1200-00129-00129-00000-RELEASE 00
BO9      TITLE 'IER9BO - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IER9BO
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 3 ASSIGNMENT MODULE VBS RECORDS WITH EXIT E35
*        THE FUNCTION OF THIS MODULE IS TO INSERT THE ADDRESS OF
*        THE OUTPUT DCB IN IER8BN. IT ALSO CHECKS TO SEE IF
*        ATTACHED IN PHASE 3 AND IF ATTACHED, INSERTS THIS
*        ADDRESS FROM PPIATP3E IN PPIX35. IF NOT ATTACHED EXIT
*        E35 (PPIX35) HAS BEEN ACTIVATED THROUGH CONTROL STMTS
*
*        MODULES IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                       CALLING SEQUENCE -
*                           LOAD  EP=IER9BO,DCB=SORTLIB
*                           LR    R15,R0
*                           BALR  R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPISTDCB
*        PPIATP3E
*
*        ADDR OF DCBS IN GENERATED CORE AND ADDRESS OF ATTACHED
*        EXIT
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPIX35
*        IF ATTACHED WILL HAVE ATTACHED ADDR
*
*        EXTERNAL ROUTINES - NONE
*
*        EXTERNAL PARAMETERS - SEE REGISTERS
*
*        EXITS - NORMAL - EXIT TO IERRC9
*                         CALLING SEQUENCE -
*                             BR   R14
*
*        EXITS - ERROR - NONE
*
*        TABLES/WORK AREAS - NONE
*
*        NOTES -
*        THE MODULE IS EXECUTED FOR ANY VARIABLE SPANNED OUTPUT
*        SORT WITH E35
*
IER9BO   CSECT
*
         USING *,R11
         USING DIER8BO,R10         ADDR OF IER8BO DSECT
         USING IERRCA,R13
         USING DIERAMC,R9          MESSAGE MOD BASE REG
*
IERMB34  LR    R11,R15             LOAD MODULE BASE REG
         L     R10,PPIBLK+4        ADDR OF IER8BO (RP) FOR DSECT BASE
         L     R4,PPIBDSVA+12      STORE ADDR OF WORKAREA FOR VBS
         ST    R4,WOPBUFAD         IN RUNNING PROGRAM
         ST    R4,PPIDOOBA         AND FOR SEQUENCE CHECK
*
*        CALCULATE ADDR OF OUTPUT DCB AND STORE IN IER8BO
*
         L     R4,PPISTDCB         R4 -> DCB ADDR LIST
         L     R4,0(,R4)           GET OUTPUT DCB ADDR
         ST    R4,WDCB             STORE DCB ADDR IN IER8BO
         L     R9,PPIAMC+4         SET MESSAGE BASE REG
         PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTICS ?
         BZ    ABONOMES            NO, BYPASS
         ST    R14,ABOSAVO         SAVE R14
         SR    R0,R0
         ICM   R0,B'0111',PPILAB04+1  R0 = ADDR OF OB1 FOR CONVERSION
         L     R15,PPICONV+4       LOAD ADDR OF CONVERSION ROUTINE
         BAS   R14,4(,R15)         CONVERT
         MVC   IER942A,2(R1)       MOVE FORMATTED ADDR INTO MESSAGE
         L     R0,PPILAB05         LOAD ADDR OF OB2 FOR CONVERSION
         L     R15,PPICONV+4       LOAD ADDR OF CONVERSION ROUTINE
         BAS   R14,4(R15)          CONVERT
         MVC   IER942B,2(R1)       MOVE FORMATTED ADDR INTO MESSAGE
         LM    R0,R1,IER942        IER942I OUTPUT BUFFER ADDR
         L     R15,PPIADSSC        R15 - > PRINT ROUTINE
         BAS   R14,12(,R15)        PRINT
         L     R14,ABOSAVO         RESTORE R14
ABONOMES ICM   R15,B'1111',PPIATP3E   ATTACHED EXIT ?
         BNZ   ABATTEXT            YES, BRANCH TO ATTACH EXIT RTN
*
*        BRANCH TO NEXT ASSIGNMENT RTN
*
ABENDMOD BR    R14                 RETURN TO IERRC9
*
ABATTEXT ST    R15,PPIX35+4        SET EXIT E35 TO ATTACHED EXIT
         B     ABENDMOD            RETURN TO RC9
*
ABOSAVO  DC    F'0'                RETURN ADDR
*
         DROP  R10,R11
*
DIERAMC  DSECT
*
         COPY  AMCMAIN
*
*        MODULE NAME - IER8BO
*
DIER8BO  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IER8BO SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IER8BOI
*
         PRINT NOGEN
*
         DCBD  DSORG=PS,DEVD=(TA,DA)
*
         PRINT NOGEN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IER9DJ   0101-20211-20211-1200-00170-00170-00000-RELEASE 00
DJ9      TITLE 'IER9DJ - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IER9DJ
*
*        MODULE FUNCTION/OPERATION -
*        PHASE 3 (MERGE ONLY) FOR VARIABLE SPANNED RECORDS
*        THE FUNCTION OF THIS MODULE IS TO PRIME THE WORKAREAS
*        AND PUT THE ADDRESS OF THE RECORD IN EACH WORKAREA IN
*        THE PRIME AREA IN PPI FOR THE MERGE NETWORK. AN
*        INCREMENT IS PLACED IN THE HIGH ORDER BYTE OF EACH
*        RECORD ADDRESS TO INDICATE WHICH INPUT DATA SET THE
*        RECORD CAME FROM. THE INCREMENT IS 4,8,12, 16....N WHERE
*        N IS 4 TIMES THE NUMBER OF INPUT DATA SETS
*
*        ON ANY INPUT END OF FILE, QSAM BRANCHES DIRECTLY TO
*        IERRGF VIA DCBEODAD. SO THAT IERRGF MAY BRANCH BACK TO
*        THIS MODULE, THIS MODULE INSERTS ITS ADDR (IERADJ) IN
*        PPIPSVA
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - NONE
*
*        MACROS USED BY MODULE -
*        SMPPI
*        GET
*
*        ENTRY POINTS - FROM IERRC9 - ENTRY FROM - IERRC9
*                                     CALLING SEQUENCE -
*                                     LOAD EP=IERRC9,DCB=SORTLIB
*                                     LR   R15,R0
*                                     BALR R14,R15
*
*                     - FROM END OF INPUT FILE RTN -
*                                     ENTRY FROM - IERRGF
*                                     CALLING SEQUENCE -
*                                     L    R11,PPIPSVA
*                                     B    8(,R11)
*
*                     - FROM GET -    ENTRY FROM - QSAM GET
*                                     CALLING SEQUENCE -
*                                     BR   R14        RETURN
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIEOF    PPISTDCB
*        PPIPDWA  PPIGETMN
*        TEST IF USER MOD SWITCH ON IN PPI, OBTAIN STARTING ADDR
*        OF INPUT DCBS, WORK AREA IN PPI FOR INPUT RCD ADDR
*        TABLE FOR MERGE NTWK
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPIPSVA  PPICNTL   PPIMRGMX
*        SAVE THIS MOD ENTRY POINT, SET PPI SWITCH TO INDICATE
*        R15, RESET MRGMX, IF NEEDED, TO CORRECT INPUT MERGE ORDER
*        EXTERNAL ROUTINES - NONE
*
*        EXTERNAL PARAMETERS - SEE REGISTERS
*
*        EXITS - NORMAL - TO GET - EXIT TO QSAM GET
*                                  CALLING SEQUENCE -
*                                  GET (R5),(R0)  R5 -> INPUT DCB
*                                                 RS -> WORKAREA
*                                  RETURN ON REGISTER R14
*
*                       - TO IERRC9
*
*        EXITS - ERROR - NONE
*
*        TABLES/WORK AREAS -
*        PPIPDWA - TABLE OF INPUT RECORD ADDRS IN PPI
*
*        NOTES -
*        THIS MODULE WILL EXECUTE FOR VARIABLE SPANNED RECORDS -
*        MERGE ONLY
*
IER9DJ   CSECT
*
         USING *,R11               ADDRESSABILITY
         USING IER8DJ,R9           IER8DJ DSECT BASE REG
         USING IERRCA,R13          PPI BASE REG
*
IERMD34  LR    R11,R15
         B     ADJ4030             NORMAL ENTRY
*
         L     R9,PPIDEB+4         ADDR OF IER8DJ
*
*        EOF REACHED ON GET - INDICATES NO RECORDS IN THAT FILE
*
         LH    R3,PPIMRGMX         DECREMENT MERGE ORDER BY 1
         BCTR  R3,0
         STC   R3,PPIMRGMX+1
         LTR   R3,R3
         BNP   ADJ4010             MERGE ORDER ZERO ? YES, BRANCH
         BCT   R4,ADJ4070          NO, DECREMENT COUNTER AND BRANCH TO
*                                  PRIME NEXT AREA
         B     ADJ4050             COUNTER = 0, BRANCH TO END OF MOD
*
*        ZERO INPUT FILES
*
ADJ4010  L     R14,WROSAV          RETURN TO
         BR    R14                 IERRC9
*
*        NORMAL ENTRY TO MODULE
*
ADJ4030  NI    IERMD34+3,X'0F'     NOP NORMAL ENTRY
         ST    R11,PPIPSVA         SAVE THIS MODULE BASE FOR END OF
*                                  FILE RTN
         ST    R14,WROSAV          SAVE RETURN TO IERRC9
         L     R9,PPIDEB+4         LOAD IER8DJ DSECT BASE REG
         L     R7,PPISTDCB         R7 -> DCB TABLE
         L     R8,KINCR            INITIALIZE INCREMENT VALUE
         LH    R4,PPIMRGMX         SET R4 = MAX MERGE ORDER
         LA    R6,PPIPDWA          R6 -> PRIME AREA ADDR LIST
         L     R3,PPIGETMN         CALCULATE ADDR OF WORKAREA - 4 AS
         LA    R4,1(,R4)           PPIGETMN + (M+1)*4
         SLL   R4,2
         AR    R3,R4               STORE ADDR IN RUNNING RPOGRAM
         ST    R3,WORKGET
         ST    R3,TEMPWORK
         LH    R4,PPIMRGMX         SET R4 = MAX MERGE ORDER
ADJ4040  LA    R7,4(,R7)           INCR R7 TO NEXT DCB ADDR IN DCBTAB
         L     R5,0(,R7)           SET R5 = ADDR OF NEXT DCB
         L     R3,TEMPWORK         LOAD ADDR OF WORK AREA
         LA    R3,4(,R3)           INCR ADDR
         ST    R3,TEMPWORK         STORE ADDR OF WORKAREA
         L     R0,0(,R3)
*
*        GET RETURNS NEW RECORD ADDR IN R1
*
         GET   (R5),(0)
*
         AR    R1,R8               ADD INCREMENT TO HI BYTE OF NEW RCD
         ST    R1,0(,R6)           STORE RCD ADDR IN PRIME AREA
         BCT   R4,ADJ4060          DECREMENT MERGE ORDER BY 1
*
ADJ4050  PPISETON PPIPEOF          SET ON TO INDICATE RUNNING PROGRAM
         L     R14,WROSAV          RETURN TO IERRC9
         BR    R14
*
ADJ4060  LA    R6,4(,R6)           INCREMENT PRIME AREA POINTER
ADJ4070  A     R8,KINCR            ADD 4 TO INCR
         B     ADJ4040             BRANCH TO NEXT DCB
*
*        CONSTANTS
*
         DC    0F'0'
KINCR    DC    X'04000000'         CONSTANT INCREMENT
*
*        WORK AREAS
*
WROSAV   DC    F'0'                RETURN ADDR
TEMPWORK DC    F'0'
*
IER8DJ   DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IER8DJ SOURCE
*
*----------------------------------------------------------------------
*
         COPY IER8DJI
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IER9GB   0101-20211-20211-1200-00280-00280-00000-RELEASE 00
GB9      TITLE 'IER9GB - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IER9GB
*
*        MODULE FUNCTION/OPERATION -
*        IER9GB IS THE ASSIGNMENT ROUTINE FOR MODULE IER8GB
*        INTERMEDIATE MERGE PHASE READ ROUTINE FOR THE CRCX
*        ALGORITHM
*
*        ALLOCATE SPACE IN GENERATED STORAGE FOR CCWS AND THE
*        BLOCK COUNT TABLE
*        ATTACHES CCWS AND BUFFERS TO THE IOBS
*        IF THE RECORD FORMAT IS VARIABLE, THE ROUTINE MAKES
*        OVERLAYS IN THE RUNNING PROGRAM TO ALLOW FOR THE BLOCK
*        CHARACTER COUNT AT THE BEGINNING OF EACH BUFFER
*        ADJUSTS THE RUNNING PROGRAM TO HANDLE THE READ ERROR
*        OPTION SPECIFIED BY E28
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACROS USED -
*        SMPPI
*        DCBD
*
*        ENTRY POINTS - ENTRY CALLING SEQUENCE -
*                       LOAD  EP=IER9GB,DCB=SORTLIB
*                       LR    R15,R0
*                       BALR  R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIRD      PPIMRGMX
*        PPIOPEN    PPIBDSVA
*        PPIAMB     PPIADSSC
*        PPISPGN1   PPISTDCB
*        PPILAB10   PPICNTL
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPISPGN1   PPISBLCT
*
*        CODE IN RUNNING PROGRAM IS OVERLAID
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL - RETURN TO LOAD MODULE
*                         BR   R14
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS - N/A
*
*        NOTES - N/A
*
IER9GB   CSECT
*
         USING *,R11               MODULE BASE REG
         USING IERAP2,R1           OPEN LIST BASE REG
         USING IOBSTDRD,R5         IOB BASE REG
         USING IHADCB,R7           DCB BASE REG
         USING IER8GB,R10          RUNNING PROGRAM BASE REG
         USING IERRCA,R13          PPI BASE REG
         USING DIERAMB,R9          MESSAGE MODULE BASE REG
*
         LR    R11,R15             SET BASE REGS
         L     R10,PPIRD+4
         L     R1,PPIOPEN+4
         L     R9,PPIAMB+4
         ST    R14,KSAVE3
*
*        CHECK IF USER SPECIFIED A SYNAD OPTION AT EXIT E28 AND
*        ADJUST RUNNING PROGRAM ACCORDINGLY
*
         L     R15,WRDOPT          USER PROVIDED A SYNAD EXIT ?
         ST    R15,AE28
         LA    R15,0(,R15)
         LTR   R15,R15             ERROR RTN FOR PERM READ ERRORS
         BZ    AGC080              NO, BRANCH
AGC005   CLI   AE28,X'40'          YES, TEST ERROR OPTION
         BE    AGC090              SKIP
         BH    AGC100              ACCEPT, FALL THRU ON TERMINATE
         DROP  R1
*
*        ALLOCATE SPACE IN GENERATED STORAGE FOR CCW'S AND
*        BLOCK COUNT TABLE
*
AGC010   L     R1,PPISPGN1         ALIGN TO DOUBLE WORD BOUNDARY
         SRL   R1,3
         SLL   R1,3
         LH    R2,PPIMRGMX         2 CCW LISTS PER FILE
         MH    R2,KH48             3 CCWS PER LIST = 6 * M CCWS
         SR    R1,R2               8 BYTES PER CCW = 48 * M BYTES
         ST    R1,KACCW            STORE ADDR OF CCW AREAS
         SR    R3,R3               (N+1)*4 BYTES NEEDED FOR BLOCK COUNT
         IC    R3,PPIBDSVA         TABLE
         LA    R3,1(,R3)
         SLL   R3,2
         SR    R1,R3
         ST    R1,PPISBLCT
         ST    R1,PPISPGN1
*
*        PRINT DIAGNOSTIC MESSAGES IF DIAGNOSTICS REQUESTED
*
         PPITEST  PPIDIAG          DIAGNOSTICS ?
         BZ    AGC020              NO, BRANCH
         STM   R14,R1,KSAVE4
         L     R0,KACCW            PRINT ADDR OF CCWS
         L     R15,PPICONV+4
         BAS   R14,4(,R15)         CONVERT
         MVC   IER927A,2(R1)
         LM    R0,R1,IER927        IER927I INPUT CCW ADDR
         L     R15,PPIADSSC        R15 -> SSC
         BAS   R14,12(,R15)        CALL MSG WRITER
         LM    R14,R1,KSAVE4
         DROP  R9
*
*        INITIALIZE CCWS
*        ATTACH BUFFERS AND CCWS TO THE FIRST M IOBS
*
AGC020   MVI   KCCWLST+20,SLI      SET SLI BIT ON TO SUPRESS WRONG
*                                  LENGTH RECORD INDICATION ON
*                                  OCCURENCE OF SHORT BLOCKS
         MVC   KCCWLST+22(2),PPILAB07+2  SET COUNT IN READ CCW
         LH    R0,PPIMRGMX         M COUNT
         L     R4,KACCW            ADDR OF CCW AREA
         L     R6,PPISTDCB         R6 -> DCB TABLE
         LA    R6,4(R6)            INCR OVER SORTIN DCB
         L     R3,PPILAB10         R3 -> SORTWK BUFFER TABLE
*
*        BEGIN ATTACH CCWS AND BUFFER LOOP
*
AGC030   L     R7,0(R6)            R7 -> DCB
         L     R5,DCBIOBAD         R5 -> IOB
         LA    R15,IOBCC           SET PTR TO DISK ADDR IN SEARCH
         STCM  R15,B'0111',KCCWLST+1  ID CCW
         STCM  R4,B'0111',KCCWLST+9   CHAIN TIC TO SEARCH ID
         ST    R4,IOBSTART          SET CCWLST ADDR IN IOB
         MVC   KCCWLST+17(3),1(R3)  MOVE BUFFER ADDR INTO CCW
         MVC   0(24,R4),KCCWLST    MOVE CCW LIST INTO GEN STORAGE
         LA    R4,24(R4)           SET UP ALTERNATE CCW LIST
         STCM  R4,B'0111',KCCWLST+9
         MVC   0(24,R4),KCCWLST
         L     R14,IOBECBPT        SAVE ALT LIST ADDR AT CCW+4
         ST    R4,4(,R14)
         MVI   4(R14),X'01'        SET NO BUFFERS ATTACHED TO 1
         LA    R4,24(,R4)          INCR POINTER TO CCWS
         LA    R6,4(,R6)           INCR POINTER TO NEXT DCB
         LA    R3,4(,R3)           INCR POINTER TO NEXT BUFFER
         BCT   R0,AGC030           HAVE M BUFFERS BEEN ATTACHED ?
*
*        END ATTACH CCWS AND BUFFER LOOP
*
         IC    R0,PPILAB10         R0 = NO OF BUFFERS ALLOCATED
         SH    R0,PPIMRGMX         SUBTRACT MERGE ORDER (NO OF SORTWK-1
         BZ    AGC060              ALL BUFFERS ALLOCATED IN FIRST PASS
         CH    R0,PPIMRGMX         IF M ALTERNATE BUFFERS, FULL OVERLAP
         BL    AGC040              LESS BUFFERS THAN SORKWK AREAS, BRCH
         NI    RGC030+1,X'0F'      MAKE OVERLAY IN RUNNING PROGRAM FOR
*                                  FULL OVERLAP
*
*        PARTIAL OR FULL OVERLAP EXISTS
*        ATTACH THE RENAMING UNASSIGNED BUFFERS TO THE
*        ALTERNATE CCW LISTS
*
AGC040   L     R6,PPISTDCB
AGC050   L     R7,4(,R6)           R7 -> DCB
         L     R5,DCBIOBAD         R5 -> IOB
         L     R1,IOBECBPT
         L     R4,4(,R1)           R4 = ALT  CCW LIST ADDR
         MVC   17(3,R4),1(R3)      MOVE BUFFER ADDR INTO READ CCW
         MVI   4(R1),X'02'         SET NO BUFFERS = 2
         LA    R3,4(,R3)           UPDATE BUFFER ADDR LIST PTR
         LA    R6,4(,R6)           UPDATE DCB PTR
         BCT   R0,AGC050           ALL ALT BUFFERS BEEN ATTACHED ?
*
*        MAKE OVERLAYS IN RUNNING PROGRAM FOR VARIABLE LENGTH
*        RECORDS IF REQUIRED
*
AGC060   PPITEST  PPIFIX           FIXED LENGTH RECORDS ?
         BO    AGC070              YES, BRANCH
         MVI   RGC010+3,X'0D'      DISPL OF EOS INDIC IS 13 RATHER
         MVI   RGC020+3,X'0D'      THAN 9 BECAUSE OF RDW
         MVI   RGC160+3,X'0D'
         MVI   RGC315+3,X'0D'
         MVI   WAIT060+5,X'04'     RATHER THAN 0 BECAUSE OF RDW
         MVI   WAIT110+3,X'0D'
         MVI   WAIT120+5,X'04'     RATHER THAN 0 BECAUSE OF RDW
         MVI   WAIT020+3,X'10'     DISPL OF FIRST RECORD IN BUFFER
         OI    WAIT030+1,X'F0'
AGC070   L     R14,KSAVE3          RETURN TO IERRC9
         BR    R14                 RETURN
*
*        MAKE OVERLAYS IN RUNNING PROGRAM FOR USER ERROR OPTION
*
AGC080   MVC   WAIT075(4),KICON1   NO SYNAD RTN SPECIFIED - OVERLAY
         B     AGC005              CONTINUE
*
AGC090   MVC   WAIT077(4),KICON2   SKIP OPTION
         PPISETON PPIACCPT         SET ACCEPT/SKIP SWITCH
         B     AGC010              CONTINUE
*
AGC100   MVC   WAIT077(4),KICON3   ACCEPT OPTION
         PPISETON PPIACCPT         SET ACCEPT/SKIP SWITCH
         B     AGC010              CONTINUE
*
*        CONSTANTS
*
KSAVE3   DC    F'0'                SAVE AREA FOR R14
KSAVE4   DC    4F'0'               SAVE AREA ON EXIT TO DIAGNOSTIC RTN
KACCW    DC    F'0'                ADDR OF CCW AREA IN GEN CORE
KH48     DC    H'48'               48
*
*        MODEL CCW LIST
*
KCCWLST  CCW   SEARIDEQ,0,CC+SLI,5
         CCW   TIC,0,CC+SLI,0
         CCW   READDATA,0,0,0
*
         DROP  R10,R11
*
         USING IER8GB,R11
KICON1   B     WAIT077             NO ERROR RTN
KICON2   B     WAIT100             SKIP
KICON3   B     WAIT090             ACCEPT
*
         DROP  R11
*
IER8GB   DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IER8GB SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IER8GBI
*
*        IOB DSECT
*
         IERIOB
*
*        IERCCWEQ
*
         IERCCWEQ
*
         PRINT NOGEN
*
*        MAP DEB
*
         IEZDEB LIST=NO
*
         DCBD  DSORG=PS,DEVD=DA
*
*        IHAECB
*
         IHAECB DSECT=NO
*
         PRINT GEN
*
*        IERAMB
*
DIERAMB  DSECT
*
         COPY  AMBMAIN
*
IERAP2   DSECT                     OPEN LIST DSECT
*
         DC    19F'0'              DCBS
WRDOPT   DC    F'0'                TO BE OPENED
         DC    11F'0'
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IER9GC   0101-20211-20211-1200-00396-00396-00000-RELEASE 00
GC9      TITLE 'IER9GC - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IER9GC
*
*        MODULE FUNCTION/OPERATION -
*        ASSIGNMENT ROUTINE FOR MODULE IER8GC, THE FINAL MERGE
*        PHASE READ ROUTINE FOR THE CRCX ALGORITHM
*
*        IF THE RECORD FORMAT IS VARIABLE, THIS ROUTINE MAKES
*        OVERLAYS IN THE RUNNING PROGRAM TO ALLOW FOR THE BLOCK
*        CHARACTER COUNT AT THE BEGINNING OF EACH BUFFER. IT ALSO
*        ADJUSTS THE RUNNING PROGRAM TO HANDLE THE READ ERROR
*        OPTION SPECIFIED BY E28
*
*        IT ALLOCATES SPACE IN GENERATED STORAGE FOR CCWS AND
*        THE BLOCK COUNT TABLE AND ATTACHES CCWS AND BUFFERS TO
*        THE IOBS. IT PRIMES BUFFERS FOR THE FINAL MERGE PHASE BY
*        READING THE FIRST BLOCK OF EACH SEQUENCE AND MAKING THE
*        FIRST M RECORD ADDRESSES AVAILABLE TO THE NETWORK. IT
*        ALSO READS INTO ANY ALTERNATE BUFFERS WHICH ARE PRESENT
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACROS USED -
*        SMPPI
*        DCBD
*
*        ENTRY POINTS - ENTRY FROM LOAD MODULE
*                       LOAD  EP=IER9GC,DCB=SORTLIB
*                       LR    R15,R0
*                       BALR  R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIRCDCT   PPISPGN1   PPIENDAR
*        PPIOPEN    PPIMRGMX   PPISTDCB
*        PPIRD      PPIBDSVA   PPILAB03
*        PPIAMC     PPICNTL    PPISRTBL
*        PPICONV    PPILAB02   PPISTIOB
*        PPIADSSC
*        PHYSICAL RECORDS ON DISK AREAS ARE READ INTO STORAGE
*
*        OUTPUT - PPIFIELDS INITIALIZED OR ALTERED -
*        PPICNTL   PPIWKARE   PPISPGN1   PPISBLCT
*        CODE IN RUNNING PROGRAM IS OVERLAID
*
*        EXTERNAL ROUTINES -
*        THE WAITRTN AND EXCP SUBROUTINES FOUND IN IER8GC ARE USED
*        BY THIS MODULE
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL - RETURN TO LOAD MODULE
*                         BR R14
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS - N/A
*
*        NOTES - N/A
*
IER9GC   CSECT
*
         USING *,R11               MODULE BASE REG
         USING IERAP33,R1          OPEN LIST BASE REG
         USING IHADCB,R7           DCB BASE REG
         USING DIERAMC,R9          MESSAGE MODULE BASE REG
         USING IOBSTDRD,R5         IOB BASE REG
         USING IERRCA,R13          PPI BASE REG
         USING DIER8GC,R10         IER8GC BASE REG
*
         LR    R11,R15
         ICM   R4,B'1111',PPIRCDCT  RECORD COUNT = 0 ?
         BZR   R14                 YES, RETURN TO LOAD MODULE
         L     R1,PPIOPEN+4        SET BASE REGS
         L     R10,PPIRD+4
         L     R9,PPIAMC+4
         ST    R14,KSAVE1          SAVE RETURN ADDR
*
*        CHECK USER SPECIFIED A SYNAD OR ERROR OPTION AT E38 AND
*        ADJUST RUNNING PROGRAM ACCORDINGLY
*
         CLC   WRDOPT+1(3),AE38    ERROR RTN SPECIFIED ?
         BE    AGE120              NO, OVERLAY TO BRANCH AROUND
AGE010   MVC   AE38+1(3),WRDOPT+1
         CLI   WRDOPT,X'40'        ERROR OPTION ?
         BE    AGE130              SKIP
         BH    AGE140              ACCEPT, FALL THRU ON TERMINATE
         DROP  R1
*
*        ALLOCATE SPACE IN GENERATED STORAGE FOR CCWS AND BLOCK
*        COUNT TABLE
*
AGE020   L     R1,PPISPGN1         ALIGN TO DOUBLE WORD BOUNDARY
         SRL   R1,3
         SLL   R1,3
         LH    R2,PPIMRGMX         2 CCW LISTS PER FILE
         AR    R2,R2               2*M = NO BUFFERS FOR FULL OVERLAP
         STC   R2,RGE020+1         SET MASK IN RP TO TEST FOR FULL
*                                  OR PARTIAL OVERLAP
         SRL   R2,1                RESET TO M
         MH    R2,K48              3 CCWS PER LIST = 6 * M CCWS
         SR    R1,R2               8 BYTES PER CCW = 48 * M BYTES
         ST    R1,KACCW            STORE ADDR OF CCW CHAINS
         SR    R3,R3               (N+1)*4 BYTES NEEDED FOR BLOCK COUNT
         IC    R3,PPIBDSVA         TABLE
         LA    R3,1(,R3)
         SLL   R3,2                MULT BY 4
         SR    R1,R3
         ST    R1,PPISBLCT         STORE ADDR OF BLOCK COUNT TABLE
         ST    R1,PPISPGN1         RESET PTR TO GENERATED STORAGE
*
*        PRINT DIAGNOSTIC MESSAGE IF DIAGNOSTICS REQUESTED
*
         PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTICS ?
         BZ    AGE030              NO, BRANCH
         STM   R14,R1,KSAVE4
         L     R0,KACCW            PRINT ADDR OF CCWS
         L     R15,PPICONV+4
         BAS   R14,4(,R15)         CONVERT
         MVC   IER945A,2(R1)
         LM    R0,R1,IER945        IER945I INPUT CCW ADDR
         L     R15,PPIADSSC        R15 -> SSC
         BAS   R14,12(,R15)        CALL MSG WRITER
         LM    R14,R1,KSAVE4
         DROP  R9
*
*        MAKE OVERLAYS IN RUNNING PROGRAM FOR VARIABLE LENGTH
*        RECORDS
*
AGE030   PPITEST  PPIFIX           FIXED LENGTH RECORDS ?
         BO    AGE040              YES, BRANCH
         MVI   RGE010+3,X'0D'      BYPASS 4 EXTRA BYTES FOR BCC
         MVI   RGE030+3,X'0D'      DSPL FOR EOS INDICATION
         MVI   RGE060+3,X'0D'
         MVI   RGE160+3,X'0D'
         MVI   WAIT110+3,X'0D'
         MVI   WAIT020+3,X'10'     DSPL OF FIRST RECORD IN BUFFER
         MVI   WAIT030+1,X'F0'     BYPASS CONVERSION OF BYTES TO RCDS
         MVI   WAIT060+5,X'04'     DSPL FOR DISK CHAIN ADDR
*
*        GENERATE CCW LISTS
*        ATTACH BUFFERS AND CCW LISTS TO INPUT IOBS
*        ISSUE M READS TO PRIME EACH OF M AREAS
*
AGE040   MVC   KCCWLST+22(2),PPILAB03+2  SET COUNT IN CCW
         SR    R1,R1
         LH    R0,PPIMRGMX         COUNT FOR M READS
         L     R4,KACCW            R4 -> CCW AREA
         L     R3,PPILAB02         R3 -> INPUT BUFFER TABLE
         L     R6,PPISTIOB         R6 -> IOB TABLE
         LA    R15,PPIENDAR        R15 -> M DISK ADDRESSES FOR PRIME
         LA    R9,KPT              R9 -> PRIMING WORKAREA
         L     R14,PPISTDCB        R14 -> DCB TABLE
*
*        BEGIN PRIMING LOOP
*
AGE050   L     R5,0(,R6)           R5 -> IOB
         LA    R2,IOBCC            SET POINTER TO DISK ADDR IN SEARCH
         STCM  R2,B'0111',KCCWLST+1  ID CCW
         STCM  R4,B'0111',KCCWLST+9  CHAIN TIC TO SEARCH ID
         ST    R4,IOBSTART         SET CCW LIST ADDR IN IOB
         MVC   KCCWLST+17(3),1(R3)  MOVE BUFFER ADDR INTO CCW FROM
*                                  INPUT BUFFER TABLE ENTRY
         MVC   0(24,R4),KCCWLST    MOVE CCW LIST INTO GEN STORAGE
         LA    R4,24(,R4)          SET UP ALTERNATE CCW LIST
         STCM  R4,B'0111',KCCWLST+9
         MVC   0(24,R4),KCCWLST    MOVE CCWS INTO GENERATED STORAGE
         L     R2,IOBECBPT         SAVE ALTERNATE CCW LIST ADDR AT
         ST    R4,4(,R2)           ECB+4
         MVI   4(R2),X'01'         SET NO BUFFERS ATTACHED TO 1
         ST    R5,0(,R9)           SAVE IOB ADDR INTO PRIMING WORKAREA
         STC   R1,0(,R9)           SAVE M INTO PRIMING WORKAREA
         STC   R1,KSAVE+11
         SR    R2,R2
         IC    R2,0(,R15)          R2 = M INCREMENT FROM PPIENDAR
         L     R7,0(R2,R14)        R7 -> DCB
         ST    R7,IOBDCBPT         CHAIN IOB TO DCB
         ST    R5,DCBIOBAD         CHAIN DCB TO IOB
         MVC   IOBSEEK,0(R15)      MOVE PPIENDAR MTTR ENTRY TO IOBSEEK
         LR    R2,R11              SAVE ADDRESSABILITY
         L     R11,PPIRD+4         R11 -> IER8GC
         BAS   R8,EXCP010          CALL READ ROUTINE IN IER8GC
         LR    R11,R2              RESTORE IER9GC BASE REG
         LA    R4,24(,R4)          UPDATE CCW LIST ADDR
         LA    R15,8(,R15)         UPDATE PPIENDAR ENTRY ADDR
         LA    R9,4(,R9)           UPDATE PRIMING WORKAREA ENTRY ADDR
         LA    R6,4(,R6)           UPDATE IOB TABLE ENTRY ADDR
         LA    R1,4(,R1)           UPDATE M NUMBER
         LA    R3,4(,R3)           UPDATE INPUT BUFFER TABLE
         BCT   R0,AGE050           LOOP TO PRIME NEXT AREA
*
*        ALL M AREAS HAVE BEEN PRIMED
*        WAIT FOR COMPLETION OF EACH READ AND ISSUE A SECOND
*        READ IF FILE HAS AN ALTERNATE BUFFER
*
         L     R14,PPISTDCB        R14 -> DCB ADDR TABLE
         ST    R3,PPILAB02         SET PPILAB02 -> LAST BUFFER USED
         LA    R9,KPT              R9 -> PRIMING WORKAREA TABLE
         LA    R4,PPIWKARE
         LA    R15,TFCNT
         L     R8,PPISBLCT
         SR    R0,R0
         IC    R0,PPILAB03
         STC   R0,KTOTAL           SET TOTAL NO BUFFERS IN RP
         SH    R0,PPIMRGMX
         STC   R0,KNUM
         SR    R1,R1               SET INCR=0
         CLI   KNUM,X'00'          NO OF EXTRA BUFFERS = 0 ?
         BE    AGE090              YES
*
*        ATTACH ALTERNATE BUFFERS
*
AGE070   L     R5,0(,R9)           R5 = IOB FROM PRIMING TABLE ENTRY
         LH    R2,PPISRTBL         2*SORT BLOCKING IN FILE COUNT TABLE
         AR    R2,R2
         ST    R2,0(R1,R15)
         STC   R1,0(R1,R15)        INCR IN FILE COUNT TABLE
         AR    R1,R1
         SR    R2,R2
         IC    R2,PPIENDAR(R1)     R2 = M
         L     R7,0(R2,R14)        R7 -> DCB
         SRL   R1,1
         ST    R1,KSAVE+8
         ST    R8,KSAVE8
         ST    R4,KSAVE9
         LR    R4,R11              SAVE ADDRESSABILITY
         LR    R11,R10             R11 -> IER8GC
         BAS   R6,WAITRTN          CALL WAITRTN IN IER8GC
         LR    R11,R4              RESTORE ADDRESSABILITY
         L     R8,KSAVE8
         L     R4,KSAVE9
         ST    R1,0(,R8)           STORE COUNT IN BLOCK COUNT TABLE
         L     R1,KSAVE+4
         ST    R1,0(,R4)           SET RECORD ADDR IN PPI FOR NETWORK
         L     R1,KSAVE+8
         STC   R1,0(,R4)
AGE080   CLI   9(R2),C'G'          AN EOS BLOCK ? (HGHH)
         BE    AGE085              YES, DONT ATTACH ALT BUFFER
         L     R3,PPILAB02         NO,GET ADDR OF NEXT AVAILABLE BUFFER
*                                  FROM BUFFER TABLE
         MVC   KEMPTY,0(R3)        ATTACH ALT BUFFER AND ISSUE
         ST    R8,KSAVE8           ANOTHER READ
         ST    R4,KSAVE9
         LR    R4,R11              SAVE ADDRESSABILITY
         LR    R11,R10             R11 -> IER8GC
         BAS   R8,EXCP             CALL EXCP IN IER8GC
         LR    R11,R4              RESTORE ADDRESSABILITY
         L     R4,KSAVE9
         L     R8,KSAVE8
         LA    R3,4(,R3)           UPDATE BUFFER TABLE NEXT ENTRY TAB
         ST    R3,PPILAB02
AGE085   LA    R4,4(,R4)
         LA    R8,4(,R8)
         LA    R9,4(,R9)
         LA    R1,4(,R1)
         BCT   R0,AGE070           DO NEXT BUFFER
*
*        ALL ALTERNATE BUFFERS HAVE BEEN ATTACHED
*
         CLC   KNUM,PPIMRGMX+1     NO ALT BUFFERS = M ?
         BE    AGE110              YES, FULL OVERLAP
*
*        PROCESS FILES WITH ONLY ONE BUFFER ATTACHED
*
         SR    R3,R3
         IC    R3,KNUM
         LH    R0,PPIMRGMX
         SR    R0,R3
         B     AGE100              GO TO PROCESS BUFS
*
*        NO ALTERNATE BUFFERS
*
AGE090   LH    R0,PPIMRGMX
AGE100   L     R5,0(R9)
         LH    R2,PPISRTBL         SET UP TFCNT TABLE
         ST    R2,0(R1,R15)        SET TFCNT ENTRY TO BLOCK SIZE
         STC   R1,0(R1,R15)        PUT INCREMENT IN TFCNT ENTRY
         ST    R4,KSAVE9
         LR    R4,R11              SAVE ADDRESSABILITY
         ST    R1,KSAVE+8          ISSUE WAIT ON ORIGINAL OF M READS
         ST    R8,KSAVE8
         LR    R11,R10             R11 -> IER8GC FOR ADDRESSABILITY
         BAS   R6,WAITRTN          CALL WAITRTN
         LR    R11,R4              RESTORE ADDRESSABILITY
         L     R8,KSAVE8
         L     R4,KSAVE9
         ST    R1,0(,R8)           SAVE BLOCK COUNT
         L     R1,KSAVE+4
         ST    R1,0(,R4)           SET RECORD ADDR FOR NETWORK
         L     R1,KSAVE+8
         STC   R1,0(,R4)
         LA    R4,4(,R4)           UPDATE POINTERS FOR NEXT FILE
         LA    R1,4(,R1)
         LA    R9,4(,R9)
         LA    R8,4(,R8)
         BCT   R0,AGE100           DO NEXT FILE
*
AGE110   L     R14,KSAVE1          RESTORE RETURN ADDR
         BR    R14                 RETURN TO CALLER
*
*
*        MAKE OVERLAYS IN RUNNING PROGRAM FOR USER ERROR OPTION
*
AGE120   MVC   WAIT075(4),KICON1   NO SYNAD ROUTINE SPECIFIED OVERLAY
         B     AGE010              RETURN
*
AGE130   MVC   WAIT077(4),KICON2   SKIP OPTION
         PPISETON PPIACCPT         SET ACCEPT/SKIP SWITCH
         B     AGE020              RETURN
*
AGE140   MVC   WAIT077(4),KICON3   ACCEPT OPTION
         PPISETON PPIACCPT         SET ACCEPT/SKIP SWITCH
         B     AGE020              RETURN
*
*        CONSTANTS AND VARIABLES
*
KSAVE1   DC    F'0'                SAVE AREA FOR RETURN REGISTER
KACCW    DC    A(0)                ADDR OF CCW AREA
KSAVE4   DC    4F'0'               SAVE AREA WHEN USING DIAGNOSTICS
*
KCCWLST  CCW   SEARIDEQ,0,SLI+CC,5
         CCW   TIC,0,SLI+CC,0
         CCW   READDATA,0,SLI,0
*
KPT      DC    16F'0'              WORK AREA USED IN PRIMING
*                                  EACH ENTRY CONTAINS THE DCB INCR
*                                  AND IOB ADDR USED TO PRIME THE
*                                  M AREAS. ACCESSED AFTER M READS
*                                  TO ISSUE M WAITS
KSAVE8   DC    F'0'                SAVE R8
KSAVE9   DC    F'0'                SAVE R4
K48      DC    H'48'               CONSTANT
KNUM     DC    X'00'               NUMBER OF ALTERNATE BUFFERS
*
         DROP  R10,R11
         DROP  R5
         USING DIER8GC,R11
KICON1   B     WAIT077             NO ERROR RTN
KICON2   B     WAIT100             SKIP
KICON3   B     WAIT090             ACCEPT
*
         DROP  R11
*
IERAP33  DSECT
         DC    23F'0'              OPEN LIST
WRDOPT   DC    9F'0'               READ ERR OPT
*
DIER8GC  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IER8GC SOURCE
*
*----------------------------------------------------------------------
*
         COPY  IER8GCI
*
*        DSECT OF MESSAGE MODULE
*
DIERAMC  DSECT
*
         COPY  AMCMAIN
*
*        IOB DSECT
*
         IERIOB
*
*        IERCCWEQ
*
         IERCCWEQ
*
         PRINT NOGEN
*
*        MAP DEB
*
         IEZDEB LIST=NO
*
*        IHAECB
*
         IHAECB DSECT=NO
*
*        DCB DSECT
*
         DCBD  DSORG=PS,DEVD=(DA)
*
         PRINT GEN
*
*        REGISTER AMD BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IER9GN   0101-20211-20211-1200-00501-00501-00000-RELEASE 00
GN9      TITLE 'IER9GN - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IER9GN
*
*        MODULE FUNCTION/OPERATION -
*        THE FUNCTION OF THIS MODULE IS TO GENERATE ALL DCB'S,
*        IOB'S, ECB'S, AND ALTERNATE CCW POINTER SLOTS ASSOCIATED
*        WITH PHASES ONE AND TWO OF A CRCX DISK SORT.
*        THEY ARE CREATED IN GENERATED STORAGE AS FOLLOWS -
*        ONE QSAM DCB FOR INPUT (SORTIN)
*        ONE EXCP DCB FOR OUTPUT TO EACH DISK AREA (SORTWKXX)
*        ONE IOB, ECB, AND ALTERNATE CCW POINTER FOR EACH DISK
*        AREA
*
*        THE ADDR OF EACH DCB GENERATED IS PLACED IN A DCB
*        ADDR TABLE AND DCB OPEN LIST. IF THE ACTIVE BITS FOR
*        ANY OR ALL OF USER MODIFICATION EXITS E18, E28, E19, AND
*        E29 ARE FOUND ON, THE PARAMETERS FROM THE USER'S
*        PROGRAM(S) ARE INCORPORATED INTO THE DCB'S AND THE OPEN
*        LIST
*
*        USED AS A DSECT IN - N/A
*
*        MACROS USED -
*        SMPPI
*        DCB
*        DCBD
*
*        ENTRY POINTS - ENTRY FROM IERRC9
*                       CALLING SEQUENCE -
*                       LOAD EP=IER9GN,DCB=SORTLIB
*                       LR   R15,R0
*                       BALR R14,R15 INITIAL ENTRY
*
*                     - ENTRY FROM IERRCV
*                       CALLING SEQUENCE -
*                       BR   R14     AFTER PRINTING MSG
*
*        INPUT PPI FIELDS REFERENCED -
*        PPISPGN1  PPINDSKA  PPIDDSRT  PPILAB03  PPILAB06  PPISTAR
*        PPICNTL   PPIEOF    PPIOPEN   PPIADSSC  PPICONV   PPIAMA
*        PPIX18    PPIX19    PPIX28    PPIX29
*
*        OUTPUT PPI FIELDS INITIALIZED OR ALTERED -
*        PPISPGN1 PPISTDCB PPISTIOB
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS - N/A
*
*        EXITS - NORMAL - TO IERRC9 - NORMAL RETURN
*                                     CALLING SEQUENCE -
*                                     BR   R14
*
*                       - TO IERRCV - PRINT MESSAGE
*                                     CALLING SEQUENCE -
*                                     L    R15,PPIADSSC
*                                     BAL  R14,12(,R15)
*
*        EXITS - ERROR - NONE
*
*        TABLES/WORK AREAS -
*        WDCBADR  - UPDATED ADDR OF DCB AREA IN STORAGE
*        WECBADR  - ADDR OF PREFIXED IOB AREA IN GENERATED STORAGE
*        WFRSTERR - GENERAL USER EXIT SWITCH
*        WREGS    - REGISTER SAVE AREA DURING PRINT ROUTINE
*        WSAVAREA - GENERAL REGISTER SAVE AREA
*        MODIOB   - MODEL PREFIXED IOB USED BY THE PROGRAM
*        SORTWK   - MODEL OUTPUT EXCP DCB
*        SORTIN   - MODEL INPUT QSAM DCB
*
IER9GN   CSECT
*
         USING *,R11               BASE REGISTER FOR THIS MODULE
         USING IHADCB,R12          BASE REGISTER FOR DCB DSECT
         USING IERRCA,R13          PPI COMMON MODULE BASE REGISTER
         USING DIERAMA,R14         BASE REG FOR MESSAGE MODULE DSECT
         USING OPENLIST,R15        BASE REG FOR OPEN LIST DSECT
*
         LR    R11,R15             LOAD BASE REGISTER
         STM   R0,R15,WSAVAREA     SAVE REGISTERS
         L     R15,PPIOPEN+4       BASE ADDR FOR OPEN LIST DSECT
*
*        ALLOCATE STORAGE FOR IOBS, ECBS, DCBS, TABLES
*        SET UP POINTERS
*
         L     R1,PPISPGN1         R1 -> GENERATED STORAGE
         LH    R4,PPINDSKA         R4 = NUMBER OF SORTWK AREAS
         LA    R3,SORTWKL          R3 = L'SORTWK DCBS
         MR    R2,R4               MULTIPLY
         SR    R2,R2
         LA    R3,SORTINL(,R3)     ADD L'SORTIN DCB
         SR    R1,R3               UPDATE ADDR OF GENERATED STORAGE
         ST    R1,WDCBADR          SAVE ADDR
         NI    WDCBADR+3,X'FC'     ROUND TO FULL WORD BOUNDARY
         L     R1,WDCBADR          R1 -> DCB AREA (ROUNDED)
         ST    R1,OPENLIST+4       MOVE ADDR OF INPUT DCB TO OPEN LIST
         LA    R3,MODIOBL          R3 = L'SORT/MERGE IOB
         MR    R2,R4               MULTIPLY BY NUMBER OF DISK AREAS
         SR    R1,R3               UPDATE ADDR OF GENERATED CORE
         ST    R1,WECBADR          SAVE ADDR OF IOBECB AREA
         LA    R4,1(,R4)           ADD ONE FOR QSAM INPUT DCB
         ST    R4,OPENLIST         STORE DCB COUNT IN OPEN LIST
         SLL   R4,2                MULTIPLY BY FOUR
         SR    R1,R4               RESERVE STORAGE FOR DCB TABLE
         ST    R1,PPISTDCB         SAVE ADDR OF DCB TABLE
         ST    R1,PPISPGN1         SAVE UPDATED GEN STORAGE ADDR
         MVC   0(4,R1),WDCBADR     MOVE ADDR OF SORTIN DCB INTO
*                                  FIRST ENTRY OF DCB ADDR TABLE
*
*        DIAGNOSTICS, PRINT ADDR OF DCB TABLE
*
         PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTICS ?
         BZ    GN01                NO, BYPASS MESSAGES
         LR    R0,R1               LOAD NUMBER TO BE CONVERTED
         L     R15,PPICONV+4       LOAD ADDR OF CONVERSION ROUTINE
         BAS   R14,4(R15)          BRANCH TO HAVE NUMBER CONVERTED
         L     R14,PPIAMA+4        ADDR OF MESSAGE MODULE
         MVC   IER906A,2(R1)       MOVE ADDR INTO MESSAGE
         LM    R0,R1,IER906        IER906I DCB TABLE ADDR
         L     R15,PPIADSSC        R15 -> SSC
         BAS   R14,12(,R15)        CALL MSG WRITER
*
*        SET INDICATOR BIT IN FIRST BYTE OF ALL DCB ADDR
*        TABLE SLOTS
*
GN01     L     R1,PPISTDCB         R1 -> DCB TABLE
         LA    R1,4(,R1)           UPDATE TO BYPASS SORTIN DCB ENTRY
         LH    R2,PPINDSKA         R2 = NUMBER OF DISK AREAS
         L     R3,KX800000         SET R3 TO X'80000000'
*
GN02     ST    R3,0(,R1)           SET FLAG BIT IN EACH DCB TABLE ENTRY
         LA    R1,4(,R1)           INCR POINTER TO DCB LIST TABLE
         BCT   R2,GN02             IF MORE ENTRIES, BRANCH
*
*        GENERATE SORTIN DCB
*
GN04     LA    R12,SORTIN          R12 -> SORTIN DCB FOR ADDRESSABILITY
         MVC   DCBDDNAM(4),PPIDDSRT  MOVE IN DDNAME
         MVC   DCBBUFNO,PPILAB03     MOVE IN NUMBER OF OUTPUT BUFFERS
         MVC   DCBBUFCA,PPILAB06+1   MOVE IN ADDR OF BUFFER POOL
         MVC   DCBBUFL,PPILAB03+2    MOVE IN SIZE OF INPUT BUFFER
         MVC   DCBEODA,PPIEOF+5      MOVE IN EOD ADDR
         MVI   DCBEROPT,DCBERABE     SET ERROR OPT, TERMINATE PROGRAM
         L     R1,PPIADSSC
         MVC   DCBSYNAD,24(R1)     MOVE IN ADDR OF SYNAD ERROR ROUTINE
         MVI   DCBBFTEK,DCBBFTS    SET SIMPLE BUFFERING
         PPITEST  PPIMVSI          VBS INPUT ?
         BO    GNVBS               YES, GO TO SET MOVE MODE
         OI    DCBMACR,DCBMRGET+DCBMRLCG  SET GET LOCATE MODE
         B     GN06                GO TEST FOR FULL BUF ALIGNMENT
*
GNVBS    OI    DCBMACR,DCBMRGET+DCBMRMVG  SET DATA MOVE MODE
         NI    DCBMACR,255-DCBMRLCG       TURN OFF LOCATE MODE
*
GN06     PPITEST  PPISWA           FULL WORD BUFFER ALIGNMENT ?
         BO    GN07                YES, BRANCH
         OI    DCBBFTEK,DCBBFAD    SET DOUBLE WORD BUFFER ALIGNMENT
         B     GN08                GO TEST FOR USER MODIFICATION E18
*
GN07     OI    DCBBFTEK,DCBBFAF1   SET FULL WORD BUFFER ALIGNMENT
*
GN08     PPITEST  PPIME18          USER EXIT E18 ACTIVE ?
         BZ    GN17                NO, BRANCH
*
*        BRANCH TO USER MODIFICATION EXIT E18
*
         L     R15,PPIX18+4        LOAD ADDR OF USER EXIT E18
         BASR  R14,R15             BRANCH TO USER E18
*
*        RETURN POINT FROM THE USER MODIFICATION PROGRAM
*
         LA    R2,TBRANCH          LOAD ADDR OF BRANCH TABLE
         LA    R3,TLDADR           LOAD ADDR OF LOAD ADDR TABLE
GN09     SR    R4,R4
         IC    R4,0(,R1)           LOAD OPTION NUMBER
         LTR   R4,R4               MORE OPTIONS ?
         BZ    GN17                NO, BRANCH
         CL    R4,KF4              CHECK OPTION FOR LEGALITY
         BNH   GN10                BRANCH IF LEGAL
         LA    R7,GN13             LOAD RETURN ADDR FROM ERROR RTN
         B     GN15                BRANCH TO ERROR ROUTINE
*
GN10     SLL   R4,2                CONVERT OPTION NUMBER TO INDEX
         EX    0,0(R4,R3)          EXECUTE PROPER LOAD ADDR INSTRUC
         AR    R4,R2               ADD INDEX TO ADDR OF BRANCH TBL
         BR    R4                  GOTO BRANCH TAB
*
*        BRANCH TABLE USED BY PROGRAM
*
TBRANCH  DC    F'0'                B   T
         B     GN12                 R   A
         B     GN12                  A   B
         B     GN14                   N   L
         B     GN11                    CH  E
*
*        LOAD ADDR TABLE USED BY PROGRAM
*
TLDADR   DC    F'0'                LA TABLE
         LA    R6,DCBSYNA
         LA    R6,DCBEXLSA
         LA    R6,DCBEROPT
         L     R6,PPIEOF+4
*
GN11     LA    R6,9(,R6)           UPDATE ADDR TO PROPER LOCATION
GN12     MVC   0(3,R6),1(R1)       MOVE ADDR INTO PROPER LOCATION
GN13     LA    R1,4(,R1)           UPDATE POINTER TO USER LIST
         B     GN09                GO THRU LOOP AGAIN
*
GN14     MVC   0(1,R6),3(R1)       MOVE ERROR OPTION INTO SORT EOD RTN
         B     GN13                GOTO UPDATE PTR TO USER LST
*
*        SET UP ERROR MESSAGE FOR PRINT MODULE IF FIRST ERROR
*
GN15     TM    WFRSTERR,X'01'      FIRST ERROR OPTION ?
         BO    GN13                NO, BRANCH
         MVI   WFRSTERR,X'01'      YES, SET INDICATOR
         L     R14,PPIAMA+4        R14 -> MESSAGE MOD DSECT
         MVC   IER044A,KTAG        MOVE '18' INTO ERROR MESSAGE
GN16     STM   R15,R7,WREGS        SAVE REGISTERS
         LM    R0,R1,IER044        IER044I EXIT INVALID OPTION
         L     R15,PPIADSSC        R15 -> SSC
         BAS   R14,12(,R15)        CALL MSG WRITER
*
*        RETURN POINT FROM PRINT MODULE
*
         LM    R15,R7,WREGS        RESTORE REGISTERS
         BR    R7                  RETURN TO WORK ON EXIT E18 PARAMS
*
*        MODIFICATION COMPLETE, RETURN TO MAIN PROGRAM
*
GN17     MVI   WFRSTERR,X'00'      RESTORE FIRST OPTION ERROR INDICATOR
         PPITEST  PPIME28          USER EXIT 28 ACTIVE ?
         BZ    GN22                NO, BRANCH
*
*        BRANCH TO USER MODIFICATION EXIT E28
*
         L     R15,PPIX28+4        LOAD ADDR OF USER EXIT E28
         BASR  R14,R15             GOTO USER E28
*
*        RETURN POINT FROM USER MODIFICATION EXIT E28
*
GN18     CLI   0(R1),X'00'         MORE OPTIONS ?
         BE    GN22                NO, BRANCH
         L     R15,PPIOPEN+4       LOAD BASE REG FOR OPEN LIST DSECT
         CLI   0(R1),X'01'         USER SYNAD OPTION ?
         BE    GN20                YES, BRANCH
         CLI   0(R1),X'03'         USER EROPT OPTION ?
         BE    GN21                YES, BRANCH
         BNH   GN19                BRANCH IF VALID OP CODE
*
*        IF FIRST ERROR, SET UP ERROR PRINTOUT FOR PRINT MODULE
*
         TM    WFRSTERR,X'01'      FIRST OPTION IN ERROR?
         BO    GN19                BRANCH ON NO
         MVI   WFRSTERR,X'01'      ON YES, SET INDICATOR
         L     R14,PPIAMA+4        LOAD BASE REG FOR MESSAGE MOD DSECT
         MVC   IER044A,KTAG+2      MOVE '28' INTO ERROR MESSAGE
         BAS   R7,GN16             BRANCH TO BRANCH TO PRINT ROUTINE
GN19     LA    R1,4(,R1)           UPDATE POINTER TO USER PARAMS
         B     GN18                GO THRU LOOP AGAIN
*
GN20     MVC   AP1RD2+1(3),1(R1)   MOVE USER SYNAD INTO OPEN LIST
         B     GN19                GO THRU THE LOOP AGAIN ?
*
GN21     MVC   AP1RD2(1),3(R1)     MOVE USER EROPT INTO OPEN LIST
         B     GN19                GO THRU THE LOOP AGAIN ?
*
*        ENTRIES MADE
*        RETURN TO MAIN PROGRAM AND MOVE DCB INTO ALLOCATED STORAGE
*
GN22     MVI   WFRSTERR,X'00'      RESTORE FIRST ERROR OPTION INDICATOR
         L     R3,WDCBADR          R3 -> DCB AREA
         MVC   0(SORTINL,R3),SORTIN  MOVE DCB INTO ALLOCATED CORE
         LA    R3,SORTINL(,R3)       UPDATE ADDR OF DCB AREA
         ST    R3,WDCBADR          SAVE
*
*        GENERATE OUTPUT EXCP DCBS
*
GN23     LA    R12,SORTWK          R12 -> SORTWK
         MVC   DCBDDNAM(4),PPIDDSRT
         MVI   DCBBFTEK,DCBBFTS    SET SIMPLE BUFFERING
GN25     PPITEST  PPISWA           FULL WORD BUFFER ALIGNMENT ?
         BO    GN26                YES, BRANCH
         OI    DCBBFTEK,DCBBFAD    SET DOUBLE WORD BUFFER ALIGNMENT
         B     GN29                GO TEST FOR USER EXIT E19
*
GN26     OI    DCBBFTEK,DCBBFAF1   SET FULL WORD BUFFER ALIGNMENT
*
GN29     PPITEST  PPIME19          USER EXIT E19 ACTIVATED ?
         BZ    GN34                NO, BRANCH
*
*        BRANCH TO USER MODIFICATION EXIT E19
*
         L     R15,PPIX19+4        R15 -> USER EXIT E19
         BASR  R14,R15             BRANCH TO E19
*
GN30     CLI   0(R1),X'00'         MORE OPTIONS ?
         BE    GN34                NO, BRANCH
         CLI   0(R1),X'01'         USER SYNAD OPTION ?
         BE    GN32                YES, BRANCH
         CLI   0(R1),X'02'         USER EXLST OPTION ?
         BE    GN33                YES, BRANCH
*
*        IF FIRST ERROR, SET UP ERROR PRINTOUT FOR PRINT MODULE
*
         TM    WFRSTERR,X'01'      FIRST ERROR OPTION ?
         BO    GN31                YES, BRANCH
         OI    WFRSTERR,X'01'      SET INDICATOR
         L     R14,PPIAMA+4        LOAD BASE RES FOR MESSAGE MOD DSECT
         MVC   IER044A,KTAG+4      MOVE '19' INTO ERROR MESSAGE
         BAS   R7,GN16             BRANCH TO BRANCH TO PRINT ROUTINE
*
*        MORE OPTIONS ?
*
GN31     TM    WFRSTERR,X'10'      SECOND TIME THRU LOOP ?
         BO    GN34                YES, BRANCH
         OI    WFRSTERR,X'10'      SET ONCE THRU LOOP INDICATOR
         LA    R1,4(,R1)           UPDATE POINTER TO USER PARAMS
         B     GN30                GO THRU LOOP AGAIN
*
GN32     L     R15,PPIOPEN+4       LOAD BASE REG FOR OPEN LIST DSECT
         MVC   AP1WRT1+1(3),1(R1)  MOVE USER SYNAD INTO OPEN LIST
         B     GN31                GO THRU LOOP AGAIN ?
*
GN33     MVI   WFRSTERR+1,X'FF'    SET USER EXIT E19 EXLST SWITCH
         MVC   DCBEXLSA,1(R1)      STORE EXLST ADDR IN MODEL DCB
         B     GN31                GO THRU LOOP AGAIN ?
*
*        ENTRIES MADE
*        RETURN TO MAIN PROGRAM
*
GN34     MVI   WFRSTERR,X'00'      RESTORE FIRST ERROR OPTION INDICATOR
         PPITEST  PPIME29          USER EXIT E29 ACTIVATED ?
         BZ    GN39                NO, BRANCH
*
*        CALL USER MODIFICATION EXIT E29
*
         L     R15,PPIX29+4        LOAD ADDR OF USER EXIT E29
         BASR  R14,R15             CALL USER E29
         L     R15,PPIOPEN+4       R15 -> OPEN LIST
*
GN35     CLI   0(R1),X'00'         MORE OPTIONS ?
         BE    GN39                NO, BRANCH
         CLI   0(R1),X'01'         USER SYNAD OPTION ?
         BE    GN37                YES, BRANCH
         CLI   0(R1),X'02'         USER EXLST OPTION ?
         BE    GN38                YES, BRANCH
*
*        IF FIRST ERROR, SET UP ERROR PRINTOUT FOR PRINT MODULE
*
         TM    WFRSTERR,X'01'      FIRST ERROR OPTION ?
         BO    GN36                YES, BRANCH
         OI    WFRSTERR,X'01'      SET INDICATOR
         L     R14,PPIAMA+4        LOAD BASE REG OF MESSAGE MOD DSECT
         MVC   IER044A,KTAG+6      MOVE '29' INTO ERROR MESSAGE
         BAS   R7,GN16             CALL TO PRINT ROUTINE
*
*        MORE OPTIONS ?
*
GN36     TM    WFRSTERR,X'10'      SECOND TIME THRU LOOP ?
         BO    GN39                YES, BRANCH
         OI    WFRSTERR,X'10'      SET ONCE THRU LOOP INDICATOR
         LA    R1,4(,R1)           UPDATE POINTER TO USER PARAMS
         B     GN35                GO THRU LOOP AGAIN
*
GN37     MVC   AP1WRT2+1(3),1(R1)  MOVE USER SYNAD INTO OPEN LIST
         B     GN36                GO THRU LOOP AGAIN ?
*
GN38     TM    WFRSTERR+1,X'FF'    USER EXIT E19 EXLST SWITCH SET ?
         BO    GN36                YES, IGNORE. GO THRU LOOP AGAIN
         MVC   DCBEXLSA,1(R1)      ELSE STORE EXLST ADDR IN DCB
         B     GN36                GO THRU LOOP AGAIN ?
*
*        ENTRIES MADE
*        RETURN TO MAIN AND SET UP PARAMS FOR LOOP
*
GN39     LH    R0,PPINDSKA         R0 = NUMBER OF OUTPUT DCBS TO GEN
         SR    R1,R1
         L     R2,WECBADR          R2 -> ECB/IOB AREA IN STORAGE
         L     R3,WDCBADR          R3 -> DCB AREA IN STORAGE
         LR    R5,R2
         LA    R5,8(,R5)           R5 -> FIRST IOB
         L     R6,PPISTDCB         R6 -> DCB ADDR TABLE
         LA    R7,PPISTAR          R7 -> DISK ADDR TABLE
         L     R15,PPIOPEN+4
*
*        LOOP TO FINISH GENERATING WORK DCBS AND IOBS AND MOVE
*        THEM INTO GENERATED STORAGE
*
GN40     ST    R2,MODIOB+IOBECBPT-IERIOB  STORE ECB ADDR IN MODEL IOB
         ST    R3,MODIOB+IOBDCBPT-IERIOB  STORE DCB ADDR IN MODEL IOB
         MVC   0(MODIOBL,R2),MODIOB  MOVE MODEL PREFIXED IOB INTO CORE
         ST    R5,DCBIOBAD         STORE IOB ADDR IN MODEL EXCP DCB
         IC    R1,0(R7)            GET M INCREMENT FOR THIS WORK UNIT
         STC   R1,DCBOPTCD         STORE M INCREMENT IN DCBOPTCD AREA
         ST    R3,0(R1,R6)         STORE DCB ADDR IN DCB ADDR TABLE
         ST    R3,OPENLIST+4(R1)   STORE DCB ADDR IN OPEN LIST
         SRL   R1,1                DIVIDE INCR BY 2 TO ACCESS ID TABLE
         LH    R4,KTABLE(R1)       LOAD SORT WORK NUMBER FOR THIS DCB
         STH   R4,DCBDDNAM+6       STORE SORTWK DDNAME NUMBER
         MVC   0(SORTWKL,R3),SORTWK  MOVE MODEL DCB INTO ALLOCATED STOR
*
*        UPDATE POINTERS TO GO THRU LOOP AGAIN
*
         LA    R2,MODIOBL(,R2)     UPDATE ECB/IOB AREA PTR
         LA    R3,SORTWKL(,R3)     UPDATE DCB AREA PTR
         LA    R5,MODIOBL(,R5)     UPDATE IOB PTR
         LA    R7,8(,R7)           UPDATE DISK ADDR TABLE PTR
         BCT   R0,GN40             GO THRU LOOP AGAIN ?
*
*        RETURN TO CALLING ROUTINE
*
         LA    R0,MODIOBL
         SR    R5,R0               BACKOFF LAST INCREMENT TO IOB ADDR
         ST    R5,PPISTIOB         SAVE ADDR OF FIRST OUTPUT IOB
         LM    R0,R15,WSAVAREA     RESTORE REGISTERS
         BR    R14                 RETURN TO LOAD ROUTINE
*
*        CONSTANTS
*
KF4      DC    F'4'                USED TO TEST VALID USER OPTION CODE
KX800000 DC    X'80000000'         SIGN BIT
*
*        NUMBERS FOR SORTWK DCB'S
*
KTABLE   DC    C'000102030405060708091011121314151617'
*
KTAG     DC    C'18281929'         USER EXIT NUMBER FOR ERROR MSG
*
*        WORK AREAS
*
WDCBADR  DC    A(0)                -> DCB AREA IN STORAGE
WECBADR  DC    A(0)                -> PREFIXED IOB AREA IN STORAGE
WFRSTERR DC    F'0'                GENERAL USER EXIT SWITCH
WREGS    DC    9F'0'               REG SAVE AREA DURING PRINT ROUTINE
WSAVAREA DC    16F'0'              GENERAL REGISTER SAVE AREA
*
*        DCB DEFINITIONS
*
         PRINT NOGEN
*
SORTWK   DCB   MACRF=(E),DSORG=PS,DDNAME=SORTWK
*
         DC    F'0'                AREA APPENDED TO EXCP DCB
*                                  REFERENCED AS DCBOPTCD
*
SORTWKL  EQU   *-SORTWK            L'SORTWK DCB
*
SORTIN   DCB   MACRF=(GL),DSORG=PS,DDNAME=SORTIN
*
SORTINL  EQU   *-SORTIN            L'SORTIN DCB
*
         PRINT NOGEN
*
*        IOB MODEL USED BY PROGRAM
*
MODIOB   DC    12F'0'              STD 40 IOB PLUS 8 BYTE S/M PREFIX
*
MODIOBL  EQU   *-MODIOB
         ORG   MODIOB+8            (IOBFLAG1-IERIOB)
         DC    AL1(IOBCMDCH)       SET IOB CMD CHAINING FLAG
         ORG
*
*        OPEN LIST DSECT USED BY MODULE
*
OPENLIST DSECT
         DC    19F'0'              USED FOR STORAGE
AP1RD2   DC    X'20000000'         USER SYNAD AND EROPT, READ - PH2
AP1WRT1  DC    F'0'                USER SYNAD, WRITE - PH1
AP1WRT2  DC    F'0'                USER SYNAD, WRITE - PH2
*
*        MODULE NAME - IERAMA
*
*        ALL MESSAGES REQUIRED BY PHASE ONE ASSIGNMENT MODULES
*
DIERAMA  DSECT
*
         COPY  AMAMAIN
*
*        IERIOB
*
         IERIOB
*
*        DCB DSECT
*
         PRINT NOGEN
*
         DCBD  DSORG=PS,DEVD=(DA)
*
         PRINT GEN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IER9ON   0101-20211-20211-1200-00253-00253-00000-RELEASE 00
ON9      TITLE 'IER9ON - OS/360 SORT/MERGE - 360S-SM-023'
*
*        MODULE NAME - IER9ON
*
*        MODULE FUNCTION/OPERATION -
*        ASSIGNMENT MODULE FOR CRCX ALGORITHM IER8ON
*        DETERMINE THE AMOUNT OF STORAGE NEEDED FOR THE TABLE, THE
*        FREE TRACK LIST (FTL), AND THE POOL (USED FOR WORK AREAS
*        CONTAINING MORE THAN 9 SEGMENTS). INITIALIZES THE
*        TABLE PROPER AND THE FREE TRACK LIST. CONSTANTS USED BY
*        THE RUNNING PROGRAM ARE DETERMINED AND PASSED TO THE
*        RUNNING PROGRAM (IER8ON)
*
*        MODULE IN WHICH THIS MODULE APPEARS AS A DSECT - N/A
*
*        MACRO'S USED - SMPPI
*
*        ENTRY POINTS - ENTRY FROM - IERRC9
*                                    CALLING SEQUENCE -
*                                    LOAD EP=IER9ON,DCB=SORTLIB
*                                    LR   R15,R0
*                                    BALR R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPISTAR    PPISPGN1   PPINDSKA
*        PPIENDAR   PPIDEPHO   PPIALG
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED -
*        PPIDEPHO - TT FOR WRITE ROUTINE
*        PPISPGN1 - NEXT AVAILABLE ADDRESS IN GENERATED STORAGE
*
*        EXTERNAL ROUTINES - N/A
*
*        EXTERNAL PARAMETERS -
*        R14  - RETURN ADDR OF IERRC9
*        R13 -> PPI
*
*        EXITS - NORMAL - MODULE HAS COMPLETED ASSIGNMENT FUNCTION
*                       - TO IERRC9 - RETURN PROCEDURE -
*                                     BR   R14
*        EXITS - ERROR - N/A
*
*        NOTE - A DSECT OF IER8ON IS USED IN THIS PROGRAM
*
IER9ON   CSECT
*
         USING *,R11
         USING DIER8ON,R12         IER8ON BASE
         USING IERRCA,R13          PPI BASE
*
         LR    R11,R15             MODULE BASE REGISTER
*
*        TABLE WIDTH (BYTES PER ROW) = 4(M+1)+4 (M = MERGE ORDER)
*        TABLE SIZE = 12(4(M+1)+4)
*        POOL AREA + FREE TRACK LIST = 2((M+1)(40))
*        AREA TAKEN FROM GENERATED CORE = TABLE + POOL + FREE
*                                         TRACK LISTS
         LH    R15,PPINDSKA        R15 = NO OF DASD SORTWORK DATA SETS
         STC   R15,PPIBDSVA        STORE NO OF DASD S/W DATA SETS
         LH    R2,PPIMRGMX         GET MERGE ORDER
         STH   R2,PPIMRGOP         STORE IT IN MERGE OP
         LR    R2,R15              R2 = NO OF DISK SORTWORK DATA SETS
         SLL   R2,2                MULT BY 4
         LA    R2,4(,R2)           INCR BY 4 TO DETERMINE BYTES PER ROW
         L     R12,PPIALG+4        R12 -> IER8ON RUNNING MODULE
         ST    R2,KBYPEROW         STORE TABLE WIDTH TO RUNNING PROG
         LR    R3,R2               SAVE BYTES/ROW
         BCTR  R3,0
         STH   R3,KBPRLS1          PASS BYTES/ROW -1
         BCTR  R3,0
         STH   R3,KBPRLS2          PASS BYTES/ROW -2
         BCTR  R3,0
         STH   R3,KBPRLS3          PASS BYTES/ROW -3
         BCTR  R3,0
         STH   R3,KBPRLS4          PASS BYTES/ROW -4
         BCTR  R3,0
         BCTR  R3,0
         STH   R3,KBPRLS6          PASS BYTES/ROW -6
         LA    R1,12
         MR    R0,R2               R1 = SIZE OF TABLE
         LR    R10,R1              SAVE TABLE SIZE
NO9SIZE2 LA    R1,80               MULT BY NO OF SORTWORK AREAS TO GET
         MR    R0,R15              SIZE OF POOL + FREE TRACK LIST
         LR    R9,R1               SAVE SIZE OF POOL + FREE TRACK LIST
         SRL   R1,1                SIZE OF POOL (ALSO SIZE OF FTL)
         STH   R1,KPOOLSZ          PASS POOL SIZE TO 8ON
*
*        TOTAL AREA TO BE TAKEN FROM GENERATED STORAGE
*        (TABLE + POOL + FREE TRACK LIST)
*
NO9GCSUB L     R8,PPISPGN1         NEXT AVAIL ADDR IN GENERAL STORAGE
         N     R8,KROUNDDW         ROUND ON FULLWORD BOUNDARY
         LR    R7,R10              GET TABLE SIZE
         AR    R7,R9               TOTAL STORAGE
         SR    R8,R7               NEW GEN STORAGE STARTING ADDR
         ST    R8,PPISPGN1         UPDATE PPI
         ST    R8,KTABLEX          PASS START OF TABLE TO 8ON
         ST    R8,KTBLMZON         ADDR OF ROW PRECEDING L = 0 ROW
*
*        ADDITIONAL STORAGE TAKEN FROM GENERATED STORAGE
*        FOR FREE POOL LIST AREA = (4*(M+1))
*
         L     R4,PPISPGN1         NEXT AVAILABLE ADDR IN GEN STORAGE
         N     R4,KROUNDDW         ROUND ON FULLWORD BOUNDARY
         LR    R5,R15              R5 = NO OF SORTWORK AREAS
         MH    R5,KH4              FREE POOL LIST LENGTH
         SR    R4,R5               NEW GEN CORE START ADDR
         ST    R4,PPISPGN1         UPDATE PPI
         SH    R4,KH4              POINT TO LIST - 4
         ST    R4,KFPPTR           KEEP ADDR TO FREE POOL LIST
*
*        CLEAR TABLE PROPER TO ZERO
*
         LR    R5,R15              R5 = NO OF SORTWORK AREAS
         LA    R5,1(,R5)           INCR LOOP COUNTER
         LR    R4,R8               R4 -> TABLE
NO9CLEAR MVI   0(R4),0             SET FIRST BYTE FOR PROPAGATION
         MVC   1(48,R4),0(R4)      SET ONE 48 BYTE BLOCK TO ZERO
         LA    R4,48(,R4)          UP ADDR TO NEXT BLOCK
         BCT   R5,NO9CLEAR         FALL OUT WHEN 48(M+2) BYTES SET
*
         LR    R3,R1               GET SIZE OF FTL AREA
         AR    R3,R10              FTL + TABLE
         AR    R3,R8               ADDR OF TBL +(TBL+FTL)= ADDR OF POOL
         ST    R3,KPOOL            STORE ADDR OF POOL IN IER8ON
         LR    R4,R2               GET BYTES PER ROW
         AR    R4,R8               END ADDR OF 1ST ROW
         SH    R4,KH4
         ST    R4,KWORK            END ADDR OF 1ST ROW -4
         L     R4,KBYPEROW         GET BYTES PER ROW
         A     R4,KTABLEX          DETERMINE L = 0 ROW ADDR
         ST    R4,KTABLEX0         PASS L = 0 ROW TO IER8ON
         ST    R4,KTABLEL          PASS TO IER8ON
*
NO9MFIG  BCTR  R15,0               M = WORK AREAS - 1
         LR    R7,R15
         MR    R6,R15              M SQUARED
         ST    R7,KMSQURD          PASS M SQUARED TO IER8ON
         ST    R15,KMERGORD        PASS M TO IER8ON
         BCTR  R15,0
         ST    R15,KMOMONE         PASS M - 1 TO IER8ON
*
*        DETERMINE ADDR OF LAST ROW IN TABLE
*        (CONTAINS POINTERS TO FTL'S)
*
NO9FTLRW LR    R6,R10              GET TABLE SIZE
         AR    R6,R8               R8 -> 1 ROW BEYOND FTL ROW
         SR    R6,R2               R6 -> FTL ROW
         SH    R6,KH4              R6 -> FTL ROW -4
         ST    R6,KFRTRKLT         STORE THIS IN IER8ON
*
*        INITIALIZE HIGH NO AND LOW NO COLUMNS OF TABLE
*
         L     R6,KWORK            GET ROW LENGTH -4
         AR    R6,R2               ADDR OF L = 0 ROW -4
         MVC   0(4,R6),KTBLSET0    INITIALIZE HI-LO PORTION OF L = 0
         LA    R7,9                SET COUNTER
NO9STBL  AR    R6,R2               UP POINTER TO NEXT ROW END -4
         MVC   0(4,R6),KTBLSET9    INITIALIZE NEXT ROW
         BCT   R7,NO9STBL          FALL OUT WHEN ALL ROWS DONE
*
         LA    R6,4(,R6)           UP POINTER TO FTL ROW
         LH    R15,PPINDSKA        R15 = NUMBER OF SORTWORK DATA SETS
         LR    R4,R6
         AR    R4,R2               POINTER TO FIRST FREE TRACK LIST
*
*        INITIALIZE FREE TRACK LIST ROW AND FREE TRACK LISTS
*
         ST    R4,0(,R6)           SET POINTER IN FTL ROW
         MVI   0(R6),1             SET AREA AVAIL BYTE TO 1
         LA    R5,PPISTAR          R5 -> PPISTAR
         LA    R7,PPIENDAR         R7 -> PPIENDAR
         MVC   PPIDEPHO,0(R5)      PASS FIRST PPISTAR TT TO WRITE RTN
         MVI   PPIDEPHO,X'04'      SET REAL INCR FOR FIRST AREA
         MVI   PPIDEPHO+1,X'04'    SET LOGICAL INCR
         MVI   PPIDEPHO+7,X'01'    SET RECORD NO
         MVI   0(R8),X'04'         SET 'M'(OF MTTD) IN TABLE
         MVC   1(2,R8),5(R5)       SET TT (OF MTTD) IN TABLE
         MVI   3(R8),X'00'         SET 'D'(OF MTTD) IN TABLE
*
*        SET FIRST ENTRY IN FIRST FREE TRACK LIST TO REFLECT
*        REQUIREMENTS FOR WRITE RTN AND END OF AREA MARKER
*
*        INCREASE FIRST START TRACK BY 1
*
         SR    R9,R9
         ICM   R9,B'0011',1(R8)
         LA    R9,1(,R9)           INCR TRACK
         STH   R9,0(,R4)           SET START TT AT TOP OF FTL
*
*        SUBTRACT ONE TRACK FROM END OF FIRST AREA FOR END OF
*        AREA MARKER
*
         ICM   R9,B'0011',5(R7)    GET END TT FROM PPIENDAR
         BCTR  R9,0                SUBTRACT 1 FOR END OF AREA MARKER
         STH   R9,2(,R4)           PLACE AREA ENDING TT IN FTL
         BCTR  R15,0               DECR NO OF LISTS REMAINING
*
*        INITIALIZE REMAINING LISTS IN FREE TRACK LIST
*
NO9UPDT4 LA    R6,4(,R6)           ADDR OF NEXT PTR IN FTL
         LA    R4,40(,R4)          ADDR OF NEXT LIST
         LA    R5,8(,R5)           INCR PPISTAR TO NEXT ENTRY
         LA    R7,8(,R7)           INCR PPIENDAR TO NEXT ENTRY
         ST    R4,0(,R6)           PLACE PTR TO FTL IN FTL ROW
         MVI   0(R6),1             SET NO OF AVAIL AREAS IN FTL PTR
         MVC   0(2,R4),5(R5)       START TT OF NEXT AREA FROM PPISTAR
*
*        SUBTRACT ONE TRACK FROM END OF EACH AREA FOR END OF AREA
*        MARKER
*
         SR    R9,R9
         ICM   R9,B'0011',5(R7)    R9 = TT FROM PPIENDAR
         BCTR  R9,0                DECR TT
         STH   R9,2(,R4)           PLACE ENDING TT IN FTL
         BCT   R15,NO9UPDT4        LOOP TO PROCESS NEXT AREA
*                                  LOOP COMPLETE, ALL AREAS PROCESSED
         BR    R14                 RETURN TO IERRC9
*
*        CONSTANTS
*
         DC    0F'0'
KROUNDDW DC    X'7FFFFFFC'         FULLWORD MASK
KWORK    DC    F'0'                WORK AREA
KTBLSET0 DC    X'02000100'         HI-LO CONSTANT, L = 0 ROW
KTBLSET9 DC    X'01000100'         HI-LO CONSTANT, L = 1-9 ROW
KH4      DC    H'4'
*
         DROP  R11,R12
*
DIER8ON  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IER8ON SOURCE
*
*----------------------------------------------------------------------
*
         COPY IER8ONI
*
DIERRMA  DSECT
*
         COPY  RMAMAIN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
./ ADD NAME=IER9PA   0101-20211-20211-1200-00257-00257-00000-RELEASE 00
PA9      TITLE 'IER9PA - OS/360 SORT/MERGE -360S-SM-023'
*
*        MODULE NAME - IER9PA
*
*        MODULE FUNCTION/OPERATION -
*        CRCX WRITE ASSIGNMENT ROUTINE FOR IER8PA
*        SETS UP THE RUNNING CRCX WRITE ROUTINE'S EXIT (DCB
*        FIELD SYNAD) AS INDICATED TO THE SORT/MERGE PHASE BY
*        EXIT E19 OR E29. IER9PA PICKS UP SYNAD FROM IERAP1, THE
*        OPEN LIST. THE DCB GENERATION ROUTINE (IER9GN) PLACES
*        THIS PARAMETER IN IERAP1 IF E19 OR E29 HAS ACTIVATED
*        SYNAD. THE WRITE ERROR OPTION (DCB FIELD EROPT) IS
*        ALWAYS TERMINATE THE JOB. IER9PA ALLOCATES SPACE IN
*        GENERATED STORAGE FOR IER8PA'S TWO CCW LISTS AND
*        ATTACHES THESE TO THE WRITE IOB. THE MODULE ALSO SETS UP
*        SEVERAL CONSTANTS IN THE RUNNING WRITE, AND, IF THE
*        RECORD FORMAT IS VARIABLE, IER9PA OVERLAYS SEVERAL
*        DISPLACEMENTS IN IER8PA INSTRUCTIONS TO BYPASS THE RDW
*        WHEN DEALING WITH THE BUFFER'S STARTING ADDRESS.
*
*        MODULE THIS MODULE APPEARS AS A DSECT IN - N/A
*
*        MACROS USED - SMPPI
*
*        ENTRY POINTS - ENTRY IER9PA - ENTRY FROM IERRC9
*                                      CALLING SEQUENCE -
*                                      LOAD EP=IER9PA,DCB=SORTLIB
*                                      LR   R15,R0
*                                      BALR R14,R15
*
*        INPUT - PPI FIELDS REFERENCED -
*        PPIAMA    PPIOPEN
*        PPIBPTRK  PPIADSSC
*        PPICONV   PPISPGN1
*        PPILAB04  PPISTIOB
*        PPILAB05  PPICNTL
*        PPILAB07  PPIWRT
*
*        OUTPUT - PPI FIELDS INITIALIZED OR ALTERED - PPISPGN1
*
*        EXTERNAL ROUTINES -
*        IERAP1   - OPEN LIST
*        PPICONV  - CONVERT RTN FOR DIAGNOSTICS
*        PPIADSSC - PRINT RTN FOR DIAGNOSTICS
*
*        EXTERNAL PARAMETERS -
*        IERAP1 - USER SYNAD ADDR FOR SYNCHONOUS ERROR EXIT
*        CCW'S  - CHANNEL COMMAND WORDS
*        IOB'S  - INPUT/OUTPUT BLOCKS
*
*        BUFFERS EXITS - NORMAL - BR R14 RETURN TO IERRC9
*
*        EXITS - ERROR - N/A
*
*        TABLES/WORK AREAS - N/A
*
IER9PA   CSECT
*
         USING *,R11               IER9PA BASE
         USING IOBSTDRD,R5         IOB BASE
         USING DIERAP1,R6          IERAP1 BASE
         USING DIER8PA,R7          IER8PA BASE
         USING IERRCA,R13          PPIA BASE
*
         LR    R11,R15             SET ADDRESSABILITY
         L     R7,PPIWRT+4         WRITE, (IER8PA)
         L     R6,PPIOPEN+4        OPEN
         ST    R14,KSAVC9          SAVE RETURN REGISTER
*
*        SET UP USER E19/29 SYNAD ADDRS
*
         MVC   AE19+1(3),AP1WRT1+1
         MVC   AE29+1(3),AP1WRT2+1
*
         L     R2,PPISPGN1         GENERATED STORAGE ADDR
         N     R2,KMASK            ALIGN TO DOUBLE WORD BOUNDARY
         SH    R2,KH48             ALLOCATE 48 BYTES FOR TWO WRITE
         ST    R2,PPISPGN1         CCW LISTS
*                                  R2 -> CCW LIST AREA
         L     R5,PPISTIOB         R5 -> WRITE IOB
         PPITEST  PPIVAR           RECORD FORMAT VARIABLE ?
         BZ    PADNOTV             NO, BYPASS RDW OVERLAYS
*
*        RECORD FORMAT IS VARIABLE
*        ADJUST DISPLACEMENTS IN IER8PA TO ALLOW FOR THE RDW
*
         MVI   PAEOSEOF+3,X'0C'
         MVI   PANORM+3,X'0C'
         MVI   PARTNV+3,X'10'
         MVI   PAEOSV+3,X'10'
         MVI   PA070V+3,X'0C'
*
PADNOTV  PPITEST  PPIDIAG+PPIDSIM  DIAGNOSTICS ?
         BNZ   PADIAG              YES, PRINT CCW, IOB,-AP1 ADDRS
*
*        RETURN FROM GENERATING DIAGNOSTIC MESSAGES
*
PASETIOB ST    R5,IOBADDR          STORE WRITE IOB IN IER8PA
         LA    R3,IOBCC            R3 -> IOB CCHHR
         STCM  R3,B'0111',CCWA+1   STORE IN SEARCH ID EQ CCW DATA ADDR
         STCM  R2,B'0111',CCWB+1   STORE FIRST CCW ADDR INTO TIC CCW
         MVC   0(24,R2),CCWA       GENERATE 2 CCW LISTS FOR
*                                  WRITE IN GENERATED STORAGE
         ST    R2,IOBSTART         IOBSTART -> CCW STRING
         LA    R2,24(,R2)          INCR PTR TO NEXT CCW STRING AREA
         STCM  R2,B'0111',CCWB+1   STORE FIRST CCW ADDR INTO TIC CCW
         MVC   0(24,R2),CCWA       MOVE SECOND STRING OF CCWS INTO
*                                  CCW LIST STORAGE AREA
         L     R3,IOBECBPT         R3 -> IOBECBPT
         ST    R2,4(,R3)           STORE ADDR OF SECOND CCW LIST AREA
         CLI   PPILAB07,2          DOUBLE BUFFERED ?
         BE    PATWO               YES, SET KBUFF TO PPILAB05
*                                       SECOND OUTPUT BUFFER
         MVC   KBUFF+1(3),PPILAB04+1  NO, SET KBUFF TO PPILAB04
*                                         FIRST OUTPUT BUFFER
         B     PASINGLE            BRANCH TO SET TRACK NO
*
PATWO    MVC   KBUFF,PPILAB05      SET KBUFF TO PPILAB05
PASINGLE CLI   PPIBPTRK+1,X'01'    FULL TRACK BLOCKING ?
         BE    PARETRN             YES, CONTINUE
         MVI   PA090+1,X'07'       NO, SET UPDATE
*
*        EXIT FROM ROUTINE
*
PARETRN  L     R14,KSAVC9          RETURN TO IERRC9
         BR    R14
*
*        DIAGNOSTICS SWITCH ON, GENERATE ADDR OF CCWS, IOB,
*        IERAP1, AND OUTPUT BUFFER ADDRS
*
PADIAG   L     R3,PPIAMA+4
         USING DIERAMA,R3
         LR    R0,R2               CCWS
         L     R15,PPICONV+4
         BAS   R14,4(,R15)
         MVC   IER907A,2(R1)
         LM    R0,R1,IER907        IER907I OUTPUT CCW ADDR
         L     R15,PPIADSSC        R15 -> SSC
         BAS   R14,12(,R15)        CALL MSG WRITER
         LR    R0,R5               IOB
         L     R15,PPICONV+4
         BAS   R14,4(,R15)
         MVC   IER908A,2(R1)
         LM    R0,R1,IER908        IER908I OUTPUT IOB ADDR
         L     R15,PPIADSSC        R15 -> SSC
         BAS   R14,12(,R15)        CALL MSG WRITER
         LR    R0,R6               OPEN LIST - IERAP1
         L     R15,PPICONV+4
         BAS   R14,4(,R15)
         MVC   IER909A,2(R1)
         LM    R0,R1,IER909        IER909I OPEN LIST ADDR
         L     R15,PPIADSSC        R15 -> SSC
         BAS   R14,12(,R15)        CALL MSG WRITER
         L     R0,PPILAB04         FIRST OUTPUT BUFFER ADDR
         L     R15,PPICONV+4
         BAS   R14,4(,R15)
         MVC   IER902A,2(R1)
         L     R0,PPILAB05         SECOND OUTPUT BUFFER ADDR
         L     R15,PPICONV+4
         BAS   R14,4(,R15)
         MVC   IER902B,2(R1)       IER902I OUTPUT BUFFER ADDR(S)
         LM    R0,R1,IER902
         L     R15,PPIADSSC        R15 -> SSC
         BAS   R14,12(,R15)        CALL MSG WRITER
         B     PASETIOB
*
*        CONSTANTS
*
KSAVC9   DC    F'0'
KMASK    DC    X'FFFFFFF8'
KH48     DC    H'48'
*
*        CCW EQUATES
*
         IERCCWEQ
*
*        CCWS
*
CCWA     CCW   SEARIDEQ,0,CC+SLI,5  +00
CCWB     CCW   TIC,0,CC+SLI,0       +08
CCWC     CCW   WRITECKD,0,SLI,0     +16
*
         LTORG
*
         DROP  R7,R11
*
*        IER8PA
*
DIER8PA  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IER8PA SOURCE
*
*----------------------------------------------------------------------
*
         COPY IER8PAI
*
*        IERAP1
*
DIERAP1  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERAP1 SOURCE
*
*----------------------------------------------------------------------
*
         COPY IERAP1I
*
*        IERAMA
*
DIERAMA  DSECT
*
*----------------------------------------------------------------------
*
*        INCLUDE IERAMA SOURCE
*
*----------------------------------------------------------------------
*
         COPY  AMAMAIN
*
*        DSECTS
*
*        MAP IOB
*
         IERIOB
*
         PRINT NOGEN
*
*        MAP DEB
*
         IEZDEB LIST=NO
*
*        MAP UCB
*
UCB      DSECT
*
         IEFUCBOB PREFIX=NO,LIST=NO
*
*        MAP ECB
*
         IHAECB
*
         DCBD  DSORG=PS,DEVD=(DA)
*
         PRINT GEN
*
*        REGISTER AND BIT EQUATES
*
         IEZREGS
*
         IEZBITS
*
         SMPPI
*
         END
